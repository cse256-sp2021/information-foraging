(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports={
  "version": "2.0",
  "metadata": {
    "apiVersion": "2014-06-30",
    "endpointPrefix": "cognito-identity",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon Cognito Identity",
    "serviceId": "Cognito Identity",
    "signatureVersion": "v4",
    "targetPrefix": "AWSCognitoIdentityService",
    "uid": "cognito-identity-2014-06-30"
  },
  "operations": {
    "CreateIdentityPool": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolName",
          "AllowUnauthenticatedIdentities"
        ],
        "members": {
          "IdentityPoolName": {},
          "AllowUnauthenticatedIdentities": {
            "type": "boolean"
          },
          "AllowClassicFlow": {
            "type": "boolean"
          },
          "SupportedLoginProviders": {
            "shape": "S5"
          },
          "DeveloperProviderName": {},
          "OpenIdConnectProviderARNs": {
            "shape": "S9"
          },
          "CognitoIdentityProviders": {
            "shape": "Sb"
          },
          "SamlProviderARNs": {
            "shape": "Sg"
          },
          "IdentityPoolTags": {
            "shape": "Sh"
          }
        }
      },
      "output": {
        "shape": "Sk"
      }
    },
    "DeleteIdentities": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityIdsToDelete"
        ],
        "members": {
          "IdentityIdsToDelete": {
            "type": "list",
            "member": {}
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "UnprocessedIdentityIds": {
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "IdentityId": {},
                "ErrorCode": {}
              }
            }
          }
        }
      }
    },
    "DeleteIdentityPool": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "IdentityPoolId": {}
        }
      }
    },
    "DescribeIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId"
        ],
        "members": {
          "IdentityId": {}
        }
      },
      "output": {
        "shape": "Sv"
      }
    },
    "DescribeIdentityPool": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "IdentityPoolId": {}
        }
      },
      "output": {
        "shape": "Sk"
      }
    },
    "GetCredentialsForIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId"
        ],
        "members": {
          "IdentityId": {},
          "Logins": {
            "shape": "S10"
          },
          "CustomRoleArn": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {},
          "Credentials": {
            "type": "structure",
            "members": {
              "AccessKeyId": {},
              "SecretKey": {},
              "SessionToken": {},
              "Expiration": {
                "type": "timestamp"
              }
            }
          }
        }
      }
    },
    "GetId": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "AccountId": {},
          "IdentityPoolId": {},
          "Logins": {
            "shape": "S10"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {}
        }
      }
    },
    "GetIdentityPoolRoles": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "IdentityPoolId": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityPoolId": {},
          "Roles": {
            "shape": "S1c"
          },
          "RoleMappings": {
            "shape": "S1e"
          }
        }
      }
    },
    "GetOpenIdToken": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId"
        ],
        "members": {
          "IdentityId": {},
          "Logins": {
            "shape": "S10"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {},
          "Token": {}
        }
      }
    },
    "GetOpenIdTokenForDeveloperIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId",
          "Logins"
        ],
        "members": {
          "IdentityPoolId": {},
          "IdentityId": {},
          "Logins": {
            "shape": "S10"
          },
          "TokenDuration": {
            "type": "long"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {},
          "Token": {}
        }
      }
    },
    "ListIdentities": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId",
          "MaxResults"
        ],
        "members": {
          "IdentityPoolId": {},
          "MaxResults": {
            "type": "integer"
          },
          "NextToken": {},
          "HideDisabled": {
            "type": "boolean"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityPoolId": {},
          "Identities": {
            "type": "list",
            "member": {
              "shape": "Sv"
            }
          },
          "NextToken": {}
        }
      }
    },
    "ListIdentityPools": {
      "input": {
        "type": "structure",
        "required": [
          "MaxResults"
        ],
        "members": {
          "MaxResults": {
            "type": "integer"
          },
          "NextToken": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityPools": {
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "IdentityPoolId": {},
                "IdentityPoolName": {}
              }
            }
          },
          "NextToken": {}
        }
      }
    },
    "ListTagsForResource": {
      "input": {
        "type": "structure",
        "required": [
          "ResourceArn"
        ],
        "members": {
          "ResourceArn": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Tags": {
            "shape": "Sh"
          }
        }
      }
    },
    "LookupDeveloperIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "IdentityPoolId": {},
          "IdentityId": {},
          "DeveloperUserIdentifier": {},
          "MaxResults": {
            "type": "integer"
          },
          "NextToken": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {},
          "DeveloperUserIdentifierList": {
            "type": "list",
            "member": {}
          },
          "NextToken": {}
        }
      }
    },
    "MergeDeveloperIdentities": {
      "input": {
        "type": "structure",
        "required": [
          "SourceUserIdentifier",
          "DestinationUserIdentifier",
          "DeveloperProviderName",
          "IdentityPoolId"
        ],
        "members": {
          "SourceUserIdentifier": {},
          "DestinationUserIdentifier": {},
          "DeveloperProviderName": {},
          "IdentityPoolId": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {}
        }
      }
    },
    "SetIdentityPoolRoles": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId",
          "Roles"
        ],
        "members": {
          "IdentityPoolId": {},
          "Roles": {
            "shape": "S1c"
          },
          "RoleMappings": {
            "shape": "S1e"
          }
        }
      }
    },
    "TagResource": {
      "input": {
        "type": "structure",
        "required": [
          "ResourceArn",
          "Tags"
        ],
        "members": {
          "ResourceArn": {},
          "Tags": {
            "shape": "Sh"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "UnlinkDeveloperIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId",
          "IdentityPoolId",
          "DeveloperProviderName",
          "DeveloperUserIdentifier"
        ],
        "members": {
          "IdentityId": {},
          "IdentityPoolId": {},
          "DeveloperProviderName": {},
          "DeveloperUserIdentifier": {}
        }
      }
    },
    "UnlinkIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId",
          "Logins",
          "LoginsToRemove"
        ],
        "members": {
          "IdentityId": {},
          "Logins": {
            "shape": "S10"
          },
          "LoginsToRemove": {
            "shape": "Sw"
          }
        }
      }
    },
    "UntagResource": {
      "input": {
        "type": "structure",
        "required": [
          "ResourceArn",
          "TagKeys"
        ],
        "members": {
          "ResourceArn": {},
          "TagKeys": {
            "type": "list",
            "member": {}
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "UpdateIdentityPool": {
      "input": {
        "shape": "Sk"
      },
      "output": {
        "shape": "Sk"
      }
    }
  },
  "shapes": {
    "S5": {
      "type": "map",
      "key": {},
      "value": {}
    },
    "S9": {
      "type": "list",
      "member": {}
    },
    "Sb": {
      "type": "list",
      "member": {
        "type": "structure",
        "members": {
          "ProviderName": {},
          "ClientId": {},
          "ServerSideTokenCheck": {
            "type": "boolean"
          }
        }
      }
    },
    "Sg": {
      "type": "list",
      "member": {}
    },
    "Sh": {
      "type": "map",
      "key": {},
      "value": {}
    },
    "Sk": {
      "type": "structure",
      "required": [
        "IdentityPoolId",
        "IdentityPoolName",
        "AllowUnauthenticatedIdentities"
      ],
      "members": {
        "IdentityPoolId": {},
        "IdentityPoolName": {},
        "AllowUnauthenticatedIdentities": {
          "type": "boolean"
        },
        "AllowClassicFlow": {
          "type": "boolean"
        },
        "SupportedLoginProviders": {
          "shape": "S5"
        },
        "DeveloperProviderName": {},
        "OpenIdConnectProviderARNs": {
          "shape": "S9"
        },
        "CognitoIdentityProviders": {
          "shape": "Sb"
        },
        "SamlProviderARNs": {
          "shape": "Sg"
        },
        "IdentityPoolTags": {
          "shape": "Sh"
        }
      }
    },
    "Sv": {
      "type": "structure",
      "members": {
        "IdentityId": {},
        "Logins": {
          "shape": "Sw"
        },
        "CreationDate": {
          "type": "timestamp"
        },
        "LastModifiedDate": {
          "type": "timestamp"
        }
      }
    },
    "Sw": {
      "type": "list",
      "member": {}
    },
    "S10": {
      "type": "map",
      "key": {},
      "value": {}
    },
    "S1c": {
      "type": "map",
      "key": {},
      "value": {}
    },
    "S1e": {
      "type": "map",
      "key": {},
      "value": {
        "type": "structure",
        "required": [
          "Type"
        ],
        "members": {
          "Type": {},
          "AmbiguousRoleResolution": {},
          "RulesConfiguration": {
            "type": "structure",
            "required": [
              "Rules"
            ],
            "members": {
              "Rules": {
                "type": "list",
                "member": {
                  "type": "structure",
                  "required": [
                    "Claim",
                    "MatchType",
                    "Value",
                    "RoleARN"
                  ],
                  "members": {
                    "Claim": {},
                    "MatchType": {},
                    "Value": {},
                    "RoleARN": {}
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
},{}],2:[function(require,module,exports){
module.exports={
  "pagination": {
  }
}

},{}],3:[function(require,module,exports){
module.exports={
  "acm": {
    "name": "ACM",
    "cors": true
  },
  "apigateway": {
    "name": "APIGateway",
    "cors": true
  },
  "applicationautoscaling": {
    "prefix": "application-autoscaling",
    "name": "ApplicationAutoScaling",
    "cors": true
  },
  "appstream": {
    "name": "AppStream"
  },
  "autoscaling": {
    "name": "AutoScaling",
    "cors": true
  },
  "batch": {
    "name": "Batch"
  },
  "budgets": {
    "name": "Budgets"
  },
  "clouddirectory": {
    "name": "CloudDirectory",
    "versions": [
      "2016-05-10*"
    ]
  },
  "cloudformation": {
    "name": "CloudFormation",
    "cors": true
  },
  "cloudfront": {
    "name": "CloudFront",
    "versions": [
      "2013-05-12*",
      "2013-11-11*",
      "2014-05-31*",
      "2014-10-21*",
      "2014-11-06*",
      "2015-04-17*",
      "2015-07-27*",
      "2015-09-17*",
      "2016-01-13*",
      "2016-01-28*",
      "2016-08-01*",
      "2016-08-20*",
      "2016-09-07*",
      "2016-09-29*",
      "2016-11-25*",
      "2017-03-25*",
      "2017-10-30*",
      "2018-06-18*",
      "2018-11-05*"
    ],
    "cors": true
  },
  "cloudhsm": {
    "name": "CloudHSM",
    "cors": true
  },
  "cloudsearch": {
    "name": "CloudSearch"
  },
  "cloudsearchdomain": {
    "name": "CloudSearchDomain"
  },
  "cloudtrail": {
    "name": "CloudTrail",
    "cors": true
  },
  "cloudwatch": {
    "prefix": "monitoring",
    "name": "CloudWatch",
    "cors": true
  },
  "cloudwatchevents": {
    "prefix": "events",
    "name": "CloudWatchEvents",
    "versions": [
      "2014-02-03*"
    ],
    "cors": true
  },
  "cloudwatchlogs": {
    "prefix": "logs",
    "name": "CloudWatchLogs",
    "cors": true
  },
  "codebuild": {
    "name": "CodeBuild",
    "cors": true
  },
  "codecommit": {
    "name": "CodeCommit",
    "cors": true
  },
  "codedeploy": {
    "name": "CodeDeploy",
    "cors": true
  },
  "codepipeline": {
    "name": "CodePipeline",
    "cors": true
  },
  "cognitoidentity": {
    "prefix": "cognito-identity",
    "name": "CognitoIdentity",
    "cors": true
  },
  "cognitoidentityserviceprovider": {
    "prefix": "cognito-idp",
    "name": "CognitoIdentityServiceProvider",
    "cors": true
  },
  "cognitosync": {
    "prefix": "cognito-sync",
    "name": "CognitoSync",
    "cors": true
  },
  "configservice": {
    "prefix": "config",
    "name": "ConfigService",
    "cors": true
  },
  "cur": {
    "name": "CUR",
    "cors": true
  },
  "datapipeline": {
    "name": "DataPipeline"
  },
  "devicefarm": {
    "name": "DeviceFarm",
    "cors": true
  },
  "directconnect": {
    "name": "DirectConnect",
    "cors": true
  },
  "directoryservice": {
    "prefix": "ds",
    "name": "DirectoryService"
  },
  "discovery": {
    "name": "Discovery"
  },
  "dms": {
    "name": "DMS"
  },
  "dynamodb": {
    "name": "DynamoDB",
    "cors": true
  },
  "dynamodbstreams": {
    "prefix": "streams.dynamodb",
    "name": "DynamoDBStreams",
    "cors": true
  },
  "ec2": {
    "name": "EC2",
    "versions": [
      "2013-06-15*",
      "2013-10-15*",
      "2014-02-01*",
      "2014-05-01*",
      "2014-06-15*",
      "2014-09-01*",
      "2014-10-01*",
      "2015-03-01*",
      "2015-04-15*",
      "2015-10-01*",
      "2016-04-01*",
      "2016-09-15*"
    ],
    "cors": true
  },
  "ecr": {
    "name": "ECR",
    "cors": true
  },
  "ecs": {
    "name": "ECS",
    "cors": true
  },
  "efs": {
    "prefix": "elasticfilesystem",
    "name": "EFS",
    "cors": true
  },
  "elasticache": {
    "name": "ElastiCache",
    "versions": [
      "2012-11-15*",
      "2014-03-24*",
      "2014-07-15*",
      "2014-09-30*"
    ],
    "cors": true
  },
  "elasticbeanstalk": {
    "name": "ElasticBeanstalk",
    "cors": true
  },
  "elb": {
    "prefix": "elasticloadbalancing",
    "name": "ELB",
    "cors": true
  },
  "elbv2": {
    "prefix": "elasticloadbalancingv2",
    "name": "ELBv2",
    "cors": true
  },
  "emr": {
    "prefix": "elasticmapreduce",
    "name": "EMR",
    "cors": true
  },
  "es": {
    "name": "ES"
  },
  "elastictranscoder": {
    "name": "ElasticTranscoder",
    "cors": true
  },
  "firehose": {
    "name": "Firehose",
    "cors": true
  },
  "gamelift": {
    "name": "GameLift",
    "cors": true
  },
  "glacier": {
    "name": "Glacier"
  },
  "health": {
    "name": "Health"
  },
  "iam": {
    "name": "IAM",
    "cors": true
  },
  "importexport": {
    "name": "ImportExport"
  },
  "inspector": {
    "name": "Inspector",
    "versions": [
      "2015-08-18*"
    ],
    "cors": true
  },
  "iot": {
    "name": "Iot",
    "cors": true
  },
  "iotdata": {
    "prefix": "iot-data",
    "name": "IotData",
    "cors": true
  },
  "kinesis": {
    "name": "Kinesis",
    "cors": true
  },
  "kinesisanalytics": {
    "name": "KinesisAnalytics"
  },
  "kms": {
    "name": "KMS",
    "cors": true
  },
  "lambda": {
    "name": "Lambda",
    "cors": true
  },
  "lexruntime": {
    "prefix": "runtime.lex",
    "name": "LexRuntime",
    "cors": true
  },
  "lightsail": {
    "name": "Lightsail"
  },
  "machinelearning": {
    "name": "MachineLearning",
    "cors": true
  },
  "marketplacecommerceanalytics": {
    "name": "MarketplaceCommerceAnalytics",
    "cors": true
  },
  "marketplacemetering": {
    "prefix": "meteringmarketplace",
    "name": "MarketplaceMetering"
  },
  "mturk": {
    "prefix": "mturk-requester",
    "name": "MTurk",
    "cors": true
  },
  "mobileanalytics": {
    "name": "MobileAnalytics",
    "cors": true
  },
  "opsworks": {
    "name": "OpsWorks",
    "cors": true
  },
  "opsworkscm": {
    "name": "OpsWorksCM"
  },
  "organizations": {
    "name": "Organizations"
  },
  "pinpoint": {
    "name": "Pinpoint"
  },
  "polly": {
    "name": "Polly",
    "cors": true
  },
  "rds": {
    "name": "RDS",
    "versions": [
      "2014-09-01*"
    ],
    "cors": true
  },
  "redshift": {
    "name": "Redshift",
    "cors": true
  },
  "rekognition": {
    "name": "Rekognition",
    "cors": true
  },
  "resourcegroupstaggingapi": {
    "name": "ResourceGroupsTaggingAPI"
  },
  "route53": {
    "name": "Route53",
    "cors": true
  },
  "route53domains": {
    "name": "Route53Domains",
    "cors": true
  },
  "s3": {
    "name": "S3",
    "dualstackAvailable": true,
    "cors": true
  },
  "s3control": {
    "name": "S3Control",
    "dualstackAvailable": true
  },
  "servicecatalog": {
    "name": "ServiceCatalog",
    "cors": true
  },
  "ses": {
    "prefix": "email",
    "name": "SES",
    "cors": true
  },
  "shield": {
    "name": "Shield"
  },
  "simpledb": {
    "prefix": "sdb",
    "name": "SimpleDB"
  },
  "sms": {
    "name": "SMS"
  },
  "snowball": {
    "name": "Snowball"
  },
  "sns": {
    "name": "SNS",
    "cors": true
  },
  "sqs": {
    "name": "SQS",
    "cors": true
  },
  "ssm": {
    "name": "SSM",
    "cors": true
  },
  "storagegateway": {
    "name": "StorageGateway",
    "cors": true
  },
  "stepfunctions": {
    "prefix": "states",
    "name": "StepFunctions"
  },
  "sts": {
    "name": "STS",
    "cors": true
  },
  "support": {
    "name": "Support"
  },
  "swf": {
    "name": "SWF"
  },
  "xray": {
    "name": "XRay",
    "cors": true
  },
  "waf": {
    "name": "WAF",
    "cors": true
  },
  "wafregional": {
    "prefix": "waf-regional",
    "name": "WAFRegional"
  },
  "workdocs": {
    "name": "WorkDocs",
    "cors": true
  },
  "workspaces": {
    "name": "WorkSpaces"
  },
  "codestar": {
    "name": "CodeStar"
  },
  "lexmodelbuildingservice": {
    "prefix": "lex-models",
    "name": "LexModelBuildingService",
    "cors": true
  },
  "marketplaceentitlementservice": {
    "prefix": "entitlement.marketplace",
    "name": "MarketplaceEntitlementService"
  },
  "athena": {
    "name": "Athena"
  },
  "greengrass": {
    "name": "Greengrass"
  },
  "dax": {
    "name": "DAX"
  },
  "migrationhub": {
    "prefix": "AWSMigrationHub",
    "name": "MigrationHub"
  },
  "cloudhsmv2": {
    "name": "CloudHSMV2"
  },
  "glue": {
    "name": "Glue"
  },
  "mobile": {
    "name": "Mobile"
  },
  "pricing": {
    "name": "Pricing",
    "cors": true
  },
  "costexplorer": {
    "prefix": "ce",
    "name": "CostExplorer",
    "cors": true
  },
  "mediaconvert": {
    "name": "MediaConvert"
  },
  "medialive": {
    "name": "MediaLive"
  },
  "mediapackage": {
    "name": "MediaPackage"
  },
  "mediastore": {
    "name": "MediaStore"
  },
  "mediastoredata": {
    "prefix": "mediastore-data",
    "name": "MediaStoreData",
    "cors": true
  },
  "appsync": {
    "name": "AppSync"
  },
  "guardduty": {
    "name": "GuardDuty"
  },
  "mq": {
    "name": "MQ"
  },
  "comprehend": {
    "name": "Comprehend",
    "cors": true
  },
  "iotjobsdataplane": {
    "prefix": "iot-jobs-data",
    "name": "IoTJobsDataPlane"
  },
  "kinesisvideoarchivedmedia": {
    "prefix": "kinesis-video-archived-media",
    "name": "KinesisVideoArchivedMedia",
    "cors": true
  },
  "kinesisvideomedia": {
    "prefix": "kinesis-video-media",
    "name": "KinesisVideoMedia",
    "cors": true
  },
  "kinesisvideo": {
    "name": "KinesisVideo",
    "cors": true
  },
  "sagemakerruntime": {
    "prefix": "runtime.sagemaker",
    "name": "SageMakerRuntime"
  },
  "sagemaker": {
    "name": "SageMaker"
  },
  "translate": {
    "name": "Translate",
    "cors": true
  },
  "resourcegroups": {
    "prefix": "resource-groups",
    "name": "ResourceGroups",
    "cors": true
  },
  "alexaforbusiness": {
    "name": "AlexaForBusiness"
  },
  "cloud9": {
    "name": "Cloud9"
  },
  "serverlessapplicationrepository": {
    "prefix": "serverlessrepo",
    "name": "ServerlessApplicationRepository"
  },
  "servicediscovery": {
    "name": "ServiceDiscovery"
  },
  "workmail": {
    "name": "WorkMail"
  },
  "autoscalingplans": {
    "prefix": "autoscaling-plans",
    "name": "AutoScalingPlans"
  },
  "transcribeservice": {
    "prefix": "transcribe",
    "name": "TranscribeService"
  },
  "connect": {
    "name": "Connect",
    "cors": true
  },
  "acmpca": {
    "prefix": "acm-pca",
    "name": "ACMPCA"
  },
  "fms": {
    "name": "FMS"
  },
  "secretsmanager": {
    "name": "SecretsManager",
    "cors": true
  },
  "iotanalytics": {
    "name": "IoTAnalytics",
    "cors": true
  },
  "iot1clickdevicesservice": {
    "prefix": "iot1click-devices",
    "name": "IoT1ClickDevicesService"
  },
  "iot1clickprojects": {
    "prefix": "iot1click-projects",
    "name": "IoT1ClickProjects"
  },
  "pi": {
    "name": "PI"
  },
  "neptune": {
    "name": "Neptune"
  },
  "mediatailor": {
    "name": "MediaTailor"
  },
  "eks": {
    "name": "EKS"
  },
  "macie": {
    "name": "Macie"
  },
  "dlm": {
    "name": "DLM"
  },
  "signer": {
    "name": "Signer"
  },
  "chime": {
    "name": "Chime"
  },
  "pinpointemail": {
    "prefix": "pinpoint-email",
    "name": "PinpointEmail"
  },
  "ram": {
    "name": "RAM"
  },
  "route53resolver": {
    "name": "Route53Resolver"
  },
  "pinpointsmsvoice": {
    "prefix": "sms-voice",
    "name": "PinpointSMSVoice"
  },
  "quicksight": {
    "name": "QuickSight"
  },
  "rdsdataservice": {
    "prefix": "rds-data",
    "name": "RDSDataService"
  },
  "amplify": {
    "name": "Amplify"
  },
  "datasync": {
    "name": "DataSync"
  },
  "robomaker": {
    "name": "RoboMaker"
  },
  "transfer": {
    "name": "Transfer"
  },
  "globalaccelerator": {
    "name": "GlobalAccelerator"
  },
  "comprehendmedical": {
    "name": "ComprehendMedical",
    "cors": true
  },
  "kinesisanalyticsv2": {
    "name": "KinesisAnalyticsV2"
  },
  "mediaconnect": {
    "name": "MediaConnect"
  },
  "fsx": {
    "name": "FSx"
  },
  "securityhub": {
    "name": "SecurityHub"
  },
  "appmesh": {
    "name": "AppMesh",
    "versions": [
      "2018-10-01*"
    ]
  },
  "licensemanager": {
    "prefix": "license-manager",
    "name": "LicenseManager"
  },
  "kafka": {
    "name": "Kafka"
  },
  "apigatewaymanagementapi": {
    "name": "ApiGatewayManagementApi"
  },
  "apigatewayv2": {
    "name": "ApiGatewayV2"
  },
  "docdb": {
    "name": "DocDB"
  },
  "backup": {
    "name": "Backup"
  },
  "worklink": {
    "name": "WorkLink"
  },
  "textract": {
    "name": "Textract"
  },
  "managedblockchain": {
    "name": "ManagedBlockchain"
  },
  "mediapackagevod": {
    "prefix": "mediapackage-vod",
    "name": "MediaPackageVod"
  },
  "groundstation": {
    "name": "GroundStation"
  },
  "iotthingsgraph": {
    "name": "IoTThingsGraph"
  },
  "iotevents": {
    "name": "IoTEvents"
  },
  "ioteventsdata": {
    "prefix": "iotevents-data",
    "name": "IoTEventsData"
  },
  "personalize": {
    "name": "Personalize",
    "cors": true
  },
  "personalizeevents": {
    "prefix": "personalize-events",
    "name": "PersonalizeEvents",
    "cors": true
  },
  "personalizeruntime": {
    "prefix": "personalize-runtime",
    "name": "PersonalizeRuntime",
    "cors": true
  },
  "applicationinsights": {
    "prefix": "application-insights",
    "name": "ApplicationInsights"
  },
  "servicequotas": {
    "prefix": "service-quotas",
    "name": "ServiceQuotas"
  },
  "ec2instanceconnect": {
    "prefix": "ec2-instance-connect",
    "name": "EC2InstanceConnect"
  },
  "eventbridge": {
    "name": "EventBridge"
  },
  "lakeformation": {
    "name": "LakeFormation"
  },
  "forecastservice": {
    "prefix": "forecast",
    "name": "ForecastService",
    "cors": true
  },
  "forecastqueryservice": {
    "prefix": "forecastquery",
    "name": "ForecastQueryService",
    "cors": true
  },
  "qldb": {
    "name": "QLDB"
  },
  "qldbsession": {
    "prefix": "qldb-session",
    "name": "QLDBSession"
  },
  "workmailmessageflow": {
    "name": "WorkMailMessageFlow"
  },
  "codestarnotifications": {
    "prefix": "codestar-notifications",
    "name": "CodeStarNotifications"
  },
  "savingsplans": {
    "name": "SavingsPlans"
  },
  "sso": {
    "name": "SSO"
  },
  "ssooidc": {
    "prefix": "sso-oidc",
    "name": "SSOOIDC"
  },
  "marketplacecatalog": {
    "prefix": "marketplace-catalog",
    "name": "MarketplaceCatalog"
  },
  "dataexchange": {
    "name": "DataExchange"
  },
  "sesv2": {
    "name": "SESV2"
  },
  "migrationhubconfig": {
    "prefix": "migrationhub-config",
    "name": "MigrationHubConfig"
  },
  "connectparticipant": {
    "name": "ConnectParticipant"
  },
  "appconfig": {
    "name": "AppConfig"
  },
  "iotsecuretunneling": {
    "name": "IoTSecureTunneling"
  },
  "wafv2": {
    "name": "WAFV2"
  },
  "elasticinference": {
    "prefix": "elastic-inference",
    "name": "ElasticInference"
  },
  "imagebuilder": {
    "name": "Imagebuilder"
  },
  "schemas": {
    "name": "Schemas"
  },
  "accessanalyzer": {
    "name": "AccessAnalyzer"
  },
  "codegurureviewer": {
    "prefix": "codeguru-reviewer",
    "name": "CodeGuruReviewer"
  },
  "codeguruprofiler": {
    "name": "CodeGuruProfiler"
  },
  "computeoptimizer": {
    "prefix": "compute-optimizer",
    "name": "ComputeOptimizer"
  },
  "frauddetector": {
    "name": "FraudDetector"
  },
  "kendra": {
    "name": "Kendra"
  },
  "networkmanager": {
    "name": "NetworkManager"
  },
  "outposts": {
    "name": "Outposts"
  },
  "augmentedairuntime": {
    "prefix": "sagemaker-a2i-runtime",
    "name": "AugmentedAIRuntime"
  },
  "ebs": {
    "name": "EBS"
  },
  "kinesisvideosignalingchannels": {
    "prefix": "kinesis-video-signaling",
    "name": "KinesisVideoSignalingChannels",
    "cors": true
  },
  "detective": {
    "name": "Detective"
  },
  "codestarconnections": {
    "prefix": "codestar-connections",
    "name": "CodeStarconnections"
  }
}
},{}],4:[function(require,module,exports){
module.exports={
  "version": "2.0",
  "metadata": {
    "apiVersion": "2006-03-01",
    "checksumFormat": "md5",
    "endpointPrefix": "s3",
    "globalEndpoint": "s3.amazonaws.com",
    "protocol": "rest-xml",
    "serviceAbbreviation": "Amazon S3",
    "serviceFullName": "Amazon Simple Storage Service",
    "serviceId": "S3",
    "signatureVersion": "s3",
    "uid": "s3-2006-03-01"
  },
  "operations": {
    "AbortMultipartUpload": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}/{Key+}",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "UploadId"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "UploadId": {
            "location": "querystring",
            "locationName": "uploadId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "CompleteMultipartUpload": {
      "http": {
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "UploadId"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "MultipartUpload": {
            "locationName": "CompleteMultipartUpload",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "Parts": {
                "locationName": "Part",
                "type": "list",
                "member": {
                  "type": "structure",
                  "members": {
                    "ETag": {},
                    "PartNumber": {
                      "type": "integer"
                    }
                  }
                },
                "flattened": true
              }
            }
          },
          "UploadId": {
            "location": "querystring",
            "locationName": "uploadId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        },
        "payload": "MultipartUpload"
      },
      "output": {
        "type": "structure",
        "members": {
          "Location": {},
          "Bucket": {},
          "Key": {},
          "Expiration": {
            "location": "header",
            "locationName": "x-amz-expiration"
          },
          "ETag": {},
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "CopyObject": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "CopySource",
          "Key"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CacheControl": {
            "location": "header",
            "locationName": "Cache-Control"
          },
          "ContentDisposition": {
            "location": "header",
            "locationName": "Content-Disposition"
          },
          "ContentEncoding": {
            "location": "header",
            "locationName": "Content-Encoding"
          },
          "ContentLanguage": {
            "location": "header",
            "locationName": "Content-Language"
          },
          "ContentType": {
            "location": "header",
            "locationName": "Content-Type"
          },
          "CopySource": {
            "location": "header",
            "locationName": "x-amz-copy-source"
          },
          "CopySourceIfMatch": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-match"
          },
          "CopySourceIfModifiedSince": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-modified-since",
            "type": "timestamp"
          },
          "CopySourceIfNoneMatch": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-none-match"
          },
          "CopySourceIfUnmodifiedSince": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-unmodified-since",
            "type": "timestamp"
          },
          "Expires": {
            "location": "header",
            "locationName": "Expires",
            "type": "timestamp"
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Metadata": {
            "shape": "S11",
            "location": "headers",
            "locationName": "x-amz-meta-"
          },
          "MetadataDirective": {
            "location": "header",
            "locationName": "x-amz-metadata-directive"
          },
          "TaggingDirective": {
            "location": "header",
            "locationName": "x-amz-tagging-directive"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "StorageClass": {
            "location": "header",
            "locationName": "x-amz-storage-class"
          },
          "WebsiteRedirectLocation": {
            "location": "header",
            "locationName": "x-amz-website-redirect-location"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "S19",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1b",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "CopySourceSSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-algorithm"
          },
          "CopySourceSSECustomerKey": {
            "shape": "S1d",
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-key"
          },
          "CopySourceSSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-key-MD5"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "Tagging": {
            "location": "header",
            "locationName": "x-amz-tagging"
          },
          "ObjectLockMode": {
            "location": "header",
            "locationName": "x-amz-object-lock-mode"
          },
          "ObjectLockRetainUntilDate": {
            "shape": "S1h",
            "location": "header",
            "locationName": "x-amz-object-lock-retain-until-date"
          },
          "ObjectLockLegalHoldStatus": {
            "location": "header",
            "locationName": "x-amz-object-lock-legal-hold"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "CopyObjectResult": {
            "type": "structure",
            "members": {
              "ETag": {},
              "LastModified": {
                "type": "timestamp"
              }
            }
          },
          "Expiration": {
            "location": "header",
            "locationName": "x-amz-expiration"
          },
          "CopySourceVersionId": {
            "location": "header",
            "locationName": "x-amz-copy-source-version-id"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1b",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        },
        "payload": "CopyObjectResult"
      },
      "alias": "PutObjectCopy"
    },
    "CreateBucket": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CreateBucketConfiguration": {
            "locationName": "CreateBucketConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "LocationConstraint": {}
            }
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWrite": {
            "location": "header",
            "locationName": "x-amz-grant-write"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          },
          "ObjectLockEnabledForBucket": {
            "location": "header",
            "locationName": "x-amz-bucket-object-lock-enabled",
            "type": "boolean"
          }
        },
        "payload": "CreateBucketConfiguration"
      },
      "output": {
        "type": "structure",
        "members": {
          "Location": {
            "location": "header",
            "locationName": "Location"
          }
        }
      },
      "alias": "PutBucket"
    },
    "CreateMultipartUpload": {
      "http": {
        "requestUri": "/{Bucket}/{Key+}?uploads"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CacheControl": {
            "location": "header",
            "locationName": "Cache-Control"
          },
          "ContentDisposition": {
            "location": "header",
            "locationName": "Content-Disposition"
          },
          "ContentEncoding": {
            "location": "header",
            "locationName": "Content-Encoding"
          },
          "ContentLanguage": {
            "location": "header",
            "locationName": "Content-Language"
          },
          "ContentType": {
            "location": "header",
            "locationName": "Content-Type"
          },
          "Expires": {
            "location": "header",
            "locationName": "Expires",
            "type": "timestamp"
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Metadata": {
            "shape": "S11",
            "location": "headers",
            "locationName": "x-amz-meta-"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "StorageClass": {
            "location": "header",
            "locationName": "x-amz-storage-class"
          },
          "WebsiteRedirectLocation": {
            "location": "header",
            "locationName": "x-amz-website-redirect-location"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "S19",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1b",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "Tagging": {
            "location": "header",
            "locationName": "x-amz-tagging"
          },
          "ObjectLockMode": {
            "location": "header",
            "locationName": "x-amz-object-lock-mode"
          },
          "ObjectLockRetainUntilDate": {
            "shape": "S1h",
            "location": "header",
            "locationName": "x-amz-object-lock-retain-until-date"
          },
          "ObjectLockLegalHoldStatus": {
            "location": "header",
            "locationName": "x-amz-object-lock-legal-hold"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "AbortDate": {
            "location": "header",
            "locationName": "x-amz-abort-date",
            "type": "timestamp"
          },
          "AbortRuleId": {
            "location": "header",
            "locationName": "x-amz-abort-rule-id"
          },
          "Bucket": {
            "locationName": "Bucket"
          },
          "Key": {},
          "UploadId": {},
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1b",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      },
      "alias": "InitiateMultipartUpload"
    },
    "DeleteBucket": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "DeleteBucketAnalyticsConfiguration": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?analytics",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          }
        }
      }
    },
    "DeleteBucketCors": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?cors",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "DeleteBucketEncryption": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?encryption",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "DeleteBucketInventoryConfiguration": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?inventory",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          }
        }
      }
    },
    "DeleteBucketLifecycle": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?lifecycle",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "DeleteBucketMetricsConfiguration": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?metrics",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          }
        }
      }
    },
    "DeleteBucketPolicy": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?policy",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "DeleteBucketReplication": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?replication",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "DeleteBucketTagging": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?tagging",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "DeleteBucketWebsite": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?website",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "DeleteObject": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}/{Key+}",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "MFA": {
            "location": "header",
            "locationName": "x-amz-mfa"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "BypassGovernanceRetention": {
            "location": "header",
            "locationName": "x-amz-bypass-governance-retention",
            "type": "boolean"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "DeleteMarker": {
            "location": "header",
            "locationName": "x-amz-delete-marker",
            "type": "boolean"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "DeleteObjectTagging": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}/{Key+}?tagging",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          }
        }
      }
    },
    "DeleteObjects": {
      "http": {
        "requestUri": "/{Bucket}?delete"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Delete"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Delete": {
            "locationName": "Delete",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "required": [
              "Objects"
            ],
            "members": {
              "Objects": {
                "locationName": "Object",
                "type": "list",
                "member": {
                  "type": "structure",
                  "required": [
                    "Key"
                  ],
                  "members": {
                    "Key": {},
                    "VersionId": {}
                  }
                },
                "flattened": true
              },
              "Quiet": {
                "type": "boolean"
              }
            }
          },
          "MFA": {
            "location": "header",
            "locationName": "x-amz-mfa"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "BypassGovernanceRetention": {
            "location": "header",
            "locationName": "x-amz-bypass-governance-retention",
            "type": "boolean"
          }
        },
        "payload": "Delete"
      },
      "output": {
        "type": "structure",
        "members": {
          "Deleted": {
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "Key": {},
                "VersionId": {},
                "DeleteMarker": {
                  "type": "boolean"
                },
                "DeleteMarkerVersionId": {}
              }
            },
            "flattened": true
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          },
          "Errors": {
            "locationName": "Error",
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "Key": {},
                "VersionId": {},
                "Code": {},
                "Message": {}
              }
            },
            "flattened": true
          }
        }
      },
      "alias": "DeleteMultipleObjects"
    },
    "DeletePublicAccessBlock": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?publicAccessBlock",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "GetBucketAccelerateConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?accelerate"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Status": {}
        }
      }
    },
    "GetBucketAcl": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?acl"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Owner": {
            "shape": "S32"
          },
          "Grants": {
            "shape": "S35",
            "locationName": "AccessControlList"
          }
        }
      }
    },
    "GetBucketAnalyticsConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?analytics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "AnalyticsConfiguration": {
            "shape": "S3e"
          }
        },
        "payload": "AnalyticsConfiguration"
      }
    },
    "GetBucketCors": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?cors"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "CORSRules": {
            "shape": "S3u",
            "locationName": "CORSRule"
          }
        }
      }
    },
    "GetBucketEncryption": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?encryption"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "ServerSideEncryptionConfiguration": {
            "shape": "S47"
          }
        },
        "payload": "ServerSideEncryptionConfiguration"
      }
    },
    "GetBucketInventoryConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?inventory"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "InventoryConfiguration": {
            "shape": "S4d"
          }
        },
        "payload": "InventoryConfiguration"
      }
    },
    "GetBucketLifecycle": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?lifecycle"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Rules": {
            "shape": "S4t",
            "locationName": "Rule"
          }
        }
      },
      "deprecated": true
    },
    "GetBucketLifecycleConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?lifecycle"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Rules": {
            "shape": "S58",
            "locationName": "Rule"
          }
        }
      }
    },
    "GetBucketLocation": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?location"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "LocationConstraint": {}
        }
      }
    },
    "GetBucketLogging": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?logging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "LoggingEnabled": {
            "shape": "S5i"
          }
        }
      }
    },
    "GetBucketMetricsConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?metrics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "MetricsConfiguration": {
            "shape": "S5q"
          }
        },
        "payload": "MetricsConfiguration"
      }
    },
    "GetBucketNotification": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?notification"
      },
      "input": {
        "shape": "S5t"
      },
      "output": {
        "shape": "S5u"
      },
      "deprecated": true
    },
    "GetBucketNotificationConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?notification"
      },
      "input": {
        "shape": "S5t"
      },
      "output": {
        "shape": "S65"
      }
    },
    "GetBucketPolicy": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?policy"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Policy": {}
        },
        "payload": "Policy"
      }
    },
    "GetBucketPolicyStatus": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?policyStatus"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "PolicyStatus": {
            "type": "structure",
            "members": {
              "IsPublic": {
                "locationName": "IsPublic",
                "type": "boolean"
              }
            }
          }
        },
        "payload": "PolicyStatus"
      }
    },
    "GetBucketReplication": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?replication"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "ReplicationConfiguration": {
            "shape": "S6s"
          }
        },
        "payload": "ReplicationConfiguration"
      }
    },
    "GetBucketRequestPayment": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?requestPayment"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Payer": {}
        }
      }
    },
    "GetBucketTagging": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?tagging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "required": [
          "TagSet"
        ],
        "members": {
          "TagSet": {
            "shape": "S3k"
          }
        }
      }
    },
    "GetBucketVersioning": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?versioning"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Status": {},
          "MFADelete": {
            "locationName": "MfaDelete"
          }
        }
      }
    },
    "GetBucketWebsite": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?website"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "RedirectAllRequestsTo": {
            "shape": "S7t"
          },
          "IndexDocument": {
            "shape": "S7w"
          },
          "ErrorDocument": {
            "shape": "S7y"
          },
          "RoutingRules": {
            "shape": "S7z"
          }
        }
      }
    },
    "GetObject": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "IfMatch": {
            "location": "header",
            "locationName": "If-Match"
          },
          "IfModifiedSince": {
            "location": "header",
            "locationName": "If-Modified-Since",
            "type": "timestamp"
          },
          "IfNoneMatch": {
            "location": "header",
            "locationName": "If-None-Match"
          },
          "IfUnmodifiedSince": {
            "location": "header",
            "locationName": "If-Unmodified-Since",
            "type": "timestamp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Range": {
            "location": "header",
            "locationName": "Range"
          },
          "ResponseCacheControl": {
            "location": "querystring",
            "locationName": "response-cache-control"
          },
          "ResponseContentDisposition": {
            "location": "querystring",
            "locationName": "response-content-disposition"
          },
          "ResponseContentEncoding": {
            "location": "querystring",
            "locationName": "response-content-encoding"
          },
          "ResponseContentLanguage": {
            "location": "querystring",
            "locationName": "response-content-language"
          },
          "ResponseContentType": {
            "location": "querystring",
            "locationName": "response-content-type"
          },
          "ResponseExpires": {
            "location": "querystring",
            "locationName": "response-expires",
            "type": "timestamp"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "S19",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "PartNumber": {
            "location": "querystring",
            "locationName": "partNumber",
            "type": "integer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Body": {
            "streaming": true,
            "type": "blob"
          },
          "DeleteMarker": {
            "location": "header",
            "locationName": "x-amz-delete-marker",
            "type": "boolean"
          },
          "AcceptRanges": {
            "location": "header",
            "locationName": "accept-ranges"
          },
          "Expiration": {
            "location": "header",
            "locationName": "x-amz-expiration"
          },
          "Restore": {
            "location": "header",
            "locationName": "x-amz-restore"
          },
          "LastModified": {
            "location": "header",
            "locationName": "Last-Modified",
            "type": "timestamp"
          },
          "ContentLength": {
            "location": "header",
            "locationName": "Content-Length",
            "type": "long"
          },
          "ETag": {
            "location": "header",
            "locationName": "ETag"
          },
          "MissingMeta": {
            "location": "header",
            "locationName": "x-amz-missing-meta",
            "type": "integer"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "CacheControl": {
            "location": "header",
            "locationName": "Cache-Control"
          },
          "ContentDisposition": {
            "location": "header",
            "locationName": "Content-Disposition"
          },
          "ContentEncoding": {
            "location": "header",
            "locationName": "Content-Encoding"
          },
          "ContentLanguage": {
            "location": "header",
            "locationName": "Content-Language"
          },
          "ContentRange": {
            "location": "header",
            "locationName": "Content-Range"
          },
          "ContentType": {
            "location": "header",
            "locationName": "Content-Type"
          },
          "Expires": {
            "location": "header",
            "locationName": "Expires",
            "type": "timestamp"
          },
          "WebsiteRedirectLocation": {
            "location": "header",
            "locationName": "x-amz-website-redirect-location"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "Metadata": {
            "shape": "S11",
            "location": "headers",
            "locationName": "x-amz-meta-"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "StorageClass": {
            "location": "header",
            "locationName": "x-amz-storage-class"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          },
          "ReplicationStatus": {
            "location": "header",
            "locationName": "x-amz-replication-status"
          },
          "PartsCount": {
            "location": "header",
            "locationName": "x-amz-mp-parts-count",
            "type": "integer"
          },
          "TagCount": {
            "location": "header",
            "locationName": "x-amz-tagging-count",
            "type": "integer"
          },
          "ObjectLockMode": {
            "location": "header",
            "locationName": "x-amz-object-lock-mode"
          },
          "ObjectLockRetainUntilDate": {
            "shape": "S1h",
            "location": "header",
            "locationName": "x-amz-object-lock-retain-until-date"
          },
          "ObjectLockLegalHoldStatus": {
            "location": "header",
            "locationName": "x-amz-object-lock-legal-hold"
          }
        },
        "payload": "Body"
      }
    },
    "GetObjectAcl": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}?acl"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Owner": {
            "shape": "S32"
          },
          "Grants": {
            "shape": "S35",
            "locationName": "AccessControlList"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "GetObjectLegalHold": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}?legal-hold"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "LegalHold": {
            "shape": "S8y"
          }
        },
        "payload": "LegalHold"
      }
    },
    "GetObjectLockConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?object-lock"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "ObjectLockConfiguration": {
            "shape": "S91"
          }
        },
        "payload": "ObjectLockConfiguration"
      }
    },
    "GetObjectRetention": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}?retention"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Retention": {
            "shape": "S99"
          }
        },
        "payload": "Retention"
      }
    },
    "GetObjectTagging": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}?tagging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          }
        }
      },
      "output": {
        "type": "structure",
        "required": [
          "TagSet"
        ],
        "members": {
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "TagSet": {
            "shape": "S3k"
          }
        }
      }
    },
    "GetObjectTorrent": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}?torrent"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Body": {
            "streaming": true,
            "type": "blob"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        },
        "payload": "Body"
      }
    },
    "GetPublicAccessBlock": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?publicAccessBlock"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "PublicAccessBlockConfiguration": {
            "shape": "S9g"
          }
        },
        "payload": "PublicAccessBlockConfiguration"
      }
    },
    "HeadBucket": {
      "http": {
        "method": "HEAD",
        "requestUri": "/{Bucket}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "HeadObject": {
      "http": {
        "method": "HEAD",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "IfMatch": {
            "location": "header",
            "locationName": "If-Match"
          },
          "IfModifiedSince": {
            "location": "header",
            "locationName": "If-Modified-Since",
            "type": "timestamp"
          },
          "IfNoneMatch": {
            "location": "header",
            "locationName": "If-None-Match"
          },
          "IfUnmodifiedSince": {
            "location": "header",
            "locationName": "If-Unmodified-Since",
            "type": "timestamp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Range": {
            "location": "header",
            "locationName": "Range"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "S19",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "PartNumber": {
            "location": "querystring",
            "locationName": "partNumber",
            "type": "integer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "DeleteMarker": {
            "location": "header",
            "locationName": "x-amz-delete-marker",
            "type": "boolean"
          },
          "AcceptRanges": {
            "location": "header",
            "locationName": "accept-ranges"
          },
          "Expiration": {
            "location": "header",
            "locationName": "x-amz-expiration"
          },
          "Restore": {
            "location": "header",
            "locationName": "x-amz-restore"
          },
          "LastModified": {
            "location": "header",
            "locationName": "Last-Modified",
            "type": "timestamp"
          },
          "ContentLength": {
            "location": "header",
            "locationName": "Content-Length",
            "type": "long"
          },
          "ETag": {
            "location": "header",
            "locationName": "ETag"
          },
          "MissingMeta": {
            "location": "header",
            "locationName": "x-amz-missing-meta",
            "type": "integer"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "CacheControl": {
            "location": "header",
            "locationName": "Cache-Control"
          },
          "ContentDisposition": {
            "location": "header",
            "locationName": "Content-Disposition"
          },
          "ContentEncoding": {
            "location": "header",
            "locationName": "Content-Encoding"
          },
          "ContentLanguage": {
            "location": "header",
            "locationName": "Content-Language"
          },
          "ContentType": {
            "location": "header",
            "locationName": "Content-Type"
          },
          "Expires": {
            "location": "header",
            "locationName": "Expires",
            "type": "timestamp"
          },
          "WebsiteRedirectLocation": {
            "location": "header",
            "locationName": "x-amz-website-redirect-location"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "Metadata": {
            "shape": "S11",
            "location": "headers",
            "locationName": "x-amz-meta-"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "StorageClass": {
            "location": "header",
            "locationName": "x-amz-storage-class"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          },
          "ReplicationStatus": {
            "location": "header",
            "locationName": "x-amz-replication-status"
          },
          "PartsCount": {
            "location": "header",
            "locationName": "x-amz-mp-parts-count",
            "type": "integer"
          },
          "ObjectLockMode": {
            "location": "header",
            "locationName": "x-amz-object-lock-mode"
          },
          "ObjectLockRetainUntilDate": {
            "shape": "S1h",
            "location": "header",
            "locationName": "x-amz-object-lock-retain-until-date"
          },
          "ObjectLockLegalHoldStatus": {
            "location": "header",
            "locationName": "x-amz-object-lock-legal-hold"
          }
        }
      }
    },
    "ListBucketAnalyticsConfigurations": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?analytics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContinuationToken": {
            "location": "querystring",
            "locationName": "continuation-token"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IsTruncated": {
            "type": "boolean"
          },
          "ContinuationToken": {},
          "NextContinuationToken": {},
          "AnalyticsConfigurationList": {
            "locationName": "AnalyticsConfiguration",
            "type": "list",
            "member": {
              "shape": "S3e"
            },
            "flattened": true
          }
        }
      }
    },
    "ListBucketInventoryConfigurations": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?inventory"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContinuationToken": {
            "location": "querystring",
            "locationName": "continuation-token"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "ContinuationToken": {},
          "InventoryConfigurationList": {
            "locationName": "InventoryConfiguration",
            "type": "list",
            "member": {
              "shape": "S4d"
            },
            "flattened": true
          },
          "IsTruncated": {
            "type": "boolean"
          },
          "NextContinuationToken": {}
        }
      }
    },
    "ListBucketMetricsConfigurations": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?metrics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContinuationToken": {
            "location": "querystring",
            "locationName": "continuation-token"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IsTruncated": {
            "type": "boolean"
          },
          "ContinuationToken": {},
          "NextContinuationToken": {},
          "MetricsConfigurationList": {
            "locationName": "MetricsConfiguration",
            "type": "list",
            "member": {
              "shape": "S5q"
            },
            "flattened": true
          }
        }
      }
    },
    "ListBuckets": {
      "http": {
        "method": "GET"
      },
      "output": {
        "type": "structure",
        "members": {
          "Buckets": {
            "type": "list",
            "member": {
              "locationName": "Bucket",
              "type": "structure",
              "members": {
                "Name": {},
                "CreationDate": {
                  "type": "timestamp"
                }
              }
            }
          },
          "Owner": {
            "shape": "S32"
          }
        }
      },
      "alias": "GetService"
    },
    "ListMultipartUploads": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?uploads"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Delimiter": {
            "location": "querystring",
            "locationName": "delimiter"
          },
          "EncodingType": {
            "location": "querystring",
            "locationName": "encoding-type"
          },
          "KeyMarker": {
            "location": "querystring",
            "locationName": "key-marker"
          },
          "MaxUploads": {
            "location": "querystring",
            "locationName": "max-uploads",
            "type": "integer"
          },
          "Prefix": {
            "location": "querystring",
            "locationName": "prefix"
          },
          "UploadIdMarker": {
            "location": "querystring",
            "locationName": "upload-id-marker"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Bucket": {},
          "KeyMarker": {},
          "UploadIdMarker": {},
          "NextKeyMarker": {},
          "Prefix": {},
          "Delimiter": {},
          "NextUploadIdMarker": {},
          "MaxUploads": {
            "type": "integer"
          },
          "IsTruncated": {
            "type": "boolean"
          },
          "Uploads": {
            "locationName": "Upload",
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "UploadId": {},
                "Key": {},
                "Initiated": {
                  "type": "timestamp"
                },
                "StorageClass": {},
                "Owner": {
                  "shape": "S32"
                },
                "Initiator": {
                  "shape": "Sad"
                }
              }
            },
            "flattened": true
          },
          "CommonPrefixes": {
            "shape": "Sae"
          },
          "EncodingType": {}
        }
      }
    },
    "ListObjectVersions": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?versions"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Delimiter": {
            "location": "querystring",
            "locationName": "delimiter"
          },
          "EncodingType": {
            "location": "querystring",
            "locationName": "encoding-type"
          },
          "KeyMarker": {
            "location": "querystring",
            "locationName": "key-marker"
          },
          "MaxKeys": {
            "location": "querystring",
            "locationName": "max-keys",
            "type": "integer"
          },
          "Prefix": {
            "location": "querystring",
            "locationName": "prefix"
          },
          "VersionIdMarker": {
            "location": "querystring",
            "locationName": "version-id-marker"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IsTruncated": {
            "type": "boolean"
          },
          "KeyMarker": {},
          "VersionIdMarker": {},
          "NextKeyMarker": {},
          "NextVersionIdMarker": {},
          "Versions": {
            "locationName": "Version",
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "ETag": {},
                "Size": {
                  "type": "integer"
                },
                "StorageClass": {},
                "Key": {},
                "VersionId": {},
                "IsLatest": {
                  "type": "boolean"
                },
                "LastModified": {
                  "type": "timestamp"
                },
                "Owner": {
                  "shape": "S32"
                }
              }
            },
            "flattened": true
          },
          "DeleteMarkers": {
            "locationName": "DeleteMarker",
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "Owner": {
                  "shape": "S32"
                },
                "Key": {},
                "VersionId": {},
                "IsLatest": {
                  "type": "boolean"
                },
                "LastModified": {
                  "type": "timestamp"
                }
              }
            },
            "flattened": true
          },
          "Name": {},
          "Prefix": {},
          "Delimiter": {},
          "MaxKeys": {
            "type": "integer"
          },
          "CommonPrefixes": {
            "shape": "Sae"
          },
          "EncodingType": {}
        }
      },
      "alias": "GetBucketObjectVersions"
    },
    "ListObjects": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Delimiter": {
            "location": "querystring",
            "locationName": "delimiter"
          },
          "EncodingType": {
            "location": "querystring",
            "locationName": "encoding-type"
          },
          "Marker": {
            "location": "querystring",
            "locationName": "marker"
          },
          "MaxKeys": {
            "location": "querystring",
            "locationName": "max-keys",
            "type": "integer"
          },
          "Prefix": {
            "location": "querystring",
            "locationName": "prefix"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IsTruncated": {
            "type": "boolean"
          },
          "Marker": {},
          "NextMarker": {},
          "Contents": {
            "shape": "Saw"
          },
          "Name": {},
          "Prefix": {},
          "Delimiter": {},
          "MaxKeys": {
            "type": "integer"
          },
          "CommonPrefixes": {
            "shape": "Sae"
          },
          "EncodingType": {}
        }
      },
      "alias": "GetBucket"
    },
    "ListObjectsV2": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?list-type=2"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Delimiter": {
            "location": "querystring",
            "locationName": "delimiter"
          },
          "EncodingType": {
            "location": "querystring",
            "locationName": "encoding-type"
          },
          "MaxKeys": {
            "location": "querystring",
            "locationName": "max-keys",
            "type": "integer"
          },
          "Prefix": {
            "location": "querystring",
            "locationName": "prefix"
          },
          "ContinuationToken": {
            "location": "querystring",
            "locationName": "continuation-token"
          },
          "FetchOwner": {
            "location": "querystring",
            "locationName": "fetch-owner",
            "type": "boolean"
          },
          "StartAfter": {
            "location": "querystring",
            "locationName": "start-after"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IsTruncated": {
            "type": "boolean"
          },
          "Contents": {
            "shape": "Saw"
          },
          "Name": {},
          "Prefix": {},
          "Delimiter": {},
          "MaxKeys": {
            "type": "integer"
          },
          "CommonPrefixes": {
            "shape": "Sae"
          },
          "EncodingType": {},
          "KeyCount": {
            "type": "integer"
          },
          "ContinuationToken": {},
          "NextContinuationToken": {},
          "StartAfter": {}
        }
      }
    },
    "ListParts": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "UploadId"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "MaxParts": {
            "location": "querystring",
            "locationName": "max-parts",
            "type": "integer"
          },
          "PartNumberMarker": {
            "location": "querystring",
            "locationName": "part-number-marker",
            "type": "integer"
          },
          "UploadId": {
            "location": "querystring",
            "locationName": "uploadId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "AbortDate": {
            "location": "header",
            "locationName": "x-amz-abort-date",
            "type": "timestamp"
          },
          "AbortRuleId": {
            "location": "header",
            "locationName": "x-amz-abort-rule-id"
          },
          "Bucket": {},
          "Key": {},
          "UploadId": {},
          "PartNumberMarker": {
            "type": "integer"
          },
          "NextPartNumberMarker": {
            "type": "integer"
          },
          "MaxParts": {
            "type": "integer"
          },
          "IsTruncated": {
            "type": "boolean"
          },
          "Parts": {
            "locationName": "Part",
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "PartNumber": {
                  "type": "integer"
                },
                "LastModified": {
                  "type": "timestamp"
                },
                "ETag": {},
                "Size": {
                  "type": "integer"
                }
              }
            },
            "flattened": true
          },
          "Initiator": {
            "shape": "Sad"
          },
          "Owner": {
            "shape": "S32"
          },
          "StorageClass": {},
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "PutBucketAccelerateConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?accelerate"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "AccelerateConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "AccelerateConfiguration": {
            "locationName": "AccelerateConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "Status": {}
            }
          }
        },
        "payload": "AccelerateConfiguration"
      }
    },
    "PutBucketAcl": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?acl"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "AccessControlPolicy": {
            "shape": "Sbe",
            "locationName": "AccessControlPolicy",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWrite": {
            "location": "header",
            "locationName": "x-amz-grant-write"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          }
        },
        "payload": "AccessControlPolicy"
      }
    },
    "PutBucketAnalyticsConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?analytics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id",
          "AnalyticsConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          },
          "AnalyticsConfiguration": {
            "shape": "S3e",
            "locationName": "AnalyticsConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "AnalyticsConfiguration"
      }
    },
    "PutBucketCors": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?cors"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "CORSConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CORSConfiguration": {
            "locationName": "CORSConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "required": [
              "CORSRules"
            ],
            "members": {
              "CORSRules": {
                "shape": "S3u",
                "locationName": "CORSRule"
              }
            }
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          }
        },
        "payload": "CORSConfiguration"
      }
    },
    "PutBucketEncryption": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?encryption"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "ServerSideEncryptionConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ServerSideEncryptionConfiguration": {
            "shape": "S47",
            "locationName": "ServerSideEncryptionConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "ServerSideEncryptionConfiguration"
      }
    },
    "PutBucketInventoryConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?inventory"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id",
          "InventoryConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          },
          "InventoryConfiguration": {
            "shape": "S4d",
            "locationName": "InventoryConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "InventoryConfiguration"
      }
    },
    "PutBucketLifecycle": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?lifecycle"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "LifecycleConfiguration": {
            "locationName": "LifecycleConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "required": [
              "Rules"
            ],
            "members": {
              "Rules": {
                "shape": "S4t",
                "locationName": "Rule"
              }
            }
          }
        },
        "payload": "LifecycleConfiguration"
      },
      "deprecated": true
    },
    "PutBucketLifecycleConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?lifecycle"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "LifecycleConfiguration": {
            "locationName": "LifecycleConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "required": [
              "Rules"
            ],
            "members": {
              "Rules": {
                "shape": "S58",
                "locationName": "Rule"
              }
            }
          }
        },
        "payload": "LifecycleConfiguration"
      }
    },
    "PutBucketLogging": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?logging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "BucketLoggingStatus"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "BucketLoggingStatus": {
            "locationName": "BucketLoggingStatus",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "LoggingEnabled": {
                "shape": "S5i"
              }
            }
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          }
        },
        "payload": "BucketLoggingStatus"
      }
    },
    "PutBucketMetricsConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?metrics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id",
          "MetricsConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          },
          "MetricsConfiguration": {
            "shape": "S5q",
            "locationName": "MetricsConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "MetricsConfiguration"
      }
    },
    "PutBucketNotification": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?notification"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "NotificationConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "NotificationConfiguration": {
            "shape": "S5u",
            "locationName": "NotificationConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "NotificationConfiguration"
      },
      "deprecated": true
    },
    "PutBucketNotificationConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?notification"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "NotificationConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "NotificationConfiguration": {
            "shape": "S65",
            "locationName": "NotificationConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "NotificationConfiguration"
      }
    },
    "PutBucketPolicy": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?policy"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Policy"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ConfirmRemoveSelfBucketAccess": {
            "location": "header",
            "locationName": "x-amz-confirm-remove-self-bucket-access",
            "type": "boolean"
          },
          "Policy": {}
        },
        "payload": "Policy"
      }
    },
    "PutBucketReplication": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?replication"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "ReplicationConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ReplicationConfiguration": {
            "shape": "S6s",
            "locationName": "ReplicationConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "Token": {
            "location": "header",
            "locationName": "x-amz-bucket-object-lock-token"
          }
        },
        "payload": "ReplicationConfiguration"
      }
    },
    "PutBucketRequestPayment": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?requestPayment"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "RequestPaymentConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "RequestPaymentConfiguration": {
            "locationName": "RequestPaymentConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "required": [
              "Payer"
            ],
            "members": {
              "Payer": {}
            }
          }
        },
        "payload": "RequestPaymentConfiguration"
      }
    },
    "PutBucketTagging": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?tagging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Tagging"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "Tagging": {
            "shape": "Sc1",
            "locationName": "Tagging",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "Tagging"
      }
    },
    "PutBucketVersioning": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?versioning"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "VersioningConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "MFA": {
            "location": "header",
            "locationName": "x-amz-mfa"
          },
          "VersioningConfiguration": {
            "locationName": "VersioningConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "MFADelete": {
                "locationName": "MfaDelete"
              },
              "Status": {}
            }
          }
        },
        "payload": "VersioningConfiguration"
      }
    },
    "PutBucketWebsite": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?website"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "WebsiteConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "WebsiteConfiguration": {
            "locationName": "WebsiteConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "ErrorDocument": {
                "shape": "S7y"
              },
              "IndexDocument": {
                "shape": "S7w"
              },
              "RedirectAllRequestsTo": {
                "shape": "S7t"
              },
              "RoutingRules": {
                "shape": "S7z"
              }
            }
          }
        },
        "payload": "WebsiteConfiguration"
      }
    },
    "PutObject": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "Body": {
            "streaming": true,
            "type": "blob"
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CacheControl": {
            "location": "header",
            "locationName": "Cache-Control"
          },
          "ContentDisposition": {
            "location": "header",
            "locationName": "Content-Disposition"
          },
          "ContentEncoding": {
            "location": "header",
            "locationName": "Content-Encoding"
          },
          "ContentLanguage": {
            "location": "header",
            "locationName": "Content-Language"
          },
          "ContentLength": {
            "location": "header",
            "locationName": "Content-Length",
            "type": "long"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ContentType": {
            "location": "header",
            "locationName": "Content-Type"
          },
          "Expires": {
            "location": "header",
            "locationName": "Expires",
            "type": "timestamp"
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Metadata": {
            "shape": "S11",
            "location": "headers",
            "locationName": "x-amz-meta-"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "StorageClass": {
            "location": "header",
            "locationName": "x-amz-storage-class"
          },
          "WebsiteRedirectLocation": {
            "location": "header",
            "locationName": "x-amz-website-redirect-location"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "S19",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1b",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "Tagging": {
            "location": "header",
            "locationName": "x-amz-tagging"
          },
          "ObjectLockMode": {
            "location": "header",
            "locationName": "x-amz-object-lock-mode"
          },
          "ObjectLockRetainUntilDate": {
            "shape": "S1h",
            "location": "header",
            "locationName": "x-amz-object-lock-retain-until-date"
          },
          "ObjectLockLegalHoldStatus": {
            "location": "header",
            "locationName": "x-amz-object-lock-legal-hold"
          }
        },
        "payload": "Body"
      },
      "output": {
        "type": "structure",
        "members": {
          "Expiration": {
            "location": "header",
            "locationName": "x-amz-expiration"
          },
          "ETag": {
            "location": "header",
            "locationName": "ETag"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1b",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "PutObjectAcl": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}?acl"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "AccessControlPolicy": {
            "shape": "Sbe",
            "locationName": "AccessControlPolicy",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWrite": {
            "location": "header",
            "locationName": "x-amz-grant-write"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          }
        },
        "payload": "AccessControlPolicy"
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "PutObjectLegalHold": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}?legal-hold"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "LegalHold": {
            "shape": "S8y",
            "locationName": "LegalHold",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          }
        },
        "payload": "LegalHold"
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "PutObjectLockConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?object-lock"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ObjectLockConfiguration": {
            "shape": "S91",
            "locationName": "ObjectLockConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "Token": {
            "location": "header",
            "locationName": "x-amz-bucket-object-lock-token"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          }
        },
        "payload": "ObjectLockConfiguration"
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "PutObjectRetention": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}?retention"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Retention": {
            "shape": "S99",
            "locationName": "Retention",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "BypassGovernanceRetention": {
            "location": "header",
            "locationName": "x-amz-bypass-governance-retention",
            "type": "boolean"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          }
        },
        "payload": "Retention"
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "PutObjectTagging": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}?tagging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "Tagging"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "Tagging": {
            "shape": "Sc1",
            "locationName": "Tagging",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "Tagging"
      },
      "output": {
        "type": "structure",
        "members": {
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          }
        }
      }
    },
    "PutPublicAccessBlock": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?publicAccessBlock"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "PublicAccessBlockConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "PublicAccessBlockConfiguration": {
            "shape": "S9g",
            "locationName": "PublicAccessBlockConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "PublicAccessBlockConfiguration"
      }
    },
    "RestoreObject": {
      "http": {
        "requestUri": "/{Bucket}/{Key+}?restore"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "RestoreRequest": {
            "locationName": "RestoreRequest",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "Days": {
                "type": "integer"
              },
              "GlacierJobParameters": {
                "type": "structure",
                "required": [
                  "Tier"
                ],
                "members": {
                  "Tier": {}
                }
              },
              "Type": {},
              "Tier": {},
              "Description": {},
              "SelectParameters": {
                "type": "structure",
                "required": [
                  "InputSerialization",
                  "ExpressionType",
                  "Expression",
                  "OutputSerialization"
                ],
                "members": {
                  "InputSerialization": {
                    "shape": "Scr"
                  },
                  "ExpressionType": {},
                  "Expression": {},
                  "OutputSerialization": {
                    "shape": "Sd6"
                  }
                }
              },
              "OutputLocation": {
                "type": "structure",
                "members": {
                  "S3": {
                    "type": "structure",
                    "required": [
                      "BucketName",
                      "Prefix"
                    ],
                    "members": {
                      "BucketName": {},
                      "Prefix": {},
                      "Encryption": {
                        "type": "structure",
                        "required": [
                          "EncryptionType"
                        ],
                        "members": {
                          "EncryptionType": {},
                          "KMSKeyId": {
                            "shape": "Sj"
                          },
                          "KMSContext": {}
                        }
                      },
                      "CannedACL": {},
                      "AccessControlList": {
                        "shape": "S35"
                      },
                      "Tagging": {
                        "shape": "Sc1"
                      },
                      "UserMetadata": {
                        "type": "list",
                        "member": {
                          "locationName": "MetadataEntry",
                          "type": "structure",
                          "members": {
                            "Name": {},
                            "Value": {}
                          }
                        }
                      },
                      "StorageClass": {}
                    }
                  }
                }
              }
            }
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        },
        "payload": "RestoreRequest"
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          },
          "RestoreOutputPath": {
            "location": "header",
            "locationName": "x-amz-restore-output-path"
          }
        }
      },
      "alias": "PostObjectRestore"
    },
    "SelectObjectContent": {
      "http": {
        "requestUri": "/{Bucket}/{Key+}?select&select-type=2"
      },
      "input": {
        "locationName": "SelectObjectContentRequest",
        "xmlNamespace": {
          "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
        },
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "Expression",
          "ExpressionType",
          "InputSerialization",
          "OutputSerialization"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "S19",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "Expression": {},
          "ExpressionType": {},
          "RequestProgress": {
            "type": "structure",
            "members": {
              "Enabled": {
                "type": "boolean"
              }
            }
          },
          "InputSerialization": {
            "shape": "Scr"
          },
          "OutputSerialization": {
            "shape": "Sd6"
          },
          "ScanRange": {
            "type": "structure",
            "members": {
              "Start": {
                "type": "long"
              },
              "End": {
                "type": "long"
              }
            }
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Payload": {
            "type": "structure",
            "members": {
              "Records": {
                "type": "structure",
                "members": {
                  "Payload": {
                    "eventpayload": true,
                    "type": "blob"
                  }
                },
                "event": true
              },
              "Stats": {
                "type": "structure",
                "members": {
                  "Details": {
                    "eventpayload": true,
                    "type": "structure",
                    "members": {
                      "BytesScanned": {
                        "type": "long"
                      },
                      "BytesProcessed": {
                        "type": "long"
                      },
                      "BytesReturned": {
                        "type": "long"
                      }
                    }
                  }
                },
                "event": true
              },
              "Progress": {
                "type": "structure",
                "members": {
                  "Details": {
                    "eventpayload": true,
                    "type": "structure",
                    "members": {
                      "BytesScanned": {
                        "type": "long"
                      },
                      "BytesProcessed": {
                        "type": "long"
                      },
                      "BytesReturned": {
                        "type": "long"
                      }
                    }
                  }
                },
                "event": true
              },
              "Cont": {
                "type": "structure",
                "members": {},
                "event": true
              },
              "End": {
                "type": "structure",
                "members": {},
                "event": true
              }
            },
            "eventstream": true
          }
        },
        "payload": "Payload"
      }
    },
    "UploadPart": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "PartNumber",
          "UploadId"
        ],
        "members": {
          "Body": {
            "streaming": true,
            "type": "blob"
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentLength": {
            "location": "header",
            "locationName": "Content-Length",
            "type": "long"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "PartNumber": {
            "location": "querystring",
            "locationName": "partNumber",
            "type": "integer"
          },
          "UploadId": {
            "location": "querystring",
            "locationName": "uploadId"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "S19",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        },
        "payload": "Body"
      },
      "output": {
        "type": "structure",
        "members": {
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "ETag": {
            "location": "header",
            "locationName": "ETag"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "UploadPartCopy": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "CopySource",
          "Key",
          "PartNumber",
          "UploadId"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CopySource": {
            "location": "header",
            "locationName": "x-amz-copy-source"
          },
          "CopySourceIfMatch": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-match"
          },
          "CopySourceIfModifiedSince": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-modified-since",
            "type": "timestamp"
          },
          "CopySourceIfNoneMatch": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-none-match"
          },
          "CopySourceIfUnmodifiedSince": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-unmodified-since",
            "type": "timestamp"
          },
          "CopySourceRange": {
            "location": "header",
            "locationName": "x-amz-copy-source-range"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "PartNumber": {
            "location": "querystring",
            "locationName": "partNumber",
            "type": "integer"
          },
          "UploadId": {
            "location": "querystring",
            "locationName": "uploadId"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "S19",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "CopySourceSSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-algorithm"
          },
          "CopySourceSSECustomerKey": {
            "shape": "S1d",
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-key"
          },
          "CopySourceSSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-key-MD5"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "CopySourceVersionId": {
            "location": "header",
            "locationName": "x-amz-copy-source-version-id"
          },
          "CopyPartResult": {
            "type": "structure",
            "members": {
              "ETag": {},
              "LastModified": {
                "type": "timestamp"
              }
            }
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        },
        "payload": "CopyPartResult"
      }
    }
  },
  "shapes": {
    "Sj": {
      "type": "string",
      "sensitive": true
    },
    "S11": {
      "type": "map",
      "key": {},
      "value": {}
    },
    "S19": {
      "type": "blob",
      "sensitive": true
    },
    "S1b": {
      "type": "string",
      "sensitive": true
    },
    "S1d": {
      "type": "blob",
      "sensitive": true
    },
    "S1h": {
      "type": "timestamp",
      "timestampFormat": "iso8601"
    },
    "S32": {
      "type": "structure",
      "members": {
        "DisplayName": {},
        "ID": {}
      }
    },
    "S35": {
      "type": "list",
      "member": {
        "locationName": "Grant",
        "type": "structure",
        "members": {
          "Grantee": {
            "shape": "S37"
          },
          "Permission": {}
        }
      }
    },
    "S37": {
      "type": "structure",
      "required": [
        "Type"
      ],
      "members": {
        "DisplayName": {},
        "EmailAddress": {},
        "ID": {},
        "Type": {
          "locationName": "xsi:type",
          "xmlAttribute": true
        },
        "URI": {}
      },
      "xmlNamespace": {
        "prefix": "xsi",
        "uri": "http://www.w3.org/2001/XMLSchema-instance"
      }
    },
    "S3e": {
      "type": "structure",
      "required": [
        "Id",
        "StorageClassAnalysis"
      ],
      "members": {
        "Id": {},
        "Filter": {
          "type": "structure",
          "members": {
            "Prefix": {},
            "Tag": {
              "shape": "S3h"
            },
            "And": {
              "type": "structure",
              "members": {
                "Prefix": {},
                "Tags": {
                  "shape": "S3k",
                  "flattened": true,
                  "locationName": "Tag"
                }
              }
            }
          }
        },
        "StorageClassAnalysis": {
          "type": "structure",
          "members": {
            "DataExport": {
              "type": "structure",
              "required": [
                "OutputSchemaVersion",
                "Destination"
              ],
              "members": {
                "OutputSchemaVersion": {},
                "Destination": {
                  "type": "structure",
                  "required": [
                    "S3BucketDestination"
                  ],
                  "members": {
                    "S3BucketDestination": {
                      "type": "structure",
                      "required": [
                        "Format",
                        "Bucket"
                      ],
                      "members": {
                        "Format": {},
                        "BucketAccountId": {},
                        "Bucket": {},
                        "Prefix": {}
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "S3h": {
      "type": "structure",
      "required": [
        "Key",
        "Value"
      ],
      "members": {
        "Key": {},
        "Value": {}
      }
    },
    "S3k": {
      "type": "list",
      "member": {
        "shape": "S3h",
        "locationName": "Tag"
      }
    },
    "S3u": {
      "type": "list",
      "member": {
        "type": "structure",
        "required": [
          "AllowedMethods",
          "AllowedOrigins"
        ],
        "members": {
          "AllowedHeaders": {
            "locationName": "AllowedHeader",
            "type": "list",
            "member": {},
            "flattened": true
          },
          "AllowedMethods": {
            "locationName": "AllowedMethod",
            "type": "list",
            "member": {},
            "flattened": true
          },
          "AllowedOrigins": {
            "locationName": "AllowedOrigin",
            "type": "list",
            "member": {},
            "flattened": true
          },
          "ExposeHeaders": {
            "locationName": "ExposeHeader",
            "type": "list",
            "member": {},
            "flattened": true
          },
          "MaxAgeSeconds": {
            "type": "integer"
          }
        }
      },
      "flattened": true
    },
    "S47": {
      "type": "structure",
      "required": [
        "Rules"
      ],
      "members": {
        "Rules": {
          "locationName": "Rule",
          "type": "list",
          "member": {
            "type": "structure",
            "members": {
              "ApplyServerSideEncryptionByDefault": {
                "type": "structure",
                "required": [
                  "SSEAlgorithm"
                ],
                "members": {
                  "SSEAlgorithm": {},
                  "KMSMasterKeyID": {
                    "shape": "Sj"
                  }
                }
              }
            }
          },
          "flattened": true
        }
      }
    },
    "S4d": {
      "type": "structure",
      "required": [
        "Destination",
        "IsEnabled",
        "Id",
        "IncludedObjectVersions",
        "Schedule"
      ],
      "members": {
        "Destination": {
          "type": "structure",
          "required": [
            "S3BucketDestination"
          ],
          "members": {
            "S3BucketDestination": {
              "type": "structure",
              "required": [
                "Bucket",
                "Format"
              ],
              "members": {
                "AccountId": {},
                "Bucket": {},
                "Format": {},
                "Prefix": {},
                "Encryption": {
                  "type": "structure",
                  "members": {
                    "SSES3": {
                      "locationName": "SSE-S3",
                      "type": "structure",
                      "members": {}
                    },
                    "SSEKMS": {
                      "locationName": "SSE-KMS",
                      "type": "structure",
                      "required": [
                        "KeyId"
                      ],
                      "members": {
                        "KeyId": {
                          "shape": "Sj"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "IsEnabled": {
          "type": "boolean"
        },
        "Filter": {
          "type": "structure",
          "required": [
            "Prefix"
          ],
          "members": {
            "Prefix": {}
          }
        },
        "Id": {},
        "IncludedObjectVersions": {},
        "OptionalFields": {
          "type": "list",
          "member": {
            "locationName": "Field"
          }
        },
        "Schedule": {
          "type": "structure",
          "required": [
            "Frequency"
          ],
          "members": {
            "Frequency": {}
          }
        }
      }
    },
    "S4t": {
      "type": "list",
      "member": {
        "type": "structure",
        "required": [
          "Prefix",
          "Status"
        ],
        "members": {
          "Expiration": {
            "shape": "S4v"
          },
          "ID": {},
          "Prefix": {},
          "Status": {},
          "Transition": {
            "shape": "S50"
          },
          "NoncurrentVersionTransition": {
            "shape": "S52"
          },
          "NoncurrentVersionExpiration": {
            "shape": "S53"
          },
          "AbortIncompleteMultipartUpload": {
            "shape": "S54"
          }
        }
      },
      "flattened": true
    },
    "S4v": {
      "type": "structure",
      "members": {
        "Date": {
          "shape": "S4w"
        },
        "Days": {
          "type": "integer"
        },
        "ExpiredObjectDeleteMarker": {
          "type": "boolean"
        }
      }
    },
    "S4w": {
      "type": "timestamp",
      "timestampFormat": "iso8601"
    },
    "S50": {
      "type": "structure",
      "members": {
        "Date": {
          "shape": "S4w"
        },
        "Days": {
          "type": "integer"
        },
        "StorageClass": {}
      }
    },
    "S52": {
      "type": "structure",
      "members": {
        "NoncurrentDays": {
          "type": "integer"
        },
        "StorageClass": {}
      }
    },
    "S53": {
      "type": "structure",
      "members": {
        "NoncurrentDays": {
          "type": "integer"
        }
      }
    },
    "S54": {
      "type": "structure",
      "members": {
        "DaysAfterInitiation": {
          "type": "integer"
        }
      }
    },
    "S58": {
      "type": "list",
      "member": {
        "type": "structure",
        "required": [
          "Status"
        ],
        "members": {
          "Expiration": {
            "shape": "S4v"
          },
          "ID": {},
          "Prefix": {
            "deprecated": true
          },
          "Filter": {
            "type": "structure",
            "members": {
              "Prefix": {},
              "Tag": {
                "shape": "S3h"
              },
              "And": {
                "type": "structure",
                "members": {
                  "Prefix": {},
                  "Tags": {
                    "shape": "S3k",
                    "flattened": true,
                    "locationName": "Tag"
                  }
                }
              }
            }
          },
          "Status": {},
          "Transitions": {
            "locationName": "Transition",
            "type": "list",
            "member": {
              "shape": "S50"
            },
            "flattened": true
          },
          "NoncurrentVersionTransitions": {
            "locationName": "NoncurrentVersionTransition",
            "type": "list",
            "member": {
              "shape": "S52"
            },
            "flattened": true
          },
          "NoncurrentVersionExpiration": {
            "shape": "S53"
          },
          "AbortIncompleteMultipartUpload": {
            "shape": "S54"
          }
        }
      },
      "flattened": true
    },
    "S5i": {
      "type": "structure",
      "required": [
        "TargetBucket",
        "TargetPrefix"
      ],
      "members": {
        "TargetBucket": {},
        "TargetGrants": {
          "type": "list",
          "member": {
            "locationName": "Grant",
            "type": "structure",
            "members": {
              "Grantee": {
                "shape": "S37"
              },
              "Permission": {}
            }
          }
        },
        "TargetPrefix": {}
      }
    },
    "S5q": {
      "type": "structure",
      "required": [
        "Id"
      ],
      "members": {
        "Id": {},
        "Filter": {
          "type": "structure",
          "members": {
            "Prefix": {},
            "Tag": {
              "shape": "S3h"
            },
            "And": {
              "type": "structure",
              "members": {
                "Prefix": {},
                "Tags": {
                  "shape": "S3k",
                  "flattened": true,
                  "locationName": "Tag"
                }
              }
            }
          }
        }
      }
    },
    "S5t": {
      "type": "structure",
      "required": [
        "Bucket"
      ],
      "members": {
        "Bucket": {
          "location": "uri",
          "locationName": "Bucket"
        }
      }
    },
    "S5u": {
      "type": "structure",
      "members": {
        "TopicConfiguration": {
          "type": "structure",
          "members": {
            "Id": {},
            "Events": {
              "shape": "S5x",
              "locationName": "Event"
            },
            "Event": {
              "deprecated": true
            },
            "Topic": {}
          }
        },
        "QueueConfiguration": {
          "type": "structure",
          "members": {
            "Id": {},
            "Event": {
              "deprecated": true
            },
            "Events": {
              "shape": "S5x",
              "locationName": "Event"
            },
            "Queue": {}
          }
        },
        "CloudFunctionConfiguration": {
          "type": "structure",
          "members": {
            "Id": {},
            "Event": {
              "deprecated": true
            },
            "Events": {
              "shape": "S5x",
              "locationName": "Event"
            },
            "CloudFunction": {},
            "InvocationRole": {}
          }
        }
      }
    },
    "S5x": {
      "type": "list",
      "member": {},
      "flattened": true
    },
    "S65": {
      "type": "structure",
      "members": {
        "TopicConfigurations": {
          "locationName": "TopicConfiguration",
          "type": "list",
          "member": {
            "type": "structure",
            "required": [
              "TopicArn",
              "Events"
            ],
            "members": {
              "Id": {},
              "TopicArn": {
                "locationName": "Topic"
              },
              "Events": {
                "shape": "S5x",
                "locationName": "Event"
              },
              "Filter": {
                "shape": "S68"
              }
            }
          },
          "flattened": true
        },
        "QueueConfigurations": {
          "locationName": "QueueConfiguration",
          "type": "list",
          "member": {
            "type": "structure",
            "required": [
              "QueueArn",
              "Events"
            ],
            "members": {
              "Id": {},
              "QueueArn": {
                "locationName": "Queue"
              },
              "Events": {
                "shape": "S5x",
                "locationName": "Event"
              },
              "Filter": {
                "shape": "S68"
              }
            }
          },
          "flattened": true
        },
        "LambdaFunctionConfigurations": {
          "locationName": "CloudFunctionConfiguration",
          "type": "list",
          "member": {
            "type": "structure",
            "required": [
              "LambdaFunctionArn",
              "Events"
            ],
            "members": {
              "Id": {},
              "LambdaFunctionArn": {
                "locationName": "CloudFunction"
              },
              "Events": {
                "shape": "S5x",
                "locationName": "Event"
              },
              "Filter": {
                "shape": "S68"
              }
            }
          },
          "flattened": true
        }
      }
    },
    "S68": {
      "type": "structure",
      "members": {
        "Key": {
          "locationName": "S3Key",
          "type": "structure",
          "members": {
            "FilterRules": {
              "locationName": "FilterRule",
              "type": "list",
              "member": {
                "type": "structure",
                "members": {
                  "Name": {},
                  "Value": {}
                }
              },
              "flattened": true
            }
          }
        }
      }
    },
    "S6s": {
      "type": "structure",
      "required": [
        "Role",
        "Rules"
      ],
      "members": {
        "Role": {},
        "Rules": {
          "locationName": "Rule",
          "type": "list",
          "member": {
            "type": "structure",
            "required": [
              "Status",
              "Destination"
            ],
            "members": {
              "ID": {},
              "Priority": {
                "type": "integer"
              },
              "Prefix": {
                "deprecated": true
              },
              "Filter": {
                "type": "structure",
                "members": {
                  "Prefix": {},
                  "Tag": {
                    "shape": "S3h"
                  },
                  "And": {
                    "type": "structure",
                    "members": {
                      "Prefix": {},
                      "Tags": {
                        "shape": "S3k",
                        "flattened": true,
                        "locationName": "Tag"
                      }
                    }
                  }
                }
              },
              "Status": {},
              "SourceSelectionCriteria": {
                "type": "structure",
                "members": {
                  "SseKmsEncryptedObjects": {
                    "type": "structure",
                    "required": [
                      "Status"
                    ],
                    "members": {
                      "Status": {}
                    }
                  }
                }
              },
              "ExistingObjectReplication": {
                "type": "structure",
                "required": [
                  "Status"
                ],
                "members": {
                  "Status": {}
                }
              },
              "Destination": {
                "type": "structure",
                "required": [
                  "Bucket"
                ],
                "members": {
                  "Bucket": {},
                  "Account": {},
                  "StorageClass": {},
                  "AccessControlTranslation": {
                    "type": "structure",
                    "required": [
                      "Owner"
                    ],
                    "members": {
                      "Owner": {}
                    }
                  },
                  "EncryptionConfiguration": {
                    "type": "structure",
                    "members": {
                      "ReplicaKmsKeyID": {}
                    }
                  },
                  "ReplicationTime": {
                    "type": "structure",
                    "required": [
                      "Status",
                      "Time"
                    ],
                    "members": {
                      "Status": {},
                      "Time": {
                        "shape": "S7c"
                      }
                    }
                  },
                  "Metrics": {
                    "type": "structure",
                    "required": [
                      "Status",
                      "EventThreshold"
                    ],
                    "members": {
                      "Status": {},
                      "EventThreshold": {
                        "shape": "S7c"
                      }
                    }
                  }
                }
              },
              "DeleteMarkerReplication": {
                "type": "structure",
                "members": {
                  "Status": {}
                }
              }
            }
          },
          "flattened": true
        }
      }
    },
    "S7c": {
      "type": "structure",
      "members": {
        "Minutes": {
          "type": "integer"
        }
      }
    },
    "S7t": {
      "type": "structure",
      "required": [
        "HostName"
      ],
      "members": {
        "HostName": {},
        "Protocol": {}
      }
    },
    "S7w": {
      "type": "structure",
      "required": [
        "Suffix"
      ],
      "members": {
        "Suffix": {}
      }
    },
    "S7y": {
      "type": "structure",
      "required": [
        "Key"
      ],
      "members": {
        "Key": {}
      }
    },
    "S7z": {
      "type": "list",
      "member": {
        "locationName": "RoutingRule",
        "type": "structure",
        "required": [
          "Redirect"
        ],
        "members": {
          "Condition": {
            "type": "structure",
            "members": {
              "HttpErrorCodeReturnedEquals": {},
              "KeyPrefixEquals": {}
            }
          },
          "Redirect": {
            "type": "structure",
            "members": {
              "HostName": {},
              "HttpRedirectCode": {},
              "Protocol": {},
              "ReplaceKeyPrefixWith": {},
              "ReplaceKeyWith": {}
            }
          }
        }
      }
    },
    "S8y": {
      "type": "structure",
      "members": {
        "Status": {}
      }
    },
    "S91": {
      "type": "structure",
      "members": {
        "ObjectLockEnabled": {},
        "Rule": {
          "type": "structure",
          "members": {
            "DefaultRetention": {
              "type": "structure",
              "members": {
                "Mode": {},
                "Days": {
                  "type": "integer"
                },
                "Years": {
                  "type": "integer"
                }
              }
            }
          }
        }
      }
    },
    "S99": {
      "type": "structure",
      "members": {
        "Mode": {},
        "RetainUntilDate": {
          "shape": "S4w"
        }
      }
    },
    "S9g": {
      "type": "structure",
      "members": {
        "BlockPublicAcls": {
          "locationName": "BlockPublicAcls",
          "type": "boolean"
        },
        "IgnorePublicAcls": {
          "locationName": "IgnorePublicAcls",
          "type": "boolean"
        },
        "BlockPublicPolicy": {
          "locationName": "BlockPublicPolicy",
          "type": "boolean"
        },
        "RestrictPublicBuckets": {
          "locationName": "RestrictPublicBuckets",
          "type": "boolean"
        }
      }
    },
    "Sad": {
      "type": "structure",
      "members": {
        "ID": {},
        "DisplayName": {}
      }
    },
    "Sae": {
      "type": "list",
      "member": {
        "type": "structure",
        "members": {
          "Prefix": {}
        }
      },
      "flattened": true
    },
    "Saw": {
      "type": "list",
      "member": {
        "type": "structure",
        "members": {
          "Key": {},
          "LastModified": {
            "type": "timestamp"
          },
          "ETag": {},
          "Size": {
            "type": "integer"
          },
          "StorageClass": {},
          "Owner": {
            "shape": "S32"
          }
        }
      },
      "flattened": true
    },
    "Sbe": {
      "type": "structure",
      "members": {
        "Grants": {
          "shape": "S35",
          "locationName": "AccessControlList"
        },
        "Owner": {
          "shape": "S32"
        }
      }
    },
    "Sc1": {
      "type": "structure",
      "required": [
        "TagSet"
      ],
      "members": {
        "TagSet": {
          "shape": "S3k"
        }
      }
    },
    "Scr": {
      "type": "structure",
      "members": {
        "CSV": {
          "type": "structure",
          "members": {
            "FileHeaderInfo": {},
            "Comments": {},
            "QuoteEscapeCharacter": {},
            "RecordDelimiter": {},
            "FieldDelimiter": {},
            "QuoteCharacter": {},
            "AllowQuotedRecordDelimiter": {
              "type": "boolean"
            }
          }
        },
        "CompressionType": {},
        "JSON": {
          "type": "structure",
          "members": {
            "Type": {}
          }
        },
        "Parquet": {
          "type": "structure",
          "members": {}
        }
      }
    },
    "Sd6": {
      "type": "structure",
      "members": {
        "CSV": {
          "type": "structure",
          "members": {
            "QuoteFields": {},
            "QuoteEscapeCharacter": {},
            "RecordDelimiter": {},
            "FieldDelimiter": {},
            "QuoteCharacter": {}
          }
        },
        "JSON": {
          "type": "structure",
          "members": {
            "RecordDelimiter": {}
          }
        }
      }
    }
  }
}
},{}],5:[function(require,module,exports){
module.exports={
  "pagination": {
    "ListBuckets": {
      "result_key": "Buckets"
    },
    "ListMultipartUploads": {
      "input_token": [
        "KeyMarker",
        "UploadIdMarker"
      ],
      "limit_key": "MaxUploads",
      "more_results": "IsTruncated",
      "output_token": [
        "NextKeyMarker",
        "NextUploadIdMarker"
      ],
      "result_key": [
        "Uploads",
        "CommonPrefixes"
      ]
    },
    "ListObjectVersions": {
      "input_token": [
        "KeyMarker",
        "VersionIdMarker"
      ],
      "limit_key": "MaxKeys",
      "more_results": "IsTruncated",
      "output_token": [
        "NextKeyMarker",
        "NextVersionIdMarker"
      ],
      "result_key": [
        "Versions",
        "DeleteMarkers",
        "CommonPrefixes"
      ]
    },
    "ListObjects": {
      "input_token": "Marker",
      "limit_key": "MaxKeys",
      "more_results": "IsTruncated",
      "output_token": "NextMarker || Contents[-1].Key",
      "result_key": [
        "Contents",
        "CommonPrefixes"
      ]
    },
    "ListObjectsV2": {
      "input_token": "ContinuationToken",
      "limit_key": "MaxKeys",
      "output_token": "NextContinuationToken",
      "result_key": [
        "Contents",
        "CommonPrefixes"
      ]
    },
    "ListParts": {
      "input_token": "PartNumberMarker",
      "limit_key": "MaxParts",
      "more_results": "IsTruncated",
      "output_token": "NextPartNumberMarker",
      "result_key": "Parts"
    }
  }
}
},{}],6:[function(require,module,exports){
module.exports={
  "version": 2,
  "waiters": {
    "BucketExists": {
      "delay": 5,
      "operation": "HeadBucket",
      "maxAttempts": 20,
      "acceptors": [
        {
          "expected": 200,
          "matcher": "status",
          "state": "success"
        },
        {
          "expected": 301,
          "matcher": "status",
          "state": "success"
        },
        {
          "expected": 403,
          "matcher": "status",
          "state": "success"
        },
        {
          "expected": 404,
          "matcher": "status",
          "state": "retry"
        }
      ]
    },
    "BucketNotExists": {
      "delay": 5,
      "operation": "HeadBucket",
      "maxAttempts": 20,
      "acceptors": [
        {
          "expected": 404,
          "matcher": "status",
          "state": "success"
        }
      ]
    },
    "ObjectExists": {
      "delay": 5,
      "operation": "HeadObject",
      "maxAttempts": 20,
      "acceptors": [
        {
          "expected": 200,
          "matcher": "status",
          "state": "success"
        },
        {
          "expected": 404,
          "matcher": "status",
          "state": "retry"
        }
      ]
    },
    "ObjectNotExists": {
      "delay": 5,
      "operation": "HeadObject",
      "maxAttempts": 20,
      "acceptors": [
        {
          "expected": 404,
          "matcher": "status",
          "state": "success"
        }
      ]
    }
  }
}

},{}],7:[function(require,module,exports){
module.exports={
  "version": "2.0",
  "metadata": {
    "apiVersion": "2011-06-15",
    "endpointPrefix": "sts",
    "globalEndpoint": "sts.amazonaws.com",
    "protocol": "query",
    "serviceAbbreviation": "AWS STS",
    "serviceFullName": "AWS Security Token Service",
    "serviceId": "STS",
    "signatureVersion": "v4",
    "uid": "sts-2011-06-15",
    "xmlNamespace": "https://sts.amazonaws.com/doc/2011-06-15/"
  },
  "operations": {
    "AssumeRole": {
      "input": {
        "type": "structure",
        "required": [
          "RoleArn",
          "RoleSessionName"
        ],
        "members": {
          "RoleArn": {},
          "RoleSessionName": {},
          "PolicyArns": {
            "shape": "S4"
          },
          "Policy": {},
          "DurationSeconds": {
            "type": "integer"
          },
          "Tags": {
            "shape": "S8"
          },
          "TransitiveTagKeys": {
            "type": "list",
            "member": {}
          },
          "ExternalId": {},
          "SerialNumber": {},
          "TokenCode": {}
        }
      },
      "output": {
        "resultWrapper": "AssumeRoleResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Sh"
          },
          "AssumedRoleUser": {
            "shape": "Sm"
          },
          "PackedPolicySize": {
            "type": "integer"
          }
        }
      }
    },
    "AssumeRoleWithSAML": {
      "input": {
        "type": "structure",
        "required": [
          "RoleArn",
          "PrincipalArn",
          "SAMLAssertion"
        ],
        "members": {
          "RoleArn": {},
          "PrincipalArn": {},
          "SAMLAssertion": {},
          "PolicyArns": {
            "shape": "S4"
          },
          "Policy": {},
          "DurationSeconds": {
            "type": "integer"
          }
        }
      },
      "output": {
        "resultWrapper": "AssumeRoleWithSAMLResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Sh"
          },
          "AssumedRoleUser": {
            "shape": "Sm"
          },
          "PackedPolicySize": {
            "type": "integer"
          },
          "Subject": {},
          "SubjectType": {},
          "Issuer": {},
          "Audience": {},
          "NameQualifier": {}
        }
      }
    },
    "AssumeRoleWithWebIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "RoleArn",
          "RoleSessionName",
          "WebIdentityToken"
        ],
        "members": {
          "RoleArn": {},
          "RoleSessionName": {},
          "WebIdentityToken": {},
          "ProviderId": {},
          "PolicyArns": {
            "shape": "S4"
          },
          "Policy": {},
          "DurationSeconds": {
            "type": "integer"
          }
        }
      },
      "output": {
        "resultWrapper": "AssumeRoleWithWebIdentityResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Sh"
          },
          "SubjectFromWebIdentityToken": {},
          "AssumedRoleUser": {
            "shape": "Sm"
          },
          "PackedPolicySize": {
            "type": "integer"
          },
          "Provider": {},
          "Audience": {}
        }
      }
    },
    "DecodeAuthorizationMessage": {
      "input": {
        "type": "structure",
        "required": [
          "EncodedMessage"
        ],
        "members": {
          "EncodedMessage": {}
        }
      },
      "output": {
        "resultWrapper": "DecodeAuthorizationMessageResult",
        "type": "structure",
        "members": {
          "DecodedMessage": {}
        }
      }
    },
    "GetAccessKeyInfo": {
      "input": {
        "type": "structure",
        "required": [
          "AccessKeyId"
        ],
        "members": {
          "AccessKeyId": {}
        }
      },
      "output": {
        "resultWrapper": "GetAccessKeyInfoResult",
        "type": "structure",
        "members": {
          "Account": {}
        }
      }
    },
    "GetCallerIdentity": {
      "input": {
        "type": "structure",
        "members": {}
      },
      "output": {
        "resultWrapper": "GetCallerIdentityResult",
        "type": "structure",
        "members": {
          "UserId": {},
          "Account": {},
          "Arn": {}
        }
      }
    },
    "GetFederationToken": {
      "input": {
        "type": "structure",
        "required": [
          "Name"
        ],
        "members": {
          "Name": {},
          "Policy": {},
          "PolicyArns": {
            "shape": "S4"
          },
          "DurationSeconds": {
            "type": "integer"
          },
          "Tags": {
            "shape": "S8"
          }
        }
      },
      "output": {
        "resultWrapper": "GetFederationTokenResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Sh"
          },
          "FederatedUser": {
            "type": "structure",
            "required": [
              "FederatedUserId",
              "Arn"
            ],
            "members": {
              "FederatedUserId": {},
              "Arn": {}
            }
          },
          "PackedPolicySize": {
            "type": "integer"
          }
        }
      }
    },
    "GetSessionToken": {
      "input": {
        "type": "structure",
        "members": {
          "DurationSeconds": {
            "type": "integer"
          },
          "SerialNumber": {},
          "TokenCode": {}
        }
      },
      "output": {
        "resultWrapper": "GetSessionTokenResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Sh"
          }
        }
      }
    }
  },
  "shapes": {
    "S4": {
      "type": "list",
      "member": {
        "type": "structure",
        "members": {
          "arn": {}
        }
      }
    },
    "S8": {
      "type": "list",
      "member": {
        "type": "structure",
        "required": [
          "Key",
          "Value"
        ],
        "members": {
          "Key": {},
          "Value": {}
        }
      }
    },
    "Sh": {
      "type": "structure",
      "required": [
        "AccessKeyId",
        "SecretAccessKey",
        "SessionToken",
        "Expiration"
      ],
      "members": {
        "AccessKeyId": {},
        "SecretAccessKey": {},
        "SessionToken": {},
        "Expiration": {
          "type": "timestamp"
        }
      }
    },
    "Sm": {
      "type": "structure",
      "required": [
        "AssumedRoleId",
        "Arn"
      ],
      "members": {
        "AssumedRoleId": {},
        "Arn": {}
      }
    }
  }
}
},{}],8:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"dup":2}],9:[function(require,module,exports){
require('./lib/browser_loader');

var AWS = require('./lib/core');
if (typeof window !== 'undefined') window.AWS = AWS;
if (typeof module !== 'undefined') module.exports = AWS;
if (typeof self !== 'undefined') self.AWS = AWS;
},{"./lib/browser_loader":20,"./lib/core":23}],10:[function(require,module,exports){
require('../lib/node_loader');
var AWS = require('../lib/core');
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['cognitoidentity'] = {};
AWS.CognitoIdentity = Service.defineService('cognitoidentity', ['2014-06-30']);
require('../lib/services/cognitoidentity');
Object.defineProperty(apiLoader.services['cognitoidentity'], '2014-06-30', {
  get: function get() {
    var model = require('../apis/cognito-identity-2014-06-30.min.json');
    model.paginators = require('../apis/cognito-identity-2014-06-30.paginators.json').pagination;
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.CognitoIdentity;

},{"../apis/cognito-identity-2014-06-30.min.json":1,"../apis/cognito-identity-2014-06-30.paginators.json":2,"../lib/core":23,"../lib/node_loader":20,"../lib/services/cognitoidentity":66}],11:[function(require,module,exports){
require('../lib/node_loader');
var AWS = require('../lib/core');
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['s3'] = {};
AWS.S3 = Service.defineService('s3', ['2006-03-01']);
require('../lib/services/s3');
Object.defineProperty(apiLoader.services['s3'], '2006-03-01', {
  get: function get() {
    var model = require('../apis/s3-2006-03-01.min.json');
    model.paginators = require('../apis/s3-2006-03-01.paginators.json').pagination;
    model.waiters = require('../apis/s3-2006-03-01.waiters2.json').waiters;
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.S3;

},{"../apis/s3-2006-03-01.min.json":4,"../apis/s3-2006-03-01.paginators.json":5,"../apis/s3-2006-03-01.waiters2.json":6,"../lib/core":23,"../lib/node_loader":20,"../lib/services/s3":67}],12:[function(require,module,exports){
require('../lib/node_loader');
var AWS = require('../lib/core');
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['sts'] = {};
AWS.STS = Service.defineService('sts', ['2011-06-15']);
require('../lib/services/sts');
Object.defineProperty(apiLoader.services['sts'], '2011-06-15', {
  get: function get() {
    var model = require('../apis/sts-2011-06-15.min.json');
    model.paginators = require('../apis/sts-2011-06-15.paginators.json').pagination;
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.STS;

},{"../apis/sts-2011-06-15.min.json":7,"../apis/sts-2011-06-15.paginators.json":8,"../lib/core":23,"../lib/node_loader":20,"../lib/services/sts":68}],13:[function(require,module,exports){
function apiLoader(svc, version) {
  if (!apiLoader.services.hasOwnProperty(svc)) {
    throw new Error('InvalidService: Failed to load api for ' + svc);
  }
  return apiLoader.services[svc][version];
}

/**
 * @api private
 *
 * This member of AWS.apiLoader is private, but changing it will necessitate a
 * change to ../scripts/services-table-generator.ts
 */
apiLoader.services = {};

/**
 * @api private
 */
module.exports = apiLoader;

},{}],14:[function(require,module,exports){
var Hmac = require('./browserHmac');
var Md5 = require('./browserMd5');
var Sha1 = require('./browserSha1');
var Sha256 = require('./browserSha256');

/**
 * @api private
 */
module.exports = exports = {
    createHash: function createHash(alg) {
      alg = alg.toLowerCase();
      if (alg === 'md5') {
        return new Md5();
      } else if (alg === 'sha256') {
        return new Sha256();
      } else if (alg === 'sha1') {
        return new Sha1();
      }

      throw new Error('Hash algorithm ' + alg + ' is not supported in the browser SDK');
    },
    createHmac: function createHmac(alg, key) {
      alg = alg.toLowerCase();
      if (alg === 'md5') {
        return new Hmac(Md5, key);
      } else if (alg === 'sha256') {
        return new Hmac(Sha256, key);
      } else if (alg === 'sha1') {
        return new Hmac(Sha1, key);
      }

      throw new Error('HMAC algorithm ' + alg + ' is not supported in the browser SDK');
    },
    createSign: function() {
      throw new Error('createSign is not implemented in the browser');
    }
  };

},{"./browserHmac":16,"./browserMd5":17,"./browserSha1":18,"./browserSha256":19}],15:[function(require,module,exports){
var Buffer = require('buffer/').Buffer;

/**
 * This is a polyfill for the static method `isView` of `ArrayBuffer`, which is
 * e.g. missing in IE 10.
 *
 * @api private
 */
if (
    typeof ArrayBuffer !== 'undefined' &&
    typeof ArrayBuffer.isView === 'undefined'
) {
    ArrayBuffer.isView = function(arg) {
        return viewStrings.indexOf(Object.prototype.toString.call(arg)) > -1;
    };
}

/**
 * @api private
 */
var viewStrings = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]',
    '[object DataView]',
];

/**
 * @api private
 */
function isEmptyData(data) {
    if (typeof data === 'string') {
        return data.length === 0;
    }
    return data.byteLength === 0;
}

/**
 * @api private
 */
function convertToBuffer(data) {
    if (typeof data === 'string') {
        data = new Buffer(data, 'utf8');
    }

    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }

    return new Uint8Array(data);
}

/**
 * @api private
 */
module.exports = exports = {
    isEmptyData: isEmptyData,
    convertToBuffer: convertToBuffer,
};

},{"buffer/":91}],16:[function(require,module,exports){
var hashUtils = require('./browserHashUtils');

/**
 * @api private
 */
function Hmac(hashCtor, secret) {
    this.hash = new hashCtor();
    this.outer = new hashCtor();

    var inner = bufferFromSecret(hashCtor, secret);
    var outer = new Uint8Array(hashCtor.BLOCK_SIZE);
    outer.set(inner);

    for (var i = 0; i < hashCtor.BLOCK_SIZE; i++) {
        inner[i] ^= 0x36;
        outer[i] ^= 0x5c;
    }

    this.hash.update(inner);
    this.outer.update(outer);

    // Zero out the copied key buffer.
    for (var i = 0; i < inner.byteLength; i++) {
        inner[i] = 0;
    }
}

/**
 * @api private
 */
module.exports = exports = Hmac;

Hmac.prototype.update = function (toHash) {
    if (hashUtils.isEmptyData(toHash) || this.error) {
        return this;
    }

    try {
        this.hash.update(hashUtils.convertToBuffer(toHash));
    } catch (e) {
        this.error = e;
    }

    return this;
};

Hmac.prototype.digest = function (encoding) {
    if (!this.outer.finished) {
        this.outer.update(this.hash.digest());
    }

    return this.outer.digest(encoding);
};

function bufferFromSecret(hashCtor, secret) {
    var input = hashUtils.convertToBuffer(secret);
    if (input.byteLength > hashCtor.BLOCK_SIZE) {
        var bufferHash = new hashCtor;
        bufferHash.update(input);
        input = bufferHash.digest();
    }
    var buffer = new Uint8Array(hashCtor.BLOCK_SIZE);
    buffer.set(input);
    return buffer;
}

},{"./browserHashUtils":15}],17:[function(require,module,exports){
var hashUtils = require('./browserHashUtils');
var Buffer = require('buffer/').Buffer;

var BLOCK_SIZE = 64;

var DIGEST_LENGTH = 16;

var INIT = [
    0x67452301,
    0xefcdab89,
    0x98badcfe,
    0x10325476,
];

/**
 * @api private
 */
function Md5() {
    this.state = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
    ];
    this.buffer = new DataView(new ArrayBuffer(BLOCK_SIZE));
    this.bufferLength = 0;
    this.bytesHashed = 0;
    this.finished = false;
}

/**
 * @api private
 */
module.exports = exports = Md5;

Md5.BLOCK_SIZE = BLOCK_SIZE;

Md5.prototype.update = function (sourceData) {
    if (hashUtils.isEmptyData(sourceData)) {
        return this;
    } else if (this.finished) {
        throw new Error('Attempted to update an already finished hash.');
    }

    var data = hashUtils.convertToBuffer(sourceData);
    var position = 0;
    var byteLength = data.byteLength;
    this.bytesHashed += byteLength;
    while (byteLength > 0) {
        this.buffer.setUint8(this.bufferLength++, data[position++]);
        byteLength--;
        if (this.bufferLength === BLOCK_SIZE) {
            this.hashBuffer();
            this.bufferLength = 0;
        }
    }

    return this;
};

Md5.prototype.digest = function (encoding) {
    if (!this.finished) {
        var _a = this, buffer = _a.buffer, undecoratedLength = _a.bufferLength, bytesHashed = _a.bytesHashed;
        var bitsHashed = bytesHashed * 8;
        buffer.setUint8(this.bufferLength++, 128);
        // Ensure the final block has enough room for the hashed length
        if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
            for (var i = this.bufferLength; i < BLOCK_SIZE; i++) {
                buffer.setUint8(i, 0);
            }
            this.hashBuffer();
            this.bufferLength = 0;
        }
        for (var i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {
            buffer.setUint8(i, 0);
        }
        buffer.setUint32(BLOCK_SIZE - 8, bitsHashed >>> 0, true);
        buffer.setUint32(BLOCK_SIZE - 4, Math.floor(bitsHashed / 0x100000000), true);
        this.hashBuffer();
        this.finished = true;
    }
    var out = new DataView(new ArrayBuffer(DIGEST_LENGTH));
    for (var i = 0; i < 4; i++) {
        out.setUint32(i * 4, this.state[i], true);
    }
    var buff = new Buffer(out.buffer, out.byteOffset, out.byteLength);
    return encoding ? buff.toString(encoding) : buff;
};

Md5.prototype.hashBuffer = function () {
    var _a = this, buffer = _a.buffer, state = _a.state;
    var a = state[0], b = state[1], c = state[2], d = state[3];
    a = ff(a, b, c, d, buffer.getUint32(0, true), 7, 0xd76aa478);
    d = ff(d, a, b, c, buffer.getUint32(4, true), 12, 0xe8c7b756);
    c = ff(c, d, a, b, buffer.getUint32(8, true), 17, 0x242070db);
    b = ff(b, c, d, a, buffer.getUint32(12, true), 22, 0xc1bdceee);
    a = ff(a, b, c, d, buffer.getUint32(16, true), 7, 0xf57c0faf);
    d = ff(d, a, b, c, buffer.getUint32(20, true), 12, 0x4787c62a);
    c = ff(c, d, a, b, buffer.getUint32(24, true), 17, 0xa8304613);
    b = ff(b, c, d, a, buffer.getUint32(28, true), 22, 0xfd469501);
    a = ff(a, b, c, d, buffer.getUint32(32, true), 7, 0x698098d8);
    d = ff(d, a, b, c, buffer.getUint32(36, true), 12, 0x8b44f7af);
    c = ff(c, d, a, b, buffer.getUint32(40, true), 17, 0xffff5bb1);
    b = ff(b, c, d, a, buffer.getUint32(44, true), 22, 0x895cd7be);
    a = ff(a, b, c, d, buffer.getUint32(48, true), 7, 0x6b901122);
    d = ff(d, a, b, c, buffer.getUint32(52, true), 12, 0xfd987193);
    c = ff(c, d, a, b, buffer.getUint32(56, true), 17, 0xa679438e);
    b = ff(b, c, d, a, buffer.getUint32(60, true), 22, 0x49b40821);
    a = gg(a, b, c, d, buffer.getUint32(4, true), 5, 0xf61e2562);
    d = gg(d, a, b, c, buffer.getUint32(24, true), 9, 0xc040b340);
    c = gg(c, d, a, b, buffer.getUint32(44, true), 14, 0x265e5a51);
    b = gg(b, c, d, a, buffer.getUint32(0, true), 20, 0xe9b6c7aa);
    a = gg(a, b, c, d, buffer.getUint32(20, true), 5, 0xd62f105d);
    d = gg(d, a, b, c, buffer.getUint32(40, true), 9, 0x02441453);
    c = gg(c, d, a, b, buffer.getUint32(60, true), 14, 0xd8a1e681);
    b = gg(b, c, d, a, buffer.getUint32(16, true), 20, 0xe7d3fbc8);
    a = gg(a, b, c, d, buffer.getUint32(36, true), 5, 0x21e1cde6);
    d = gg(d, a, b, c, buffer.getUint32(56, true), 9, 0xc33707d6);
    c = gg(c, d, a, b, buffer.getUint32(12, true), 14, 0xf4d50d87);
    b = gg(b, c, d, a, buffer.getUint32(32, true), 20, 0x455a14ed);
    a = gg(a, b, c, d, buffer.getUint32(52, true), 5, 0xa9e3e905);
    d = gg(d, a, b, c, buffer.getUint32(8, true), 9, 0xfcefa3f8);
    c = gg(c, d, a, b, buffer.getUint32(28, true), 14, 0x676f02d9);
    b = gg(b, c, d, a, buffer.getUint32(48, true), 20, 0x8d2a4c8a);
    a = hh(a, b, c, d, buffer.getUint32(20, true), 4, 0xfffa3942);
    d = hh(d, a, b, c, buffer.getUint32(32, true), 11, 0x8771f681);
    c = hh(c, d, a, b, buffer.getUint32(44, true), 16, 0x6d9d6122);
    b = hh(b, c, d, a, buffer.getUint32(56, true), 23, 0xfde5380c);
    a = hh(a, b, c, d, buffer.getUint32(4, true), 4, 0xa4beea44);
    d = hh(d, a, b, c, buffer.getUint32(16, true), 11, 0x4bdecfa9);
    c = hh(c, d, a, b, buffer.getUint32(28, true), 16, 0xf6bb4b60);
    b = hh(b, c, d, a, buffer.getUint32(40, true), 23, 0xbebfbc70);
    a = hh(a, b, c, d, buffer.getUint32(52, true), 4, 0x289b7ec6);
    d = hh(d, a, b, c, buffer.getUint32(0, true), 11, 0xeaa127fa);
    c = hh(c, d, a, b, buffer.getUint32(12, true), 16, 0xd4ef3085);
    b = hh(b, c, d, a, buffer.getUint32(24, true), 23, 0x04881d05);
    a = hh(a, b, c, d, buffer.getUint32(36, true), 4, 0xd9d4d039);
    d = hh(d, a, b, c, buffer.getUint32(48, true), 11, 0xe6db99e5);
    c = hh(c, d, a, b, buffer.getUint32(60, true), 16, 0x1fa27cf8);
    b = hh(b, c, d, a, buffer.getUint32(8, true), 23, 0xc4ac5665);
    a = ii(a, b, c, d, buffer.getUint32(0, true), 6, 0xf4292244);
    d = ii(d, a, b, c, buffer.getUint32(28, true), 10, 0x432aff97);
    c = ii(c, d, a, b, buffer.getUint32(56, true), 15, 0xab9423a7);
    b = ii(b, c, d, a, buffer.getUint32(20, true), 21, 0xfc93a039);
    a = ii(a, b, c, d, buffer.getUint32(48, true), 6, 0x655b59c3);
    d = ii(d, a, b, c, buffer.getUint32(12, true), 10, 0x8f0ccc92);
    c = ii(c, d, a, b, buffer.getUint32(40, true), 15, 0xffeff47d);
    b = ii(b, c, d, a, buffer.getUint32(4, true), 21, 0x85845dd1);
    a = ii(a, b, c, d, buffer.getUint32(32, true), 6, 0x6fa87e4f);
    d = ii(d, a, b, c, buffer.getUint32(60, true), 10, 0xfe2ce6e0);
    c = ii(c, d, a, b, buffer.getUint32(24, true), 15, 0xa3014314);
    b = ii(b, c, d, a, buffer.getUint32(52, true), 21, 0x4e0811a1);
    a = ii(a, b, c, d, buffer.getUint32(16, true), 6, 0xf7537e82);
    d = ii(d, a, b, c, buffer.getUint32(44, true), 10, 0xbd3af235);
    c = ii(c, d, a, b, buffer.getUint32(8, true), 15, 0x2ad7d2bb);
    b = ii(b, c, d, a, buffer.getUint32(36, true), 21, 0xeb86d391);
    state[0] = (a + state[0]) & 0xFFFFFFFF;
    state[1] = (b + state[1]) & 0xFFFFFFFF;
    state[2] = (c + state[2]) & 0xFFFFFFFF;
    state[3] = (d + state[3]) & 0xFFFFFFFF;
};

function cmn(q, a, b, x, s, t) {
    a = (((a + q) & 0xFFFFFFFF) + ((x + t) & 0xFFFFFFFF)) & 0xFFFFFFFF;
    return (((a << s) | (a >>> (32 - s))) + b) & 0xFFFFFFFF;
}

function ff(a, b, c, d, x, s, t) {
    return cmn((b & c) | ((~b) & d), a, b, x, s, t);
}

function gg(a, b, c, d, x, s, t) {
    return cmn((b & d) | (c & (~d)), a, b, x, s, t);
}

function hh(a, b, c, d, x, s, t) {
    return cmn(b ^ c ^ d, a, b, x, s, t);
}

function ii(a, b, c, d, x, s, t) {
    return cmn(c ^ (b | (~d)), a, b, x, s, t);
}

},{"./browserHashUtils":15,"buffer/":91}],18:[function(require,module,exports){
var Buffer = require('buffer/').Buffer;
var hashUtils = require('./browserHashUtils');

var BLOCK_SIZE = 64;

var DIGEST_LENGTH = 20;

var KEY = new Uint32Array([
    0x5a827999,
    0x6ed9eba1,
    0x8f1bbcdc | 0,
    0xca62c1d6 | 0
]);

var INIT = [
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19,
];

var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;

/**
 * @api private
 */
function Sha1() {
    this.h0 = 0x67452301;
    this.h1 = 0xEFCDAB89;
    this.h2 = 0x98BADCFE;
    this.h3 = 0x10325476;
    this.h4 = 0xC3D2E1F0;
    // The first 64 bytes (16 words) is the data chunk
    this.block = new Uint32Array(80);
    this.offset = 0;
    this.shift = 24;
    this.totalLength = 0;
}

/**
 * @api private
 */
module.exports = exports = Sha1;

Sha1.BLOCK_SIZE = BLOCK_SIZE;

Sha1.prototype.update = function (data) {
    if (this.finished) {
        throw new Error('Attempted to update an already finished hash.');
    }

    if (hashUtils.isEmptyData(data)) {
        return this;
    }

    data = hashUtils.convertToBuffer(data);

    var length = data.length;
    this.totalLength += length * 8;
    for (var i = 0; i < length; i++) {
        this.write(data[i]);
    }

    return this;
};

Sha1.prototype.write = function write(byte) {
    this.block[this.offset] |= (byte & 0xff) << this.shift;
    if (this.shift) {
        this.shift -= 8;
    } else {
        this.offset++;
        this.shift = 24;
    }

    if (this.offset === 16) this.processBlock();
};

Sha1.prototype.digest = function (encoding) {
    // Pad
    this.write(0x80);
    if (this.offset > 14 || (this.offset === 14 && this.shift < 24)) {
      this.processBlock();
    }
    this.offset = 14;
    this.shift = 24;

    // 64-bit length big-endian
    this.write(0x00); // numbers this big aren't accurate in javascript anyway
    this.write(0x00); // ..So just hard-code to zero.
    this.write(this.totalLength > 0xffffffffff ? this.totalLength / 0x10000000000 : 0x00);
    this.write(this.totalLength > 0xffffffff ? this.totalLength / 0x100000000 : 0x00);
    for (var s = 24; s >= 0; s -= 8) {
        this.write(this.totalLength >> s);
    }
    // The value in state is little-endian rather than big-endian, so flip
    // each word into a new Uint8Array
    var out = new Buffer(DIGEST_LENGTH);
    var outView = new DataView(out.buffer);
    outView.setUint32(0, this.h0, false);
    outView.setUint32(4, this.h1, false);
    outView.setUint32(8, this.h2, false);
    outView.setUint32(12, this.h3, false);
    outView.setUint32(16, this.h4, false);

    return encoding ? out.toString(encoding) : out;
};

Sha1.prototype.processBlock = function processBlock() {
    // Extend the sixteen 32-bit words into eighty 32-bit words:
    for (var i = 16; i < 80; i++) {
      var w = this.block[i - 3] ^ this.block[i - 8] ^ this.block[i - 14] ^ this.block[i - 16];
      this.block[i] = (w << 1) | (w >>> 31);
    }

    // Initialize hash value for this chunk:
    var a = this.h0;
    var b = this.h1;
    var c = this.h2;
    var d = this.h3;
    var e = this.h4;
    var f, k;

    // Main loop:
    for (i = 0; i < 80; i++) {
      if (i < 20) {
        f = d ^ (b & (c ^ d));
        k = 0x5A827999;
      }
      else if (i < 40) {
        f = b ^ c ^ d;
        k = 0x6ED9EBA1;
      }
      else if (i < 60) {
        f = (b & c) | (d & (b | c));
        k = 0x8F1BBCDC;
      }
      else {
        f = b ^ c ^ d;
        k = 0xCA62C1D6;
      }
      var temp = (a << 5 | a >>> 27) + f + e + k + (this.block[i]|0);
      e = d;
      d = c;
      c = (b << 30 | b >>> 2);
      b = a;
      a = temp;
    }

    // Add this chunk's hash to result so far:
    this.h0 = (this.h0 + a) | 0;
    this.h1 = (this.h1 + b) | 0;
    this.h2 = (this.h2 + c) | 0;
    this.h3 = (this.h3 + d) | 0;
    this.h4 = (this.h4 + e) | 0;

    // The block is now reusable.
    this.offset = 0;
    for (i = 0; i < 16; i++) {
        this.block[i] = 0;
    }
};

},{"./browserHashUtils":15,"buffer/":91}],19:[function(require,module,exports){
var Buffer = require('buffer/').Buffer;
var hashUtils = require('./browserHashUtils');

var BLOCK_SIZE = 64;

var DIGEST_LENGTH = 32;

var KEY = new Uint32Array([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);

var INIT = [
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19,
];

var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;

/**
 * @private
 */
function Sha256() {
    this.state = [
        0x6a09e667,
        0xbb67ae85,
        0x3c6ef372,
        0xa54ff53a,
        0x510e527f,
        0x9b05688c,
        0x1f83d9ab,
        0x5be0cd19,
    ];
    this.temp = new Int32Array(64);
    this.buffer = new Uint8Array(64);
    this.bufferLength = 0;
    this.bytesHashed = 0;
    /**
     * @private
     */
    this.finished = false;
}

/**
 * @api private
 */
module.exports = exports = Sha256;

Sha256.BLOCK_SIZE = BLOCK_SIZE;

Sha256.prototype.update = function (data) {
    if (this.finished) {
        throw new Error('Attempted to update an already finished hash.');
    }

    if (hashUtils.isEmptyData(data)) {
        return this;
    }

    data = hashUtils.convertToBuffer(data);

    var position = 0;
    var byteLength = data.byteLength;
    this.bytesHashed += byteLength;
    if (this.bytesHashed * 8 > MAX_HASHABLE_LENGTH) {
        throw new Error('Cannot hash more than 2^53 - 1 bits');
    }

    while (byteLength > 0) {
        this.buffer[this.bufferLength++] = data[position++];
        byteLength--;
        if (this.bufferLength === BLOCK_SIZE) {
            this.hashBuffer();
            this.bufferLength = 0;
        }
    }

    return this;
};

Sha256.prototype.digest = function (encoding) {
    if (!this.finished) {
        var bitsHashed = this.bytesHashed * 8;
        var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
        var undecoratedLength = this.bufferLength;
        bufferView.setUint8(this.bufferLength++, 0x80);
        // Ensure the final block has enough room for the hashed length
        if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
            for (var i = this.bufferLength; i < BLOCK_SIZE; i++) {
                bufferView.setUint8(i, 0);
            }
            this.hashBuffer();
            this.bufferLength = 0;
        }
        for (var i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {
            bufferView.setUint8(i, 0);
        }
        bufferView.setUint32(BLOCK_SIZE - 8, Math.floor(bitsHashed / 0x100000000), true);
        bufferView.setUint32(BLOCK_SIZE - 4, bitsHashed);
        this.hashBuffer();
        this.finished = true;
    }
    // The value in state is little-endian rather than big-endian, so flip
    // each word into a new Uint8Array
    var out = new Buffer(DIGEST_LENGTH);
    for (var i = 0; i < 8; i++) {
        out[i * 4] = (this.state[i] >>> 24) & 0xff;
        out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;
        out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;
        out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;
    }
    return encoding ? out.toString(encoding) : out;
};

Sha256.prototype.hashBuffer = function () {
    var _a = this,
        buffer = _a.buffer,
        state = _a.state;
    var state0 = state[0],
        state1 = state[1],
        state2 = state[2],
        state3 = state[3],
        state4 = state[4],
        state5 = state[5],
        state6 = state[6],
        state7 = state[7];
    for (var i = 0; i < BLOCK_SIZE; i++) {
        if (i < 16) {
            this.temp[i] = (((buffer[i * 4] & 0xff) << 24) |
                ((buffer[(i * 4) + 1] & 0xff) << 16) |
                ((buffer[(i * 4) + 2] & 0xff) << 8) |
                (buffer[(i * 4) + 3] & 0xff));
        }
        else {
            var u = this.temp[i - 2];
            var t1_1 = (u >>> 17 | u << 15) ^
                (u >>> 19 | u << 13) ^
                (u >>> 10);
            u = this.temp[i - 15];
            var t2_1 = (u >>> 7 | u << 25) ^
                (u >>> 18 | u << 14) ^
                (u >>> 3);
            this.temp[i] = (t1_1 + this.temp[i - 7] | 0) +
                (t2_1 + this.temp[i - 16] | 0);
        }
        var t1 = (((((state4 >>> 6 | state4 << 26) ^
            (state4 >>> 11 | state4 << 21) ^
            (state4 >>> 25 | state4 << 7))
            + ((state4 & state5) ^ (~state4 & state6))) | 0)
            + ((state7 + ((KEY[i] + this.temp[i]) | 0)) | 0)) | 0;
        var t2 = (((state0 >>> 2 | state0 << 30) ^
            (state0 >>> 13 | state0 << 19) ^
            (state0 >>> 22 | state0 << 10)) + ((state0 & state1) ^ (state0 & state2) ^ (state1 & state2))) | 0;
        state7 = state6;
        state6 = state5;
        state5 = state4;
        state4 = (state3 + t1) | 0;
        state3 = state2;
        state2 = state1;
        state1 = state0;
        state0 = (t1 + t2) | 0;
    }
    state[0] += state0;
    state[1] += state1;
    state[2] += state2;
    state[3] += state3;
    state[4] += state4;
    state[5] += state5;
    state[6] += state6;
    state[7] += state7;
};

},{"./browserHashUtils":15,"buffer/":91}],20:[function(require,module,exports){
(function (process){
var util = require('./util');

// browser specific modules
util.crypto.lib = require('./browserCryptoLib');
util.Buffer = require('buffer/').Buffer;
util.url = require('url/');
util.querystring = require('querystring/');
util.realClock = require('./realclock/browserClock');
util.environment = 'js';
util.createEventStream = require('./event-stream/buffered-create-event-stream').createEventStream;
util.isBrowser = function() { return true; };
util.isNode = function() { return false; };

var AWS = require('./core');

/**
 * @api private
 */
module.exports = AWS;

require('./credentials');
require('./credentials/credential_provider_chain');
require('./credentials/temporary_credentials');
require('./credentials/chainable_temporary_credentials');
require('./credentials/web_identity_credentials');
require('./credentials/cognito_identity_credentials');
require('./credentials/saml_credentials');

// Load the DOMParser XML parser
AWS.XML.Parser = require('./xml/browser_parser');

// Load the XHR HttpClient
require('./http/xhr');

if (typeof process === 'undefined') {
  var process = {
    browser: true
  };
}

}).call(this,require('_process'))

},{"./browserCryptoLib":14,"./core":23,"./credentials":24,"./credentials/chainable_temporary_credentials":25,"./credentials/cognito_identity_credentials":26,"./credentials/credential_provider_chain":27,"./credentials/saml_credentials":28,"./credentials/temporary_credentials":29,"./credentials/web_identity_credentials":30,"./event-stream/buffered-create-event-stream":32,"./http/xhr":40,"./realclock/browserClock":57,"./util":78,"./xml/browser_parser":79,"_process":95,"buffer/":91,"querystring/":102,"url/":104}],21:[function(require,module,exports){
var AWS = require('./core');
require('./credentials');
require('./credentials/credential_provider_chain');
var PromisesDependency;

/**
 * The main configuration class used by all service objects to set
 * the region, credentials, and other options for requests.
 *
 * By default, credentials and region settings are left unconfigured.
 * This should be configured by the application before using any
 * AWS service APIs.
 *
 * In order to set global configuration options, properties should
 * be assigned to the global {AWS.config} object.
 *
 * @see AWS.config
 *
 * @!group General Configuration Options
 *
 * @!attribute credentials
 *   @return [AWS.Credentials] the AWS credentials to sign requests with.
 *
 * @!attribute region
 *   @example Set the global region setting to us-west-2
 *     AWS.config.update({region: 'us-west-2'});
 *   @return [AWS.Credentials] The region to send service requests to.
 *   @see http://docs.amazonwebservices.com/general/latest/gr/rande.html
 *     A list of available endpoints for each AWS service
 *
 * @!attribute maxRetries
 *   @return [Integer] the maximum amount of retries to perform for a
 *     service request. By default this value is calculated by the specific
 *     service object that the request is being made to.
 *
 * @!attribute maxRedirects
 *   @return [Integer] the maximum amount of redirects to follow for a
 *     service request. Defaults to 10.
 *
 * @!attribute paramValidation
 *   @return [Boolean|map] whether input parameters should be validated against
 *     the operation description before sending the request. Defaults to true.
 *     Pass a map to enable any of the following specific validation features:
 *
 *     * **min** [Boolean] &mdash; Validates that a value meets the min
 *       constraint. This is enabled by default when paramValidation is set
 *       to `true`.
 *     * **max** [Boolean] &mdash; Validates that a value meets the max
 *       constraint.
 *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
 *       regular expression.
 *     * **enum** [Boolean] &mdash; Validates that a string value matches one
 *       of the allowable enum values.
 *
 * @!attribute computeChecksums
 *   @return [Boolean] whether to compute checksums for payload bodies when
 *     the service accepts it (currently supported in S3 only).
 *
 * @!attribute convertResponseTypes
 *   @return [Boolean] whether types are converted when parsing response data.
 *     Currently only supported for JSON based services. Turning this off may
 *     improve performance on large response payloads. Defaults to `true`.
 *
 * @!attribute correctClockSkew
 *   @return [Boolean] whether to apply a clock skew correction and retry
 *     requests that fail because of an skewed client clock. Defaults to
 *     `false`.
 *
 * @!attribute sslEnabled
 *   @return [Boolean] whether SSL is enabled for requests
 *
 * @!attribute s3ForcePathStyle
 *   @return [Boolean] whether to force path style URLs for S3 objects
 *
 * @!attribute s3BucketEndpoint
 *   @note Setting this configuration option requires an `endpoint` to be
 *     provided explicitly to the service constructor.
 *   @return [Boolean] whether the provided endpoint addresses an individual
 *     bucket (false if it addresses the root API endpoint).
 *
 * @!attribute s3DisableBodySigning
 *   @return [Boolean] whether to disable S3 body signing when using signature version `v4`.
 *     Body signing can only be disabled when using https. Defaults to `true`.
 *
 * @!attribute s3UsEast1RegionalEndpoint
 *   @return ['legacy'|'regional'] when region is set to 'us-east-1', whether to send s3
 *     request to global endpoints or 'us-east-1' regional endpoints. This config is only
 *     applicable to S3 client;
 *     Defaults to 'legacy'
 * @!attribute s3UseArnRegion
 *   @return [Boolean] whether to override the request region with the region inferred
 *     from requested resource's ARN. Only available for S3 buckets
 *     Defaults to `true`
 *
 * @!attribute useAccelerateEndpoint
 *   @note This configuration option is only compatible with S3 while accessing
 *     dns-compatible buckets.
 *   @return [Boolean] Whether to use the Accelerate endpoint with the S3 service.
 *     Defaults to `false`.
 *
 * @!attribute retryDelayOptions
 *   @example Set the base retry delay for all services to 300 ms
 *     AWS.config.update({retryDelayOptions: {base: 300}});
 *     // Delays with maxRetries = 3: 300, 600, 1200
 *   @example Set a custom backoff function to provide delay values on retries
 *     AWS.config.update({retryDelayOptions: {customBackoff: function(retryCount, err) {
 *       // returns delay in ms
 *     }}});
 *   @return [map] A set of options to configure the retry delay on retryable errors.
 *     Currently supported options are:
 *
 *     * **base** [Integer] &mdash; The base number of milliseconds to use in the
 *       exponential backoff for operation retries. Defaults to 100 ms for all services except
 *       DynamoDB, where it defaults to 50ms.
 *
 *     * **customBackoff ** [function] &mdash; A custom function that accepts a
 *       retry count and error and returns the amount of time to delay in
 *       milliseconds. If the result is a non-zero negative value, no further
 *       retry attempts will be made. The `base` option will be ignored if this
 *       option is supplied.
 *
 * @!attribute httpOptions
 *   @return [map] A set of options to pass to the low-level HTTP request.
 *     Currently supported options are:
 *
 *     * **proxy** [String] &mdash; the URL to proxy requests through
 *     * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
 *       HTTP requests with. Used for connection pooling. Note that for
 *       SSL connections, a special Agent object is used in order to enable
 *       peer certificate verification. This feature is only supported in the
 *       Node.js environment.
 *     * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
 *       failing to establish a connection with the server after
 *       `connectTimeout` milliseconds. This timeout has no effect once a socket
 *       connection has been established.
 *     * **timeout** [Integer] &mdash; Sets the socket to timeout after timeout
 *       milliseconds of inactivity on the socket. Defaults to two minutes
 *       (120000)
 *     * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
 *       HTTP requests. Used in the browser environment only. Set to false to
 *       send requests synchronously. Defaults to true (async on).
 *     * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
 *       property of an XMLHttpRequest object. Used in the browser environment
 *       only. Defaults to false.
 * @!attribute logger
 *   @return [#write,#log] an object that responds to .write() (like a stream)
 *     or .log() (like the console object) in order to log information about
 *     requests
 *
 * @!attribute systemClockOffset
 *   @return [Number] an offset value in milliseconds to apply to all signing
 *     times. Use this to compensate for clock skew when your system may be
 *     out of sync with the service time. Note that this configuration option
 *     can only be applied to the global `AWS.config` object and cannot be
 *     overridden in service-specific configuration. Defaults to 0 milliseconds.
 *
 * @!attribute signatureVersion
 *   @return [String] the signature version to sign requests with (overriding
 *     the API configuration). Possible values are: 'v2', 'v3', 'v4'.
 *
 * @!attribute signatureCache
 *   @return [Boolean] whether the signature to sign requests with (overriding
 *     the API configuration) is cached. Only applies to the signature version 'v4'.
 *     Defaults to `true`.
 *
 * @!attribute endpointDiscoveryEnabled
 *   @return [Boolean] whether to enable endpoint discovery for operations that
 *     allow optionally using an endpoint returned by the service.
 *     Defaults to 'false'
 *
 * @!attribute endpointCacheSize
 *   @return [Number] the size of the global cache storing endpoints from endpoint
 *     discovery operations. Once endpoint cache is created, updating this setting
 *     cannot change existing cache size.
 *     Defaults to 1000
 *
 * @!attribute hostPrefixEnabled
 *   @return [Boolean] whether to marshal request parameters to the prefix of
 *     hostname. Defaults to `true`.
 *
 * @!attribute stsRegionalEndpoints
 *   @return ['legacy'|'regional'] whether to send sts request to global endpoints or
 *     regional endpoints.
 *     Defaults to 'legacy'
 */
AWS.Config = AWS.util.inherit({
  /**
   * @!endgroup
   */

  /**
   * Creates a new configuration object. This is the object that passes
   * option data along to service requests, including credentials, security,
   * region information, and some service specific settings.
   *
   * @example Creating a new configuration object with credentials and region
   *   var config = new AWS.Config({
   *     accessKeyId: 'AKID', secretAccessKey: 'SECRET', region: 'us-west-2'
   *   });
   * @option options accessKeyId [String] your AWS access key ID.
   * @option options secretAccessKey [String] your AWS secret access key.
   * @option options sessionToken [AWS.Credentials] the optional AWS
   *   session token to sign requests with.
   * @option options credentials [AWS.Credentials] the AWS credentials
   *   to sign requests with. You can either specify this object, or
   *   specify the accessKeyId and secretAccessKey options directly.
   * @option options credentialProvider [AWS.CredentialProviderChain] the
   *   provider chain used to resolve credentials if no static `credentials`
   *   property is set.
   * @option options region [String] the region to send service requests to.
   *   See {region} for more information.
   * @option options maxRetries [Integer] the maximum amount of retries to
   *   attempt with a request. See {maxRetries} for more information.
   * @option options maxRedirects [Integer] the maximum amount of redirects to
   *   follow with a request. See {maxRedirects} for more information.
   * @option options sslEnabled [Boolean] whether to enable SSL for
   *   requests.
   * @option options paramValidation [Boolean|map] whether input parameters
   *   should be validated against the operation description before sending
   *   the request. Defaults to true. Pass a map to enable any of the
   *   following specific validation features:
   *
   *   * **min** [Boolean] &mdash; Validates that a value meets the min
   *     constraint. This is enabled by default when paramValidation is set
   *     to `true`.
   *   * **max** [Boolean] &mdash; Validates that a value meets the max
   *     constraint.
   *   * **pattern** [Boolean] &mdash; Validates that a string value matches a
   *     regular expression.
   *   * **enum** [Boolean] &mdash; Validates that a string value matches one
   *     of the allowable enum values.
   * @option options computeChecksums [Boolean] whether to compute checksums
   *   for payload bodies when the service accepts it (currently supported
   *   in S3 only)
   * @option options convertResponseTypes [Boolean] whether types are converted
   *     when parsing response data. Currently only supported for JSON based
   *     services. Turning this off may improve performance on large response
   *     payloads. Defaults to `true`.
   * @option options correctClockSkew [Boolean] whether to apply a clock skew
   *     correction and retry requests that fail because of an skewed client
   *     clock. Defaults to `false`.
   * @option options s3ForcePathStyle [Boolean] whether to force path
   *   style URLs for S3 objects.
   * @option options s3BucketEndpoint [Boolean] whether the provided endpoint
   *   addresses an individual bucket (false if it addresses the root API
   *   endpoint). Note that setting this configuration option requires an
   *   `endpoint` to be provided explicitly to the service constructor.
   * @option options s3DisableBodySigning [Boolean] whether S3 body signing
   *   should be disabled when using signature version `v4`. Body signing
   *   can only be disabled when using https. Defaults to `true`.
   * @option options s3UsEast1RegionalEndpoint ['legacy'|'regional'] when region
   *   is set to 'us-east-1', whether to send s3 request to global endpoints or
   *   'us-east-1' regional endpoints. This config is only applicable to S3 client.
   *   Defaults to `legacy`
   * @option options s3UseArnRegion [Boolean] whether to override the request region
   *   with the region inferred from requested resource's ARN. Only available for S3 buckets
   *   Defaults to `true`
   *
   * @option options retryDelayOptions [map] A set of options to configure
   *   the retry delay on retryable errors. Currently supported options are:
   *
   *   * **base** [Integer] &mdash; The base number of milliseconds to use in the
   *     exponential backoff for operation retries. Defaults to 100 ms for all
   *     services except DynamoDB, where it defaults to 50ms.
   *   * **customBackoff ** [function] &mdash; A custom function that accepts a
   *     retry count and error and returns the amount of time to delay in
   *     milliseconds. If the result is a non-zero negative value, no further
   *     retry attempts will be made. The `base` option will be ignored if this
   *     option is supplied.
   * @option options httpOptions [map] A set of options to pass to the low-level
   *   HTTP request. Currently supported options are:
   *
   *   * **proxy** [String] &mdash; the URL to proxy requests through
   *   * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
   *     HTTP requests with. Used for connection pooling. Defaults to the global
   *     agent (`http.globalAgent`) for non-SSL connections. Note that for
   *     SSL connections, a special Agent object is used in order to enable
   *     peer certificate verification. This feature is only available in the
   *     Node.js environment.
   *   * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
   *     failing to establish a connection with the server after
   *     `connectTimeout` milliseconds. This timeout has no effect once a socket
   *     connection has been established.
   *   * **timeout** [Integer] &mdash; Sets the socket to timeout after timeout
   *     milliseconds of inactivity on the socket. Defaults to two minutes
   *     (120000).
   *   * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
   *     HTTP requests. Used in the browser environment only. Set to false to
   *     send requests synchronously. Defaults to true (async on).
   *   * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
   *     property of an XMLHttpRequest object. Used in the browser environment
   *     only. Defaults to false.
   * @option options apiVersion [String, Date] a String in YYYY-MM-DD format
   *   (or a date) that represents the latest possible API version that can be
   *   used in all services (unless overridden by `apiVersions`). Specify
   *   'latest' to use the latest possible version.
   * @option options apiVersions [map<String, String|Date>] a map of service
   *   identifiers (the lowercase service class name) with the API version to
   *   use when instantiating a service. Specify 'latest' for each individual
   *   that can use the latest available version.
   * @option options logger [#write,#log] an object that responds to .write()
   *   (like a stream) or .log() (like the console object) in order to log
   *   information about requests
   * @option options systemClockOffset [Number] an offset value in milliseconds
   *   to apply to all signing times. Use this to compensate for clock skew
   *   when your system may be out of sync with the service time. Note that
   *   this configuration option can only be applied to the global `AWS.config`
   *   object and cannot be overridden in service-specific configuration.
   *   Defaults to 0 milliseconds.
   * @option options signatureVersion [String] the signature version to sign
   *   requests with (overriding the API configuration). Possible values are:
   *   'v2', 'v3', 'v4'.
   * @option options signatureCache [Boolean] whether the signature to sign
   *   requests with (overriding the API configuration) is cached. Only applies
   *   to the signature version 'v4'. Defaults to `true`.
   * @option options dynamoDbCrc32 [Boolean] whether to validate the CRC32
   *   checksum of HTTP response bodies returned by DynamoDB. Default: `true`.
   * @option options useAccelerateEndpoint [Boolean] Whether to use the
   *   S3 Transfer Acceleration endpoint with the S3 service. Default: `false`.
   * @option options clientSideMonitoring [Boolean] whether to collect and
   *   publish this client's performance metrics of all its API requests.
   * @option options endpointDiscoveryEnabled [Boolean] whether to enable endpoint
   *   discovery for operations that allow optionally using an endpoint returned by
   *   the service.
   *   Defaults to 'false'
   * @option options endpointCacheSize [Number] the size of the global cache storing
   *   endpoints from endpoint discovery operations. Once endpoint cache is created,
   *   updating this setting cannot change existing cache size.
   *   Defaults to 1000
   * @option options hostPrefixEnabled [Boolean] whether to marshal request
   *   parameters to the prefix of hostname.
   *   Defaults to `true`.
   * @option options stsRegionalEndpoints ['legacy'|'regional'] whether to send sts request
   *   to global endpoints or regional endpoints.
   *   Defaults to 'legacy'.
   */
  constructor: function Config(options) {
    if (options === undefined) options = {};
    options = this.extractCredentials(options);

    AWS.util.each.call(this, this.keys, function (key, value) {
      this.set(key, options[key], value);
    });
  },

  /**
   * @!group Managing Credentials
   */

  /**
   * Loads credentials from the configuration object. This is used internally
   * by the SDK to ensure that refreshable {Credentials} objects are properly
   * refreshed and loaded when sending a request. If you want to ensure that
   * your credentials are loaded prior to a request, you can use this method
   * directly to provide accurate credential data stored in the object.
   *
   * @note If you configure the SDK with static or environment credentials,
   *   the credential data should already be present in {credentials} attribute.
   *   This method is primarily necessary to load credentials from asynchronous
   *   sources, or sources that can refresh credentials periodically.
   * @example Getting your access key
   *   AWS.config.getCredentials(function(err) {
   *     if (err) console.log(err.stack); // credentials not loaded
   *     else console.log("Access Key:", AWS.config.credentials.accessKeyId);
   *   })
   * @callback callback function(err)
   *   Called when the {credentials} have been properly set on the configuration
   *   object.
   *
   *   @param err [Error] if this is set, credentials were not successfully
   *     loaded and this error provides information why.
   * @see credentials
   * @see Credentials
   */
  getCredentials: function getCredentials(callback) {
    var self = this;

    function finish(err) {
      callback(err, err ? null : self.credentials);
    }

    function credError(msg, err) {
      return new AWS.util.error(err || new Error(), {
        code: 'CredentialsError',
        message: msg,
        name: 'CredentialsError'
      });
    }

    function getAsyncCredentials() {
      self.credentials.get(function(err) {
        if (err) {
          var msg = 'Could not load credentials from ' +
            self.credentials.constructor.name;
          err = credError(msg, err);
        }
        finish(err);
      });
    }

    function getStaticCredentials() {
      var err = null;
      if (!self.credentials.accessKeyId || !self.credentials.secretAccessKey) {
        err = credError('Missing credentials');
      }
      finish(err);
    }

    if (self.credentials) {
      if (typeof self.credentials.get === 'function') {
        getAsyncCredentials();
      } else { // static credentials
        getStaticCredentials();
      }
    } else if (self.credentialProvider) {
      self.credentialProvider.resolve(function(err, creds) {
        if (err) {
          err = credError('Could not load credentials from any providers', err);
        }
        self.credentials = creds;
        finish(err);
      });
    } else {
      finish(credError('No credentials to load'));
    }
  },

  /**
   * @!group Loading and Setting Configuration Options
   */

  /**
   * @overload update(options, allowUnknownKeys = false)
   *   Updates the current configuration object with new options.
   *
   *   @example Update maxRetries property of a configuration object
   *     config.update({maxRetries: 10});
   *   @param [Object] options a map of option keys and values.
   *   @param [Boolean] allowUnknownKeys whether unknown keys can be set on
   *     the configuration object. Defaults to `false`.
   *   @see constructor
   */
  update: function update(options, allowUnknownKeys) {
    allowUnknownKeys = allowUnknownKeys || false;
    options = this.extractCredentials(options);
    AWS.util.each.call(this, options, function (key, value) {
      if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) ||
          AWS.Service.hasService(key)) {
        this.set(key, value);
      }
    });
  },

  /**
   * Loads configuration data from a JSON file into this config object.
   * @note Loading configuration will reset all existing configuration
   *   on the object.
   * @!macro nobrowser
   * @param path [String] the path relative to your process's current
   *    working directory to load configuration from.
   * @return [AWS.Config] the same configuration object
   */
  loadFromPath: function loadFromPath(path) {
    this.clear();

    var options = JSON.parse(AWS.util.readFileSync(path));
    var fileSystemCreds = new AWS.FileSystemCredentials(path);
    var chain = new AWS.CredentialProviderChain();
    chain.providers.unshift(fileSystemCreds);
    chain.resolve(function (err, creds) {
      if (err) throw err;
      else options.credentials = creds;
    });

    this.constructor(options);

    return this;
  },

  /**
   * Clears configuration data on this object
   *
   * @api private
   */
  clear: function clear() {
    /*jshint forin:false */
    AWS.util.each.call(this, this.keys, function (key) {
      delete this[key];
    });

    // reset credential provider
    this.set('credentials', undefined);
    this.set('credentialProvider', undefined);
  },

  /**
   * Sets a property on the configuration object, allowing for a
   * default value
   * @api private
   */
  set: function set(property, value, defaultValue) {
    if (value === undefined) {
      if (defaultValue === undefined) {
        defaultValue = this.keys[property];
      }
      if (typeof defaultValue === 'function') {
        this[property] = defaultValue.call(this);
      } else {
        this[property] = defaultValue;
      }
    } else if (property === 'httpOptions' && this[property]) {
      // deep merge httpOptions
      this[property] = AWS.util.merge(this[property], value);
    } else {
      this[property] = value;
    }
  },

  /**
   * All of the keys with their default values.
   *
   * @constant
   * @api private
   */
  keys: {
    credentials: null,
    credentialProvider: null,
    region: null,
    logger: null,
    apiVersions: {},
    apiVersion: null,
    endpoint: undefined,
    httpOptions: {
      timeout: 120000
    },
    maxRetries: undefined,
    maxRedirects: 10,
    paramValidation: true,
    sslEnabled: true,
    s3ForcePathStyle: false,
    s3BucketEndpoint: false,
    s3DisableBodySigning: true,
    s3UsEast1RegionalEndpoint: 'legacy',
    s3UseArnRegion: undefined,
    computeChecksums: true,
    convertResponseTypes: true,
    correctClockSkew: false,
    customUserAgent: null,
    dynamoDbCrc32: true,
    systemClockOffset: 0,
    signatureVersion: null,
    signatureCache: true,
    retryDelayOptions: {},
    useAccelerateEndpoint: false,
    clientSideMonitoring: false,
    endpointDiscoveryEnabled: false,
    endpointCacheSize: 1000,
    hostPrefixEnabled: true,
    stsRegionalEndpoints: 'legacy'
  },

  /**
   * Extracts accessKeyId, secretAccessKey and sessionToken
   * from a configuration hash.
   *
   * @api private
   */
  extractCredentials: function extractCredentials(options) {
    if (options.accessKeyId && options.secretAccessKey) {
      options = AWS.util.copy(options);
      options.credentials = new AWS.Credentials(options);
    }
    return options;
  },

  /**
   * Sets the promise dependency the SDK will use wherever Promises are returned.
   * Passing `null` will force the SDK to use native Promises if they are available.
   * If native Promises are not available, passing `null` will have no effect.
   * @param [Constructor] dep A reference to a Promise constructor
   */
  setPromisesDependency: function setPromisesDependency(dep) {
    PromisesDependency = dep;
    // if null was passed in, we should try to use native promises
    if (dep === null && typeof Promise === 'function') {
      PromisesDependency = Promise;
    }
    var constructors = [AWS.Request, AWS.Credentials, AWS.CredentialProviderChain];
    if (AWS.S3) {
      constructors.push(AWS.S3);
      if (AWS.S3.ManagedUpload) {
        constructors.push(AWS.S3.ManagedUpload);
      }
    }
    AWS.util.addPromises(constructors, PromisesDependency);
  },

  /**
   * Gets the promise dependency set by `AWS.config.setPromisesDependency`.
   */
  getPromisesDependency: function getPromisesDependency() {
    return PromisesDependency;
  }
});

/**
 * @return [AWS.Config] The global configuration object singleton instance
 * @readonly
 * @see AWS.Config
 */
AWS.config = new AWS.Config();

},{"./core":23,"./credentials":24,"./credentials/credential_provider_chain":27}],22:[function(require,module,exports){
(function (process){
var AWS = require('./core');
/**
 * @api private
 */
function validateRegionalEndpointsFlagValue(configValue, errorOptions) {
  if (typeof configValue !== 'string') return undefined;
  else if (['legacy', 'regional'].indexOf(configValue.toLowerCase()) >= 0) {
    return configValue.toLowerCase();
  } else {
    throw AWS.util.error(new Error(), errorOptions);
  }
}

/**
 * Resolve the configuration value for regional endpoint from difference sources: client
 * config, environmental variable, shared config file. Value can be case-insensitive
 * 'legacy' or 'reginal'.
 * @param originalConfig user-supplied config object to resolve
 * @param options a map of config property names from individual configuration source
 *  - env: name of environmental variable that refers to the config
 *  - sharedConfig: name of shared configuration file property that refers to the config
 *  - clientConfig: name of client configuration property that refers to the config
 *
 * @api private
 */
function resolveRegionalEndpointsFlag(originalConfig, options) {
  originalConfig = originalConfig || {};
  //validate config value
  var resolved;
  if (originalConfig[options.clientConfig]) {
    resolved = validateRegionalEndpointsFlagValue(originalConfig[options.clientConfig], {
      code: 'InvalidConfiguration',
      message: 'invalid "' + options.clientConfig + '" configuration. Expect "legacy" ' +
      ' or "regional". Got "' + originalConfig[options.clientConfig] + '".'
    });
    if (resolved) return resolved;
  }
  if (!AWS.util.isNode()) return resolved;
  //validate environmental variable
  if (Object.prototype.hasOwnProperty.call(process.env, options.env)) {
    var envFlag = process.env[options.env];
    resolved = validateRegionalEndpointsFlagValue(envFlag, {
      code: 'InvalidEnvironmentalVariable',
      message: 'invalid ' + options.env + ' environmental variable. Expect "legacy" ' +
      ' or "regional". Got "' + process.env[options.env] + '".'
    });
    if (resolved) return resolved;
  }
  //validate shared config file
  var profile = {};
  try {
    var profiles = AWS.util.getProfilesFromSharedConfig(AWS.util.iniLoader);
    profile = profiles[process.env.AWS_PROFILE || AWS.util.defaultProfile];
  } catch (e) {};
  if (profile && Object.prototype.hasOwnProperty.call(profile, options.sharedConfig)) {
    var fileFlag = profile[options.sharedConfig];
    resolved = validateRegionalEndpointsFlagValue(fileFlag, {
      code: 'InvalidConfiguration',
      message: 'invalid ' + options.sharedConfig + ' profile config. Expect "legacy" ' +
      ' or "regional". Got "' + profile[options.sharedConfig] + '".'
    });
    if (resolved) return resolved;
  }
  return resolved;
}

module.exports = resolveRegionalEndpointsFlag;

}).call(this,require('_process'))

},{"./core":23,"_process":95}],23:[function(require,module,exports){
/**
 * The main AWS namespace
 */
var AWS = { util: require('./util') };

/**
 * @api private
 * @!macro [new] nobrowser
 *   @note This feature is not supported in the browser environment of the SDK.
 */
var _hidden = {}; _hidden.toString(); // hack to parse macro

/**
 * @api private
 */
module.exports = AWS;

AWS.util.update(AWS, {

  /**
   * @constant
   */
  VERSION: '2.596.0',

  /**
   * @api private
   */
  Signers: {},

  /**
   * @api private
   */
  Protocol: {
    Json: require('./protocol/json'),
    Query: require('./protocol/query'),
    Rest: require('./protocol/rest'),
    RestJson: require('./protocol/rest_json'),
    RestXml: require('./protocol/rest_xml')
  },

  /**
   * @api private
   */
  XML: {
    Builder: require('./xml/builder'),
    Parser: null // conditionally set based on environment
  },

  /**
   * @api private
   */
  JSON: {
    Builder: require('./json/builder'),
    Parser: require('./json/parser')
  },

  /**
   * @api private
   */
  Model: {
    Api: require('./model/api'),
    Operation: require('./model/operation'),
    Shape: require('./model/shape'),
    Paginator: require('./model/paginator'),
    ResourceWaiter: require('./model/resource_waiter')
  },

  /**
   * @api private
   */
  apiLoader: require('./api_loader'),

  /**
   * @api private
   */
  EndpointCache: require('../vendor/endpoint-cache').EndpointCache
});
require('./sequential_executor');
require('./service');
require('./config');
require('./http');
require('./event_listeners');
require('./request');
require('./response');
require('./resource_waiter');
require('./signers/request_signer');
require('./param_validator');

/**
 * @readonly
 * @return [AWS.SequentialExecutor] a collection of global event listeners that
 *   are attached to every sent request.
 * @see AWS.Request AWS.Request for a list of events to listen for
 * @example Logging the time taken to send a request
 *   AWS.events.on('send', function startSend(resp) {
 *     resp.startTime = new Date().getTime();
 *   }).on('complete', function calculateTime(resp) {
 *     var time = (new Date().getTime() - resp.startTime) / 1000;
 *     console.log('Request took ' + time + ' seconds');
 *   });
 *
 *   new AWS.S3().listBuckets(); // prints 'Request took 0.285 seconds'
 */
AWS.events = new AWS.SequentialExecutor();

//create endpoint cache lazily
AWS.util.memoizedProperty(AWS, 'endpointCache', function() {
  return new AWS.EndpointCache(AWS.config.endpointCacheSize);
}, true);

},{"../vendor/endpoint-cache":85,"./api_loader":13,"./config":21,"./event_listeners":38,"./http":39,"./json/builder":41,"./json/parser":42,"./model/api":43,"./model/operation":45,"./model/paginator":46,"./model/resource_waiter":47,"./model/shape":48,"./param_validator":49,"./protocol/json":51,"./protocol/query":52,"./protocol/rest":53,"./protocol/rest_json":54,"./protocol/rest_xml":55,"./request":60,"./resource_waiter":61,"./response":62,"./sequential_executor":64,"./service":65,"./signers/request_signer":70,"./util":78,"./xml/builder":80}],24:[function(require,module,exports){
var AWS = require('./core');

/**
 * Represents your AWS security credentials, specifically the
 * {accessKeyId}, {secretAccessKey}, and optional {sessionToken}.
 * Creating a `Credentials` object allows you to pass around your
 * security information to configuration and service objects.
 *
 * Note that this class typically does not need to be constructed manually,
 * as the {AWS.Config} and {AWS.Service} classes both accept simple
 * options hashes with the three keys. These structures will be converted
 * into Credentials objects automatically.
 *
 * ## Expiring and Refreshing Credentials
 *
 * Occasionally credentials can expire in the middle of a long-running
 * application. In this case, the SDK will automatically attempt to
 * refresh the credentials from the storage location if the Credentials
 * class implements the {refresh} method.
 *
 * If you are implementing a credential storage location, you
 * will want to create a subclass of the `Credentials` class and
 * override the {refresh} method. This method allows credentials to be
 * retrieved from the backing store, be it a file system, database, or
 * some network storage. The method should reset the credential attributes
 * on the object.
 *
 * @!attribute expired
 *   @return [Boolean] whether the credentials have been expired and
 *     require a refresh. Used in conjunction with {expireTime}.
 * @!attribute expireTime
 *   @return [Date] a time when credentials should be considered expired. Used
 *     in conjunction with {expired}.
 * @!attribute accessKeyId
 *   @return [String] the AWS access key ID
 * @!attribute secretAccessKey
 *   @return [String] the AWS secret access key
 * @!attribute sessionToken
 *   @return [String] an optional AWS session token
 */
AWS.Credentials = AWS.util.inherit({
  /**
   * A credentials object can be created using positional arguments or an options
   * hash.
   *
   * @overload AWS.Credentials(accessKeyId, secretAccessKey, sessionToken=null)
   *   Creates a Credentials object with a given set of credential information
   *   as positional arguments.
   *   @param accessKeyId [String] the AWS access key ID
   *   @param secretAccessKey [String] the AWS secret access key
   *   @param sessionToken [String] the optional AWS session token
   *   @example Create a credentials object with AWS credentials
   *     var creds = new AWS.Credentials('akid', 'secret', 'session');
   * @overload AWS.Credentials(options)
   *   Creates a Credentials object with a given set of credential information
   *   as an options hash.
   *   @option options accessKeyId [String] the AWS access key ID
   *   @option options secretAccessKey [String] the AWS secret access key
   *   @option options sessionToken [String] the optional AWS session token
   *   @example Create a credentials object with AWS credentials
   *     var creds = new AWS.Credentials({
   *       accessKeyId: 'akid', secretAccessKey: 'secret', sessionToken: 'session'
   *     });
   */
  constructor: function Credentials() {
    // hide secretAccessKey from being displayed with util.inspect
    AWS.util.hideProperties(this, ['secretAccessKey']);

    this.expired = false;
    this.expireTime = null;
    this.refreshCallbacks = [];
    if (arguments.length === 1 && typeof arguments[0] === 'object') {
      var creds = arguments[0].credentials || arguments[0];
      this.accessKeyId = creds.accessKeyId;
      this.secretAccessKey = creds.secretAccessKey;
      this.sessionToken = creds.sessionToken;
    } else {
      this.accessKeyId = arguments[0];
      this.secretAccessKey = arguments[1];
      this.sessionToken = arguments[2];
    }
  },

  /**
   * @return [Integer] the number of seconds before {expireTime} during which
   *   the credentials will be considered expired.
   */
  expiryWindow: 15,

  /**
   * @return [Boolean] whether the credentials object should call {refresh}
   * @note Subclasses should override this method to provide custom refresh
   *   logic.
   */
  needsRefresh: function needsRefresh() {
    var currentTime = AWS.util.date.getDate().getTime();
    var adjustedTime = new Date(currentTime + this.expiryWindow * 1000);

    if (this.expireTime && adjustedTime > this.expireTime) {
      return true;
    } else {
      return this.expired || !this.accessKeyId || !this.secretAccessKey;
    }
  },

  /**
   * Gets the existing credentials, refreshing them if they are not yet loaded
   * or have expired. Users should call this method before using {refresh},
   * as this will not attempt to reload credentials when they are already
   * loaded into the object.
   *
   * @callback callback function(err)
   *   When this callback is called with no error, it means either credentials
   *   do not need to be refreshed or refreshed credentials information has
   *   been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
   *   and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   */
  get: function get(callback) {
    var self = this;
    if (this.needsRefresh()) {
      this.refresh(function(err) {
        if (!err) self.expired = false; // reset expired flag
        if (callback) callback(err);
      });
    } else if (callback) {
      callback();
    }
  },

  /**
   * @!method  getPromise()
   *   Returns a 'thenable' promise.
   *   Gets the existing credentials, refreshing them if they are not yet loaded
   *   or have expired. Users should call this method before using {refresh},
   *   as this will not attempt to reload credentials when they are already
   *   loaded into the object.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function()
   *     Called if the promise is fulfilled. When this callback is called, it
   *     means either credentials do not need to be refreshed or refreshed
   *     credentials information has been loaded into the object (as the
   *     `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] if an error occurred, this value will be filled
   *   @return [Promise] A promise that represents the state of the `get` call.
   *   @example Calling the `getPromise` method.
   *     var promise = credProvider.getPromise();
   *     promise.then(function() { ... }, function(err) { ... });
   */

  /**
   * @!method  refreshPromise()
   *   Returns a 'thenable' promise.
   *   Refreshes the credentials. Users should call {get} before attempting
   *   to forcibly refresh credentials.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function()
   *     Called if the promise is fulfilled. When this callback is called, it
   *     means refreshed credentials information has been loaded into the object
   *     (as the `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] if an error occurred, this value will be filled
   *   @return [Promise] A promise that represents the state of the `refresh` call.
   *   @example Calling the `refreshPromise` method.
   *     var promise = credProvider.refreshPromise();
   *     promise.then(function() { ... }, function(err) { ... });
   */

  /**
   * Refreshes the credentials. Users should call {get} before attempting
   * to forcibly refresh credentials.
   *
   * @callback callback function(err)
   *   When this callback is called with no error, it means refreshed
   *   credentials information has been loaded into the object (as the
   *   `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @note Subclasses should override this class to reset the
   *   {accessKeyId}, {secretAccessKey} and optional {sessionToken}
   *   on the credentials object and then call the callback with
   *   any error information.
   * @see get
   */
  refresh: function refresh(callback) {
    this.expired = false;
    callback();
  },

  /**
   * @api private
   * @param callback
   */
  coalesceRefresh: function coalesceRefresh(callback, sync) {
    var self = this;
    if (self.refreshCallbacks.push(callback) === 1) {
      self.load(function onLoad(err) {
        AWS.util.arrayEach(self.refreshCallbacks, function(callback) {
          if (sync) {
            callback(err);
          } else {
            // callback could throw, so defer to ensure all callbacks are notified
            AWS.util.defer(function () {
              callback(err);
            });
          }
        });
        self.refreshCallbacks.length = 0;
      });
    }
  },

  /**
   * @api private
   * @param callback
   */
  load: function load(callback) {
    callback();
  }
});

/**
 * @api private
 */
AWS.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.getPromise = AWS.util.promisifyMethod('get', PromiseDependency);
  this.prototype.refreshPromise = AWS.util.promisifyMethod('refresh', PromiseDependency);
};

/**
 * @api private
 */
AWS.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.getPromise;
  delete this.prototype.refreshPromise;
};

AWS.util.addPromises(AWS.Credentials);

},{"./core":23}],25:[function(require,module,exports){
var AWS = require('../core');
var STS = require('../../clients/sts');

/**
 * Represents temporary credentials retrieved from {AWS.STS}. Without any
 * extra parameters, credentials will be fetched from the
 * {AWS.STS.getSessionToken} operation. If an IAM role is provided, the
 * {AWS.STS.assumeRole} operation will be used to fetch credentials for the
 * role instead.
 *
 * AWS.ChainableTemporaryCredentials differs from AWS.TemporaryCredentials in
 * the way masterCredentials and refreshes are handled.
 * AWS.ChainableTemporaryCredentials refreshes expired credentials using the
 * masterCredentials passed by the user to support chaining of STS credentials.
 * However, AWS.TemporaryCredentials recursively collapses the masterCredentials
 * during instantiation, precluding the ability to refresh credentials which
 * require intermediate, temporary credentials.
 *
 * For example, if the application should use RoleA, which must be assumed from
 * RoleB, and the environment provides credentials which can assume RoleB, then
 * AWS.ChainableTemporaryCredentials must be used to support refreshing the
 * temporary credentials for RoleA:
 *
 * ```javascript
 * var roleACreds = new AWS.ChainableTemporaryCredentials({
 *   params: {RoleArn: 'RoleA'},
 *   masterCredentials: new AWS.ChainableTemporaryCredentials({
 *     params: {RoleArn: 'RoleB'},
 *     masterCredentials: new AWS.EnvironmentCredentials('AWS')
 *   })
 * });
 * ```
 *
 * If AWS.TemporaryCredentials had been used in the previous example,
 * `roleACreds` would fail to refresh because `roleACreds` would
 * use the environment credentials for the AssumeRole request.
 *
 * Another difference is that AWS.ChainableTemporaryCredentials creates the STS
 * service instance during instantiation while AWS.TemporaryCredentials creates
 * the STS service instance during the first refresh. Creating the service
 * instance during instantiation effectively captures the master credentials
 * from the global config, so that subsequent changes to the global config do
 * not affect the master credentials used to refresh the temporary credentials.
 *
 * This allows an instance of AWS.ChainableTemporaryCredentials to be assigned
 * to AWS.config.credentials:
 *
 * ```javascript
 * var envCreds = new AWS.EnvironmentCredentials('AWS');
 * AWS.config.credentials = envCreds;
 * // masterCredentials will be envCreds
 * AWS.config.credentials = new AWS.ChainableTemporaryCredentials({
 *   params: {RoleArn: '...'}
 * });
 * ```
 *
 * Similarly, to use the CredentialProviderChain's default providers as the
 * master credentials, simply create a new instance of
 * AWS.ChainableTemporaryCredentials:
 *
 * ```javascript
 * AWS.config.credentials = new ChainableTemporaryCredentials({
 *   params: {RoleArn: '...'}
 * });
 * ```
 *
 * @!attribute service
 *   @return [AWS.STS] the STS service instance used to
 *     get and refresh temporary credentials from AWS STS.
 * @note (see constructor)
 */
AWS.ChainableTemporaryCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new temporary credentials object.
   *
   * @param options [map] a set of options
   * @option options params [map] ({}) a map of options that are passed to the
   *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
   *   If a `RoleArn` parameter is passed in, credentials will be based on the
   *   IAM role. If a `SerialNumber` parameter is passed in, {tokenCodeFn} must
   *   also be passed in or an error will be thrown.
   * @option options masterCredentials [AWS.Credentials] the master credentials
   *   used to get and refresh temporary credentials from AWS STS. By default,
   *   AWS.config.credentials or AWS.config.credentialProvider will be used.
   * @option options tokenCodeFn [Function] (null) Function to provide
   *   `TokenCode`, if `SerialNumber` is provided for profile in {params}. Function
   *   is called with value of `SerialNumber` and `callback`, and should provide
   *   the `TokenCode` or an error to the callback in the format
   *   `callback(err, token)`.
   * @example Creating a new credentials object for generic temporary credentials
   *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials();
   * @example Creating a new credentials object for an IAM role
   *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials({
   *     params: {
   *       RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials'
   *     }
   *   });
   * @see AWS.STS.assumeRole
   * @see AWS.STS.getSessionToken
   */
  constructor: function ChainableTemporaryCredentials(options) {
    AWS.Credentials.call(this);
    options = options || {};
    this.errorCode = 'ChainableTemporaryCredentialsProviderFailure';
    this.expired = true;
    this.tokenCodeFn = null;

    var params = AWS.util.copy(options.params) || {};
    if (params.RoleArn) {
      params.RoleSessionName = params.RoleSessionName || 'temporary-credentials';
    }
    if (params.SerialNumber) {
      if (!options.tokenCodeFn || (typeof options.tokenCodeFn !== 'function')) {
        throw new AWS.util.error(
          new Error('tokenCodeFn must be a function when params.SerialNumber is given'),
          {code: this.errorCode}
        );
      } else {
        this.tokenCodeFn = options.tokenCodeFn;
      }
    }
    var config = AWS.util.merge(
      {
        params: params,
        credentials: options.masterCredentials || AWS.config.credentials
      },
      options.stsConfig || {}
    );
    this.service = new STS(config);
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRole} or
   * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
   * to the credentials {constructor}.
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see AWS.Credentials.get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   * @param callback
   */
  load: function load(callback) {
    var self = this;
    var operation = self.service.config.params.RoleArn ? 'assumeRole' : 'getSessionToken';
    this.getTokenCode(function (err, tokenCode) {
      var params = {};
      if (err) {
        callback(err);
        return;
      }
      if (tokenCode) {
        params.TokenCode = tokenCode;
      }
      self.service[operation](params, function (err, data) {
        if (!err) {
          self.service.credentialsFrom(data, self);
        }
        callback(err);
      });
    });
  },

  /**
   * @api private
   */
  getTokenCode: function getTokenCode(callback) {
    var self = this;
    if (this.tokenCodeFn) {
      this.tokenCodeFn(this.service.config.params.SerialNumber, function (err, token) {
        if (err) {
          var message = err;
          if (err instanceof Error) {
            message = err.message;
          }
          callback(
            AWS.util.error(
              new Error('Error fetching MFA token: ' + message),
              { code: self.errorCode}
            )
          );
          return;
        }
        callback(null, token);
      });
    } else {
      callback(null);
    }
  }
});

},{"../../clients/sts":12,"../core":23}],26:[function(require,module,exports){
var AWS = require('../core');
var CognitoIdentity = require('../../clients/cognitoidentity');
var STS = require('../../clients/sts');

/**
 * Represents credentials retrieved from STS Web Identity Federation using
 * the Amazon Cognito Identity service.
 *
 * By default this provider gets credentials using the
 * {AWS.CognitoIdentity.getCredentialsForIdentity} service operation, which
 * requires either an `IdentityId` or an `IdentityPoolId` (Amazon Cognito
 * Identity Pool ID), which is used to call {AWS.CognitoIdentity.getId} to
 * obtain an `IdentityId`. If the identity or identity pool is not configured in
 * the Amazon Cognito Console to use IAM roles with the appropriate permissions,
 * then additionally a `RoleArn` is required containing the ARN of the IAM trust
 * policy for the Amazon Cognito role that the user will log into. If a `RoleArn`
 * is provided, then this provider gets credentials using the
 * {AWS.STS.assumeRoleWithWebIdentity} service operation, after first getting an
 * Open ID token from {AWS.CognitoIdentity.getOpenIdToken}.
 *
 * In addition, if this credential provider is used to provide authenticated
 * login, the `Logins` map may be set to the tokens provided by the respective
 * identity providers. See {constructor} for an example on creating a credentials
 * object with proper property values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the WebIdentityToken, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.Logins['graph.facebook.com'] = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.CognitoIdentity.getId},
 *     {AWS.CognitoIdentity.getOpenIdToken}, and
 *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
 *     `params.WebIdentityToken` property.
 * @!attribute data
 *   @return [map] the raw data response from the call to
 *     {AWS.CognitoIdentity.getCredentialsForIdentity}, or
 *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
 *     access to other properties from the response.
 * @!attribute identityId
 *   @return [String] the Cognito ID returned by the last call to
 *     {AWS.CognitoIdentity.getOpenIdToken}. This ID represents the actual
 *     final resolved identity ID from Amazon Cognito.
 */
AWS.CognitoIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * @api private
   */
  localStorageKey: {
    id: 'aws.cognito.identity-id.',
    providers: 'aws.cognito.identity-providers.'
  },

  /**
   * Creates a new credentials object.
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.CognitoIdentityCredentials({
   *
   *     // either IdentityPoolId or IdentityId is required
   *     // See the IdentityPoolId param for AWS.CognitoIdentity.getID (linked below)
   *     // See the IdentityId param for AWS.CognitoIdentity.getCredentialsForIdentity
   *     // or AWS.CognitoIdentity.getOpenIdToken (linked below)
   *     IdentityPoolId: 'us-east-1:1699ebc0-7900-4099-b910-2df94f52a030',
   *     IdentityId: 'us-east-1:128d0a74-c82f-4553-916d-90053e4a8b0f'
   *
   *     // optional, only necessary when the identity pool is not configured
   *     // to use IAM roles in the Amazon Cognito Console
   *     // See the RoleArn param for AWS.STS.assumeRoleWithWebIdentity (linked below)
   *     RoleArn: 'arn:aws:iam::1234567890:role/MYAPP-CognitoIdentity',
   *
   *     // optional tokens, used for authenticated login
   *     // See the Logins param for AWS.CognitoIdentity.getID (linked below)
   *     Logins: {
   *       'graph.facebook.com': 'FBTOKEN',
   *       'www.amazon.com': 'AMAZONTOKEN',
   *       'accounts.google.com': 'GOOGLETOKEN',
   *       'api.twitter.com': 'TWITTERTOKEN',
   *       'www.digits.com': 'DIGITSTOKEN'
   *     },
   *
   *     // optional name, defaults to web-identity
   *     // See the RoleSessionName param for AWS.STS.assumeRoleWithWebIdentity (linked below)
   *     RoleSessionName: 'web',
   *
   *     // optional, only necessary when application runs in a browser
   *     // and multiple users are signed in at once, used for caching
   *     LoginId: 'example@gmail.com'
   *
   *   }, {
   *      // optionally provide configuration to apply to the underlying service clients
   *      // if configuration is not provided, then configuration will be pulled from AWS.config
   *
   *      // region should match the region your identity pool is located in
   *      region: 'us-east-1',
   *
   *      // specify timeout options
   *      httpOptions: {
   *        timeout: 100
   *      }
   *   });
   * @see AWS.CognitoIdentity.getId
   * @see AWS.CognitoIdentity.getCredentialsForIdentity
   * @see AWS.STS.assumeRoleWithWebIdentity
   * @see AWS.CognitoIdentity.getOpenIdToken
   * @see AWS.Config
   * @note If a region is not provided in the global AWS.config, or
   *   specified in the `clientConfig` to the CognitoIdentityCredentials
   *   constructor, you may encounter a 'Missing credentials in config' error
   *   when calling making a service call.
   */
  constructor: function CognitoIdentityCredentials(params, clientConfig) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
    this.data = null;
    this._identityId = null;
    this._clientConfig = AWS.util.copy(clientConfig || {});
    this.loadCachedId();
    var self = this;
    Object.defineProperty(this, 'identityId', {
      get: function() {
        self.loadCachedId();
        return self._identityId || self.params.IdentityId;
      },
      set: function(identityId) {
        self._identityId = identityId;
      }
    });
  },

  /**
   * Refreshes credentials using {AWS.CognitoIdentity.getCredentialsForIdentity},
   * or {AWS.STS.assumeRoleWithWebIdentity}.
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see AWS.Credentials.get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   * @param callback
   */
  load: function load(callback) {
    var self = this;
    self.createClients();
    self.data = null;
    self._identityId = null;
    self.getId(function(err) {
      if (!err) {
        if (!self.params.RoleArn) {
          self.getCredentialsForIdentity(callback);
        } else {
          self.getCredentialsFromSTS(callback);
        }
      } else {
        self.clearIdOnNotAuthorized(err);
        callback(err);
      }
    });
  },

  /**
   * Clears the cached Cognito ID associated with the currently configured
   * identity pool ID. Use this to manually invalidate your cache if
   * the identity pool ID was deleted.
   */
  clearCachedId: function clearCache() {
    this._identityId = null;
    delete this.params.IdentityId;

    var poolId = this.params.IdentityPoolId;
    var loginId = this.params.LoginId || '';
    delete this.storage[this.localStorageKey.id + poolId + loginId];
    delete this.storage[this.localStorageKey.providers + poolId + loginId];
  },

  /**
   * @api private
   */
  clearIdOnNotAuthorized: function clearIdOnNotAuthorized(err) {
    var self = this;
    if (err.code == 'NotAuthorizedException') {
      self.clearCachedId();
    }
  },

  /**
   * Retrieves a Cognito ID, loading from cache if it was already retrieved
   * on this device.
   *
   * @callback callback function(err, identityId)
   *   @param err [Error, null] an error object if the call failed or null if
   *     it succeeded.
   *   @param identityId [String, null] if successful, the callback will return
   *     the Cognito ID.
   * @note If not loaded explicitly, the Cognito ID is loaded and stored in
   *   localStorage in the browser environment of a device.
   * @api private
   */
  getId: function getId(callback) {
    var self = this;
    if (typeof self.params.IdentityId === 'string') {
      return callback(null, self.params.IdentityId);
    }

    self.cognito.getId(function(err, data) {
      if (!err && data.IdentityId) {
        self.params.IdentityId = data.IdentityId;
        callback(null, data.IdentityId);
      } else {
        callback(err);
      }
    });
  },


  /**
   * @api private
   */
  loadCredentials: function loadCredentials(data, credentials) {
    if (!data || !credentials) return;
    credentials.expired = false;
    credentials.accessKeyId = data.Credentials.AccessKeyId;
    credentials.secretAccessKey = data.Credentials.SecretKey;
    credentials.sessionToken = data.Credentials.SessionToken;
    credentials.expireTime = data.Credentials.Expiration;
  },

  /**
   * @api private
   */
  getCredentialsForIdentity: function getCredentialsForIdentity(callback) {
    var self = this;
    self.cognito.getCredentialsForIdentity(function(err, data) {
      if (!err) {
        self.cacheId(data);
        self.data = data;
        self.loadCredentials(self.data, self);
      } else {
        self.clearIdOnNotAuthorized(err);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  getCredentialsFromSTS: function getCredentialsFromSTS(callback) {
    var self = this;
    self.cognito.getOpenIdToken(function(err, data) {
      if (!err) {
        self.cacheId(data);
        self.params.WebIdentityToken = data.Token;
        self.webIdentityCredentials.refresh(function(webErr) {
          if (!webErr) {
            self.data = self.webIdentityCredentials.data;
            self.sts.credentialsFrom(self.data, self);
          }
          callback(webErr);
        });
      } else {
        self.clearIdOnNotAuthorized(err);
        callback(err);
      }
    });
  },

  /**
   * @api private
   */
  loadCachedId: function loadCachedId() {
    var self = this;

    // in the browser we source default IdentityId from localStorage
    if (AWS.util.isBrowser() && !self.params.IdentityId) {
      var id = self.getStorage('id');
      if (id && self.params.Logins) {
        var actualProviders = Object.keys(self.params.Logins);
        var cachedProviders =
          (self.getStorage('providers') || '').split(',');

        // only load ID if at least one provider used this ID before
        var intersect = cachedProviders.filter(function(n) {
          return actualProviders.indexOf(n) !== -1;
        });
        if (intersect.length !== 0) {
          self.params.IdentityId = id;
        }
      } else if (id) {
        self.params.IdentityId = id;
      }
    }
  },

  /**
   * @api private
   */
  createClients: function() {
    var clientConfig = this._clientConfig;
    this.webIdentityCredentials = this.webIdentityCredentials ||
      new AWS.WebIdentityCredentials(this.params, clientConfig);
    if (!this.cognito) {
      var cognitoConfig = AWS.util.merge({}, clientConfig);
      cognitoConfig.params = this.params;
      this.cognito = new CognitoIdentity(cognitoConfig);
    }
    this.sts = this.sts || new STS(clientConfig);
  },

  /**
   * @api private
   */
  cacheId: function cacheId(data) {
    this._identityId = data.IdentityId;
    this.params.IdentityId = this._identityId;

    // cache this IdentityId in browser localStorage if possible
    if (AWS.util.isBrowser()) {
      this.setStorage('id', data.IdentityId);

      if (this.params.Logins) {
        this.setStorage('providers', Object.keys(this.params.Logins).join(','));
      }
    }
  },

  /**
   * @api private
   */
  getStorage: function getStorage(key) {
    return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')];
  },

  /**
   * @api private
   */
  setStorage: function setStorage(key, val) {
    try {
      this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')] = val;
    } catch (_) {}
  },

  /**
   * @api private
   */
  storage: (function() {
    try {
      var storage = AWS.util.isBrowser() && window.localStorage !== null && typeof window.localStorage === 'object' ?
          window.localStorage : {};

      // Test set/remove which would throw an error in Safari's private browsing
      storage['aws.test-storage'] = 'foobar';
      delete storage['aws.test-storage'];

      return storage;
    } catch (_) {
      return {};
    }
  })()
});

},{"../../clients/cognitoidentity":10,"../../clients/sts":12,"../core":23}],27:[function(require,module,exports){
var AWS = require('../core');

/**
 * Creates a credential provider chain that searches for AWS credentials
 * in a list of credential providers specified by the {providers} property.
 *
 * By default, the chain will use the {defaultProviders} to resolve credentials.
 * These providers will look in the environment using the
 * {AWS.EnvironmentCredentials} class with the 'AWS' and 'AMAZON' prefixes.
 *
 * ## Setting Providers
 *
 * Each provider in the {providers} list should be a function that returns
 * a {AWS.Credentials} object, or a hardcoded credentials object. The function
 * form allows for delayed execution of the credential construction.
 *
 * ## Resolving Credentials from a Chain
 *
 * Call {resolve} to return the first valid credential object that can be
 * loaded by the provider chain.
 *
 * For example, to resolve a chain with a custom provider that checks a file
 * on disk after the set of {defaultProviders}:
 *
 * ```javascript
 * var diskProvider = new AWS.FileSystemCredentials('./creds.json');
 * var chain = new AWS.CredentialProviderChain();
 * chain.providers.push(diskProvider);
 * chain.resolve();
 * ```
 *
 * The above code will return the `diskProvider` object if the
 * file contains credentials and the `defaultProviders` do not contain
 * any credential settings.
 *
 * @!attribute providers
 *   @return [Array<AWS.Credentials, Function>]
 *     a list of credentials objects or functions that return credentials
 *     objects. If the provider is a function, the function will be
 *     executed lazily when the provider needs to be checked for valid
 *     credentials. By default, this object will be set to the
 *     {defaultProviders}.
 *   @see defaultProviders
 */
AWS.CredentialProviderChain = AWS.util.inherit(AWS.Credentials, {

  /**
   * Creates a new CredentialProviderChain with a default set of providers
   * specified by {defaultProviders}.
   */
  constructor: function CredentialProviderChain(providers) {
    if (providers) {
      this.providers = providers;
    } else {
      this.providers = AWS.CredentialProviderChain.defaultProviders.slice(0);
    }
    this.resolveCallbacks = [];
  },

  /**
   * @!method  resolvePromise()
   *   Returns a 'thenable' promise.
   *   Resolves the provider chain by searching for the first set of
   *   credentials in {providers}.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function(credentials)
   *     Called if the promise is fulfilled and the provider resolves the chain
   *     to a credentials object
   *     @param credentials [AWS.Credentials] the credentials object resolved
   *       by the provider chain.
   *   @callback rejectedCallback function(error)
   *     Called if the promise is rejected.
   *     @param err [Error] the error object returned if no credentials are found.
   *   @return [Promise] A promise that represents the state of the `resolve` method call.
   *   @example Calling the `resolvePromise` method.
   *     var promise = chain.resolvePromise();
   *     promise.then(function(credentials) { ... }, function(err) { ... });
   */

  /**
   * Resolves the provider chain by searching for the first set of
   * credentials in {providers}.
   *
   * @callback callback function(err, credentials)
   *   Called when the provider resolves the chain to a credentials object
   *   or null if no credentials can be found.
   *
   *   @param err [Error] the error object returned if no credentials are
   *     found.
   *   @param credentials [AWS.Credentials] the credentials object resolved
   *     by the provider chain.
   * @return [AWS.CredentialProviderChain] the provider, for chaining.
   */
  resolve: function resolve(callback) {
    var self = this;
    if (self.providers.length === 0) {
      callback(new Error('No providers'));
      return self;
    }

    if (self.resolveCallbacks.push(callback) === 1) {
      var index = 0;
      var providers = self.providers.slice(0);

      function resolveNext(err, creds) {
        if ((!err && creds) || index === providers.length) {
          AWS.util.arrayEach(self.resolveCallbacks, function (callback) {
            callback(err, creds);
          });
          self.resolveCallbacks.length = 0;
          return;
        }

        var provider = providers[index++];
        if (typeof provider === 'function') {
          creds = provider.call();
        } else {
          creds = provider;
        }

        if (creds.get) {
          creds.get(function (getErr) {
            resolveNext(getErr, getErr ? null : creds);
          });
        } else {
          resolveNext(null, creds);
        }
      }

      resolveNext();
    }

    return self;
  }
});

/**
 * The default set of providers used by a vanilla CredentialProviderChain.
 *
 * In the browser:
 *
 * ```javascript
 * AWS.CredentialProviderChain.defaultProviders = []
 * ```
 *
 * In Node.js:
 *
 * ```javascript
 * AWS.CredentialProviderChain.defaultProviders = [
 *   function () { return new AWS.EnvironmentCredentials('AWS'); },
 *   function () { return new AWS.EnvironmentCredentials('AMAZON'); },
 *   function () { return new AWS.SharedIniFileCredentials(); },
 *   function () { return new AWS.ECSCredentials(); },
 *   function () { return new AWS.ProcessCredentials(); },
 *   function () { return new AWS.TokenFileWebIdentityCredentials(); },
 *   function () { return new AWS.EC2MetadataCredentials() }
 * ]
 * ```
 */
AWS.CredentialProviderChain.defaultProviders = [];

/**
 * @api private
 */
AWS.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.resolvePromise = AWS.util.promisifyMethod('resolve', PromiseDependency);
};

/**
 * @api private
 */
AWS.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.resolvePromise;
};

AWS.util.addPromises(AWS.CredentialProviderChain);

},{"../core":23}],28:[function(require,module,exports){
var AWS = require('../core');
var STS = require('../../clients/sts');

/**
 * Represents credentials retrieved from STS SAML support.
 *
 * By default this provider gets credentials using the
 * {AWS.STS.assumeRoleWithSAML} service operation. This operation
 * requires a `RoleArn` containing the ARN of the IAM trust policy for the
 * application for which credentials will be given, as well as a `PrincipalArn`
 * representing the ARN for the SAML identity provider. In addition, the
 * `SAMLAssertion` must be set to the token provided by the identity
 * provider. See {constructor} for an example on creating a credentials
 * object with proper `RoleArn`, `PrincipalArn`, and `SAMLAssertion` values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the SAMLAssertion, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.SAMLAssertion = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.STS.assumeRoleWithSAML}. To update the token, set the
 *     `params.SAMLAssertion` property.
 */
AWS.SAMLCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new credentials object.
   * @param (see AWS.STS.assumeRoleWithSAML)
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.SAMLCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/SAMLRole',
   *     PrincipalArn: 'arn:aws:iam::1234567890:role/SAMLPrincipal',
   *     SAMLAssertion: 'base64-token', // base64-encoded token from IdP
   *   });
   * @see AWS.STS.assumeRoleWithSAML
   */
  constructor: function SAMLCredentials(params) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRoleWithSAML}
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    self.createClients();
    self.service.assumeRoleWithSAML(function (err, data) {
      if (!err) {
        self.service.credentialsFrom(data, self);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  createClients: function() {
    this.service = this.service || new STS({params: this.params});
  }

});

},{"../../clients/sts":12,"../core":23}],29:[function(require,module,exports){
var AWS = require('../core');
var STS = require('../../clients/sts');

/**
 * Represents temporary credentials retrieved from {AWS.STS}. Without any
 * extra parameters, credentials will be fetched from the
 * {AWS.STS.getSessionToken} operation. If an IAM role is provided, the
 * {AWS.STS.assumeRole} operation will be used to fetch credentials for the
 * role instead.
 *
 * @note AWS.TemporaryCredentials is deprecated, but remains available for
 *   backwards compatibility. {AWS.ChainableTemporaryCredentials} is the
 *   preferred class for temporary credentials.
 *
 * To setup temporary credentials, configure a set of master credentials
 * using the standard credentials providers (environment, EC2 instance metadata,
 * or from the filesystem), then set the global credentials to a new
 * temporary credentials object:
 *
 * ```javascript
 * // Note that environment credentials are loaded by default,
 * // the following line is shown for clarity:
 * AWS.config.credentials = new AWS.EnvironmentCredentials('AWS');
 *
 * // Now set temporary credentials seeded from the master credentials
 * AWS.config.credentials = new AWS.TemporaryCredentials();
 *
 * // subsequent requests will now use temporary credentials from AWS STS.
 * new AWS.S3().listBucket(function(err, data) { ... });
 * ```
 *
 * @!attribute masterCredentials
 *   @return [AWS.Credentials] the master (non-temporary) credentials used to
 *     get and refresh temporary credentials from AWS STS.
 * @note (see constructor)
 */
AWS.TemporaryCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new temporary credentials object.
   *
   * @note In order to create temporary credentials, you first need to have
   *   "master" credentials configured in {AWS.Config.credentials}. These
   *   master credentials are necessary to retrieve the temporary credentials,
   *   as well as refresh the credentials when they expire.
   * @param params [map] a map of options that are passed to the
   *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
   *   If a `RoleArn` parameter is passed in, credentials will be based on the
   *   IAM role.
   * @param masterCredentials [AWS.Credentials] the master (non-temporary) credentials
   *  used to get and refresh temporary credentials from AWS STS.
   * @example Creating a new credentials object for generic temporary credentials
   *   AWS.config.credentials = new AWS.TemporaryCredentials();
   * @example Creating a new credentials object for an IAM role
   *   AWS.config.credentials = new AWS.TemporaryCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials',
   *   });
   * @see AWS.STS.assumeRole
   * @see AWS.STS.getSessionToken
   */
  constructor: function TemporaryCredentials(params, masterCredentials) {
    AWS.Credentials.call(this);
    this.loadMasterCredentials(masterCredentials);
    this.expired = true;

    this.params = params || {};
    if (this.params.RoleArn) {
      this.params.RoleSessionName =
        this.params.RoleSessionName || 'temporary-credentials';
    }
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRole} or
   * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
   * to the credentials {constructor}.
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh (callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   */
  load: function load (callback) {
    var self = this;
    self.createClients();
    self.masterCredentials.get(function () {
      self.service.config.credentials = self.masterCredentials;
      var operation = self.params.RoleArn ?
        self.service.assumeRole : self.service.getSessionToken;
      operation.call(self.service, function (err, data) {
        if (!err) {
          self.service.credentialsFrom(data, self);
        }
        callback(err);
      });
    });
  },

  /**
   * @api private
   */
  loadMasterCredentials: function loadMasterCredentials (masterCredentials) {
    this.masterCredentials = masterCredentials || AWS.config.credentials;
    while (this.masterCredentials.masterCredentials) {
      this.masterCredentials = this.masterCredentials.masterCredentials;
    }

    if (typeof this.masterCredentials.get !== 'function') {
      this.masterCredentials = new AWS.Credentials(this.masterCredentials);
    }
  },

  /**
   * @api private
   */
  createClients: function () {
    this.service = this.service || new STS({params: this.params});
  }

});

},{"../../clients/sts":12,"../core":23}],30:[function(require,module,exports){
var AWS = require('../core');
var STS = require('../../clients/sts');

/**
 * Represents credentials retrieved from STS Web Identity Federation support.
 *
 * By default this provider gets credentials using the
 * {AWS.STS.assumeRoleWithWebIdentity} service operation. This operation
 * requires a `RoleArn` containing the ARN of the IAM trust policy for the
 * application for which credentials will be given. In addition, the
 * `WebIdentityToken` must be set to the token provided by the identity
 * provider. See {constructor} for an example on creating a credentials
 * object with proper `RoleArn` and `WebIdentityToken` values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the WebIdentityToken, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.WebIdentityToken = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
 *     `params.WebIdentityToken` property.
 * @!attribute data
 *   @return [map] the raw data response from the call to
 *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
 *     access to other properties from the response.
 */
AWS.WebIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new credentials object.
   * @param (see AWS.STS.assumeRoleWithWebIdentity)
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.WebIdentityCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/WebIdentity',
   *     WebIdentityToken: 'ABCDEFGHIJKLMNOP', // token from identity service
   *     RoleSessionName: 'web' // optional name, defaults to web-identity
   *   }, {
   *     // optionally provide configuration to apply to the underlying AWS.STS service client
   *     // if configuration is not provided, then configuration will be pulled from AWS.config
   *
   *     // specify timeout options
   *     httpOptions: {
   *       timeout: 100
   *     }
   *   });
   * @see AWS.STS.assumeRoleWithWebIdentity
   * @see AWS.Config
   */
  constructor: function WebIdentityCredentials(params, clientConfig) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
    this.params.RoleSessionName = this.params.RoleSessionName || 'web-identity';
    this.data = null;
    this._clientConfig = AWS.util.copy(clientConfig || {});
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRoleWithWebIdentity}
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    self.createClients();
    self.service.assumeRoleWithWebIdentity(function (err, data) {
      self.data = null;
      if (!err) {
        self.data = data;
        self.service.credentialsFrom(data, self);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  createClients: function() {
    if (!this.service) {
      var stsConfig = AWS.util.merge({}, this._clientConfig);
      stsConfig.params = this.params;
      this.service = new STS(stsConfig);
    }
  }

});

},{"../../clients/sts":12,"../core":23}],31:[function(require,module,exports){
(function (process){
var AWS = require('./core');
var util = require('./util');
var endpointDiscoveryEnabledEnvs = ['AWS_ENABLE_ENDPOINT_DISCOVERY', 'AWS_ENDPOINT_DISCOVERY_ENABLED'];

/**
 * Generate key (except resources and operation part) to index the endpoints in the cache
 * If input shape has endpointdiscoveryid trait then use
 *   accessKey + operation + resources + region + service as cache key
 * If input shape doesn't have endpointdiscoveryid trait then use
 *   accessKey + region + service as cache key
 * @return [map<String,String>] object with keys to index endpoints.
 * @api private
 */
function getCacheKey(request) {
  var service = request.service;
  var api = service.api || {};
  var operations = api.operations;
  var identifiers = {};
  if (service.config.region) {
    identifiers.region = service.config.region;
  }
  if (api.serviceId) {
    identifiers.serviceId = api.serviceId;
  }
  if (service.config.credentials.accessKeyId) {
    identifiers.accessKeyId = service.config.credentials.accessKeyId;
  }
  return identifiers;
}

/**
 * Recursive helper for marshallCustomIdentifiers().
 * Looks for required string input members that have 'endpointdiscoveryid' trait.
 * @api private
 */
function marshallCustomIdentifiersHelper(result, params, shape) {
  if (!shape || params === undefined || params === null) return;
  if (shape.type === 'structure' && shape.required && shape.required.length > 0) {
    util.arrayEach(shape.required, function(name) {
      var memberShape = shape.members[name];
      if (memberShape.endpointDiscoveryId === true) {
        var locationName = memberShape.isLocationName ? memberShape.name : name;
        result[locationName] = String(params[name]);
      } else {
        marshallCustomIdentifiersHelper(result, params[name], memberShape);
      }
    });
  }
}

/**
 * Get custom identifiers for cache key.
 * Identifies custom identifiers by checking each shape's `endpointDiscoveryId` trait.
 * @param [object] request object
 * @param [object] input shape of the given operation's api
 * @api private
 */
function marshallCustomIdentifiers(request, shape) {
  var identifiers = {};
  marshallCustomIdentifiersHelper(identifiers, request.params, shape);
  return identifiers;
}

/**
 * Call endpoint discovery operation when it's optional.
 * When endpoint is available in cache then use the cached endpoints. If endpoints
 * are unavailable then use regional endpoints and call endpoint discovery operation
 * asynchronously. This is turned off by default.
 * @param [object] request object
 * @api private
 */
function optionalDiscoverEndpoint(request) {
  var service = request.service;
  var api = service.api;
  var operationModel = api.operations ? api.operations[request.operation] : undefined;
  var inputShape = operationModel ? operationModel.input : undefined;

  var identifiers = marshallCustomIdentifiers(request, inputShape);
  var cacheKey = getCacheKey(request);
  if (Object.keys(identifiers).length > 0) {
    cacheKey = util.update(cacheKey, identifiers);
    if (operationModel) cacheKey.operation = operationModel.name;
  }
  var endpoints = AWS.endpointCache.get(cacheKey);
  if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {
    //endpoint operation is being made but response not yet received
    //or endpoint operation just failed in 1 minute
    return;
  } else if (endpoints && endpoints.length > 0) {
    //found endpoint record from cache
    request.httpRequest.updateEndpoint(endpoints[0].Address);
  } else {
    //endpoint record not in cache or outdated. make discovery operation
    var endpointRequest = service.makeRequest(api.endpointOperation, {
      Operation: operationModel.name,
      Identifiers: identifiers,
    });
    addApiVersionHeader(endpointRequest);
    endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);
    endpointRequest.removeListener('retry', AWS.EventListeners.Core.RETRY_CHECK);
    //put in a placeholder for endpoints already requested, prevent
    //too much in-flight calls
    AWS.endpointCache.put(cacheKey, [{
      Address: '',
      CachePeriodInMinutes: 1
    }]);
    endpointRequest.send(function(err, data) {
      if (data && data.Endpoints) {
        AWS.endpointCache.put(cacheKey, data.Endpoints);
      } else if (err) {
        AWS.endpointCache.put(cacheKey, [{
          Address: '',
          CachePeriodInMinutes: 1 //not to make more endpoint operation in next 1 minute
        }]);
      }
    });
  }
}

var requestQueue = {};

/**
 * Call endpoint discovery operation when it's required.
 * When endpoint is available in cache then use cached ones. If endpoints are
 * unavailable then SDK should call endpoint operation then use returned new
 * endpoint for the api call. SDK will automatically attempt to do endpoint
 * discovery. This is turned off by default
 * @param [object] request object
 * @api private
 */
function requiredDiscoverEndpoint(request, done) {
  var service = request.service;
  var api = service.api;
  var operationModel = api.operations ? api.operations[request.operation] : undefined;
  var inputShape = operationModel ? operationModel.input : undefined;

  var identifiers = marshallCustomIdentifiers(request, inputShape);
  var cacheKey = getCacheKey(request);
  if (Object.keys(identifiers).length > 0) {
    cacheKey = util.update(cacheKey, identifiers);
    if (operationModel) cacheKey.operation = operationModel.name;
  }
  var cacheKeyStr = AWS.EndpointCache.getKeyString(cacheKey);
  var endpoints = AWS.endpointCache.get(cacheKeyStr); //endpoint cache also accepts string keys
  if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {
    //endpoint operation is being made but response not yet received
    //push request object to a pending queue
    if (!requestQueue[cacheKeyStr]) requestQueue[cacheKeyStr] = [];
    requestQueue[cacheKeyStr].push({request: request, callback: done});
    return;
  } else if (endpoints && endpoints.length > 0) {
    request.httpRequest.updateEndpoint(endpoints[0].Address);
    done();
  } else {
    var endpointRequest = service.makeRequest(api.endpointOperation, {
      Operation: operationModel.name,
      Identifiers: identifiers,
    });
    endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);
    addApiVersionHeader(endpointRequest);

    //put in a placeholder for endpoints already requested, prevent
    //too much in-flight calls
    AWS.endpointCache.put(cacheKeyStr, [{
      Address: '',
      CachePeriodInMinutes: 60 //long-live cache
    }]);
    endpointRequest.send(function(err, data) {
      if (err) {
        var errorParams = {
          code: 'EndpointDiscoveryException',
          message: 'Request cannot be fulfilled without specifying an endpoint',
          retryable: false
        };
        request.response.error = util.error(err, errorParams);
        AWS.endpointCache.remove(cacheKey);

        //fail all the pending requests in batch
        if (requestQueue[cacheKeyStr]) {
          var pendingRequests = requestQueue[cacheKeyStr];
          util.arrayEach(pendingRequests, function(requestContext) {
            requestContext.request.response.error = util.error(err, errorParams);
            requestContext.callback();
          });
          delete requestQueue[cacheKeyStr];
        }
      } else if (data) {
        AWS.endpointCache.put(cacheKeyStr, data.Endpoints);
        request.httpRequest.updateEndpoint(data.Endpoints[0].Address);

        //update the endpoint for all the pending requests in batch
        if (requestQueue[cacheKeyStr]) {
          var pendingRequests = requestQueue[cacheKeyStr];
          util.arrayEach(pendingRequests, function(requestContext) {
            requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);
            requestContext.callback();
          });
          delete requestQueue[cacheKeyStr];
        }
      }
      done();
    });
  }
}

/**
 * add api version header to endpoint operation
 * @api private
 */
function addApiVersionHeader(endpointRequest) {
  var api = endpointRequest.service.api;
  var apiVersion = api.apiVersion;
  if (apiVersion && !endpointRequest.httpRequest.headers['x-amz-api-version']) {
    endpointRequest.httpRequest.headers['x-amz-api-version'] = apiVersion;
  }
}

/**
 * If api call gets invalid endpoint exception, SDK should attempt to remove the invalid
 * endpoint from cache.
 * @api private
 */
function invalidateCachedEndpoints(response) {
  var error = response.error;
  var httpResponse = response.httpResponse;
  if (error &&
    (error.code === 'InvalidEndpointException' || httpResponse.statusCode === 421)
  ) {
    var request = response.request;
    var operations = request.service.api.operations || {};
    var inputShape = operations[request.operation] ? operations[request.operation].input : undefined;
    var identifiers = marshallCustomIdentifiers(request, inputShape);
    var cacheKey = getCacheKey(request);
    if (Object.keys(identifiers).length > 0) {
      cacheKey = util.update(cacheKey, identifiers);
      if (operations[request.operation]) cacheKey.operation = operations[request.operation].name;
    }
    AWS.endpointCache.remove(cacheKey);
  }
}

/**
 * If endpoint is explicitly configured, SDK should not do endpoint discovery in anytime.
 * @param [object] client Service client object.
 * @api private
 */
function hasCustomEndpoint(client) {
  //if set endpoint is set for specific client, enable endpoint discovery will raise an error.
  if (client._originalConfig && client._originalConfig.endpoint && client._originalConfig.endpointDiscoveryEnabled === true) {
    throw util.error(new Error(), {
      code: 'ConfigurationException',
      message: 'Custom endpoint is supplied; endpointDiscoveryEnabled must not be true.'
    });
  };
  var svcConfig = AWS.config[client.serviceIdentifier] || {};
  return Boolean(AWS.config.endpoint || svcConfig.endpoint || (client._originalConfig && client._originalConfig.endpoint));
}

/**
 * @api private
 */
function isFalsy(value) {
  return ['false', '0'].indexOf(value) >= 0;
}

/**
 * If endpoint discovery should perform for this request when endpoint discovery is optional.
 * SDK performs config resolution in order like below:
 * 1. If turned on client configuration(default to off) then turn on endpoint discovery.
 * 2. If turned on in env AWS_ENABLE_ENDPOINT_DISCOVERY then turn on endpoint discovery.
 * 3. If turned on in shared ini config file with key 'endpoint_discovery_enabled', then
 *   turn on endpoint discovery.
 * @param [object] request request object.
 * @api private
 */
function isEndpointDiscoveryApplicable(request) {
  var service = request.service || {};
  if (service.config.endpointDiscoveryEnabled === true) return true;

  //shared ini file is only available in Node
  //not to check env in browser
  if (util.isBrowser()) return false;

  for (var i = 0; i < endpointDiscoveryEnabledEnvs.length; i++) {
    var env = endpointDiscoveryEnabledEnvs[i];
    if (Object.prototype.hasOwnProperty.call(process.env, env)) {
      if (process.env[env] === '' || process.env[env] === undefined) {
        throw util.error(new Error(), {
          code: 'ConfigurationException',
          message: 'environmental variable ' + env + ' cannot be set to nothing'
        });
      }
      if (!isFalsy(process.env[env])) return true;
    }
  }

  var configFile = {};
  try {
    configFile = AWS.util.iniLoader ? AWS.util.iniLoader.loadFrom({
      isConfig: true,
      filename: process.env[AWS.util.sharedConfigFileEnv]
    }) : {};
  } catch (e) {}
  var sharedFileConfig = configFile[
    process.env.AWS_PROFILE || AWS.util.defaultProfile
  ] || {};
  if (Object.prototype.hasOwnProperty.call(sharedFileConfig, 'endpoint_discovery_enabled')) {
    if (sharedFileConfig.endpoint_discovery_enabled === undefined) {
      throw util.error(new Error(), {
        code: 'ConfigurationException',
        message: 'config file entry \'endpoint_discovery_enabled\' cannot be set to nothing'
      });
    }
    if (!isFalsy(sharedFileConfig.endpoint_discovery_enabled)) return true;
  }
  return false;
}

/**
 * attach endpoint discovery logic to request object
 * @param [object] request
 * @api private
 */
function discoverEndpoint(request, done) {
  var service = request.service || {};
  if (hasCustomEndpoint(service) || request.isPresigned()) return done();

  if (!isEndpointDiscoveryApplicable(request)) return done();

  request.httpRequest.appendToUserAgent('endpoint-discovery');

  var operations = service.api.operations || {};
  var operationModel = operations[request.operation];
  var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : 'NULL';
  switch (isEndpointDiscoveryRequired) {
    case 'OPTIONAL':
      optionalDiscoverEndpoint(request);
      request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);
      done();
      break;
    case 'REQUIRED':
      request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);
      requiredDiscoverEndpoint(request, done);
      break;
    case 'NULL':
    default:
      done();
      break;
  }
}

module.exports = {
  discoverEndpoint: discoverEndpoint,
  requiredDiscoverEndpoint: requiredDiscoverEndpoint,
  optionalDiscoverEndpoint: optionalDiscoverEndpoint,
  marshallCustomIdentifiers: marshallCustomIdentifiers,
  getCacheKey: getCacheKey,
  invalidateCachedEndpoint: invalidateCachedEndpoints,
};

}).call(this,require('_process'))

},{"./core":23,"./util":78,"_process":95}],32:[function(require,module,exports){
var eventMessageChunker = require('../event-stream/event-message-chunker').eventMessageChunker;
var parseEvent = require('./parse-event').parseEvent;

function createEventStream(body, parser, model) {
    var eventMessages = eventMessageChunker(body);

    var events = [];

    for (var i = 0; i < eventMessages.length; i++) {
        events.push(parseEvent(parser, eventMessages[i], model));
    }

    return events;
}

/**
 * @api private
 */
module.exports = {
    createEventStream: createEventStream
};

},{"../event-stream/event-message-chunker":33,"./parse-event":35}],33:[function(require,module,exports){
/**
 * Takes in a buffer of event messages and splits them into individual messages.
 * @param {Buffer} buffer
 * @api private
 */
function eventMessageChunker(buffer) {
    /** @type Buffer[] */
    var messages = [];
    var offset = 0;

    while (offset < buffer.length) {
        var totalLength = buffer.readInt32BE(offset);

        // create new buffer for individual message (shares memory with original)
        var message = buffer.slice(offset, totalLength + offset);
        // increment offset to it starts at the next message
        offset += totalLength;

        messages.push(message);
    }

    return messages;
}

/**
 * @api private
 */
module.exports = {
    eventMessageChunker: eventMessageChunker
};

},{}],34:[function(require,module,exports){
var util = require('../core').util;
var toBuffer = util.buffer.toBuffer;

/**
 * A lossless representation of a signed, 64-bit integer. Instances of this
 * class may be used in arithmetic expressions as if they were numeric
 * primitives, but the binary representation will be preserved unchanged as the
 * `bytes` property of the object. The bytes should be encoded as big-endian,
 * two's complement integers.
 * @param {Buffer} bytes
 *
 * @api private
 */
function Int64(bytes) {
    if (bytes.length !== 8) {
        throw new Error('Int64 buffers must be exactly 8 bytes');
    }
    if (!util.Buffer.isBuffer(bytes)) bytes = toBuffer(bytes);

    this.bytes = bytes;
}

/**
 * @param {number} number
 * @returns {Int64}
 *
 * @api private
 */
Int64.fromNumber = function(number) {
    if (number > 9223372036854775807 || number < -9223372036854775808) {
        throw new Error(
            number + ' is too large (or, if negative, too small) to represent as an Int64'
        );
    }

    var bytes = new Uint8Array(8);
    for (
        var i = 7, remaining = Math.abs(Math.round(number));
        i > -1 && remaining > 0;
        i--, remaining /= 256
    ) {
        bytes[i] = remaining;
    }

    if (number < 0) {
        negate(bytes);
    }

    return new Int64(bytes);
};

/**
 * @returns {number}
 *
 * @api private
 */
Int64.prototype.valueOf = function() {
    var bytes = this.bytes.slice(0);
    var negative = bytes[0] & 128;
    if (negative) {
        negate(bytes);
    }

    return parseInt(bytes.toString('hex'), 16) * (negative ? -1 : 1);
};

Int64.prototype.toString = function() {
    return String(this.valueOf());
};

/**
 * @param {Buffer} bytes
 *
 * @api private
 */
function negate(bytes) {
    for (var i = 0; i < 8; i++) {
        bytes[i] ^= 0xFF;
    }
    for (var i = 7; i > -1; i--) {
        bytes[i]++;
        if (bytes[i] !== 0) {
            break;
        }
    }
}

/**
 * @api private
 */
module.exports = {
    Int64: Int64
};

},{"../core":23}],35:[function(require,module,exports){
var parseMessage = require('./parse-message').parseMessage;

/**
 *
 * @param {*} parser
 * @param {Buffer} message
 * @param {*} shape
 * @api private
 */
function parseEvent(parser, message, shape) {
    var parsedMessage = parseMessage(message);

    // check if message is an event or error
    var messageType = parsedMessage.headers[':message-type'];
    if (messageType) {
        if (messageType.value === 'error') {
            throw parseError(parsedMessage);
        } else if (messageType.value !== 'event') {
            // not sure how to parse non-events/non-errors, ignore for now
            return;
        }
    }

    // determine event type
    var eventType = parsedMessage.headers[':event-type'];
    // check that the event type is modeled
    var eventModel = shape.members[eventType.value];
    if (!eventModel) {
        return;
    }

    var result = {};
    // check if an event payload exists
    var eventPayloadMemberName = eventModel.eventPayloadMemberName;
    if (eventPayloadMemberName) {
        var payloadShape = eventModel.members[eventPayloadMemberName];
        // if the shape is binary, return the byte array
        if (payloadShape.type === 'binary') {
            result[eventPayloadMemberName] = parsedMessage.body;
        } else {
            result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);
        }
    }

    // read event headers
    var eventHeaderNames = eventModel.eventHeaderMemberNames;
    for (var i = 0; i < eventHeaderNames.length; i++) {
        var name = eventHeaderNames[i];
        if (parsedMessage.headers[name]) {
            // parse the header!
            result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);
        }
    }

    var output = {};
    output[eventType.value] = result;
    return output;
}

function parseError(message) {
    var errorCode = message.headers[':error-code'];
    var errorMessage = message.headers[':error-message'];
    var error = new Error(errorMessage.value || errorMessage);
    error.code = error.name = errorCode.value || errorCode;
    return error;
}

/**
 * @api private
 */
module.exports = {
    parseEvent: parseEvent
};

},{"./parse-message":36}],36:[function(require,module,exports){
var Int64 = require('./int64').Int64;

var splitMessage = require('./split-message').splitMessage;

var BOOLEAN_TAG = 'boolean';
var BYTE_TAG = 'byte';
var SHORT_TAG = 'short';
var INT_TAG = 'integer';
var LONG_TAG = 'long';
var BINARY_TAG = 'binary';
var STRING_TAG = 'string';
var TIMESTAMP_TAG = 'timestamp';
var UUID_TAG = 'uuid';

/**
 * @api private
 *
 * @param {Buffer} headers
 */
function parseHeaders(headers) {
    var out = {};
    var position = 0;
    while (position < headers.length) {
        var nameLength = headers.readUInt8(position++);
        var name = headers.slice(position, position + nameLength).toString();
        position += nameLength;
        switch (headers.readUInt8(position++)) {
            case 0 /* boolTrue */:
                out[name] = {
                    type: BOOLEAN_TAG,
                    value: true
                };
                break;
            case 1 /* boolFalse */:
                out[name] = {
                    type: BOOLEAN_TAG,
                    value: false
                };
                break;
            case 2 /* byte */:
                out[name] = {
                    type: BYTE_TAG,
                    value: headers.readInt8(position++)
                };
                break;
            case 3 /* short */:
                out[name] = {
                    type: SHORT_TAG,
                    value: headers.readInt16BE(position)
                };
                position += 2;
                break;
            case 4 /* integer */:
                out[name] = {
                    type: INT_TAG,
                    value: headers.readInt32BE(position)
                };
                position += 4;
                break;
            case 5 /* long */:
                out[name] = {
                    type: LONG_TAG,
                    value: new Int64(headers.slice(position, position + 8))
                };
                position += 8;
                break;
            case 6 /* byteArray */:
                var binaryLength = headers.readUInt16BE(position);
                position += 2;
                out[name] = {
                    type: BINARY_TAG,
                    value: headers.slice(position, position + binaryLength)
                };
                position += binaryLength;
                break;
            case 7 /* string */:
                var stringLength = headers.readUInt16BE(position);
                position += 2;
                out[name] = {
                    type: STRING_TAG,
                    value: headers.slice(
                        position,
                        position + stringLength
                    ).toString()
                };
                position += stringLength;
                break;
            case 8 /* timestamp */:
                out[name] = {
                    type: TIMESTAMP_TAG,
                    value: new Date(
                        new Int64(headers.slice(position, position + 8))
                            .valueOf()
                    )
                };
                position += 8;
                break;
            case 9 /* uuid */:
                var uuidChars = headers.slice(position, position + 16)
                    .toString('hex');
                position += 16;
                out[name] = {
                    type: UUID_TAG,
                    value: uuidChars.substr(0, 8) + '-' +
                        uuidChars.substr(8, 4) + '-' +
                        uuidChars.substr(12, 4) + '-' +
                        uuidChars.substr(16, 4) + '-' +
                        uuidChars.substr(20)
                };
                break;
            default:
                throw new Error('Unrecognized header type tag');
        }
    }
    return out;
}

function parseMessage(message) {
    var parsed = splitMessage(message);
    return { headers: parseHeaders(parsed.headers), body: parsed.body };
}

/**
 * @api private
 */
module.exports = {
    parseMessage: parseMessage
};

},{"./int64":34,"./split-message":37}],37:[function(require,module,exports){
var util = require('../core').util;
var toBuffer = util.buffer.toBuffer;

// All prelude components are unsigned, 32-bit integers
var PRELUDE_MEMBER_LENGTH = 4;
// The prelude consists of two components
var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
// Checksums are always CRC32 hashes.
var CHECKSUM_LENGTH = 4;
// Messages must include a full prelude, a prelude checksum, and a message checksum
var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;

/**
 * @api private
 *
 * @param {Buffer} message
 */
function splitMessage(message) {
    if (!util.Buffer.isBuffer(message)) message = toBuffer(message);

    if (message.length < MINIMUM_MESSAGE_LENGTH) {
        throw new Error('Provided message too short to accommodate event stream message overhead');
    }

    if (message.length !== message.readUInt32BE(0)) {
        throw new Error('Reported message length does not match received message length');
    }

    var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);

    if (
        expectedPreludeChecksum !== util.crypto.crc32(
            message.slice(0, PRELUDE_LENGTH)
        )
    ) {
        throw new Error(
            'The prelude checksum specified in the message (' +
            expectedPreludeChecksum +
            ') does not match the calculated CRC32 checksum.'
        );
    }

    var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);

    if (
        expectedMessageChecksum !== util.crypto.crc32(
            message.slice(0, message.length - CHECKSUM_LENGTH)
        )
    ) {
        throw new Error(
            'The message checksum did not match the expected value of ' +
                expectedMessageChecksum
        );
    }

    var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;
    var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);

    return {
        headers: message.slice(headersStart, headersEnd),
        body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH),
    };
}

/**
 * @api private
 */
module.exports = {
    splitMessage: splitMessage
};

},{"../core":23}],38:[function(require,module,exports){
var AWS = require('./core');
var SequentialExecutor = require('./sequential_executor');
var DISCOVER_ENDPOINT = require('./discover_endpoint').discoverEndpoint;
/**
 * The namespace used to register global event listeners for request building
 * and sending.
 */
AWS.EventListeners = {
  /**
   * @!attribute VALIDATE_CREDENTIALS
   *   A request listener that validates whether the request is being
   *   sent with credentials.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating credentials
   *     var listener = AWS.EventListeners.Core.VALIDATE_CREDENTIALS;
   *     request.removeListener('validate', listener);
   *   @readonly
   *   @return [Function]
   * @!attribute VALIDATE_REGION
   *   A request listener that validates whether the region is set
   *   for a request.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating region configuration
   *     var listener = AWS.EventListeners.Core.VALIDATE_REGION;
   *     request.removeListener('validate', listener);
   *   @readonly
   *   @return [Function]
   * @!attribute VALIDATE_PARAMETERS
   *   A request listener that validates input parameters in a request.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating parameters
   *     var listener = AWS.EventListeners.Core.VALIDATE_PARAMETERS;
   *     request.removeListener('validate', listener);
   *   @example Disable parameter validation globally
   *     AWS.EventListeners.Core.removeListener('validate',
   *       AWS.EventListeners.Core.VALIDATE_REGION);
   *   @readonly
   *   @return [Function]
   * @!attribute SEND
   *   A request listener that initiates the HTTP connection for a
   *   request being sent. Handles the {AWS.Request~send 'send' Request event}
   *   @example Replacing the HTTP handler
   *     var listener = AWS.EventListeners.Core.SEND;
   *     request.removeListener('send', listener);
   *     request.on('send', function(response) {
   *       customHandler.send(response);
   *     });
   *   @return [Function]
   *   @readonly
   * @!attribute HTTP_DATA
   *   A request listener that reads data from the HTTP connection in order
   *   to build the response data.
   *   Handles the {AWS.Request~httpData 'httpData' Request event}.
   *   Remove this handler if you are overriding the 'httpData' event and
   *   do not want extra data processing and buffering overhead.
   *   @example Disabling default data processing
   *     var listener = AWS.EventListeners.Core.HTTP_DATA;
   *     request.removeListener('httpData', listener);
   *   @return [Function]
   *   @readonly
   */
  Core: {} /* doc hack */
};

/**
 * @api private
 */
function getOperationAuthtype(req) {
  if (!req.service.api.operations) {
    return '';
  }
  var operation = req.service.api.operations[req.operation];
  return operation ? operation.authtype : '';
}

AWS.EventListeners = {
  Core: new SequentialExecutor().addNamedListeners(function(add, addAsync) {
    addAsync('VALIDATE_CREDENTIALS', 'validate',
        function VALIDATE_CREDENTIALS(req, done) {
      if (!req.service.api.signatureVersion && !req.service.config.signatureVersion) return done(); // none
      req.service.config.getCredentials(function(err) {
        if (err) {
          req.response.error = AWS.util.error(err,
            {code: 'CredentialsError', message: 'Missing credentials in config'});
        }
        done();
      });
    });

    add('VALIDATE_REGION', 'validate', function VALIDATE_REGION(req) {
      if (!req.service.config.region && !req.service.isGlobalEndpoint) {
        req.response.error = AWS.util.error(new Error(),
          {code: 'ConfigError', message: 'Missing region in config'});
      }
    });

    add('BUILD_IDEMPOTENCY_TOKENS', 'validate', function BUILD_IDEMPOTENCY_TOKENS(req) {
      if (!req.service.api.operations) {
        return;
      }
      var operation = req.service.api.operations[req.operation];
      if (!operation) {
        return;
      }
      var idempotentMembers = operation.idempotentMembers;
      if (!idempotentMembers.length) {
        return;
      }
      // creates a copy of params so user's param object isn't mutated
      var params = AWS.util.copy(req.params);
      for (var i = 0, iLen = idempotentMembers.length; i < iLen; i++) {
        if (!params[idempotentMembers[i]]) {
          // add the member
          params[idempotentMembers[i]] = AWS.util.uuid.v4();
        }
      }
      req.params = params;
    });

    add('VALIDATE_PARAMETERS', 'validate', function VALIDATE_PARAMETERS(req) {
      if (!req.service.api.operations) {
        return;
      }
      var rules = req.service.api.operations[req.operation].input;
      var validation = req.service.config.paramValidation;
      new AWS.ParamValidator(validation).validate(rules, req.params);
    });

    addAsync('COMPUTE_SHA256', 'afterBuild', function COMPUTE_SHA256(req, done) {
      req.haltHandlersOnError();
      if (!req.service.api.operations) {
        return;
      }
      var operation = req.service.api.operations[req.operation];
      var authtype = operation ? operation.authtype : '';
      if (!req.service.api.signatureVersion && !authtype && !req.service.config.signatureVersion) return done(); // none
      if (req.service.getSignerClass(req) === AWS.Signers.V4) {
        var body = req.httpRequest.body || '';
        if (authtype.indexOf('unsigned-body') >= 0) {
          req.httpRequest.headers['X-Amz-Content-Sha256'] = 'UNSIGNED-PAYLOAD';
          return done();
        }
        AWS.util.computeSha256(body, function(err, sha) {
          if (err) {
            done(err);
          }
          else {
            req.httpRequest.headers['X-Amz-Content-Sha256'] = sha;
            done();
          }
        });
      } else {
        done();
      }
    });

    add('SET_CONTENT_LENGTH', 'afterBuild', function SET_CONTENT_LENGTH(req) {
      var authtype = getOperationAuthtype(req);
      var payloadMember = AWS.util.getRequestPayloadShape(req);
      if (req.httpRequest.headers['Content-Length'] === undefined) {
        try {
          var length = AWS.util.string.byteLength(req.httpRequest.body);
          req.httpRequest.headers['Content-Length'] = length;
        } catch (err) {
          if (payloadMember && payloadMember.isStreaming) {
            if (payloadMember.requiresLength) {
              //streaming payload requires length(s3, glacier)
              throw err;
            } else if (authtype.indexOf('unsigned-body') >= 0) {
              //unbounded streaming payload(lex, mediastore)
              req.httpRequest.headers['Transfer-Encoding'] = 'chunked';
              return;
            } else {
              throw err;
            }
          }
          throw err;
        }
      }
    });

    add('SET_HTTP_HOST', 'afterBuild', function SET_HTTP_HOST(req) {
      req.httpRequest.headers['Host'] = req.httpRequest.endpoint.host;
    });

    add('RESTART', 'restart', function RESTART() {
      var err = this.response.error;
      if (!err || !err.retryable) return;

      this.httpRequest = new AWS.HttpRequest(
        this.service.endpoint,
        this.service.region
      );

      if (this.response.retryCount < this.service.config.maxRetries) {
        this.response.retryCount++;
      } else {
        this.response.error = null;
      }
    });

    var addToHead = true;
    addAsync('DISCOVER_ENDPOINT', 'sign', DISCOVER_ENDPOINT, addToHead);

    addAsync('SIGN', 'sign', function SIGN(req, done) {
      var service = req.service;
      var operations = req.service.api.operations || {};
      var operation = operations[req.operation];
      var authtype = operation ? operation.authtype : '';
      if (!service.api.signatureVersion && !authtype && !service.config.signatureVersion) return done(); // none

      service.config.getCredentials(function (err, credentials) {
        if (err) {
          req.response.error = err;
          return done();
        }

        try {
          var date = service.getSkewCorrectedDate();
          var SignerClass = service.getSignerClass(req);
          var signer = new SignerClass(req.httpRequest,
            service.api.signingName || service.api.endpointPrefix,
            {
              signatureCache: service.config.signatureCache,
              operation: operation,
              signatureVersion: service.api.signatureVersion
            });
          signer.setServiceClientId(service._clientId);

          // clear old authorization headers
          delete req.httpRequest.headers['Authorization'];
          delete req.httpRequest.headers['Date'];
          delete req.httpRequest.headers['X-Amz-Date'];

          // add new authorization
          signer.addAuthorization(credentials, date);
          req.signedAt = date;
        } catch (e) {
          req.response.error = e;
        }
        done();
      });
    });

    add('VALIDATE_RESPONSE', 'validateResponse', function VALIDATE_RESPONSE(resp) {
      if (this.service.successfulResponse(resp, this)) {
        resp.data = {};
        resp.error = null;
      } else {
        resp.data = null;
        resp.error = AWS.util.error(new Error(),
          {code: 'UnknownError', message: 'An unknown error occurred.'});
      }
    });

    addAsync('SEND', 'send', function SEND(resp, done) {
      resp.httpResponse._abortCallback = done;
      resp.error = null;
      resp.data = null;

      function callback(httpResp) {
        resp.httpResponse.stream = httpResp;
        var stream = resp.request.httpRequest.stream;
        var service = resp.request.service;
        var api = service.api;
        var operationName = resp.request.operation;
        var operation = api.operations[operationName] || {};

        httpResp.on('headers', function onHeaders(statusCode, headers, statusMessage) {
          resp.request.emit(
            'httpHeaders',
            [statusCode, headers, resp, statusMessage]
          );

          if (!resp.httpResponse.streaming) {
            if (AWS.HttpClient.streamsApiVersion === 2) { // streams2 API check
              // if we detect event streams, we're going to have to
              // return the stream immediately
              if (operation.hasEventOutput && service.successfulResponse(resp)) {
                // skip reading the IncomingStream
                resp.request.emit('httpDone');
                done();
                return;
              }

              httpResp.on('readable', function onReadable() {
                var data = httpResp.read();
                if (data !== null) {
                  resp.request.emit('httpData', [data, resp]);
                }
              });
            } else { // legacy streams API
              httpResp.on('data', function onData(data) {
                resp.request.emit('httpData', [data, resp]);
              });
            }
          }
        });

        httpResp.on('end', function onEnd() {
          if (!stream || !stream.didCallback) {
            if (AWS.HttpClient.streamsApiVersion === 2 && (operation.hasEventOutput && service.successfulResponse(resp))) {
              // don't concatenate response chunks when streaming event stream data when response is successful
              return;
            }
            resp.request.emit('httpDone');
            done();
          }
        });
      }

      function progress(httpResp) {
        httpResp.on('sendProgress', function onSendProgress(value) {
          resp.request.emit('httpUploadProgress', [value, resp]);
        });

        httpResp.on('receiveProgress', function onReceiveProgress(value) {
          resp.request.emit('httpDownloadProgress', [value, resp]);
        });
      }

      function error(err) {
        if (err.code !== 'RequestAbortedError') {
          var errCode = err.code === 'TimeoutError' ? err.code : 'NetworkingError';
          err = AWS.util.error(err, {
            code: errCode,
            region: resp.request.httpRequest.region,
            hostname: resp.request.httpRequest.endpoint.hostname,
            retryable: true
          });
        }
        resp.error = err;
        resp.request.emit('httpError', [resp.error, resp], function() {
          done();
        });
      }

      function executeSend() {
        var http = AWS.HttpClient.getInstance();
        var httpOptions = resp.request.service.config.httpOptions || {};
        try {
          var stream = http.handleRequest(resp.request.httpRequest, httpOptions,
                                          callback, error);
          progress(stream);
        } catch (err) {
          error(err);
        }
      }
      var timeDiff = (resp.request.service.getSkewCorrectedDate() - this.signedAt) / 1000;
      if (timeDiff >= 60 * 10) { // if we signed 10min ago, re-sign
        this.emit('sign', [this], function(err) {
          if (err) done(err);
          else executeSend();
        });
      } else {
        executeSend();
      }
    });

    add('HTTP_HEADERS', 'httpHeaders',
        function HTTP_HEADERS(statusCode, headers, resp, statusMessage) {
      resp.httpResponse.statusCode = statusCode;
      resp.httpResponse.statusMessage = statusMessage;
      resp.httpResponse.headers = headers;
      resp.httpResponse.body = AWS.util.buffer.toBuffer('');
      resp.httpResponse.buffers = [];
      resp.httpResponse.numBytes = 0;
      var dateHeader = headers.date || headers.Date;
      var service = resp.request.service;
      if (dateHeader) {
        var serverTime = Date.parse(dateHeader);
        if (service.config.correctClockSkew
            && service.isClockSkewed(serverTime)) {
          service.applyClockOffset(serverTime);
        }
      }
    });

    add('HTTP_DATA', 'httpData', function HTTP_DATA(chunk, resp) {
      if (chunk) {
        if (AWS.util.isNode()) {
          resp.httpResponse.numBytes += chunk.length;

          var total = resp.httpResponse.headers['content-length'];
          var progress = { loaded: resp.httpResponse.numBytes, total: total };
          resp.request.emit('httpDownloadProgress', [progress, resp]);
        }

        resp.httpResponse.buffers.push(AWS.util.buffer.toBuffer(chunk));
      }
    });

    add('HTTP_DONE', 'httpDone', function HTTP_DONE(resp) {
      // convert buffers array into single buffer
      if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {
        var body = AWS.util.buffer.concat(resp.httpResponse.buffers);
        resp.httpResponse.body = body;
      }
      delete resp.httpResponse.numBytes;
      delete resp.httpResponse.buffers;
    });

    add('FINALIZE_ERROR', 'retry', function FINALIZE_ERROR(resp) {
      if (resp.httpResponse.statusCode) {
        resp.error.statusCode = resp.httpResponse.statusCode;
        if (resp.error.retryable === undefined) {
          resp.error.retryable = this.service.retryableError(resp.error, this);
        }
      }
    });

    add('INVALIDATE_CREDENTIALS', 'retry', function INVALIDATE_CREDENTIALS(resp) {
      if (!resp.error) return;
      switch (resp.error.code) {
        case 'RequestExpired': // EC2 only
        case 'ExpiredTokenException':
        case 'ExpiredToken':
          resp.error.retryable = true;
          resp.request.service.config.credentials.expired = true;
      }
    });

    add('EXPIRED_SIGNATURE', 'retry', function EXPIRED_SIGNATURE(resp) {
      var err = resp.error;
      if (!err) return;
      if (typeof err.code === 'string' && typeof err.message === 'string') {
        if (err.code.match(/Signature/) && err.message.match(/expired/)) {
          resp.error.retryable = true;
        }
      }
    });

    add('CLOCK_SKEWED', 'retry', function CLOCK_SKEWED(resp) {
      if (!resp.error) return;
      if (this.service.clockSkewError(resp.error)
          && this.service.config.correctClockSkew) {
        resp.error.retryable = true;
      }
    });

    add('REDIRECT', 'retry', function REDIRECT(resp) {
      if (resp.error && resp.error.statusCode >= 300 &&
          resp.error.statusCode < 400 && resp.httpResponse.headers['location']) {
        this.httpRequest.endpoint =
          new AWS.Endpoint(resp.httpResponse.headers['location']);
        this.httpRequest.headers['Host'] = this.httpRequest.endpoint.host;
        resp.error.redirect = true;
        resp.error.retryable = true;
      }
    });

    add('RETRY_CHECK', 'retry', function RETRY_CHECK(resp) {
      if (resp.error) {
        if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
          resp.error.retryDelay = 0;
        } else if (resp.retryCount < resp.maxRetries) {
          resp.error.retryDelay = this.service.retryDelays(resp.retryCount, resp.error) || 0;
        }
      }
    });

    addAsync('RESET_RETRY_STATE', 'afterRetry', function RESET_RETRY_STATE(resp, done) {
      var delay, willRetry = false;

      if (resp.error) {
        delay = resp.error.retryDelay || 0;
        if (resp.error.retryable && resp.retryCount < resp.maxRetries) {
          resp.retryCount++;
          willRetry = true;
        } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
          resp.redirectCount++;
          willRetry = true;
        }
      }

      // delay < 0 is a signal from customBackoff to skip retries
      if (willRetry && delay >= 0) {
        resp.error = null;
        setTimeout(done, delay);
      } else {
        done();
      }
    });
  }),

  CorePost: new SequentialExecutor().addNamedListeners(function(add) {
    add('EXTRACT_REQUEST_ID', 'extractData', AWS.util.extractRequestId);
    add('EXTRACT_REQUEST_ID', 'extractError', AWS.util.extractRequestId);

    add('ENOTFOUND_ERROR', 'httpError', function ENOTFOUND_ERROR(err) {
      if (err.code === 'NetworkingError' && err.errno === 'ENOTFOUND') {
        var message = 'Inaccessible host: `' + err.hostname +
          '\'. This service may not be available in the `' + err.region +
          '\' region.';
        this.response.error = AWS.util.error(new Error(message), {
          code: 'UnknownEndpoint',
          region: err.region,
          hostname: err.hostname,
          retryable: true,
          originalError: err
        });
      }
    });
  }),

  Logger: new SequentialExecutor().addNamedListeners(function(add) {
    add('LOG_REQUEST', 'complete', function LOG_REQUEST(resp) {
      var req = resp.request;
      var logger = req.service.config.logger;
      if (!logger) return;
      function filterSensitiveLog(inputShape, shape) {
        if (!shape) {
          return shape;
        }
        switch (inputShape.type) {
          case 'structure':
            var struct = {};
            AWS.util.each(shape, function(subShapeName, subShape) {
              if (Object.prototype.hasOwnProperty.call(inputShape.members, subShapeName)) {
                struct[subShapeName] = filterSensitiveLog(inputShape.members[subShapeName], subShape);
              } else {
                struct[subShapeName] = subShape;
              }
            });
            return struct;
          case 'list':
            var list = [];
            AWS.util.arrayEach(shape, function(subShape, index) {
              list.push(filterSensitiveLog(inputShape.member, subShape));
            });
            return list;
          case 'map':
            var map = {};
            AWS.util.each(shape, function(key, value) {
              map[key] = filterSensitiveLog(inputShape.value, value);
            });
            return map;
          default:
            if (inputShape.isSensitive) {
              return '***SensitiveInformation***';
            } else {
              return shape;
            }
        }
      }

      function buildMessage() {
        var time = resp.request.service.getSkewCorrectedDate().getTime();
        var delta = (time - req.startTime.getTime()) / 1000;
        var ansi = logger.isTTY ? true : false;
        var status = resp.httpResponse.statusCode;
        var censoredParams = req.params;
        if (
          req.service.api.operations &&
              req.service.api.operations[req.operation] &&
              req.service.api.operations[req.operation].input
        ) {
          var inputShape = req.service.api.operations[req.operation].input;
          censoredParams = filterSensitiveLog(inputShape, req.params);
        }
        var params = require('util').inspect(censoredParams, true, null);
        var message = '';
        if (ansi) message += '\x1B[33m';
        message += '[AWS ' + req.service.serviceIdentifier + ' ' + status;
        message += ' ' + delta.toString() + 's ' + resp.retryCount + ' retries]';
        if (ansi) message += '\x1B[0;1m';
        message += ' ' + AWS.util.string.lowerFirst(req.operation);
        message += '(' + params + ')';
        if (ansi) message += '\x1B[0m';
        return message;
      }

      var line = buildMessage();
      if (typeof logger.log === 'function') {
        logger.log(line);
      } else if (typeof logger.write === 'function') {
        logger.write(line + '\n');
      }
    });
  }),

  Json: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/json');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  Rest: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/rest');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  RestJson: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/rest_json');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  RestXml: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/rest_xml');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  Query: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/query');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  })
};

},{"./core":23,"./discover_endpoint":31,"./protocol/json":51,"./protocol/query":52,"./protocol/rest":53,"./protocol/rest_json":54,"./protocol/rest_xml":55,"./sequential_executor":64,"util":107}],39:[function(require,module,exports){
var AWS = require('./core');
var inherit = AWS.util.inherit;

/**
 * The endpoint that a service will talk to, for example,
 * `'https://ec2.ap-southeast-1.amazonaws.com'`. If
 * you need to override an endpoint for a service, you can
 * set the endpoint on a service by passing the endpoint
 * object with the `endpoint` option key:
 *
 * ```javascript
 * var ep = new AWS.Endpoint('awsproxy.example.com');
 * var s3 = new AWS.S3({endpoint: ep});
 * s3.service.endpoint.hostname == 'awsproxy.example.com'
 * ```
 *
 * Note that if you do not specify a protocol, the protocol will
 * be selected based on your current {AWS.config} configuration.
 *
 * @!attribute protocol
 *   @return [String] the protocol (http or https) of the endpoint
 *     URL
 * @!attribute hostname
 *   @return [String] the host portion of the endpoint, e.g.,
 *     example.com
 * @!attribute host
 *   @return [String] the host portion of the endpoint including
 *     the port, e.g., example.com:80
 * @!attribute port
 *   @return [Integer] the port of the endpoint
 * @!attribute href
 *   @return [String] the full URL of the endpoint
 */
AWS.Endpoint = inherit({

  /**
   * @overload Endpoint(endpoint)
   *   Constructs a new endpoint given an endpoint URL. If the
   *   URL omits a protocol (http or https), the default protocol
   *   set in the global {AWS.config} will be used.
   *   @param endpoint [String] the URL to construct an endpoint from
   */
  constructor: function Endpoint(endpoint, config) {
    AWS.util.hideProperties(this, ['slashes', 'auth', 'hash', 'search', 'query']);

    if (typeof endpoint === 'undefined' || endpoint === null) {
      throw new Error('Invalid endpoint: ' + endpoint);
    } else if (typeof endpoint !== 'string') {
      return AWS.util.copy(endpoint);
    }

    if (!endpoint.match(/^http/)) {
      var useSSL = config && config.sslEnabled !== undefined ?
        config.sslEnabled : AWS.config.sslEnabled;
      endpoint = (useSSL ? 'https' : 'http') + '://' + endpoint;
    }

    AWS.util.update(this, AWS.util.urlParse(endpoint));

    // Ensure the port property is set as an integer
    if (this.port) {
      this.port = parseInt(this.port, 10);
    } else {
      this.port = this.protocol === 'https:' ? 443 : 80;
    }
  }

});

/**
 * The low level HTTP request object, encapsulating all HTTP header
 * and body data sent by a service request.
 *
 * @!attribute method
 *   @return [String] the HTTP method of the request
 * @!attribute path
 *   @return [String] the path portion of the URI, e.g.,
 *     "/list/?start=5&num=10"
 * @!attribute headers
 *   @return [map<String,String>]
 *     a map of header keys and their respective values
 * @!attribute body
 *   @return [String] the request body payload
 * @!attribute endpoint
 *   @return [AWS.Endpoint] the endpoint for the request
 * @!attribute region
 *   @api private
 *   @return [String] the region, for signing purposes only.
 */
AWS.HttpRequest = inherit({

  /**
   * @api private
   */
  constructor: function HttpRequest(endpoint, region) {
    endpoint = new AWS.Endpoint(endpoint);
    this.method = 'POST';
    this.path = endpoint.path || '/';
    this.headers = {};
    this.body = '';
    this.endpoint = endpoint;
    this.region = region;
    this._userAgent = '';
    this.setUserAgent();
  },

  /**
   * @api private
   */
  setUserAgent: function setUserAgent() {
    this._userAgent = this.headers[this.getUserAgentHeaderName()] = AWS.util.userAgent();
  },

  getUserAgentHeaderName: function getUserAgentHeaderName() {
    var prefix = AWS.util.isBrowser() ? 'X-Amz-' : '';
    return prefix + 'User-Agent';
  },

  /**
   * @api private
   */
  appendToUserAgent: function appendToUserAgent(agentPartial) {
    if (typeof agentPartial === 'string' && agentPartial) {
      this._userAgent += ' ' + agentPartial;
    }
    this.headers[this.getUserAgentHeaderName()] = this._userAgent;
  },

  /**
   * @api private
   */
  getUserAgent: function getUserAgent() {
    return this._userAgent;
  },

  /**
   * @return [String] the part of the {path} excluding the
   *   query string
   */
  pathname: function pathname() {
    return this.path.split('?', 1)[0];
  },

  /**
   * @return [String] the query string portion of the {path}
   */
  search: function search() {
    var query = this.path.split('?', 2)[1];
    if (query) {
      query = AWS.util.queryStringParse(query);
      return AWS.util.queryParamsToString(query);
    }
    return '';
  },

  /**
   * @api private
   * update httpRequest endpoint with endpoint string
   */
  updateEndpoint: function updateEndpoint(endpointStr) {
    var newEndpoint = new AWS.Endpoint(endpointStr);
    this.endpoint = newEndpoint;
    this.path = newEndpoint.path || '/';
  }
});

/**
 * The low level HTTP response object, encapsulating all HTTP header
 * and body data returned from the request.
 *
 * @!attribute statusCode
 *   @return [Integer] the HTTP status code of the response (e.g., 200, 404)
 * @!attribute headers
 *   @return [map<String,String>]
 *      a map of response header keys and their respective values
 * @!attribute body
 *   @return [String] the response body payload
 * @!attribute [r] streaming
 *   @return [Boolean] whether this response is being streamed at a low-level.
 *     Defaults to `false` (buffered reads). Do not modify this manually, use
 *     {createUnbufferedStream} to convert the stream to unbuffered mode
 *     instead.
 */
AWS.HttpResponse = inherit({

  /**
   * @api private
   */
  constructor: function HttpResponse() {
    this.statusCode = undefined;
    this.headers = {};
    this.body = undefined;
    this.streaming = false;
    this.stream = null;
  },

  /**
   * Disables buffering on the HTTP response and returns the stream for reading.
   * @return [Stream, XMLHttpRequest, null] the underlying stream object.
   *   Use this object to directly read data off of the stream.
   * @note This object is only available after the {AWS.Request~httpHeaders}
   *   event has fired. This method must be called prior to
   *   {AWS.Request~httpData}.
   * @example Taking control of a stream
   *   request.on('httpHeaders', function(statusCode, headers) {
   *     if (statusCode < 300) {
   *       if (headers.etag === 'xyz') {
   *         // pipe the stream, disabling buffering
   *         var stream = this.response.httpResponse.createUnbufferedStream();
   *         stream.pipe(process.stdout);
   *       } else { // abort this request and set a better error message
   *         this.abort();
   *         this.response.error = new Error('Invalid ETag');
   *       }
   *     }
   *   }).send(console.log);
   */
  createUnbufferedStream: function createUnbufferedStream() {
    this.streaming = true;
    return this.stream;
  }
});


AWS.HttpClient = inherit({});

/**
 * @api private
 */
AWS.HttpClient.getInstance = function getInstance() {
  if (this.singleton === undefined) {
    this.singleton = new this();
  }
  return this.singleton;
};

},{"./core":23}],40:[function(require,module,exports){
var AWS = require('../core');
var EventEmitter = require('events').EventEmitter;
require('../http');

/**
 * @api private
 */
AWS.XHRClient = AWS.util.inherit({
  handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {
    var self = this;
    var endpoint = httpRequest.endpoint;
    var emitter = new EventEmitter();
    var href = endpoint.protocol + '//' + endpoint.hostname;
    if (endpoint.port !== 80 && endpoint.port !== 443) {
      href += ':' + endpoint.port;
    }
    href += httpRequest.path;

    var xhr = new XMLHttpRequest(), headersEmitted = false;
    httpRequest.stream = xhr;

    xhr.addEventListener('readystatechange', function() {
      try {
        if (xhr.status === 0) return; // 0 code is invalid
      } catch (e) { return; }

      if (this.readyState >= this.HEADERS_RECEIVED && !headersEmitted) {
        emitter.statusCode = xhr.status;
        emitter.headers = self.parseHeaders(xhr.getAllResponseHeaders());
        emitter.emit(
          'headers',
          emitter.statusCode,
          emitter.headers,
          xhr.statusText
        );
        headersEmitted = true;
      }
      if (this.readyState === this.DONE) {
        self.finishRequest(xhr, emitter);
      }
    }, false);
    xhr.upload.addEventListener('progress', function (evt) {
      emitter.emit('sendProgress', evt);
    });
    xhr.addEventListener('progress', function (evt) {
      emitter.emit('receiveProgress', evt);
    }, false);
    xhr.addEventListener('timeout', function () {
      errCallback(AWS.util.error(new Error('Timeout'), {code: 'TimeoutError'}));
    }, false);
    xhr.addEventListener('error', function () {
      errCallback(AWS.util.error(new Error('Network Failure'), {
        code: 'NetworkingError'
      }));
    }, false);
    xhr.addEventListener('abort', function () {
      errCallback(AWS.util.error(new Error('Request aborted'), {
        code: 'RequestAbortedError'
      }));
    }, false);

    callback(emitter);
    xhr.open(httpRequest.method, href, httpOptions.xhrAsync !== false);
    AWS.util.each(httpRequest.headers, function (key, value) {
      if (key !== 'Content-Length' && key !== 'User-Agent' && key !== 'Host') {
        xhr.setRequestHeader(key, value);
      }
    });

    if (httpOptions.timeout && httpOptions.xhrAsync !== false) {
      xhr.timeout = httpOptions.timeout;
    }

    if (httpOptions.xhrWithCredentials) {
      xhr.withCredentials = true;
    }
    try { xhr.responseType = 'arraybuffer'; } catch (e) {}

    try {
      if (httpRequest.body) {
        xhr.send(httpRequest.body);
      } else {
        xhr.send();
      }
    } catch (err) {
      if (httpRequest.body && typeof httpRequest.body.buffer === 'object') {
        xhr.send(httpRequest.body.buffer); // send ArrayBuffer directly
      } else {
        throw err;
      }
    }

    return emitter;
  },

  parseHeaders: function parseHeaders(rawHeaders) {
    var headers = {};
    AWS.util.arrayEach(rawHeaders.split(/\r?\n/), function (line) {
      var key = line.split(':', 1)[0];
      var value = line.substring(key.length + 2);
      if (key.length > 0) headers[key.toLowerCase()] = value;
    });
    return headers;
  },

  finishRequest: function finishRequest(xhr, emitter) {
    var buffer;
    if (xhr.responseType === 'arraybuffer' && xhr.response) {
      var ab = xhr.response;
      buffer = new AWS.util.Buffer(ab.byteLength);
      var view = new Uint8Array(ab);
      for (var i = 0; i < buffer.length; ++i) {
        buffer[i] = view[i];
      }
    }

    try {
      if (!buffer && typeof xhr.responseText === 'string') {
        buffer = new AWS.util.Buffer(xhr.responseText);
      }
    } catch (e) {}

    if (buffer) emitter.emit('data', buffer);
    emitter.emit('end');
  }
});

/**
 * @api private
 */
AWS.HttpClient.prototype = AWS.XHRClient.prototype;

/**
 * @api private
 */
AWS.HttpClient.streamsApiVersion = 1;

},{"../core":23,"../http":39,"events":90}],41:[function(require,module,exports){
var util = require('../util');

function JsonBuilder() { }

JsonBuilder.prototype.build = function(value, shape) {
  return JSON.stringify(translate(value, shape));
};

function translate(value, shape) {
  if (!shape || value === undefined || value === null) return undefined;

  switch (shape.type) {
    case 'structure': return translateStructure(value, shape);
    case 'map': return translateMap(value, shape);
    case 'list': return translateList(value, shape);
    default: return translateScalar(value, shape);
  }
}

function translateStructure(structure, shape) {
  var struct = {};
  util.each(structure, function(name, value) {
    var memberShape = shape.members[name];
    if (memberShape) {
      if (memberShape.location !== 'body') return;
      var locationName = memberShape.isLocationName ? memberShape.name : name;
      var result = translate(value, memberShape);
      if (result !== undefined) struct[locationName] = result;
    }
  });
  return struct;
}

function translateList(list, shape) {
  var out = [];
  util.arrayEach(list, function(value) {
    var result = translate(value, shape.member);
    if (result !== undefined) out.push(result);
  });
  return out;
}

function translateMap(map, shape) {
  var out = {};
  util.each(map, function(key, value) {
    var result = translate(value, shape.value);
    if (result !== undefined) out[key] = result;
  });
  return out;
}

function translateScalar(value, shape) {
  return shape.toWireFormat(value);
}

/**
 * @api private
 */
module.exports = JsonBuilder;

},{"../util":78}],42:[function(require,module,exports){
var util = require('../util');

function JsonParser() { }

JsonParser.prototype.parse = function(value, shape) {
  return translate(JSON.parse(value), shape);
};

function translate(value, shape) {
  if (!shape || value === undefined) return undefined;

  switch (shape.type) {
    case 'structure': return translateStructure(value, shape);
    case 'map': return translateMap(value, shape);
    case 'list': return translateList(value, shape);
    default: return translateScalar(value, shape);
  }
}

function translateStructure(structure, shape) {
  if (structure == null) return undefined;

  var struct = {};
  var shapeMembers = shape.members;
  util.each(shapeMembers, function(name, memberShape) {
    var locationName = memberShape.isLocationName ? memberShape.name : name;
    if (Object.prototype.hasOwnProperty.call(structure, locationName)) {
      var value = structure[locationName];
      var result = translate(value, memberShape);
      if (result !== undefined) struct[name] = result;
    }
  });
  return struct;
}

function translateList(list, shape) {
  if (list == null) return undefined;

  var out = [];
  util.arrayEach(list, function(value) {
    var result = translate(value, shape.member);
    if (result === undefined) out.push(null);
    else out.push(result);
  });
  return out;
}

function translateMap(map, shape) {
  if (map == null) return undefined;

  var out = {};
  util.each(map, function(key, value) {
    var result = translate(value, shape.value);
    if (result === undefined) out[key] = null;
    else out[key] = result;
  });
  return out;
}

function translateScalar(value, shape) {
  return shape.toType(value);
}

/**
 * @api private
 */
module.exports = JsonParser;

},{"../util":78}],43:[function(require,module,exports){
var Collection = require('./collection');
var Operation = require('./operation');
var Shape = require('./shape');
var Paginator = require('./paginator');
var ResourceWaiter = require('./resource_waiter');

var util = require('../util');
var property = util.property;
var memoizedProperty = util.memoizedProperty;

function Api(api, options) {
  var self = this;
  api = api || {};
  options = options || {};
  options.api = this;

  api.metadata = api.metadata || {};

  property(this, 'isApi', true, false);
  property(this, 'apiVersion', api.metadata.apiVersion);
  property(this, 'endpointPrefix', api.metadata.endpointPrefix);
  property(this, 'signingName', api.metadata.signingName);
  property(this, 'globalEndpoint', api.metadata.globalEndpoint);
  property(this, 'signatureVersion', api.metadata.signatureVersion);
  property(this, 'jsonVersion', api.metadata.jsonVersion);
  property(this, 'targetPrefix', api.metadata.targetPrefix);
  property(this, 'protocol', api.metadata.protocol);
  property(this, 'timestampFormat', api.metadata.timestampFormat);
  property(this, 'xmlNamespaceUri', api.metadata.xmlNamespace);
  property(this, 'abbreviation', api.metadata.serviceAbbreviation);
  property(this, 'fullName', api.metadata.serviceFullName);
  property(this, 'serviceId', api.metadata.serviceId);

  memoizedProperty(this, 'className', function() {
    var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;
    if (!name) return null;

    name = name.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, '');
    if (name === 'ElasticLoadBalancing') name = 'ELB';
    return name;
  });

  function addEndpointOperation(name, operation) {
    if (operation.endpointoperation === true) {
      property(self, 'endpointOperation', util.string.lowerFirst(name));
    }
  }

  property(this, 'operations', new Collection(api.operations, options, function(name, operation) {
    return new Operation(name, operation, options);
  }, util.string.lowerFirst, addEndpointOperation));

  property(this, 'shapes', new Collection(api.shapes, options, function(name, shape) {
    return Shape.create(shape, options);
  }));

  property(this, 'paginators', new Collection(api.paginators, options, function(name, paginator) {
    return new Paginator(name, paginator, options);
  }));

  property(this, 'waiters', new Collection(api.waiters, options, function(name, waiter) {
    return new ResourceWaiter(name, waiter, options);
  }, util.string.lowerFirst));

  if (options.documentation) {
    property(this, 'documentation', api.documentation);
    property(this, 'documentationUrl', api.documentationUrl);
  }
}

/**
 * @api private
 */
module.exports = Api;

},{"../util":78,"./collection":44,"./operation":45,"./paginator":46,"./resource_waiter":47,"./shape":48}],44:[function(require,module,exports){
var memoizedProperty = require('../util').memoizedProperty;

function memoize(name, value, factory, nameTr) {
  memoizedProperty(this, nameTr(name), function() {
    return factory(name, value);
  });
}

function Collection(iterable, options, factory, nameTr, callback) {
  nameTr = nameTr || String;
  var self = this;

  for (var id in iterable) {
    if (Object.prototype.hasOwnProperty.call(iterable, id)) {
      memoize.call(self, id, iterable[id], factory, nameTr);
      if (callback) callback(id, iterable[id]);
    }
  }
}

/**
 * @api private
 */
module.exports = Collection;

},{"../util":78}],45:[function(require,module,exports){
var Shape = require('./shape');

var util = require('../util');
var property = util.property;
var memoizedProperty = util.memoizedProperty;

function Operation(name, operation, options) {
  var self = this;
  options = options || {};

  property(this, 'name', operation.name || name);
  property(this, 'api', options.api, false);

  operation.http = operation.http || {};
  property(this, 'endpoint', operation.endpoint);
  property(this, 'httpMethod', operation.http.method || 'POST');
  property(this, 'httpPath', operation.http.requestUri || '/');
  property(this, 'authtype', operation.authtype || '');
  property(
    this,
    'endpointDiscoveryRequired',
    operation.endpointdiscovery ?
      (operation.endpointdiscovery.required ? 'REQUIRED' : 'OPTIONAL') :
    'NULL'
  );

  memoizedProperty(this, 'input', function() {
    if (!operation.input) {
      return new Shape.create({type: 'structure'}, options);
    }
    return Shape.create(operation.input, options);
  });

  memoizedProperty(this, 'output', function() {
    if (!operation.output) {
      return new Shape.create({type: 'structure'}, options);
    }
    return Shape.create(operation.output, options);
  });

  memoizedProperty(this, 'errors', function() {
    var list = [];
    if (!operation.errors) return null;

    for (var i = 0; i < operation.errors.length; i++) {
      list.push(Shape.create(operation.errors[i], options));
    }

    return list;
  });

  memoizedProperty(this, 'paginator', function() {
    return options.api.paginators[name];
  });

  if (options.documentation) {
    property(this, 'documentation', operation.documentation);
    property(this, 'documentationUrl', operation.documentationUrl);
  }

  // idempotentMembers only tracks top-level input shapes
  memoizedProperty(this, 'idempotentMembers', function() {
    var idempotentMembers = [];
    var input = self.input;
    var members = input.members;
    if (!input.members) {
      return idempotentMembers;
    }
    for (var name in members) {
      if (!members.hasOwnProperty(name)) {
        continue;
      }
      if (members[name].isIdempotent === true) {
        idempotentMembers.push(name);
      }
    }
    return idempotentMembers;
  });

  memoizedProperty(this, 'hasEventOutput', function() {
    var output = self.output;
    return hasEventStream(output);
  });
}

function hasEventStream(topLevelShape) {
  var members = topLevelShape.members;
  var payload = topLevelShape.payload;

  if (!topLevelShape.members) {
    return false;
  }

  if (payload) {
    var payloadMember = members[payload];
    return payloadMember.isEventStream;
  }

  // check if any member is an event stream
  for (var name in members) {
    if (!members.hasOwnProperty(name)) {
      if (members[name].isEventStream === true) {
        return true;
      }
    }
  }
  return false;
}

/**
 * @api private
 */
module.exports = Operation;

},{"../util":78,"./shape":48}],46:[function(require,module,exports){
var property = require('../util').property;

function Paginator(name, paginator) {
  property(this, 'inputToken', paginator.input_token);
  property(this, 'limitKey', paginator.limit_key);
  property(this, 'moreResults', paginator.more_results);
  property(this, 'outputToken', paginator.output_token);
  property(this, 'resultKey', paginator.result_key);
}

/**
 * @api private
 */
module.exports = Paginator;

},{"../util":78}],47:[function(require,module,exports){
var util = require('../util');
var property = util.property;

function ResourceWaiter(name, waiter, options) {
  options = options || {};
  property(this, 'name', name);
  property(this, 'api', options.api, false);

  if (waiter.operation) {
    property(this, 'operation', util.string.lowerFirst(waiter.operation));
  }

  var self = this;
  var keys = [
    'type',
    'description',
    'delay',
    'maxAttempts',
    'acceptors'
  ];

  keys.forEach(function(key) {
    var value = waiter[key];
    if (value) {
      property(self, key, value);
    }
  });
}

/**
 * @api private
 */
module.exports = ResourceWaiter;

},{"../util":78}],48:[function(require,module,exports){
var Collection = require('./collection');

var util = require('../util');

function property(obj, name, value) {
  if (value !== null && value !== undefined) {
    util.property.apply(this, arguments);
  }
}

function memoizedProperty(obj, name) {
  if (!obj.constructor.prototype[name]) {
    util.memoizedProperty.apply(this, arguments);
  }
}

function Shape(shape, options, memberName) {
  options = options || {};

  property(this, 'shape', shape.shape);
  property(this, 'api', options.api, false);
  property(this, 'type', shape.type);
  property(this, 'enum', shape.enum);
  property(this, 'min', shape.min);
  property(this, 'max', shape.max);
  property(this, 'pattern', shape.pattern);
  property(this, 'location', shape.location || this.location || 'body');
  property(this, 'name', this.name || shape.xmlName || shape.queryName ||
    shape.locationName || memberName);
  property(this, 'isStreaming', shape.streaming || this.isStreaming || false);
  property(this, 'requiresLength', shape.requiresLength, false);
  property(this, 'isComposite', shape.isComposite || false);
  property(this, 'isShape', true, false);
  property(this, 'isQueryName', Boolean(shape.queryName), false);
  property(this, 'isLocationName', Boolean(shape.locationName), false);
  property(this, 'isIdempotent', shape.idempotencyToken === true);
  property(this, 'isJsonValue', shape.jsonvalue === true);
  property(this, 'isSensitive', shape.sensitive === true || shape.prototype && shape.prototype.sensitive === true);
  property(this, 'isEventStream', Boolean(shape.eventstream), false);
  property(this, 'isEvent', Boolean(shape.event), false);
  property(this, 'isEventPayload', Boolean(shape.eventpayload), false);
  property(this, 'isEventHeader', Boolean(shape.eventheader), false);
  property(this, 'isTimestampFormatSet', Boolean(shape.timestampFormat) || shape.prototype && shape.prototype.isTimestampFormatSet === true, false);
  property(this, 'endpointDiscoveryId', Boolean(shape.endpointdiscoveryid), false);
  property(this, 'hostLabel', Boolean(shape.hostLabel), false);

  if (options.documentation) {
    property(this, 'documentation', shape.documentation);
    property(this, 'documentationUrl', shape.documentationUrl);
  }

  if (shape.xmlAttribute) {
    property(this, 'isXmlAttribute', shape.xmlAttribute || false);
  }

  // type conversion and parsing
  property(this, 'defaultValue', null);
  this.toWireFormat = function(value) {
    if (value === null || value === undefined) return '';
    return value;
  };
  this.toType = function(value) { return value; };
}

/**
 * @api private
 */
Shape.normalizedTypes = {
  character: 'string',
  double: 'float',
  long: 'integer',
  short: 'integer',
  biginteger: 'integer',
  bigdecimal: 'float',
  blob: 'binary'
};

/**
 * @api private
 */
Shape.types = {
  'structure': StructureShape,
  'list': ListShape,
  'map': MapShape,
  'boolean': BooleanShape,
  'timestamp': TimestampShape,
  'float': FloatShape,
  'integer': IntegerShape,
  'string': StringShape,
  'base64': Base64Shape,
  'binary': BinaryShape
};

Shape.resolve = function resolve(shape, options) {
  if (shape.shape) {
    var refShape = options.api.shapes[shape.shape];
    if (!refShape) {
      throw new Error('Cannot find shape reference: ' + shape.shape);
    }

    return refShape;
  } else {
    return null;
  }
};

Shape.create = function create(shape, options, memberName) {
  if (shape.isShape) return shape;

  var refShape = Shape.resolve(shape, options);
  if (refShape) {
    var filteredKeys = Object.keys(shape);
    if (!options.documentation) {
      filteredKeys = filteredKeys.filter(function(name) {
        return !name.match(/documentation/);
      });
    }

    // create an inline shape with extra members
    var InlineShape = function() {
      refShape.constructor.call(this, shape, options, memberName);
    };
    InlineShape.prototype = refShape;
    return new InlineShape();
  } else {
    // set type if not set
    if (!shape.type) {
      if (shape.members) shape.type = 'structure';
      else if (shape.member) shape.type = 'list';
      else if (shape.key) shape.type = 'map';
      else shape.type = 'string';
    }

    // normalize types
    var origType = shape.type;
    if (Shape.normalizedTypes[shape.type]) {
      shape.type = Shape.normalizedTypes[shape.type];
    }

    if (Shape.types[shape.type]) {
      return new Shape.types[shape.type](shape, options, memberName);
    } else {
      throw new Error('Unrecognized shape type: ' + origType);
    }
  }
};

function CompositeShape(shape) {
  Shape.apply(this, arguments);
  property(this, 'isComposite', true);

  if (shape.flattened) {
    property(this, 'flattened', shape.flattened || false);
  }
}

function StructureShape(shape, options) {
  var self = this;
  var requiredMap = null, firstInit = !this.isShape;

  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return {}; });
    property(this, 'members', {});
    property(this, 'memberNames', []);
    property(this, 'required', []);
    property(this, 'isRequired', function() { return false; });
  }

  if (shape.members) {
    property(this, 'members', new Collection(shape.members, options, function(name, member) {
      return Shape.create(member, options, name);
    }));
    memoizedProperty(this, 'memberNames', function() {
      return shape.xmlOrder || Object.keys(shape.members);
    });

    if (shape.event) {
      memoizedProperty(this, 'eventPayloadMemberName', function() {
        var members = self.members;
        var memberNames = self.memberNames;
        // iterate over members to find ones that are event payloads
        for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
          if (members[memberNames[i]].isEventPayload) {
            return memberNames[i];
          }
        }
      });

      memoizedProperty(this, 'eventHeaderMemberNames', function() {
        var members = self.members;
        var memberNames = self.memberNames;
        var eventHeaderMemberNames = [];
        // iterate over members to find ones that are event headers
        for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
          if (members[memberNames[i]].isEventHeader) {
            eventHeaderMemberNames.push(memberNames[i]);
          }
        }
        return eventHeaderMemberNames;
      });
    }
  }

  if (shape.required) {
    property(this, 'required', shape.required);
    property(this, 'isRequired', function(name) {
      if (!requiredMap) {
        requiredMap = {};
        for (var i = 0; i < shape.required.length; i++) {
          requiredMap[shape.required[i]] = true;
        }
      }

      return requiredMap[name];
    }, false, true);
  }

  property(this, 'resultWrapper', shape.resultWrapper || null);

  if (shape.payload) {
    property(this, 'payload', shape.payload);
  }

  if (typeof shape.xmlNamespace === 'string') {
    property(this, 'xmlNamespaceUri', shape.xmlNamespace);
  } else if (typeof shape.xmlNamespace === 'object') {
    property(this, 'xmlNamespacePrefix', shape.xmlNamespace.prefix);
    property(this, 'xmlNamespaceUri', shape.xmlNamespace.uri);
  }
}

function ListShape(shape, options) {
  var self = this, firstInit = !this.isShape;
  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return []; });
  }

  if (shape.member) {
    memoizedProperty(this, 'member', function() {
      return Shape.create(shape.member, options);
    });
  }

  if (this.flattened) {
    var oldName = this.name;
    memoizedProperty(this, 'name', function() {
      return self.member.name || oldName;
    });
  }
}

function MapShape(shape, options) {
  var firstInit = !this.isShape;
  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return {}; });
    property(this, 'key', Shape.create({type: 'string'}, options));
    property(this, 'value', Shape.create({type: 'string'}, options));
  }

  if (shape.key) {
    memoizedProperty(this, 'key', function() {
      return Shape.create(shape.key, options);
    });
  }
  if (shape.value) {
    memoizedProperty(this, 'value', function() {
      return Shape.create(shape.value, options);
    });
  }
}

function TimestampShape(shape) {
  var self = this;
  Shape.apply(this, arguments);

  if (shape.timestampFormat) {
    property(this, 'timestampFormat', shape.timestampFormat);
  } else if (self.isTimestampFormatSet && this.timestampFormat) {
    property(this, 'timestampFormat', this.timestampFormat);
  } else if (this.location === 'header') {
    property(this, 'timestampFormat', 'rfc822');
  } else if (this.location === 'querystring') {
    property(this, 'timestampFormat', 'iso8601');
  } else if (this.api) {
    switch (this.api.protocol) {
      case 'json':
      case 'rest-json':
        property(this, 'timestampFormat', 'unixTimestamp');
        break;
      case 'rest-xml':
      case 'query':
      case 'ec2':
        property(this, 'timestampFormat', 'iso8601');
        break;
    }
  }

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    if (typeof value.toUTCString === 'function') return value;
    return typeof value === 'string' || typeof value === 'number' ?
           util.date.parseTimestamp(value) : null;
  };

  this.toWireFormat = function(value) {
    return util.date.format(value, self.timestampFormat);
  };
}

function StringShape() {
  Shape.apply(this, arguments);

  var nullLessProtocols = ['rest-xml', 'query', 'ec2'];
  this.toType = function(value) {
    value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ?
      value || '' : value;
    if (this.isJsonValue) {
      return JSON.parse(value);
    }

    return value && typeof value.toString === 'function' ?
      value.toString() : value;
  };

  this.toWireFormat = function(value) {
    return this.isJsonValue ? JSON.stringify(value) : value;
  };
}

function FloatShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    return parseFloat(value);
  };
  this.toWireFormat = this.toType;
}

function IntegerShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    return parseInt(value, 10);
  };
  this.toWireFormat = this.toType;
}

function BinaryShape() {
  Shape.apply(this, arguments);
  this.toType = function(value) {
    var buf = util.base64.decode(value);
    if (this.isSensitive && util.isNode() && typeof util.Buffer.alloc === 'function') {
  /* Node.js can create a Buffer that is not isolated.
   * i.e. buf.byteLength !== buf.buffer.byteLength
   * This means that the sensitive data is accessible to anyone with access to buf.buffer.
   * If this is the node shared Buffer, then other code within this process _could_ find this secret.
   * Copy sensitive data to an isolated Buffer and zero the sensitive data.
   * While this is safe to do here, copying this code somewhere else may produce unexpected results.
   */
      var secureBuf = util.Buffer.alloc(buf.length, buf);
      buf.fill(0);
      buf = secureBuf;
    }
    return buf;
  };
  this.toWireFormat = util.base64.encode;
}

function Base64Shape() {
  BinaryShape.apply(this, arguments);
}

function BooleanShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (typeof value === 'boolean') return value;
    if (value === null || value === undefined) return null;
    return value === 'true';
  };
}

/**
 * @api private
 */
Shape.shapes = {
  StructureShape: StructureShape,
  ListShape: ListShape,
  MapShape: MapShape,
  StringShape: StringShape,
  BooleanShape: BooleanShape,
  Base64Shape: Base64Shape
};

/**
 * @api private
 */
module.exports = Shape;

},{"../util":78,"./collection":44}],49:[function(require,module,exports){
var AWS = require('./core');

/**
 * @api private
 */
AWS.ParamValidator = AWS.util.inherit({
  /**
   * Create a new validator object.
   *
   * @param validation [Boolean|map] whether input parameters should be
   *     validated against the operation description before sending the
   *     request. Pass a map to enable any of the following specific
   *     validation features:
   *
   *     * **min** [Boolean] &mdash; Validates that a value meets the min
   *       constraint. This is enabled by default when paramValidation is set
   *       to `true`.
   *     * **max** [Boolean] &mdash; Validates that a value meets the max
   *       constraint.
   *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
   *       regular expression.
   *     * **enum** [Boolean] &mdash; Validates that a string value matches one
   *       of the allowable enum values.
   */
  constructor: function ParamValidator(validation) {
    if (validation === true || validation === undefined) {
      validation = {'min': true};
    }
    this.validation = validation;
  },

  validate: function validate(shape, params, context) {
    this.errors = [];
    this.validateMember(shape, params || {}, context || 'params');

    if (this.errors.length > 1) {
      var msg = this.errors.join('\n* ');
      msg = 'There were ' + this.errors.length +
        ' validation errors:\n* ' + msg;
      throw AWS.util.error(new Error(msg),
        {code: 'MultipleValidationErrors', errors: this.errors});
    } else if (this.errors.length === 1) {
      throw this.errors[0];
    } else {
      return true;
    }
  },

  fail: function fail(code, message) {
    this.errors.push(AWS.util.error(new Error(message), {code: code}));
  },

  validateStructure: function validateStructure(shape, params, context) {
    this.validateType(params, context, ['object'], 'structure');

    var paramName;
    for (var i = 0; shape.required && i < shape.required.length; i++) {
      paramName = shape.required[i];
      var value = params[paramName];
      if (value === undefined || value === null) {
        this.fail('MissingRequiredParameter',
          'Missing required key \'' + paramName + '\' in ' + context);
      }
    }

    // validate hash members
    for (paramName in params) {
      if (!Object.prototype.hasOwnProperty.call(params, paramName)) continue;

      var paramValue = params[paramName],
          memberShape = shape.members[paramName];

      if (memberShape !== undefined) {
        var memberContext = [context, paramName].join('.');
        this.validateMember(memberShape, paramValue, memberContext);
      } else {
        this.fail('UnexpectedParameter',
          'Unexpected key \'' + paramName + '\' found in ' + context);
      }
    }

    return true;
  },

  validateMember: function validateMember(shape, param, context) {
    switch (shape.type) {
      case 'structure':
        return this.validateStructure(shape, param, context);
      case 'list':
        return this.validateList(shape, param, context);
      case 'map':
        return this.validateMap(shape, param, context);
      default:
        return this.validateScalar(shape, param, context);
    }
  },

  validateList: function validateList(shape, params, context) {
    if (this.validateType(params, context, [Array])) {
      this.validateRange(shape, params.length, context, 'list member count');
      // validate array members
      for (var i = 0; i < params.length; i++) {
        this.validateMember(shape.member, params[i], context + '[' + i + ']');
      }
    }
  },

  validateMap: function validateMap(shape, params, context) {
    if (this.validateType(params, context, ['object'], 'map')) {
      // Build up a count of map members to validate range traits.
      var mapCount = 0;
      for (var param in params) {
        if (!Object.prototype.hasOwnProperty.call(params, param)) continue;
        // Validate any map key trait constraints
        this.validateMember(shape.key, param,
                            context + '[key=\'' + param + '\']');
        this.validateMember(shape.value, params[param],
                            context + '[\'' + param + '\']');
        mapCount++;
      }
      this.validateRange(shape, mapCount, context, 'map member count');
    }
  },

  validateScalar: function validateScalar(shape, value, context) {
    switch (shape.type) {
      case null:
      case undefined:
      case 'string':
        return this.validateString(shape, value, context);
      case 'base64':
      case 'binary':
        return this.validatePayload(value, context);
      case 'integer':
      case 'float':
        return this.validateNumber(shape, value, context);
      case 'boolean':
        return this.validateType(value, context, ['boolean']);
      case 'timestamp':
        return this.validateType(value, context, [Date,
          /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/, 'number'],
          'Date object, ISO-8601 string, or a UNIX timestamp');
      default:
        return this.fail('UnkownType', 'Unhandled type ' +
                         shape.type + ' for ' + context);
    }
  },

  validateString: function validateString(shape, value, context) {
    var validTypes = ['string'];
    if (shape.isJsonValue) {
      validTypes = validTypes.concat(['number', 'object', 'boolean']);
    }
    if (value !== null && this.validateType(value, context, validTypes)) {
      this.validateEnum(shape, value, context);
      this.validateRange(shape, value.length, context, 'string length');
      this.validatePattern(shape, value, context);
      this.validateUri(shape, value, context);
    }
  },

  validateUri: function validateUri(shape, value, context) {
    if (shape['location'] === 'uri') {
      if (value.length === 0) {
        this.fail('UriParameterError', 'Expected uri parameter to have length >= 1,'
          + ' but found "' + value +'" for ' + context);
      }
    }
  },

  validatePattern: function validatePattern(shape, value, context) {
    if (this.validation['pattern'] && shape['pattern'] !== undefined) {
      if (!(new RegExp(shape['pattern'])).test(value)) {
        this.fail('PatternMatchError', 'Provided value "' + value + '" '
          + 'does not match regex pattern /' + shape['pattern'] + '/ for '
          + context);
      }
    }
  },

  validateRange: function validateRange(shape, value, context, descriptor) {
    if (this.validation['min']) {
      if (shape['min'] !== undefined && value < shape['min']) {
        this.fail('MinRangeError', 'Expected ' + descriptor + ' >= '
          + shape['min'] + ', but found ' + value + ' for ' + context);
      }
    }
    if (this.validation['max']) {
      if (shape['max'] !== undefined && value > shape['max']) {
        this.fail('MaxRangeError', 'Expected ' + descriptor + ' <= '
          + shape['max'] + ', but found ' + value + ' for ' + context);
      }
    }
  },

  validateEnum: function validateRange(shape, value, context) {
    if (this.validation['enum'] && shape['enum'] !== undefined) {
      // Fail if the string value is not present in the enum list
      if (shape['enum'].indexOf(value) === -1) {
        this.fail('EnumError', 'Found string value of ' + value + ', but '
          + 'expected ' + shape['enum'].join('|') + ' for ' + context);
      }
    }
  },

  validateType: function validateType(value, context, acceptedTypes, type) {
    // We will not log an error for null or undefined, but we will return
    // false so that callers know that the expected type was not strictly met.
    if (value === null || value === undefined) return false;

    var foundInvalidType = false;
    for (var i = 0; i < acceptedTypes.length; i++) {
      if (typeof acceptedTypes[i] === 'string') {
        if (typeof value === acceptedTypes[i]) return true;
      } else if (acceptedTypes[i] instanceof RegExp) {
        if ((value || '').toString().match(acceptedTypes[i])) return true;
      } else {
        if (value instanceof acceptedTypes[i]) return true;
        if (AWS.util.isType(value, acceptedTypes[i])) return true;
        if (!type && !foundInvalidType) acceptedTypes = acceptedTypes.slice();
        acceptedTypes[i] = AWS.util.typeName(acceptedTypes[i]);
      }
      foundInvalidType = true;
    }

    var acceptedType = type;
    if (!acceptedType) {
      acceptedType = acceptedTypes.join(', ').replace(/,([^,]+)$/, ', or$1');
    }

    var vowel = acceptedType.match(/^[aeiou]/i) ? 'n' : '';
    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a' +
              vowel + ' ' + acceptedType);
    return false;
  },

  validateNumber: function validateNumber(shape, value, context) {
    if (value === null || value === undefined) return;
    if (typeof value === 'string') {
      var castedValue = parseFloat(value);
      if (castedValue.toString() === value) value = castedValue;
    }
    if (this.validateType(value, context, ['number'])) {
      this.validateRange(shape, value, context, 'numeric value');
    }
  },

  validatePayload: function validatePayload(value, context) {
    if (value === null || value === undefined) return;
    if (typeof value === 'string') return;
    if (value && typeof value.byteLength === 'number') return; // typed arrays
    if (AWS.util.isNode()) { // special check for buffer/stream in Node.js
      var Stream = AWS.util.stream.Stream;
      if (AWS.util.Buffer.isBuffer(value) || value instanceof Stream) return;
    } else {
      if (typeof Blob !== void 0 && value instanceof Blob) return;
    }

    var types = ['Buffer', 'Stream', 'File', 'Blob', 'ArrayBuffer', 'DataView'];
    if (value) {
      for (var i = 0; i < types.length; i++) {
        if (AWS.util.isType(value, types[i])) return;
        if (AWS.util.typeName(value.constructor) === types[i]) return;
      }
    }

    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a ' +
      'string, Buffer, Stream, Blob, or typed array object');
  }
});

},{"./core":23}],50:[function(require,module,exports){
var util =  require('../util');
var AWS = require('../core');

/**
 * Prepend prefix defined by API model to endpoint that's already
 * constructed. This feature does not apply to operations using
 * endpoint discovery and can be disabled.
 * @api private
 */
function populateHostPrefix(request)  {
  var enabled = request.service.config.hostPrefixEnabled;
  if (!enabled) return request;
  var operationModel = request.service.api.operations[request.operation];
  //don't marshal host prefix when operation has endpoint discovery traits
  if (hasEndpointDiscover(request)) return request;
  if (operationModel.endpoint && operationModel.endpoint.hostPrefix) {
    var hostPrefixNotation = operationModel.endpoint.hostPrefix;
    var hostPrefix = expandHostPrefix(hostPrefixNotation, request.params, operationModel.input);
    prependEndpointPrefix(request.httpRequest.endpoint, hostPrefix);
    validateHostname(request.httpRequest.endpoint.hostname);
  }
  return request;
}

/**
 * @api private
 */
function hasEndpointDiscover(request) {
  var api = request.service.api;
  var operationModel = api.operations[request.operation];
  var isEndpointOperation = api.endpointOperation && (api.endpointOperation === util.string.lowerFirst(operationModel.name));
  return (operationModel.endpointDiscoveryRequired !== 'NULL' || isEndpointOperation === true);
}

/**
 * @api private
 */
function expandHostPrefix(hostPrefixNotation, params, shape) {
  util.each(shape.members, function(name, member) {
    if (member.hostLabel === true) {
      if (typeof params[name] !== 'string' || params[name] === '') {
        throw util.error(new Error(), {
          message: 'Parameter ' + name + ' should be a non-empty string.',
          code: 'InvalidParameter'
        });
      }
      var regex = new RegExp('\\{' + name + '\\}', 'g');
      hostPrefixNotation = hostPrefixNotation.replace(regex, params[name]);
    }
  });
  return hostPrefixNotation;
}

/**
 * @api private
 */
function prependEndpointPrefix(endpoint, prefix) {
  if (endpoint.host) {
    endpoint.host = prefix + endpoint.host;
  }
  if (endpoint.hostname) {
    endpoint.hostname = prefix + endpoint.hostname;
  }
}

/**
 * @api private
 */
function validateHostname(hostname) {
  var labels = hostname.split('.');
  //Reference: https://tools.ietf.org/html/rfc1123#section-2
  var hostPattern = /^[a-zA-Z0-9]{1}$|^[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9]$/;
  util.arrayEach(labels, function(label) {
    if (!label.length || label.length < 1 || label.length > 63) {
      throw util.error(new Error(), {
        code: 'ValidationError',
        message: 'Hostname label length should be between 1 to 63 characters, inclusive.'
      });
    }
    if (!hostPattern.test(label)) {
      throw AWS.util.error(new Error(),
        {code: 'ValidationError', message: label + ' is not hostname compatible.'});
    }
  });
}

module.exports = {
  populateHostPrefix: populateHostPrefix
};

},{"../core":23,"../util":78}],51:[function(require,module,exports){
var util = require('../util');
var JsonBuilder = require('../json/builder');
var JsonParser = require('../json/parser');
var populateHostPrefix = require('./helpers').populateHostPrefix;

function buildRequest(req) {
  var httpRequest = req.httpRequest;
  var api = req.service.api;
  var target = api.targetPrefix + '.' + api.operations[req.operation].name;
  var version = api.jsonVersion || '1.0';
  var input = api.operations[req.operation].input;
  var builder = new JsonBuilder();

  if (version === 1) version = '1.0';
  httpRequest.body = builder.build(req.params || {}, input);
  httpRequest.headers['Content-Type'] = 'application/x-amz-json-' + version;
  httpRequest.headers['X-Amz-Target'] = target;

  populateHostPrefix(req);
}

function extractError(resp) {
  var error = {};
  var httpResponse = resp.httpResponse;

  error.code = httpResponse.headers['x-amzn-errortype'] || 'UnknownError';
  if (typeof error.code === 'string') {
    error.code = error.code.split(':')[0];
  }

  if (httpResponse.body.length > 0) {
    try {
      var e = JSON.parse(httpResponse.body.toString());
      if (e.__type || e.code) {
        error.code = (e.__type || e.code).split('#').pop();
      }
      if (error.code === 'RequestEntityTooLarge') {
        error.message = 'Request body must be less than 1 MB';
      } else {
        error.message = (e.message || e.Message || null);
      }
    } catch (e) {
      error.statusCode = httpResponse.statusCode;
      error.message = httpResponse.statusMessage;
    }
  } else {
    error.statusCode = httpResponse.statusCode;
    error.message = httpResponse.statusCode.toString();
  }

  resp.error = util.error(new Error(), error);
}

function extractData(resp) {
  var body = resp.httpResponse.body.toString() || '{}';
  if (resp.request.service.config.convertResponseTypes === false) {
    resp.data = JSON.parse(body);
  } else {
    var operation = resp.request.service.api.operations[resp.request.operation];
    var shape = operation.output || {};
    var parser = new JsonParser();
    resp.data = parser.parse(body, shape);
  }
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};

},{"../json/builder":41,"../json/parser":42,"../util":78,"./helpers":50}],52:[function(require,module,exports){
var AWS = require('../core');
var util = require('../util');
var QueryParamSerializer = require('../query/query_param_serializer');
var Shape = require('../model/shape');
var populateHostPrefix = require('./helpers').populateHostPrefix;

function buildRequest(req) {
  var operation = req.service.api.operations[req.operation];
  var httpRequest = req.httpRequest;
  httpRequest.headers['Content-Type'] =
    'application/x-www-form-urlencoded; charset=utf-8';
  httpRequest.params = {
    Version: req.service.api.apiVersion,
    Action: operation.name
  };

  // convert the request parameters into a list of query params,
  // e.g. Deeply.NestedParam.0.Name=value
  var builder = new QueryParamSerializer();
  builder.serialize(req.params, operation.input, function(name, value) {
    httpRequest.params[name] = value;
  });
  httpRequest.body = util.queryParamsToString(httpRequest.params);

  populateHostPrefix(req);
}

function extractError(resp) {
  var data, body = resp.httpResponse.body.toString();
  if (body.match('<UnknownOperationException')) {
    data = {
      Code: 'UnknownOperation',
      Message: 'Unknown operation ' + resp.request.operation
    };
  } else {
    try {
      data = new AWS.XML.Parser().parse(body);
    } catch (e) {
      data = {
        Code: resp.httpResponse.statusCode,
        Message: resp.httpResponse.statusMessage
      };
    }
  }

  if (data.requestId && !resp.requestId) resp.requestId = data.requestId;
  if (data.Errors) data = data.Errors;
  if (data.Error) data = data.Error;
  if (data.Code) {
    resp.error = util.error(new Error(), {
      code: data.Code,
      message: data.Message
    });
  } else {
    resp.error = util.error(new Error(), {
      code: resp.httpResponse.statusCode,
      message: null
    });
  }
}

function extractData(resp) {
  var req = resp.request;
  var operation = req.service.api.operations[req.operation];
  var shape = operation.output || {};
  var origRules = shape;

  if (origRules.resultWrapper) {
    var tmp = Shape.create({type: 'structure'});
    tmp.members[origRules.resultWrapper] = shape;
    tmp.memberNames = [origRules.resultWrapper];
    util.property(shape, 'name', shape.resultWrapper);
    shape = tmp;
  }

  var parser = new AWS.XML.Parser();

  // TODO: Refactor XML Parser to parse RequestId from response.
  if (shape && shape.members && !shape.members._XAMZRequestId) {
    var requestIdShape = Shape.create(
      { type: 'string' },
      { api: { protocol: 'query' } },
      'requestId'
    );
    shape.members._XAMZRequestId = requestIdShape;
  }

  var data = parser.parse(resp.httpResponse.body.toString(), shape);
  resp.requestId = data._XAMZRequestId || data.requestId;

  if (data._XAMZRequestId) delete data._XAMZRequestId;

  if (origRules.resultWrapper) {
    if (data[origRules.resultWrapper]) {
      util.update(data, data[origRules.resultWrapper]);
      delete data[origRules.resultWrapper];
    }
  }

  resp.data = data;
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};

},{"../core":23,"../model/shape":48,"../query/query_param_serializer":56,"../util":78,"./helpers":50}],53:[function(require,module,exports){
var util = require('../util');
var populateHostPrefix = require('./helpers').populateHostPrefix;

function populateMethod(req) {
  req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;
}

function generateURI(endpointPath, operationPath, input, params) {
  var uri = [endpointPath, operationPath].join('/');
  uri = uri.replace(/\/+/g, '/');

  var queryString = {}, queryStringSet = false;
  util.each(input.members, function (name, member) {
    var paramValue = params[name];
    if (paramValue === null || paramValue === undefined) return;
    if (member.location === 'uri') {
      var regex = new RegExp('\\{' + member.name + '(\\+)?\\}');
      uri = uri.replace(regex, function(_, plus) {
        var fn = plus ? util.uriEscapePath : util.uriEscape;
        return fn(String(paramValue));
      });
    } else if (member.location === 'querystring') {
      queryStringSet = true;

      if (member.type === 'list') {
        queryString[member.name] = paramValue.map(function(val) {
          return util.uriEscape(member.member.toWireFormat(val).toString());
        });
      } else if (member.type === 'map') {
        util.each(paramValue, function(key, value) {
          if (Array.isArray(value)) {
            queryString[key] = value.map(function(val) {
              return util.uriEscape(String(val));
            });
          } else {
            queryString[key] = util.uriEscape(String(value));
          }
        });
      } else {
        queryString[member.name] = util.uriEscape(member.toWireFormat(paramValue).toString());
      }
    }
  });

  if (queryStringSet) {
    uri += (uri.indexOf('?') >= 0 ? '&' : '?');
    var parts = [];
    util.arrayEach(Object.keys(queryString).sort(), function(key) {
      if (!Array.isArray(queryString[key])) {
        queryString[key] = [queryString[key]];
      }
      for (var i = 0; i < queryString[key].length; i++) {
        parts.push(util.uriEscape(String(key)) + '=' + queryString[key][i]);
      }
    });
    uri += parts.join('&');
  }

  return uri;
}

function populateURI(req) {
  var operation = req.service.api.operations[req.operation];
  var input = operation.input;

  var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);
  req.httpRequest.path = uri;
}

function populateHeaders(req) {
  var operation = req.service.api.operations[req.operation];
  util.each(operation.input.members, function (name, member) {
    var value = req.params[name];
    if (value === null || value === undefined) return;

    if (member.location === 'headers' && member.type === 'map') {
      util.each(value, function(key, memberValue) {
        req.httpRequest.headers[member.name + key] = memberValue;
      });
    } else if (member.location === 'header') {
      value = member.toWireFormat(value).toString();
      if (member.isJsonValue) {
        value = util.base64.encode(value);
      }
      req.httpRequest.headers[member.name] = value;
    }
  });
}

function buildRequest(req) {
  populateMethod(req);
  populateURI(req);
  populateHeaders(req);
  populateHostPrefix(req);
}

function extractError() {
}

function extractData(resp) {
  var req = resp.request;
  var data = {};
  var r = resp.httpResponse;
  var operation = req.service.api.operations[req.operation];
  var output = operation.output;

  // normalize headers names to lower-cased keys for matching
  var headers = {};
  util.each(r.headers, function (k, v) {
    headers[k.toLowerCase()] = v;
  });

  util.each(output.members, function(name, member) {
    var header = (member.name || name).toLowerCase();
    if (member.location === 'headers' && member.type === 'map') {
      data[name] = {};
      var location = member.isLocationName ? member.name : '';
      var pattern = new RegExp('^' + location + '(.+)', 'i');
      util.each(r.headers, function (k, v) {
        var result = k.match(pattern);
        if (result !== null) {
          data[name][result[1]] = v;
        }
      });
    } else if (member.location === 'header') {
      if (headers[header] !== undefined) {
        var value = member.isJsonValue ?
          util.base64.decode(headers[header]) :
          headers[header];
        data[name] = member.toType(value);
      }
    } else if (member.location === 'statusCode') {
      data[name] = parseInt(r.statusCode, 10);
    }
  });

  resp.data = data;
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData,
  generateURI: generateURI
};

},{"../util":78,"./helpers":50}],54:[function(require,module,exports){
var util = require('../util');
var Rest = require('./rest');
var Json = require('./json');
var JsonBuilder = require('../json/builder');
var JsonParser = require('../json/parser');

function populateBody(req) {
  var builder = new JsonBuilder();
  var input = req.service.api.operations[req.operation].input;

  if (input.payload) {
    var params = {};
    var payloadShape = input.members[input.payload];
    params = req.params[input.payload];
    if (params === undefined) return;

    if (payloadShape.type === 'structure') {
      req.httpRequest.body = builder.build(params, payloadShape);
      applyContentTypeHeader(req);
    } else { // non-JSON payload
      req.httpRequest.body = params;
      if (payloadShape.type === 'binary' || payloadShape.isStreaming) {
        applyContentTypeHeader(req, true);
      }
    }
  } else {
    var body = builder.build(req.params, input);
    if (body !== '{}' || req.httpRequest.method !== 'GET') { //don't send empty body for GET method
      req.httpRequest.body = body;
    }
    applyContentTypeHeader(req);
  }
}

function applyContentTypeHeader(req, isBinary) {
  var operation = req.service.api.operations[req.operation];
  var input = operation.input;

  if (!req.httpRequest.headers['Content-Type']) {
    var type = isBinary ? 'binary/octet-stream' : 'application/json';
    req.httpRequest.headers['Content-Type'] = type;
  }
}

function buildRequest(req) {
  Rest.buildRequest(req);

  // never send body payload on HEAD/DELETE
  if (['HEAD', 'DELETE'].indexOf(req.httpRequest.method) < 0) {
    populateBody(req);
  }
}

function extractError(resp) {
  Json.extractError(resp);
}

function extractData(resp) {
  Rest.extractData(resp);

  var req = resp.request;
  var operation = req.service.api.operations[req.operation];
  var rules = req.service.api.operations[req.operation].output || {};
  var parser;
  var hasEventOutput = operation.hasEventOutput;

  if (rules.payload) {
    var payloadMember = rules.members[rules.payload];
    var body = resp.httpResponse.body;
    if (payloadMember.isEventStream) {
      parser = new JsonParser();
      resp.data[payload] = util.createEventStream(
        AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : body,
        parser,
        payloadMember
      );
    } else if (payloadMember.type === 'structure' || payloadMember.type === 'list') {
      var parser = new JsonParser();
      resp.data[rules.payload] = parser.parse(body, payloadMember);
    } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
      resp.data[rules.payload] = body;
    } else {
      resp.data[rules.payload] = payloadMember.toType(body);
    }
  } else {
    var data = resp.data;
    Json.extractData(resp);
    resp.data = util.merge(data, resp.data);
  }
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};

},{"../json/builder":41,"../json/parser":42,"../util":78,"./json":51,"./rest":53}],55:[function(require,module,exports){
var AWS = require('../core');
var util = require('../util');
var Rest = require('./rest');

function populateBody(req) {
  var input = req.service.api.operations[req.operation].input;
  var builder = new AWS.XML.Builder();
  var params = req.params;

  var payload = input.payload;
  if (payload) {
    var payloadMember = input.members[payload];
    params = params[payload];
    if (params === undefined) return;

    if (payloadMember.type === 'structure') {
      var rootElement = payloadMember.name;
      req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);
    } else { // non-xml payload
      req.httpRequest.body = params;
    }
  } else {
    req.httpRequest.body = builder.toXML(params, input, input.name ||
      input.shape || util.string.upperFirst(req.operation) + 'Request');
  }
}

function buildRequest(req) {
  Rest.buildRequest(req);

  // never send body payload on GET/HEAD
  if (['GET', 'HEAD'].indexOf(req.httpRequest.method) < 0) {
    populateBody(req);
  }
}

function extractError(resp) {
  Rest.extractError(resp);

  var data;
  try {
    data = new AWS.XML.Parser().parse(resp.httpResponse.body.toString());
  } catch (e) {
    data = {
      Code: resp.httpResponse.statusCode,
      Message: resp.httpResponse.statusMessage
    };
  }

  if (data.Errors) data = data.Errors;
  if (data.Error) data = data.Error;
  if (data.Code) {
    resp.error = util.error(new Error(), {
      code: data.Code,
      message: data.Message
    });
  } else {
    resp.error = util.error(new Error(), {
      code: resp.httpResponse.statusCode,
      message: null
    });
  }
}

function extractData(resp) {
  Rest.extractData(resp);

  var parser;
  var req = resp.request;
  var body = resp.httpResponse.body;
  var operation = req.service.api.operations[req.operation];
  var output = operation.output;

  var hasEventOutput = operation.hasEventOutput;

  var payload = output.payload;
  if (payload) {
    var payloadMember = output.members[payload];
    if (payloadMember.isEventStream) {
      parser = new AWS.XML.Parser();
      resp.data[payload] = util.createEventStream(
        AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : resp.httpResponse.body,
        parser,
        payloadMember
      );
    } else if (payloadMember.type === 'structure') {
      parser = new AWS.XML.Parser();
      resp.data[payload] = parser.parse(body.toString(), payloadMember);
    } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
      resp.data[payload] = body;
    } else {
      resp.data[payload] = payloadMember.toType(body);
    }
  } else if (body.length > 0) {
    parser = new AWS.XML.Parser();
    var data = parser.parse(body.toString(), output);
    util.update(resp.data, data);
  }
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};

},{"../core":23,"../util":78,"./rest":53}],56:[function(require,module,exports){
var util = require('../util');

function QueryParamSerializer() {
}

QueryParamSerializer.prototype.serialize = function(params, shape, fn) {
  serializeStructure('', params, shape, fn);
};

function ucfirst(shape) {
  if (shape.isQueryName || shape.api.protocol !== 'ec2') {
    return shape.name;
  } else {
    return shape.name[0].toUpperCase() + shape.name.substr(1);
  }
}

function serializeStructure(prefix, struct, rules, fn) {
  util.each(rules.members, function(name, member) {
    var value = struct[name];
    if (value === null || value === undefined) return;

    var memberName = ucfirst(member);
    memberName = prefix ? prefix + '.' + memberName : memberName;
    serializeMember(memberName, value, member, fn);
  });
}

function serializeMap(name, map, rules, fn) {
  var i = 1;
  util.each(map, function (key, value) {
    var prefix = rules.flattened ? '.' : '.entry.';
    var position = prefix + (i++) + '.';
    var keyName = position + (rules.key.name || 'key');
    var valueName = position + (rules.value.name || 'value');
    serializeMember(name + keyName, key, rules.key, fn);
    serializeMember(name + valueName, value, rules.value, fn);
  });
}

function serializeList(name, list, rules, fn) {
  var memberRules = rules.member || {};

  if (list.length === 0) {
    fn.call(this, name, null);
    return;
  }

  util.arrayEach(list, function (v, n) {
    var suffix = '.' + (n + 1);
    if (rules.api.protocol === 'ec2') {
      // Do nothing for EC2
      suffix = suffix + ''; // make linter happy
    } else if (rules.flattened) {
      if (memberRules.name) {
        var parts = name.split('.');
        parts.pop();
        parts.push(ucfirst(memberRules));
        name = parts.join('.');
      }
    } else {
      suffix = '.' + (memberRules.name ? memberRules.name : 'member') + suffix;
    }
    serializeMember(name + suffix, v, memberRules, fn);
  });
}

function serializeMember(name, value, rules, fn) {
  if (value === null || value === undefined) return;
  if (rules.type === 'structure') {
    serializeStructure(name, value, rules, fn);
  } else if (rules.type === 'list') {
    serializeList(name, value, rules, fn);
  } else if (rules.type === 'map') {
    serializeMap(name, value, rules, fn);
  } else {
    fn(name, rules.toWireFormat(value).toString());
  }
}

/**
 * @api private
 */
module.exports = QueryParamSerializer;

},{"../util":78}],57:[function(require,module,exports){
module.exports = {
  //provide realtime clock for performance measurement
  now: function now() {
    if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
      return performance.now();
    }
    return Date.now();
  }
};

},{}],58:[function(require,module,exports){
var util = require('./util');
var regionConfig = require('./region_config_data.json');

function generateRegionPrefix(region) {
  if (!region) return null;

  var parts = region.split('-');
  if (parts.length < 3) return null;
  return parts.slice(0, parts.length - 2).join('-') + '-*';
}

function derivedKeys(service) {
  var region = service.config.region;
  var regionPrefix = generateRegionPrefix(region);
  var endpointPrefix = service.api.endpointPrefix;

  return [
    [region, endpointPrefix],
    [regionPrefix, endpointPrefix],
    [region, '*'],
    [regionPrefix, '*'],
    ['*', endpointPrefix],
    ['*', '*']
  ].map(function(item) {
    return item[0] && item[1] ? item.join('/') : null;
  });
}

function applyConfig(service, config) {
  util.each(config, function(key, value) {
    if (key === 'globalEndpoint') return;
    if (service.config[key] === undefined || service.config[key] === null) {
      service.config[key] = value;
    }
  });
}

function configureEndpoint(service) {
  var keys = derivedKeys(service);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!key) continue;

    if (Object.prototype.hasOwnProperty.call(regionConfig.rules, key)) {
      var config = regionConfig.rules[key];
      if (typeof config === 'string') {
        config = regionConfig.patterns[config];
      }

      // set dualstack endpoint
      if (service.config.useDualstack && util.isDualstackAvailable(service)) {
        config = util.copy(config);
        config.endpoint = '{service}.dualstack.{region}.amazonaws.com';
      }

      // set global endpoint
      service.isGlobalEndpoint = !!config.globalEndpoint;

      // signature version
      if (!config.signatureVersion) config.signatureVersion = 'v4';

      // merge config
      applyConfig(service, config);
      return;
    }
  }
}

function getEndpointSuffix(region) {
  var regionRegexes = {
    '^(us|eu|ap|sa|ca|me)\\-\\w+\\-\\d+$': 'amazonaws.com',
    '^cn\\-\\w+\\-\\d+$': 'amazonaws.com.cn',
    '^us\\-gov\\-\\w+\\-\\d+$': 'amazonaws.com',
    '^us\\-iso\\-\\w+\\-\\d+$': 'c2s.ic.gov',
    '^us\\-isob\\-\\w+\\-\\d+$': 'sc2s.sgov.gov'
  };
  var defaultSuffix = 'amazonaws.com';
  var regexes = Object.keys(regionRegexes);
  for (var i = 0; i < regexes.length; i++) {
    var regionPattern = RegExp(regexes[i]);
    var dnsSuffix = regionRegexes[regexes[i]];
    if (regionPattern.test(region)) return dnsSuffix;
  }
  return defaultSuffix;
}

/**
 * @api private
 */
module.exports = {
  configureEndpoint: configureEndpoint,
  getEndpointSuffix: getEndpointSuffix
};

},{"./region_config_data.json":59,"./util":78}],59:[function(require,module,exports){
module.exports={
  "rules": {
    "*/*": {
      "endpoint": "{service}.{region}.amazonaws.com"
    },
    "cn-*/*": {
      "endpoint": "{service}.{region}.amazonaws.com.cn"
    },
    "*/budgets": "globalSSL",
    "*/cloudfront": "globalSSL",
    "*/iam": "globalSSL",
    "*/sts": "globalSSL",
    "*/importexport": {
      "endpoint": "{service}.amazonaws.com",
      "signatureVersion": "v2",
      "globalEndpoint": true
    },
    "*/route53": {
      "endpoint": "https://{service}.amazonaws.com",
      "signatureVersion": "v3https",
      "globalEndpoint": true
    },
    "*/waf": "globalSSL",
    "us-gov-*/iam": "globalGovCloud",
    "us-gov-*/sts": {
      "endpoint": "{service}.{region}.amazonaws.com"
    },
    "us-gov-west-1/s3": "s3signature",
    "us-west-1/s3": "s3signature",
    "us-west-2/s3": "s3signature",
    "eu-west-1/s3": "s3signature",
    "ap-southeast-1/s3": "s3signature",
    "ap-southeast-2/s3": "s3signature",
    "ap-northeast-1/s3": "s3signature",
    "sa-east-1/s3": "s3signature",
    "us-east-1/s3": {
      "endpoint": "{service}.amazonaws.com",
      "signatureVersion": "s3"
    },
    "us-east-1/sdb": {
      "endpoint": "{service}.amazonaws.com",
      "signatureVersion": "v2"
    },
    "*/sdb": {
      "endpoint": "{service}.{region}.amazonaws.com",
      "signatureVersion": "v2"
    }
  },

  "patterns": {
    "globalSSL": {
      "endpoint": "https://{service}.amazonaws.com",
      "globalEndpoint": true
    },
    "globalGovCloud": {
      "endpoint": "{service}.us-gov.amazonaws.com"
    },
    "s3signature": {
      "endpoint": "{service}.{region}.amazonaws.com",
      "signatureVersion": "s3"
    }
  }
}

},{}],60:[function(require,module,exports){
(function (process){
var AWS = require('./core');
var AcceptorStateMachine = require('./state_machine');
var inherit = AWS.util.inherit;
var domain = AWS.util.domain;
var jmespath = require('jmespath');

/**
 * @api private
 */
var hardErrorStates = {success: 1, error: 1, complete: 1};

function isTerminalState(machine) {
  return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);
}

var fsm = new AcceptorStateMachine();
fsm.setupStates = function() {
  var transition = function(_, done) {
    var self = this;
    self._haltHandlersOnError = false;

    self.emit(self._asm.currentState, function(err) {
      if (err) {
        if (isTerminalState(self)) {
          if (domain && self.domain instanceof domain.Domain) {
            err.domainEmitter = self;
            err.domain = self.domain;
            err.domainThrown = false;
            self.domain.emit('error', err);
          } else {
            throw err;
          }
        } else {
          self.response.error = err;
          done(err);
        }
      } else {
        done(self.response.error);
      }
    });

  };

  this.addState('validate', 'build', 'error', transition);
  this.addState('build', 'afterBuild', 'restart', transition);
  this.addState('afterBuild', 'sign', 'restart', transition);
  this.addState('sign', 'send', 'retry', transition);
  this.addState('retry', 'afterRetry', 'afterRetry', transition);
  this.addState('afterRetry', 'sign', 'error', transition);
  this.addState('send', 'validateResponse', 'retry', transition);
  this.addState('validateResponse', 'extractData', 'extractError', transition);
  this.addState('extractError', 'extractData', 'retry', transition);
  this.addState('extractData', 'success', 'retry', transition);
  this.addState('restart', 'build', 'error', transition);
  this.addState('success', 'complete', 'complete', transition);
  this.addState('error', 'complete', 'complete', transition);
  this.addState('complete', null, null, transition);
};
fsm.setupStates();

/**
 * ## Asynchronous Requests
 *
 * All requests made through the SDK are asynchronous and use a
 * callback interface. Each service method that kicks off a request
 * returns an `AWS.Request` object that you can use to register
 * callbacks.
 *
 * For example, the following service method returns the request
 * object as "request", which can be used to register callbacks:
 *
 * ```javascript
 * // request is an AWS.Request object
 * var request = ec2.describeInstances();
 *
 * // register callbacks on request to retrieve response data
 * request.on('success', function(response) {
 *   console.log(response.data);
 * });
 * ```
 *
 * When a request is ready to be sent, the {send} method should
 * be called:
 *
 * ```javascript
 * request.send();
 * ```
 *
 * Since registered callbacks may or may not be idempotent, requests should only
 * be sent once. To perform the same operation multiple times, you will need to
 * create multiple request objects, each with its own registered callbacks.
 *
 * ## Removing Default Listeners for Events
 *
 * Request objects are built with default listeners for the various events,
 * depending on the service type. In some cases, you may want to remove
 * some built-in listeners to customize behaviour. Doing this requires
 * access to the built-in listener functions, which are exposed through
 * the {AWS.EventListeners.Core} namespace. For instance, you may
 * want to customize the HTTP handler used when sending a request. In this
 * case, you can remove the built-in listener associated with the 'send'
 * event, the {AWS.EventListeners.Core.SEND} listener and add your own.
 *
 * ## Multiple Callbacks and Chaining
 *
 * You can register multiple callbacks on any request object. The
 * callbacks can be registered for different events, or all for the
 * same event. In addition, you can chain callback registration, for
 * example:
 *
 * ```javascript
 * request.
 *   on('success', function(response) {
 *     console.log("Success!");
 *   }).
 *   on('error', function(error, response) {
 *     console.log("Error!");
 *   }).
 *   on('complete', function(response) {
 *     console.log("Always!");
 *   }).
 *   send();
 * ```
 *
 * The above example will print either "Success! Always!", or "Error! Always!",
 * depending on whether the request succeeded or not.
 *
 * @!attribute httpRequest
 *   @readonly
 *   @!group HTTP Properties
 *   @return [AWS.HttpRequest] the raw HTTP request object
 *     containing request headers and body information
 *     sent by the service.
 *
 * @!attribute startTime
 *   @readonly
 *   @!group Operation Properties
 *   @return [Date] the time that the request started
 *
 * @!group Request Building Events
 *
 * @!event validate(request)
 *   Triggered when a request is being validated. Listeners
 *   should throw an error if the request should not be sent.
 *   @param request [Request] the request object being sent
 *   @see AWS.EventListeners.Core.VALIDATE_CREDENTIALS
 *   @see AWS.EventListeners.Core.VALIDATE_REGION
 *   @example Ensuring that a certain parameter is set before sending a request
 *     var req = s3.putObject(params);
 *     req.on('validate', function() {
 *       if (!req.params.Body.match(/^Hello\s/)) {
 *         throw new Error('Body must start with "Hello "');
 *       }
 *     });
 *     req.send(function(err, data) { ... });
 *
 * @!event build(request)
 *   Triggered when the request payload is being built. Listeners
 *   should fill the necessary information to send the request
 *   over HTTP.
 *   @param (see AWS.Request~validate)
 *   @example Add a custom HTTP header to a request
 *     var req = s3.putObject(params);
 *     req.on('build', function() {
 *       req.httpRequest.headers['Custom-Header'] = 'value';
 *     });
 *     req.send(function(err, data) { ... });
 *
 * @!event sign(request)
 *   Triggered when the request is being signed. Listeners should
 *   add the correct authentication headers and/or adjust the body,
 *   depending on the authentication mechanism being used.
 *   @param (see AWS.Request~validate)
 *
 * @!group Request Sending Events
 *
 * @!event send(response)
 *   Triggered when the request is ready to be sent. Listeners
 *   should call the underlying transport layer to initiate
 *   the sending of the request.
 *   @param response [Response] the response object
 *   @context [Request] the request object that was sent
 *   @see AWS.EventListeners.Core.SEND
 *
 * @!event retry(response)
 *   Triggered when a request failed and might need to be retried or redirected.
 *   If the response is retryable, the listener should set the
 *   `response.error.retryable` property to `true`, and optionally set
 *   `response.error.retryDelay` to the millisecond delay for the next attempt.
 *   In the case of a redirect, `response.error.redirect` should be set to
 *   `true` with `retryDelay` set to an optional delay on the next request.
 *
 *   If a listener decides that a request should not be retried,
 *   it should set both `retryable` and `redirect` to false.
 *
 *   Note that a retryable error will be retried at most
 *   {AWS.Config.maxRetries} times (based on the service object's config).
 *   Similarly, a request that is redirected will only redirect at most
 *   {AWS.Config.maxRedirects} times.
 *
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @example Adding a custom retry for a 404 response
 *     request.on('retry', function(response) {
 *       // this resource is not yet available, wait 10 seconds to get it again
 *       if (response.httpResponse.statusCode === 404 && response.error) {
 *         response.error.retryable = true;   // retry this error
 *         response.error.retryDelay = 10000; // wait 10 seconds
 *       }
 *     });
 *
 * @!group Data Parsing Events
 *
 * @!event extractError(response)
 *   Triggered on all non-2xx requests so that listeners can extract
 *   error details from the response body. Listeners to this event
 *   should set the `response.error` property.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event extractData(response)
 *   Triggered in successful requests to allow listeners to
 *   de-serialize the response body into `response.data`.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!group Completion Events
 *
 * @!event success(response)
 *   Triggered when the request completed successfully.
 *   `response.data` will contain the response data and
 *   `response.error` will be null.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event error(error, response)
 *   Triggered when an error occurs at any point during the
 *   request. `response.error` will contain details about the error
 *   that occurred. `response.data` will be null.
 *   @param error [Error] the error object containing details about
 *     the error that occurred.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event complete(response)
 *   Triggered whenever a request cycle completes. `response.error`
 *   should be checked, since the request may have failed.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!group HTTP Events
 *
 * @!event httpHeaders(statusCode, headers, response, statusMessage)
 *   Triggered when headers are sent by the remote server
 *   @param statusCode [Integer] the HTTP response code
 *   @param headers [map<String,String>] the response headers
 *   @param (see AWS.Request~send)
 *   @param statusMessage [String] A status message corresponding to the HTTP
 *                                 response code
 *   @context (see AWS.Request~send)
 *
 * @!event httpData(chunk, response)
 *   Triggered when data is sent by the remote server
 *   @param chunk [Buffer] the buffer data containing the next data chunk
 *     from the server
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @see AWS.EventListeners.Core.HTTP_DATA
 *
 * @!event httpUploadProgress(progress, response)
 *   Triggered when the HTTP request has uploaded more data
 *   @param progress [map] An object containing the `loaded` and `total` bytes
 *     of the request.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @note This event will not be emitted in Node.js 0.8.x.
 *
 * @!event httpDownloadProgress(progress, response)
 *   Triggered when the HTTP request has downloaded more data
 *   @param progress [map] An object containing the `loaded` and `total` bytes
 *     of the request.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @note This event will not be emitted in Node.js 0.8.x.
 *
 * @!event httpError(error, response)
 *   Triggered when the HTTP request failed
 *   @param error [Error] the error object that was thrown
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event httpDone(response)
 *   Triggered when the server is finished sending data
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @see AWS.Response
 */
AWS.Request = inherit({

  /**
   * Creates a request for an operation on a given service with
   * a set of input parameters.
   *
   * @param service [AWS.Service] the service to perform the operation on
   * @param operation [String] the operation to perform on the service
   * @param params [Object] parameters to send to the operation.
   *   See the operation's documentation for the format of the
   *   parameters.
   */
  constructor: function Request(service, operation, params) {
    var endpoint = service.endpoint;
    var region = service.config.region;
    var customUserAgent = service.config.customUserAgent;

    // global endpoints sign as us-east-1
    if (service.isGlobalEndpoint) region = 'us-east-1';

    this.domain = domain && domain.active;
    this.service = service;
    this.operation = operation;
    this.params = params || {};
    this.httpRequest = new AWS.HttpRequest(endpoint, region);
    this.httpRequest.appendToUserAgent(customUserAgent);
    this.startTime = service.getSkewCorrectedDate();

    this.response = new AWS.Response(this);
    this._asm = new AcceptorStateMachine(fsm.states, 'validate');
    this._haltHandlersOnError = false;

    AWS.SequentialExecutor.call(this);
    this.emit = this.emitEvent;
  },

  /**
   * @!group Sending a Request
   */

  /**
   * @overload send(callback = null)
   *   Sends the request object.
   *
   *   @callback callback function(err, data)
   *     If a callback is supplied, it is called when a response is returned
   *     from the service.
   *     @context [AWS.Request] the request object being sent.
   *     @param err [Error] the error object returned from the request.
   *       Set to `null` if the request is successful.
   *     @param data [Object] the de-serialized data returned from
   *       the request. Set to `null` if a request error occurs.
   *   @example Sending a request with a callback
   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     request.send(function(err, data) { console.log(err, data); });
   *   @example Sending a request with no callback (using event handlers)
   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     request.on('complete', function(response) { ... }); // register a callback
   *     request.send();
   */
  send: function send(callback) {
    if (callback) {
      // append to user agent
      this.httpRequest.appendToUserAgent('callback');
      this.on('complete', function (resp) {
        callback.call(resp, resp.error, resp.data);
      });
    }
    this.runTo();

    return this.response;
  },

  /**
   * @!method  promise()
   *   Sends the request and returns a 'thenable' promise.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function(data)
   *     Called if the promise is fulfilled.
   *     @param data [Object] the de-serialized data returned from the request.
   *   @callback rejectedCallback function(error)
   *     Called if the promise is rejected.
   *     @param error [Error] the error object returned from the request.
   *   @return [Promise] A promise that represents the state of the request.
   *   @example Sending a request using promises.
   *     var request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     var result = request.promise();
   *     result.then(function(data) { ... }, function(error) { ... });
   */

  /**
   * @api private
   */
  build: function build(callback) {
    return this.runTo('send', callback);
  },

  /**
   * @api private
   */
  runTo: function runTo(state, done) {
    this._asm.runTo(state, done, this);
    return this;
  },

  /**
   * Aborts a request, emitting the error and complete events.
   *
   * @!macro nobrowser
   * @example Aborting a request after sending
   *   var params = {
   *     Bucket: 'bucket', Key: 'key',
   *     Body: Buffer.alloc(1024 * 1024 * 5) // 5MB payload
   *   };
   *   var request = s3.putObject(params);
   *   request.send(function (err, data) {
   *     if (err) console.log("Error:", err.code, err.message);
   *     else console.log(data);
   *   });
   *
   *   // abort request in 1 second
   *   setTimeout(request.abort.bind(request), 1000);
   *
   *   // prints "Error: RequestAbortedError Request aborted by user"
   * @return [AWS.Request] the same request object, for chaining.
   * @since v1.4.0
   */
  abort: function abort() {
    this.removeAllListeners('validateResponse');
    this.removeAllListeners('extractError');
    this.on('validateResponse', function addAbortedError(resp) {
      resp.error = AWS.util.error(new Error('Request aborted by user'), {
         code: 'RequestAbortedError', retryable: false
      });
    });

    if (this.httpRequest.stream && !this.httpRequest.stream.didCallback) { // abort HTTP stream
      this.httpRequest.stream.abort();
      if (this.httpRequest._abortCallback) {
         this.httpRequest._abortCallback();
      } else {
        this.removeAllListeners('send'); // haven't sent yet, so let's not
      }
    }

    return this;
  },

  /**
   * Iterates over each page of results given a pageable request, calling
   * the provided callback with each page of data. After all pages have been
   * retrieved, the callback is called with `null` data.
   *
   * @note This operation can generate multiple requests to a service.
   * @example Iterating over multiple pages of objects in an S3 bucket
   *   var pages = 1;
   *   s3.listObjects().eachPage(function(err, data) {
   *     if (err) return;
   *     console.log("Page", pages++);
   *     console.log(data);
   *   });
   * @example Iterating over multiple pages with an asynchronous callback
   *   s3.listObjects(params).eachPage(function(err, data, done) {
   *     doSomethingAsyncAndOrExpensive(function() {
   *       // The next page of results isn't fetched until done is called
   *       done();
   *     });
   *   });
   * @callback callback function(err, data, [doneCallback])
   *   Called with each page of resulting data from the request. If the
   *   optional `doneCallback` is provided in the function, it must be called
   *   when the callback is complete.
   *
   *   @param err [Error] an error object, if an error occurred.
   *   @param data [Object] a single page of response data. If there is no
   *     more data, this object will be `null`.
   *   @param doneCallback [Function] an optional done callback. If this
   *     argument is defined in the function declaration, it should be called
   *     when the next page is ready to be retrieved. This is useful for
   *     controlling serial pagination across asynchronous operations.
   *   @return [Boolean] if the callback returns `false`, pagination will
   *     stop.
   *
   * @see AWS.Request.eachItem
   * @see AWS.Response.nextPage
   * @since v1.4.0
   */
  eachPage: function eachPage(callback) {
    // Make all callbacks async-ish
    callback = AWS.util.fn.makeAsync(callback, 3);

    function wrappedCallback(response) {
      callback.call(response, response.error, response.data, function (result) {
        if (result === false) return;

        if (response.hasNextPage()) {
          response.nextPage().on('complete', wrappedCallback).send();
        } else {
          callback.call(response, null, null, AWS.util.fn.noop);
        }
      });
    }

    this.on('complete', wrappedCallback).send();
  },

  /**
   * Enumerates over individual items of a request, paging the responses if
   * necessary.
   *
   * @api experimental
   * @since v1.4.0
   */
  eachItem: function eachItem(callback) {
    var self = this;
    function wrappedCallback(err, data) {
      if (err) return callback(err, null);
      if (data === null) return callback(null, null);

      var config = self.service.paginationConfig(self.operation);
      var resultKey = config.resultKey;
      if (Array.isArray(resultKey)) resultKey = resultKey[0];
      var items = jmespath.search(data, resultKey);
      var continueIteration = true;
      AWS.util.arrayEach(items, function(item) {
        continueIteration = callback(null, item);
        if (continueIteration === false) {
          return AWS.util.abort;
        }
      });
      return continueIteration;
    }

    this.eachPage(wrappedCallback);
  },

  /**
   * @return [Boolean] whether the operation can return multiple pages of
   *   response data.
   * @see AWS.Response.eachPage
   * @since v1.4.0
   */
  isPageable: function isPageable() {
    return this.service.paginationConfig(this.operation) ? true : false;
  },

  /**
   * Sends the request and converts the request object into a readable stream
   * that can be read from or piped into a writable stream.
   *
   * @note The data read from a readable stream contains only
   *   the raw HTTP body contents.
   * @example Manually reading from a stream
   *   request.createReadStream().on('data', function(data) {
   *     console.log("Got data:", data.toString());
   *   });
   * @example Piping a request body into a file
   *   var out = fs.createWriteStream('/path/to/outfile.jpg');
   *   s3.service.getObject(params).createReadStream().pipe(out);
   * @return [Stream] the readable stream object that can be piped
   *   or read from (by registering 'data' event listeners).
   * @!macro nobrowser
   */
  createReadStream: function createReadStream() {
    var streams = AWS.util.stream;
    var req = this;
    var stream = null;

    if (AWS.HttpClient.streamsApiVersion === 2) {
      stream = new streams.PassThrough();
      process.nextTick(function() { req.send(); });
    } else {
      stream = new streams.Stream();
      stream.readable = true;

      stream.sent = false;
      stream.on('newListener', function(event) {
        if (!stream.sent && event === 'data') {
          stream.sent = true;
          process.nextTick(function() { req.send(); });
        }
      });
    }

    this.on('error', function(err) {
      stream.emit('error', err);
    });

    this.on('httpHeaders', function streamHeaders(statusCode, headers, resp) {
      if (statusCode < 300) {
        req.removeListener('httpData', AWS.EventListeners.Core.HTTP_DATA);
        req.removeListener('httpError', AWS.EventListeners.Core.HTTP_ERROR);
        req.on('httpError', function streamHttpError(error) {
          resp.error = error;
          resp.error.retryable = false;
        });

        var shouldCheckContentLength = false;
        var expectedLen;
        if (req.httpRequest.method !== 'HEAD') {
          expectedLen = parseInt(headers['content-length'], 10);
        }
        if (expectedLen !== undefined && !isNaN(expectedLen) && expectedLen >= 0) {
          shouldCheckContentLength = true;
          var receivedLen = 0;
        }

        var checkContentLengthAndEmit = function checkContentLengthAndEmit() {
          if (shouldCheckContentLength && receivedLen !== expectedLen) {
            stream.emit('error', AWS.util.error(
              new Error('Stream content length mismatch. Received ' +
                receivedLen + ' of ' + expectedLen + ' bytes.'),
              { code: 'StreamContentLengthMismatch' }
            ));
          } else if (AWS.HttpClient.streamsApiVersion === 2) {
            stream.end();
          } else {
            stream.emit('end');
          }
        };

        var httpStream = resp.httpResponse.createUnbufferedStream();

        if (AWS.HttpClient.streamsApiVersion === 2) {
          if (shouldCheckContentLength) {
            var lengthAccumulator = new streams.PassThrough();
            lengthAccumulator._write = function(chunk) {
              if (chunk && chunk.length) {
                receivedLen += chunk.length;
              }
              return streams.PassThrough.prototype._write.apply(this, arguments);
            };

            lengthAccumulator.on('end', checkContentLengthAndEmit);
            stream.on('error', function(err) {
              shouldCheckContentLength = false;
              httpStream.unpipe(lengthAccumulator);
              lengthAccumulator.emit('end');
              lengthAccumulator.end();
            });
            httpStream.pipe(lengthAccumulator).pipe(stream, { end: false });
          } else {
            httpStream.pipe(stream);
          }
        } else {

          if (shouldCheckContentLength) {
            httpStream.on('data', function(arg) {
              if (arg && arg.length) {
                receivedLen += arg.length;
              }
            });
          }

          httpStream.on('data', function(arg) {
            stream.emit('data', arg);
          });
          httpStream.on('end', checkContentLengthAndEmit);
        }

        httpStream.on('error', function(err) {
          shouldCheckContentLength = false;
          stream.emit('error', err);
        });
      }
    });

    return stream;
  },

  /**
   * @param [Array,Response] args This should be the response object,
   *   or an array of args to send to the event.
   * @api private
   */
  emitEvent: function emit(eventName, args, done) {
    if (typeof args === 'function') { done = args; args = null; }
    if (!done) done = function() { };
    if (!args) args = this.eventParameters(eventName, this.response);

    var origEmit = AWS.SequentialExecutor.prototype.emit;
    origEmit.call(this, eventName, args, function (err) {
      if (err) this.response.error = err;
      done.call(this, err);
    });
  },

  /**
   * @api private
   */
  eventParameters: function eventParameters(eventName) {
    switch (eventName) {
      case 'restart':
      case 'validate':
      case 'sign':
      case 'build':
      case 'afterValidate':
      case 'afterBuild':
        return [this];
      case 'error':
        return [this.response.error, this.response];
      default:
        return [this.response];
    }
  },

  /**
   * @api private
   */
  presign: function presign(expires, callback) {
    if (!callback && typeof expires === 'function') {
      callback = expires;
      expires = null;
    }
    return new AWS.Signers.Presign().sign(this.toGet(), expires, callback);
  },

  /**
   * @api private
   */
  isPresigned: function isPresigned() {
    return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, 'presigned-expires');
  },

  /**
   * @api private
   */
  toUnauthenticated: function toUnauthenticated() {
    this._unAuthenticated = true;
    this.removeListener('validate', AWS.EventListeners.Core.VALIDATE_CREDENTIALS);
    this.removeListener('sign', AWS.EventListeners.Core.SIGN);
    return this;
  },

  /**
   * @api private
   */
  toGet: function toGet() {
    if (this.service.api.protocol === 'query' ||
        this.service.api.protocol === 'ec2') {
      this.removeListener('build', this.buildAsGet);
      this.addListener('build', this.buildAsGet);
    }
    return this;
  },

  /**
   * @api private
   */
  buildAsGet: function buildAsGet(request) {
    request.httpRequest.method = 'GET';
    request.httpRequest.path = request.service.endpoint.path +
                               '?' + request.httpRequest.body;
    request.httpRequest.body = '';

    // don't need these headers on a GET request
    delete request.httpRequest.headers['Content-Length'];
    delete request.httpRequest.headers['Content-Type'];
  },

  /**
   * @api private
   */
  haltHandlersOnError: function haltHandlersOnError() {
    this._haltHandlersOnError = true;
  }
});

/**
 * @api private
 */
AWS.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.promise = function promise() {
    var self = this;
    // append to user agent
    this.httpRequest.appendToUserAgent('promise');
    return new PromiseDependency(function(resolve, reject) {
      self.on('complete', function(resp) {
        if (resp.error) {
          reject(resp.error);
        } else {
          // define $response property so that it is not enumberable
          // this prevents circular reference errors when stringifying the JSON object
          resolve(Object.defineProperty(
            resp.data || {},
            '$response',
            {value: resp}
          ));
        }
      });
      self.runTo();
    });
  };
};

/**
 * @api private
 */
AWS.Request.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.promise;
};

AWS.util.addPromises(AWS.Request);

AWS.util.mixin(AWS.Request, AWS.SequentialExecutor);

}).call(this,require('_process'))

},{"./core":23,"./state_machine":77,"_process":95,"jmespath":94}],61:[function(require,module,exports){
/**
 * Copyright 2012-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You
 * may not use this file except in compliance with the License. A copy of
 * the License is located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

var AWS = require('./core');
var inherit = AWS.util.inherit;
var jmespath = require('jmespath');

/**
 * @api private
 */
function CHECK_ACCEPTORS(resp) {
  var waiter = resp.request._waiter;
  var acceptors = waiter.config.acceptors;
  var acceptorMatched = false;
  var state = 'retry';

  acceptors.forEach(function(acceptor) {
    if (!acceptorMatched) {
      var matcher = waiter.matchers[acceptor.matcher];
      if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {
        acceptorMatched = true;
        state = acceptor.state;
      }
    }
  });

  if (!acceptorMatched && resp.error) state = 'failure';

  if (state === 'success') {
    waiter.setSuccess(resp);
  } else {
    waiter.setError(resp, state === 'retry');
  }
}

/**
 * @api private
 */
AWS.ResourceWaiter = inherit({
  /**
   * Waits for a given state on a service object
   * @param service [Service] the service object to wait on
   * @param state [String] the state (defined in waiter configuration) to wait
   *   for.
   * @example Create a waiter for running EC2 instances
   *   var ec2 = new AWS.EC2;
   *   var waiter = new AWS.ResourceWaiter(ec2, 'instanceRunning');
   */
  constructor: function constructor(service, state) {
    this.service = service;
    this.state = state;
    this.loadWaiterConfig(this.state);
  },

  service: null,

  state: null,

  config: null,

  matchers: {
    path: function(resp, expected, argument) {
      try {
        var result = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      return jmespath.strictDeepEqual(result,expected);
    },

    pathAll: function(resp, expected, argument) {
      try {
        var results = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      if (!Array.isArray(results)) results = [results];
      var numResults = results.length;
      if (!numResults) return false;
      for (var ind = 0 ; ind < numResults; ind++) {
        if (!jmespath.strictDeepEqual(results[ind], expected)) {
          return false;
        }
      }
      return true;
    },

    pathAny: function(resp, expected, argument) {
      try {
        var results = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      if (!Array.isArray(results)) results = [results];
      var numResults = results.length;
      for (var ind = 0 ; ind < numResults; ind++) {
        if (jmespath.strictDeepEqual(results[ind], expected)) {
          return true;
        }
      }
      return false;
    },

    status: function(resp, expected) {
      var statusCode = resp.httpResponse.statusCode;
      return (typeof statusCode === 'number') && (statusCode === expected);
    },

    error: function(resp, expected) {
      if (typeof expected === 'string' && resp.error) {
        return expected === resp.error.code;
      }
      // if expected is not string, can be boolean indicating presence of error
      return expected === !!resp.error;
    }
  },

  listeners: new AWS.SequentialExecutor().addNamedListeners(function(add) {
    add('RETRY_CHECK', 'retry', function(resp) {
      var waiter = resp.request._waiter;
      if (resp.error && resp.error.code === 'ResourceNotReady') {
        resp.error.retryDelay = (waiter.config.delay || 0) * 1000;
      }
    });

    add('CHECK_OUTPUT', 'extractData', CHECK_ACCEPTORS);

    add('CHECK_ERROR', 'extractError', CHECK_ACCEPTORS);
  }),

  /**
   * @return [AWS.Request]
   */
  wait: function wait(params, callback) {
    if (typeof params === 'function') {
      callback = params; params = undefined;
    }

    if (params && params.$waiter) {
      params = AWS.util.copy(params);
      if (typeof params.$waiter.delay === 'number') {
        this.config.delay = params.$waiter.delay;
      }
      if (typeof params.$waiter.maxAttempts === 'number') {
        this.config.maxAttempts = params.$waiter.maxAttempts;
      }
      delete params.$waiter;
    }

    var request = this.service.makeRequest(this.config.operation, params);
    request._waiter = this;
    request.response.maxRetries = this.config.maxAttempts;
    request.addListeners(this.listeners);

    if (callback) request.send(callback);
    return request;
  },

  setSuccess: function setSuccess(resp) {
    resp.error = null;
    resp.data = resp.data || {};
    resp.request.removeAllListeners('extractData');
  },

  setError: function setError(resp, retryable) {
    resp.data = null;
    resp.error = AWS.util.error(resp.error || new Error(), {
      code: 'ResourceNotReady',
      message: 'Resource is not in the state ' + this.state,
      retryable: retryable
    });
  },

  /**
   * Loads waiter configuration from API configuration
   *
   * @api private
   */
  loadWaiterConfig: function loadWaiterConfig(state) {
    if (!this.service.api.waiters[state]) {
      throw new AWS.util.error(new Error(), {
        code: 'StateNotFoundError',
        message: 'State ' + state + ' not found.'
      });
    }

    this.config = AWS.util.copy(this.service.api.waiters[state]);
  }
});

},{"./core":23,"jmespath":94}],62:[function(require,module,exports){
var AWS = require('./core');
var inherit = AWS.util.inherit;
var jmespath = require('jmespath');

/**
 * This class encapsulates the response information
 * from a service request operation sent through {AWS.Request}.
 * The response object has two main properties for getting information
 * back from a request:
 *
 * ## The `data` property
 *
 * The `response.data` property contains the serialized object data
 * retrieved from the service request. For instance, for an
 * Amazon DynamoDB `listTables` method call, the response data might
 * look like:
 *
 * ```
 * > resp.data
 * { TableNames:
 *    [ 'table1', 'table2', ... ] }
 * ```
 *
 * The `data` property can be null if an error occurs (see below).
 *
 * ## The `error` property
 *
 * In the event of a service error (or transfer error), the
 * `response.error` property will be filled with the given
 * error data in the form:
 *
 * ```
 * { code: 'SHORT_UNIQUE_ERROR_CODE',
 *   message: 'Some human readable error message' }
 * ```
 *
 * In the case of an error, the `data` property will be `null`.
 * Note that if you handle events that can be in a failure state,
 * you should always check whether `response.error` is set
 * before attempting to access the `response.data` property.
 *
 * @!attribute data
 *   @readonly
 *   @!group Data Properties
 *   @note Inside of a {AWS.Request~httpData} event, this
 *     property contains a single raw packet instead of the
 *     full de-serialized service response.
 *   @return [Object] the de-serialized response data
 *     from the service.
 *
 * @!attribute error
 *   An structure containing information about a service
 *   or networking error.
 *   @readonly
 *   @!group Data Properties
 *   @note This attribute is only filled if a service or
 *     networking error occurs.
 *   @return [Error]
 *     * code [String] a unique short code representing the
 *       error that was emitted.
 *     * message [String] a longer human readable error message
 *     * retryable [Boolean] whether the error message is
 *       retryable.
 *     * statusCode [Numeric] in the case of a request that reached the service,
 *       this value contains the response status code.
 *     * time [Date] the date time object when the error occurred.
 *     * hostname [String] set when a networking error occurs to easily
 *       identify the endpoint of the request.
 *     * region [String] set when a networking error occurs to easily
 *       identify the region of the request.
 *
 * @!attribute requestId
 *   @readonly
 *   @!group Data Properties
 *   @return [String] the unique request ID associated with the response.
 *     Log this value when debugging requests for AWS support.
 *
 * @!attribute retryCount
 *   @readonly
 *   @!group Operation Properties
 *   @return [Integer] the number of retries that were
 *     attempted before the request was completed.
 *
 * @!attribute redirectCount
 *   @readonly
 *   @!group Operation Properties
 *   @return [Integer] the number of redirects that were
 *     followed before the request was completed.
 *
 * @!attribute httpResponse
 *   @readonly
 *   @!group HTTP Properties
 *   @return [AWS.HttpResponse] the raw HTTP response object
 *     containing the response headers and body information
 *     from the server.
 *
 * @see AWS.Request
 */
AWS.Response = inherit({

  /**
   * @api private
   */
  constructor: function Response(request) {
    this.request = request;
    this.data = null;
    this.error = null;
    this.retryCount = 0;
    this.redirectCount = 0;
    this.httpResponse = new AWS.HttpResponse();
    if (request) {
      this.maxRetries = request.service.numRetries();
      this.maxRedirects = request.service.config.maxRedirects;
    }
  },

  /**
   * Creates a new request for the next page of response data, calling the
   * callback with the page data if a callback is provided.
   *
   * @callback callback function(err, data)
   *   Called when a page of data is returned from the next request.
   *
   *   @param err [Error] an error object, if an error occurred in the request
   *   @param data [Object] the next page of data, or null, if there are no
   *     more pages left.
   * @return [AWS.Request] the request object for the next page of data
   * @return [null] if no callback is provided and there are no pages left
   *   to retrieve.
   * @since v1.4.0
   */
  nextPage: function nextPage(callback) {
    var config;
    var service = this.request.service;
    var operation = this.request.operation;
    try {
      config = service.paginationConfig(operation, true);
    } catch (e) { this.error = e; }

    if (!this.hasNextPage()) {
      if (callback) callback(this.error, null);
      else if (this.error) throw this.error;
      return null;
    }

    var params = AWS.util.copy(this.request.params);
    if (!this.nextPageTokens) {
      return callback ? callback(null, null) : null;
    } else {
      var inputTokens = config.inputToken;
      if (typeof inputTokens === 'string') inputTokens = [inputTokens];
      for (var i = 0; i < inputTokens.length; i++) {
        params[inputTokens[i]] = this.nextPageTokens[i];
      }
      return service.makeRequest(this.request.operation, params, callback);
    }
  },

  /**
   * @return [Boolean] whether more pages of data can be returned by further
   *   requests
   * @since v1.4.0
   */
  hasNextPage: function hasNextPage() {
    this.cacheNextPageTokens();
    if (this.nextPageTokens) return true;
    if (this.nextPageTokens === undefined) return undefined;
    else return false;
  },

  /**
   * @api private
   */
  cacheNextPageTokens: function cacheNextPageTokens() {
    if (Object.prototype.hasOwnProperty.call(this, 'nextPageTokens')) return this.nextPageTokens;
    this.nextPageTokens = undefined;

    var config = this.request.service.paginationConfig(this.request.operation);
    if (!config) return this.nextPageTokens;

    this.nextPageTokens = null;
    if (config.moreResults) {
      if (!jmespath.search(this.data, config.moreResults)) {
        return this.nextPageTokens;
      }
    }

    var exprs = config.outputToken;
    if (typeof exprs === 'string') exprs = [exprs];
    AWS.util.arrayEach.call(this, exprs, function (expr) {
      var output = jmespath.search(this.data, expr);
      if (output) {
        this.nextPageTokens = this.nextPageTokens || [];
        this.nextPageTokens.push(output);
      }
    });

    return this.nextPageTokens;
  }

});

},{"./core":23,"jmespath":94}],63:[function(require,module,exports){
var AWS = require('../core');
var byteLength = AWS.util.string.byteLength;
var Buffer = AWS.util.Buffer;

/**
 * The managed uploader allows for easy and efficient uploading of buffers,
 * blobs, or streams, using a configurable amount of concurrency to perform
 * multipart uploads where possible. This abstraction also enables uploading
 * streams of unknown size due to the use of multipart uploads.
 *
 * To construct a managed upload object, see the {constructor} function.
 *
 * ## Tracking upload progress
 *
 * The managed upload object can also track progress by attaching an
 * 'httpUploadProgress' listener to the upload manager. This event is similar
 * to {AWS.Request~httpUploadProgress} but groups all concurrent upload progress
 * into a single event. See {AWS.S3.ManagedUpload~httpUploadProgress} for more
 * information.
 *
 * ## Handling Multipart Cleanup
 *
 * By default, this class will automatically clean up any multipart uploads
 * when an individual part upload fails. This behavior can be disabled in order
 * to manually handle failures by setting the `leavePartsOnError` configuration
 * option to `true` when initializing the upload object.
 *
 * @!event httpUploadProgress(progress)
 *   Triggered when the uploader has uploaded more data.
 *   @note The `total` property may not be set if the stream being uploaded has
 *     not yet finished chunking. In this case the `total` will be undefined
 *     until the total stream size is known.
 *   @note This event will not be emitted in Node.js 0.8.x.
 *   @param progress [map] An object containing the `loaded` and `total` bytes
 *     of the request and the `key` of the S3 object. Note that `total` may be undefined until the payload
 *     size is known.
 *   @context (see AWS.Request~send)
 */
AWS.S3.ManagedUpload = AWS.util.inherit({
  /**
   * Creates a managed upload object with a set of configuration options.
   *
   * @note A "Body" parameter is required to be set prior to calling {send}.
   * @note In Node.js, sending "Body" as {https://nodejs.org/dist/latest/docs/api/stream.html#stream_object_mode object-mode stream}
   *   may result in upload hangs. Using buffer stream is preferable.
   * @option options params [map] a map of parameters to pass to the upload
   *   requests. The "Body" parameter is required to be specified either on
   *   the service or in the params option.
   * @note ContentMD5 should not be provided when using the managed upload object.
   *   Instead, setting "computeChecksums" to true will enable automatic ContentMD5 generation
   *   by the managed upload object.
   * @option options queueSize [Number] (4) the size of the concurrent queue
   *   manager to upload parts in parallel. Set to 1 for synchronous uploading
   *   of parts. Note that the uploader will buffer at most queueSize * partSize
   *   bytes into memory at any given time.
   * @option options partSize [Number] (5mb) the size in bytes for each
   *   individual part to be uploaded. Adjust the part size to ensure the number
   *   of parts does not exceed {maxTotalParts}. See {minPartSize} for the
   *   minimum allowed part size.
   * @option options leavePartsOnError [Boolean] (false) whether to abort the
   *   multipart upload if an error occurs. Set to true if you want to handle
   *   failures manually.
   * @option options service [AWS.S3] an optional S3 service object to use for
   *   requests. This object might have bound parameters used by the uploader.
   * @option options tags [Array<map>] The tags to apply to the uploaded object.
   *   Each tag should have a `Key` and `Value` keys.
   * @example Creating a default uploader for a stream object
   *   var upload = new AWS.S3.ManagedUpload({
   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}
   *   });
   * @example Creating an uploader with concurrency of 1 and partSize of 10mb
   *   var upload = new AWS.S3.ManagedUpload({
   *     partSize: 10 * 1024 * 1024, queueSize: 1,
   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}
   *   });
   * @example Creating an uploader with tags
   *   var upload = new AWS.S3.ManagedUpload({
   *     params: {Bucket: 'bucket', Key: 'key', Body: stream},
   *     tags: [{Key: 'tag1', Value: 'value1'}, {Key: 'tag2', Value: 'value2'}]
   *   });
   * @see send
   */
  constructor: function ManagedUpload(options) {
    var self = this;
    AWS.SequentialExecutor.call(self);
    self.body = null;
    self.sliceFn = null;
    self.callback = null;
    self.parts = {};
    self.completeInfo = [];
    self.fillQueue = function() {
      self.callback(new Error('Unsupported body payload ' + typeof self.body));
    };

    self.configure(options);
  },

  /**
   * @api private
   */
  configure: function configure(options) {
    options = options || {};
    this.partSize = this.minPartSize;

    if (options.queueSize) this.queueSize = options.queueSize;
    if (options.partSize) this.partSize = options.partSize;
    if (options.leavePartsOnError) this.leavePartsOnError = true;
    if (options.tags) {
      if (!Array.isArray(options.tags)) {
        throw new Error('Tags must be specified as an array; ' +
          typeof options.tags + ' provided.');
      }
      this.tags = options.tags;
    }

    if (this.partSize < this.minPartSize) {
      throw new Error('partSize must be greater than ' +
                      this.minPartSize);
    }

    this.service = options.service;
    this.bindServiceObject(options.params);
    this.validateBody();
    this.adjustTotalBytes();
  },

  /**
   * @api private
   */
  leavePartsOnError: false,

  /**
   * @api private
   */
  queueSize: 4,

  /**
   * @api private
   */
  partSize: null,

  /**
   * @readonly
   * @return [Number] the minimum number of bytes for an individual part
   *   upload.
   */
  minPartSize: 1024 * 1024 * 5,

  /**
   * @readonly
   * @return [Number] the maximum allowed number of parts in a multipart upload.
   */
  maxTotalParts: 10000,

  /**
   * Initiates the managed upload for the payload.
   *
   * @callback callback function(err, data)
   *   @param err [Error] an error or null if no error occurred.
   *   @param data [map] The response data from the successful upload:
   *     * `Location` (String) the URL of the uploaded object
   *     * `ETag` (String) the ETag of the uploaded object
   *     * `Bucket` (String) the bucket to which the object was uploaded
   *     * `Key` (String) the key to which the object was uploaded
   * @example Sending a managed upload object
   *   var params = {Bucket: 'bucket', Key: 'key', Body: stream};
   *   var upload = new AWS.S3.ManagedUpload({params: params});
   *   upload.send(function(err, data) {
   *     console.log(err, data);
   *   });
   */
  send: function(callback) {
    var self = this;
    self.failed = false;
    self.callback = callback || function(err) { if (err) throw err; };

    var runFill = true;
    if (self.sliceFn) {
      self.fillQueue = self.fillBuffer;
    } else if (AWS.util.isNode()) {
      var Stream = AWS.util.stream.Stream;
      if (self.body instanceof Stream) {
        runFill = false;
        self.fillQueue = self.fillStream;
        self.partBuffers = [];
        self.body.
          on('error', function(err) { self.cleanup(err); }).
          on('readable', function() { self.fillQueue(); }).
          on('end', function() {
            self.isDoneChunking = true;
            self.numParts = self.totalPartNumbers;
            self.fillQueue.call(self);

            if (self.isDoneChunking && self.totalPartNumbers >= 1 && self.doneParts === self.numParts) {
              self.finishMultiPart();
            }
          });
      }
    }

    if (runFill) self.fillQueue.call(self);
  },

  /**
   * @!method  promise()
   *   Returns a 'thenable' promise.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function(data)
   *     Called if the promise is fulfilled.
   *     @param data [map] The response data from the successful upload:
   *       `Location` (String) the URL of the uploaded object
   *       `ETag` (String) the ETag of the uploaded object
   *       `Bucket` (String) the bucket to which the object was uploaded
   *       `Key` (String) the key to which the object was uploaded
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] an error or null if no error occurred.
   *   @return [Promise] A promise that represents the state of the upload request.
   *   @example Sending an upload request using promises.
   *     var upload = s3.upload({Bucket: 'bucket', Key: 'key', Body: stream});
   *     var promise = upload.promise();
   *     promise.then(function(data) { ... }, function(err) { ... });
   */

  /**
   * Aborts a managed upload, including all concurrent upload requests.
   * @note By default, calling this function will cleanup a multipart upload
   *   if one was created. To leave the multipart upload around after aborting
   *   a request, configure `leavePartsOnError` to `true` in the {constructor}.
   * @note Calling {abort} in the browser environment will not abort any requests
   *   that are already in flight. If a multipart upload was created, any parts
   *   not yet uploaded will not be sent, and the multipart upload will be cleaned up.
   * @example Aborting an upload
   *   var params = {
   *     Bucket: 'bucket', Key: 'key',
   *     Body: Buffer.alloc(1024 * 1024 * 25) // 25MB payload
   *   };
   *   var upload = s3.upload(params);
   *   upload.send(function (err, data) {
   *     if (err) console.log("Error:", err.code, err.message);
   *     else console.log(data);
   *   });
   *
   *   // abort request in 1 second
   *   setTimeout(upload.abort.bind(upload), 1000);
   */
  abort: function() {
    var self = this;
    //abort putObject request
    if (self.isDoneChunking === true && self.totalPartNumbers === 1 && self.singlePart) {
      self.singlePart.abort();
    } else {
      self.cleanup(AWS.util.error(new Error('Request aborted by user'), {
        code: 'RequestAbortedError', retryable: false
      }));
    }
  },

  /**
   * @api private
   */
  validateBody: function validateBody() {
    var self = this;
    self.body = self.service.config.params.Body;
    if (typeof self.body === 'string') {
      self.body = AWS.util.buffer.toBuffer(self.body);
    } else if (!self.body) {
      throw new Error('params.Body is required');
    }
    self.sliceFn = AWS.util.arraySliceFn(self.body);
  },

  /**
   * @api private
   */
  bindServiceObject: function bindServiceObject(params) {
    params = params || {};
    var self = this;
    // bind parameters to new service object
    if (!self.service) {
      self.service = new AWS.S3({params: params});
    } else {
      var service = self.service;
      var config = AWS.util.copy(service.config);
      config.signatureVersion = service.getSignatureVersion();
      self.service = new service.constructor.__super__(config);
      self.service.config.params =
        AWS.util.merge(self.service.config.params || {}, params);
    }
  },

  /**
   * @api private
   */
  adjustTotalBytes: function adjustTotalBytes() {
    var self = this;
    try { // try to get totalBytes
      self.totalBytes = byteLength(self.body);
    } catch (e) { }

    // try to adjust partSize if we know payload length
    if (self.totalBytes) {
      var newPartSize = Math.ceil(self.totalBytes / self.maxTotalParts);
      if (newPartSize > self.partSize) self.partSize = newPartSize;
    } else {
      self.totalBytes = undefined;
    }
  },

  /**
   * @api private
   */
  isDoneChunking: false,

  /**
   * @api private
   */
  partPos: 0,

  /**
   * @api private
   */
  totalChunkedBytes: 0,

  /**
   * @api private
   */
  totalUploadedBytes: 0,

  /**
   * @api private
   */
  totalBytes: undefined,

  /**
   * @api private
   */
  numParts: 0,

  /**
   * @api private
   */
  totalPartNumbers: 0,

  /**
   * @api private
   */
  activeParts: 0,

  /**
   * @api private
   */
  doneParts: 0,

  /**
   * @api private
   */
  parts: null,

  /**
   * @api private
   */
  completeInfo: null,

  /**
   * @api private
   */
  failed: false,

  /**
   * @api private
   */
  multipartReq: null,

  /**
   * @api private
   */
  partBuffers: null,

  /**
   * @api private
   */
  partBufferLength: 0,

  /**
   * @api private
   */
  fillBuffer: function fillBuffer() {
    var self = this;
    var bodyLen = byteLength(self.body);

    if (bodyLen === 0) {
      self.isDoneChunking = true;
      self.numParts = 1;
      self.nextChunk(self.body);
      return;
    }

    while (self.activeParts < self.queueSize && self.partPos < bodyLen) {
      var endPos = Math.min(self.partPos + self.partSize, bodyLen);
      var buf = self.sliceFn.call(self.body, self.partPos, endPos);
      self.partPos += self.partSize;

      if (byteLength(buf) < self.partSize || self.partPos === bodyLen) {
        self.isDoneChunking = true;
        self.numParts = self.totalPartNumbers + 1;
      }
      self.nextChunk(buf);
    }
  },

  /**
   * @api private
   */
  fillStream: function fillStream() {
    var self = this;
    if (self.activeParts >= self.queueSize) return;

    var buf = self.body.read(self.partSize - self.partBufferLength) ||
              self.body.read();
    if (buf) {
      self.partBuffers.push(buf);
      self.partBufferLength += buf.length;
      self.totalChunkedBytes += buf.length;
    }

    if (self.partBufferLength >= self.partSize) {
      // if we have single buffer we avoid copyfull concat
      var pbuf = self.partBuffers.length === 1 ?
        self.partBuffers[0] : Buffer.concat(self.partBuffers);
      self.partBuffers = [];
      self.partBufferLength = 0;

      // if we have more than partSize, push the rest back on the queue
      if (pbuf.length > self.partSize) {
        var rest = pbuf.slice(self.partSize);
        self.partBuffers.push(rest);
        self.partBufferLength += rest.length;
        pbuf = pbuf.slice(0, self.partSize);
      }

      self.nextChunk(pbuf);
    }

    if (self.isDoneChunking && !self.isDoneSending) {
      // if we have single buffer we avoid copyfull concat
      pbuf = self.partBuffers.length === 1 ?
          self.partBuffers[0] : Buffer.concat(self.partBuffers);
      self.partBuffers = [];
      self.partBufferLength = 0;
      self.totalBytes = self.totalChunkedBytes;
      self.isDoneSending = true;

      if (self.numParts === 0 || pbuf.length > 0) {
        self.numParts++;
        self.nextChunk(pbuf);
      }
    }

    self.body.read(0);
  },

  /**
   * @api private
   */
  nextChunk: function nextChunk(chunk) {
    var self = this;
    if (self.failed) return null;

    var partNumber = ++self.totalPartNumbers;
    if (self.isDoneChunking && partNumber === 1) {
      var params = {Body: chunk};
      if (this.tags) {
        params.Tagging = this.getTaggingHeader();
      }
      var req = self.service.putObject(params);
      req._managedUpload = self;
      req.on('httpUploadProgress', self.progress).send(self.finishSinglePart);
      self.singlePart = req; //save the single part request
      return null;
    } else if (self.service.config.params.ContentMD5) {
      var err = AWS.util.error(new Error('The Content-MD5 you specified is invalid for multi-part uploads.'), {
        code: 'InvalidDigest', retryable: false
      });

      self.cleanup(err);
      return null;
    }

    if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) {
      return null; // Already uploaded this part.
    }

    self.activeParts++;
    if (!self.service.config.params.UploadId) {

      if (!self.multipartReq) { // create multipart
        self.multipartReq = self.service.createMultipartUpload();
        self.multipartReq.on('success', function(resp) {
          self.service.config.params.UploadId = resp.data.UploadId;
          self.multipartReq = null;
        });
        self.queueChunks(chunk, partNumber);
        self.multipartReq.on('error', function(err) {
          self.cleanup(err);
        });
        self.multipartReq.send();
      } else {
        self.queueChunks(chunk, partNumber);
      }
    } else { // multipart is created, just send
      self.uploadPart(chunk, partNumber);
    }
  },

  /**
   * @api private
   */
  getTaggingHeader: function getTaggingHeader() {
    var kvPairStrings = [];
    for (var i = 0; i < this.tags.length; i++) {
      kvPairStrings.push(AWS.util.uriEscape(this.tags[i].Key) + '=' +
        AWS.util.uriEscape(this.tags[i].Value));
    }

    return kvPairStrings.join('&');
  },

  /**
   * @api private
   */
  uploadPart: function uploadPart(chunk, partNumber) {
    var self = this;

    var partParams = {
      Body: chunk,
      ContentLength: AWS.util.string.byteLength(chunk),
      PartNumber: partNumber
    };

    var partInfo = {ETag: null, PartNumber: partNumber};
    self.completeInfo[partNumber] = partInfo;

    var req = self.service.uploadPart(partParams);
    self.parts[partNumber] = req;
    req._lastUploadedBytes = 0;
    req._managedUpload = self;
    req.on('httpUploadProgress', self.progress);
    req.send(function(err, data) {
      delete self.parts[partParams.PartNumber];
      self.activeParts--;

      if (!err && (!data || !data.ETag)) {
        var message = 'No access to ETag property on response.';
        if (AWS.util.isBrowser()) {
          message += ' Check CORS configuration to expose ETag header.';
        }

        err = AWS.util.error(new Error(message), {
          code: 'ETagMissing', retryable: false
        });
      }
      if (err) return self.cleanup(err);
      //prevent sending part being returned twice (https://github.com/aws/aws-sdk-js/issues/2304)
      if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) return null;
      partInfo.ETag = data.ETag;
      self.doneParts++;
      if (self.isDoneChunking && self.doneParts === self.numParts) {
        self.finishMultiPart();
      } else {
        self.fillQueue.call(self);
      }
    });
  },

  /**
   * @api private
   */
  queueChunks: function queueChunks(chunk, partNumber) {
    var self = this;
    self.multipartReq.on('success', function() {
      self.uploadPart(chunk, partNumber);
    });
  },

  /**
   * @api private
   */
  cleanup: function cleanup(err) {
    var self = this;
    if (self.failed) return;

    // clean up stream
    if (typeof self.body.removeAllListeners === 'function' &&
        typeof self.body.resume === 'function') {
      self.body.removeAllListeners('readable');
      self.body.removeAllListeners('end');
      self.body.resume();
    }

    // cleanup multipartReq listeners
    if (self.multipartReq) {
      self.multipartReq.removeAllListeners('success');
      self.multipartReq.removeAllListeners('error');
      self.multipartReq.removeAllListeners('complete');
      delete self.multipartReq;
    }

    if (self.service.config.params.UploadId && !self.leavePartsOnError) {
      self.service.abortMultipartUpload().send();
    } else if (self.leavePartsOnError) {
      self.isDoneChunking = false;
    }

    AWS.util.each(self.parts, function(partNumber, part) {
      part.removeAllListeners('complete');
      part.abort();
    });

    self.activeParts = 0;
    self.partPos = 0;
    self.numParts = 0;
    self.totalPartNumbers = 0;
    self.parts = {};
    self.failed = true;
    self.callback(err);
  },

  /**
   * @api private
   */
  finishMultiPart: function finishMultiPart() {
    var self = this;
    var completeParams = { MultipartUpload: { Parts: self.completeInfo.slice(1) } };
    self.service.completeMultipartUpload(completeParams, function(err, data) {
      if (err) {
        return self.cleanup(err);
      }

      if (data && typeof data.Location === 'string') {
        data.Location = data.Location.replace(/%2F/g, '/');
      }

      if (Array.isArray(self.tags)) {
        for (var i = 0; i < self.tags.length; i++) {
          self.tags[i].Value = String(self.tags[i].Value);
        }
        self.service.putObjectTagging(
          {Tagging: {TagSet: self.tags}},
          function(e, d) {
            if (e) {
              self.callback(e);
            } else {
              self.callback(e, data);
            }
          }
        );
      } else {
        self.callback(err, data);
      }
    });
  },

  /**
   * @api private
   */
  finishSinglePart: function finishSinglePart(err, data) {
    var upload = this.request._managedUpload;
    var httpReq = this.request.httpRequest;
    var endpoint = httpReq.endpoint;
    if (err) return upload.callback(err);
    data.Location =
      [endpoint.protocol, '//', endpoint.host, httpReq.path].join('');
    data.key = this.request.params.Key; // will stay undocumented
    data.Key = this.request.params.Key;
    data.Bucket = this.request.params.Bucket;
    upload.callback(err, data);
  },

  /**
   * @api private
   */
  progress: function progress(info) {
    var upload = this._managedUpload;
    if (this.operation === 'putObject') {
      info.part = 1;
      info.key = this.params.Key;
    } else {
      upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;
      this._lastUploadedBytes = info.loaded;
      info = {
        loaded: upload.totalUploadedBytes,
        total: upload.totalBytes,
        part: this.params.PartNumber,
        key: this.params.Key
      };
    }
    upload.emit('httpUploadProgress', [info]);
  }
});

AWS.util.mixin(AWS.S3.ManagedUpload, AWS.SequentialExecutor);

/**
 * @api private
 */
AWS.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.promise = AWS.util.promisifyMethod('send', PromiseDependency);
};

/**
 * @api private
 */
AWS.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.promise;
};

AWS.util.addPromises(AWS.S3.ManagedUpload);

/**
 * @api private
 */
module.exports = AWS.S3.ManagedUpload;

},{"../core":23}],64:[function(require,module,exports){
var AWS = require('./core');

/**
 * @api private
 * @!method on(eventName, callback)
 *   Registers an event listener callback for the event given by `eventName`.
 *   Parameters passed to the callback function depend on the individual event
 *   being triggered. See the event documentation for those parameters.
 *
 *   @param eventName [String] the event name to register the listener for
 *   @param callback [Function] the listener callback function
 *   @param toHead [Boolean] attach the listener callback to the head of callback array if set to true.
 *     Default to be false.
 *   @return [AWS.SequentialExecutor] the same object for chaining
 */
AWS.SequentialExecutor = AWS.util.inherit({

  constructor: function SequentialExecutor() {
    this._events = {};
  },

  /**
   * @api private
   */
  listeners: function listeners(eventName) {
    return this._events[eventName] ? this._events[eventName].slice(0) : [];
  },

  on: function on(eventName, listener, toHead) {
    if (this._events[eventName]) {
      toHead ?
        this._events[eventName].unshift(listener) :
        this._events[eventName].push(listener);
    } else {
      this._events[eventName] = [listener];
    }
    return this;
  },

  onAsync: function onAsync(eventName, listener, toHead) {
    listener._isAsync = true;
    return this.on(eventName, listener, toHead);
  },

  removeListener: function removeListener(eventName, listener) {
    var listeners = this._events[eventName];
    if (listeners) {
      var length = listeners.length;
      var position = -1;
      for (var i = 0; i < length; ++i) {
        if (listeners[i] === listener) {
          position = i;
        }
      }
      if (position > -1) {
        listeners.splice(position, 1);
      }
    }
    return this;
  },

  removeAllListeners: function removeAllListeners(eventName) {
    if (eventName) {
      delete this._events[eventName];
    } else {
      this._events = {};
    }
    return this;
  },

  /**
   * @api private
   */
  emit: function emit(eventName, eventArgs, doneCallback) {
    if (!doneCallback) doneCallback = function() { };
    var listeners = this.listeners(eventName);
    var count = listeners.length;
    this.callListeners(listeners, eventArgs, doneCallback);
    return count > 0;
  },

  /**
   * @api private
   */
  callListeners: function callListeners(listeners, args, doneCallback, prevError) {
    var self = this;
    var error = prevError || null;

    function callNextListener(err) {
      if (err) {
        error = AWS.util.error(error || new Error(), err);
        if (self._haltHandlersOnError) {
          return doneCallback.call(self, error);
        }
      }
      self.callListeners(listeners, args, doneCallback, error);
    }

    while (listeners.length > 0) {
      var listener = listeners.shift();
      if (listener._isAsync) { // asynchronous listener
        listener.apply(self, args.concat([callNextListener]));
        return; // stop here, callNextListener will continue
      } else { // synchronous listener
        try {
          listener.apply(self, args);
        } catch (err) {
          error = AWS.util.error(error || new Error(), err);
        }
        if (error && self._haltHandlersOnError) {
          doneCallback.call(self, error);
          return;
        }
      }
    }
    doneCallback.call(self, error);
  },

  /**
   * Adds or copies a set of listeners from another list of
   * listeners or SequentialExecutor object.
   *
   * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]
   *   a list of events and callbacks, or an event emitter object
   *   containing listeners to add to this emitter object.
   * @return [AWS.SequentialExecutor] the emitter object, for chaining.
   * @example Adding listeners from a map of listeners
   *   emitter.addListeners({
   *     event1: [function() { ... }, function() { ... }],
   *     event2: [function() { ... }]
   *   });
   *   emitter.emit('event1'); // emitter has event1
   *   emitter.emit('event2'); // emitter has event2
   * @example Adding listeners from another emitter object
   *   var emitter1 = new AWS.SequentialExecutor();
   *   emitter1.on('event1', function() { ... });
   *   emitter1.on('event2', function() { ... });
   *   var emitter2 = new AWS.SequentialExecutor();
   *   emitter2.addListeners(emitter1);
   *   emitter2.emit('event1'); // emitter2 has event1
   *   emitter2.emit('event2'); // emitter2 has event2
   */
  addListeners: function addListeners(listeners) {
    var self = this;

    // extract listeners if parameter is an SequentialExecutor object
    if (listeners._events) listeners = listeners._events;

    AWS.util.each(listeners, function(event, callbacks) {
      if (typeof callbacks === 'function') callbacks = [callbacks];
      AWS.util.arrayEach(callbacks, function(callback) {
        self.on(event, callback);
      });
    });

    return self;
  },

  /**
   * Registers an event with {on} and saves the callback handle function
   * as a property on the emitter object using a given `name`.
   *
   * @param name [String] the property name to set on this object containing
   *   the callback function handle so that the listener can be removed in
   *   the future.
   * @param (see on)
   * @return (see on)
   * @example Adding a named listener DATA_CALLBACK
   *   var listener = function() { doSomething(); };
   *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);
   *
   *   // the following prints: true
   *   console.log(emitter.DATA_CALLBACK == listener);
   */
  addNamedListener: function addNamedListener(name, eventName, callback, toHead) {
    this[name] = callback;
    this.addListener(eventName, callback, toHead);
    return this;
  },

  /**
   * @api private
   */
  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback, toHead) {
    callback._isAsync = true;
    return this.addNamedListener(name, eventName, callback, toHead);
  },

  /**
   * Helper method to add a set of named listeners using
   * {addNamedListener}. The callback contains a parameter
   * with a handle to the `addNamedListener` method.
   *
   * @callback callback function(add)
   *   The callback function is called immediately in order to provide
   *   the `add` function to the block. This simplifies the addition of
   *   a large group of named listeners.
   *   @param add [Function] the {addNamedListener} function to call
   *     when registering listeners.
   * @example Adding a set of named listeners
   *   emitter.addNamedListeners(function(add) {
   *     add('DATA_CALLBACK', 'data', function() { ... });
   *     add('OTHER', 'otherEvent', function() { ... });
   *     add('LAST', 'lastEvent', function() { ... });
   *   });
   *
   *   // these properties are now set:
   *   emitter.DATA_CALLBACK;
   *   emitter.OTHER;
   *   emitter.LAST;
   */
  addNamedListeners: function addNamedListeners(callback) {
    var self = this;
    callback(
      function() {
        self.addNamedListener.apply(self, arguments);
      },
      function() {
        self.addNamedAsyncListener.apply(self, arguments);
      }
    );
    return this;
  }
});

/**
 * {on} is the prefered method.
 * @api private
 */
AWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;

/**
 * @api private
 */
module.exports = AWS.SequentialExecutor;

},{"./core":23}],65:[function(require,module,exports){
(function (process){
var AWS = require('./core');
var Api = require('./model/api');
var regionConfig = require('./region_config');

var inherit = AWS.util.inherit;
var clientCount = 0;

/**
 * The service class representing an AWS service.
 *
 * @class_abstract This class is an abstract class.
 *
 * @!attribute apiVersions
 *   @return [Array<String>] the list of API versions supported by this service.
 *   @readonly
 */
AWS.Service = inherit({
  /**
   * Create a new service object with a configuration object
   *
   * @param config [map] a map of configuration options
   */
  constructor: function Service(config) {
    if (!this.loadServiceClass) {
      throw AWS.util.error(new Error(),
        'Service must be constructed with `new\' operator');
    }
    var ServiceClass = this.loadServiceClass(config || {});
    if (ServiceClass) {
      var originalConfig = AWS.util.copy(config);
      var svc = new ServiceClass(config);
      Object.defineProperty(svc, '_originalConfig', {
        get: function() { return originalConfig; },
        enumerable: false,
        configurable: true
      });
      svc._clientId = ++clientCount;
      return svc;
    }
    this.initialize(config);
  },

  /**
   * @api private
   */
  initialize: function initialize(config) {
    var svcConfig = AWS.config[this.serviceIdentifier];
    this.config = new AWS.Config(AWS.config);
    if (svcConfig) this.config.update(svcConfig, true);
    if (config) this.config.update(config, true);

    this.validateService();
    if (!this.config.endpoint) regionConfig.configureEndpoint(this);

    this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);
    this.setEndpoint(this.config.endpoint);
    //enable attaching listeners to service client
    AWS.SequentialExecutor.call(this);
    AWS.Service.addDefaultMonitoringListeners(this);
    if ((this.config.clientSideMonitoring || AWS.Service._clientSideMonitoring) && this.publisher) {
      var publisher = this.publisher;
      this.addNamedListener('PUBLISH_API_CALL', 'apiCall', function PUBLISH_API_CALL(event) {
        process.nextTick(function() {publisher.eventHandler(event);});
      });
      this.addNamedListener('PUBLISH_API_ATTEMPT', 'apiCallAttempt', function PUBLISH_API_ATTEMPT(event) {
        process.nextTick(function() {publisher.eventHandler(event);});
      });
    }
  },

  /**
   * @api private
   */
  validateService: function validateService() {
  },

  /**
   * @api private
   */
  loadServiceClass: function loadServiceClass(serviceConfig) {
    var config = serviceConfig;
    if (!AWS.util.isEmpty(this.api)) {
      return null;
    } else if (config.apiConfig) {
      return AWS.Service.defineServiceApi(this.constructor, config.apiConfig);
    } else if (!this.constructor.services) {
      return null;
    } else {
      config = new AWS.Config(AWS.config);
      config.update(serviceConfig, true);
      var version = config.apiVersions[this.constructor.serviceIdentifier];
      version = version || config.apiVersion;
      return this.getLatestServiceClass(version);
    }
  },

  /**
   * @api private
   */
  getLatestServiceClass: function getLatestServiceClass(version) {
    version = this.getLatestServiceVersion(version);
    if (this.constructor.services[version] === null) {
      AWS.Service.defineServiceApi(this.constructor, version);
    }

    return this.constructor.services[version];
  },

  /**
   * @api private
   */
  getLatestServiceVersion: function getLatestServiceVersion(version) {
    if (!this.constructor.services || this.constructor.services.length === 0) {
      throw new Error('No services defined on ' +
                      this.constructor.serviceIdentifier);
    }

    if (!version) {
      version = 'latest';
    } else if (AWS.util.isType(version, Date)) {
      version = AWS.util.date.iso8601(version).split('T')[0];
    }

    if (Object.hasOwnProperty(this.constructor.services, version)) {
      return version;
    }

    var keys = Object.keys(this.constructor.services).sort();
    var selectedVersion = null;
    for (var i = keys.length - 1; i >= 0; i--) {
      // versions that end in "*" are not available on disk and can be
      // skipped, so do not choose these as selectedVersions
      if (keys[i][keys[i].length - 1] !== '*') {
        selectedVersion = keys[i];
      }
      if (keys[i].substr(0, 10) <= version) {
        return selectedVersion;
      }
    }

    throw new Error('Could not find ' + this.constructor.serviceIdentifier +
                    ' API to satisfy version constraint `' + version + '\'');
  },

  /**
   * @api private
   */
  api: {},

  /**
   * @api private
   */
  defaultRetryCount: 3,

  /**
   * @api private
   */
  customizeRequests: function customizeRequests(callback) {
    if (!callback) {
      this.customRequestHandler = null;
    } else if (typeof callback === 'function') {
      this.customRequestHandler = callback;
    } else {
      throw new Error('Invalid callback type \'' + typeof callback + '\' provided in customizeRequests');
    }
  },

  /**
   * Calls an operation on a service with the given input parameters.
   *
   * @param operation [String] the name of the operation to call on the service.
   * @param params [map] a map of input options for the operation
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  makeRequest: function makeRequest(operation, params, callback) {
    if (typeof params === 'function') {
      callback = params;
      params = null;
    }

    params = params || {};
    if (this.config.params) { // copy only toplevel bound params
      var rules = this.api.operations[operation];
      if (rules) {
        params = AWS.util.copy(params);
        AWS.util.each(this.config.params, function(key, value) {
          if (rules.input.members[key]) {
            if (params[key] === undefined || params[key] === null) {
              params[key] = value;
            }
          }
        });
      }
    }

    var request = new AWS.Request(this, operation, params);
    this.addAllRequestListeners(request);
    this.attachMonitoringEmitter(request);
    if (callback) request.send(callback);
    return request;
  },

  /**
   * Calls an operation on a service with the given input parameters, without
   * any authentication data. This method is useful for "public" API operations.
   *
   * @param operation [String] the name of the operation to call on the service.
   * @param params [map] a map of input options for the operation
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {
    if (typeof params === 'function') {
      callback = params;
      params = {};
    }

    var request = this.makeRequest(operation, params).toUnauthenticated();
    return callback ? request.send(callback) : request;
  },

  /**
   * Waits for a given state
   *
   * @param state [String] the state on the service to wait for
   * @param params [map] a map of parameters to pass with each request
   * @option params $waiter [map] a map of configuration options for the waiter
   * @option params $waiter.delay [Number] The number of seconds to wait between
   *                                       requests
   * @option params $waiter.maxAttempts [Number] The maximum number of requests
   *                                             to send while waiting
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  waitFor: function waitFor(state, params, callback) {
    var waiter = new AWS.ResourceWaiter(this, state);
    return waiter.wait(params, callback);
  },

  /**
   * @api private
   */
  addAllRequestListeners: function addAllRequestListeners(request) {
    var list = [AWS.events, AWS.EventListeners.Core, this.serviceInterface(),
                AWS.EventListeners.CorePost];
    for (var i = 0; i < list.length; i++) {
      if (list[i]) request.addListeners(list[i]);
    }

    // disable parameter validation
    if (!this.config.paramValidation) {
      request.removeListener('validate',
        AWS.EventListeners.Core.VALIDATE_PARAMETERS);
    }

    if (this.config.logger) { // add logging events
      request.addListeners(AWS.EventListeners.Logger);
    }

    this.setupRequestListeners(request);
    // call prototype's customRequestHandler
    if (typeof this.constructor.prototype.customRequestHandler === 'function') {
      this.constructor.prototype.customRequestHandler(request);
    }
    // call instance's customRequestHandler
    if (Object.prototype.hasOwnProperty.call(this, 'customRequestHandler') && typeof this.customRequestHandler === 'function') {
      this.customRequestHandler(request);
    }
  },

  /**
   * Event recording metrics for a whole API call.
   * @returns {object} a subset of api call metrics
   * @api private
   */
  apiCallEvent: function apiCallEvent(request) {
    var api = request.service.api.operations[request.operation];
    var monitoringEvent = {
      Type: 'ApiCall',
      Api: api ? api.name : request.operation,
      Version: 1,
      Service: request.service.api.serviceId || request.service.api.endpointPrefix,
      Region: request.httpRequest.region,
      MaxRetriesExceeded: 0,
      UserAgent: request.httpRequest.getUserAgent(),
    };
    var response = request.response;
    if (response.httpResponse.statusCode) {
      monitoringEvent.FinalHttpStatusCode = response.httpResponse.statusCode;
    }
    if (response.error) {
      var error = response.error;
      var statusCode = response.httpResponse.statusCode;
      if (statusCode > 299) {
        if (error.code) monitoringEvent.FinalAwsException = error.code;
        if (error.message) monitoringEvent.FinalAwsExceptionMessage = error.message;
      } else {
        if (error.code || error.name) monitoringEvent.FinalSdkException = error.code || error.name;
        if (error.message) monitoringEvent.FinalSdkExceptionMessage = error.message;
      }
    }
    return monitoringEvent;
  },

  /**
   * Event recording metrics for an API call attempt.
   * @returns {object} a subset of api call attempt metrics
   * @api private
   */
  apiAttemptEvent: function apiAttemptEvent(request) {
    var api = request.service.api.operations[request.operation];
    var monitoringEvent = {
      Type: 'ApiCallAttempt',
      Api: api ? api.name : request.operation,
      Version: 1,
      Service: request.service.api.serviceId || request.service.api.endpointPrefix,
      Fqdn: request.httpRequest.endpoint.hostname,
      UserAgent: request.httpRequest.getUserAgent(),
    };
    var response = request.response;
    if (response.httpResponse.statusCode) {
      monitoringEvent.HttpStatusCode = response.httpResponse.statusCode;
    }
    if (
      !request._unAuthenticated &&
      request.service.config.credentials &&
      request.service.config.credentials.accessKeyId
    ) {
      monitoringEvent.AccessKey = request.service.config.credentials.accessKeyId;
    }
    if (!response.httpResponse.headers) return monitoringEvent;
    if (request.httpRequest.headers['x-amz-security-token']) {
      monitoringEvent.SessionToken = request.httpRequest.headers['x-amz-security-token'];
    }
    if (response.httpResponse.headers['x-amzn-requestid']) {
      monitoringEvent.XAmznRequestId = response.httpResponse.headers['x-amzn-requestid'];
    }
    if (response.httpResponse.headers['x-amz-request-id']) {
      monitoringEvent.XAmzRequestId = response.httpResponse.headers['x-amz-request-id'];
    }
    if (response.httpResponse.headers['x-amz-id-2']) {
      monitoringEvent.XAmzId2 = response.httpResponse.headers['x-amz-id-2'];
    }
    return monitoringEvent;
  },

  /**
   * Add metrics of failed request.
   * @api private
   */
  attemptFailEvent: function attemptFailEvent(request) {
    var monitoringEvent = this.apiAttemptEvent(request);
    var response = request.response;
    var error = response.error;
    if (response.httpResponse.statusCode > 299 ) {
      if (error.code) monitoringEvent.AwsException = error.code;
      if (error.message) monitoringEvent.AwsExceptionMessage = error.message;
    } else {
      if (error.code || error.name) monitoringEvent.SdkException = error.code || error.name;
      if (error.message) monitoringEvent.SdkExceptionMessage = error.message;
    }
    return monitoringEvent;
  },

  /**
   * Attach listeners to request object to fetch metrics of each request
   * and emit data object through \'ApiCall\' and \'ApiCallAttempt\' events.
   * @api private
   */
  attachMonitoringEmitter: function attachMonitoringEmitter(request) {
    var attemptTimestamp; //timestamp marking the beginning of a request attempt
    var attemptStartRealTime; //Start time of request attempt. Used to calculating attemptLatency
    var attemptLatency; //latency from request sent out to http response reaching SDK
    var callStartRealTime; //Start time of API call. Used to calculating API call latency
    var attemptCount = 0; //request.retryCount is not reliable here
    var region; //region cache region for each attempt since it can be updated in plase (e.g. s3)
    var callTimestamp; //timestamp when the request is created
    var self = this;
    var addToHead = true;

    request.on('validate', function () {
      callStartRealTime = AWS.util.realClock.now();
      callTimestamp = Date.now();
    }, addToHead);
    request.on('sign', function () {
      attemptStartRealTime = AWS.util.realClock.now();
      attemptTimestamp = Date.now();
      region = request.httpRequest.region;
      attemptCount++;
    }, addToHead);
    request.on('validateResponse', function() {
      attemptLatency = Math.round(AWS.util.realClock.now() - attemptStartRealTime);
    });
    request.addNamedListener('API_CALL_ATTEMPT', 'success', function API_CALL_ATTEMPT() {
      var apiAttemptEvent = self.apiAttemptEvent(request);
      apiAttemptEvent.Timestamp = attemptTimestamp;
      apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
      apiAttemptEvent.Region = region;
      self.emit('apiCallAttempt', [apiAttemptEvent]);
    });
    request.addNamedListener('API_CALL_ATTEMPT_RETRY', 'retry', function API_CALL_ATTEMPT_RETRY() {
      var apiAttemptEvent = self.attemptFailEvent(request);
      apiAttemptEvent.Timestamp = attemptTimestamp;
      //attemptLatency may not be available if fail before response
      attemptLatency = attemptLatency ||
        Math.round(AWS.util.realClock.now() - attemptStartRealTime);
      apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
      apiAttemptEvent.Region = region;
      self.emit('apiCallAttempt', [apiAttemptEvent]);
    });
    request.addNamedListener('API_CALL', 'complete', function API_CALL() {
      var apiCallEvent = self.apiCallEvent(request);
      apiCallEvent.AttemptCount = attemptCount;
      if (apiCallEvent.AttemptCount <= 0) return;
      apiCallEvent.Timestamp = callTimestamp;
      var latency = Math.round(AWS.util.realClock.now() - callStartRealTime);
      apiCallEvent.Latency = latency >= 0 ? latency : 0;
      var response = request.response;
      if (
        typeof response.retryCount === 'number' &&
        typeof response.maxRetries === 'number' &&
        (response.retryCount >= response.maxRetries)
      ) {
        apiCallEvent.MaxRetriesExceeded = 1;
      }
      self.emit('apiCall', [apiCallEvent]);
    });
  },

  /**
   * Override this method to setup any custom request listeners for each
   * new request to the service.
   *
   * @method_abstract This is an abstract method.
   */
  setupRequestListeners: function setupRequestListeners(request) {
  },

  /**
   * Gets the signer class for a given request
   * @api private
   */
  getSignerClass: function getSignerClass(request) {
    var version;
    // get operation authtype if present
    var operation = null;
    var authtype = '';
    if (request) {
      var operations = request.service.api.operations || {};
      operation = operations[request.operation] || null;
      authtype = operation ? operation.authtype : '';
    }
    if (this.config.signatureVersion) {
      version = this.config.signatureVersion;
    } else if (authtype === 'v4' || authtype === 'v4-unsigned-body') {
      version = 'v4';
    } else {
      version = this.api.signatureVersion;
    }
    return AWS.Signers.RequestSigner.getVersion(version);
  },

  /**
   * @api private
   */
  serviceInterface: function serviceInterface() {
    switch (this.api.protocol) {
      case 'ec2': return AWS.EventListeners.Query;
      case 'query': return AWS.EventListeners.Query;
      case 'json': return AWS.EventListeners.Json;
      case 'rest-json': return AWS.EventListeners.RestJson;
      case 'rest-xml': return AWS.EventListeners.RestXml;
    }
    if (this.api.protocol) {
      throw new Error('Invalid service `protocol\' ' +
        this.api.protocol + ' in API config');
    }
  },

  /**
   * @api private
   */
  successfulResponse: function successfulResponse(resp) {
    return resp.httpResponse.statusCode < 300;
  },

  /**
   * How many times a failed request should be retried before giving up.
   * the defaultRetryCount can be overriden by service classes.
   *
   * @api private
   */
  numRetries: function numRetries() {
    if (this.config.maxRetries !== undefined) {
      return this.config.maxRetries;
    } else {
      return this.defaultRetryCount;
    }
  },

  /**
   * @api private
   */
  retryDelays: function retryDelays(retryCount, err) {
    return AWS.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions, err);
  },

  /**
   * @api private
   */
  retryableError: function retryableError(error) {
    if (this.timeoutError(error)) return true;
    if (this.networkingError(error)) return true;
    if (this.expiredCredentialsError(error)) return true;
    if (this.throttledError(error)) return true;
    if (error.statusCode >= 500) return true;
    return false;
  },

  /**
   * @api private
   */
  networkingError: function networkingError(error) {
    return error.code === 'NetworkingError';
  },

  /**
   * @api private
   */
  timeoutError: function timeoutError(error) {
    return error.code === 'TimeoutError';
  },

  /**
   * @api private
   */
  expiredCredentialsError: function expiredCredentialsError(error) {
    // TODO : this only handles *one* of the expired credential codes
    return (error.code === 'ExpiredTokenException');
  },

  /**
   * @api private
   */
  clockSkewError: function clockSkewError(error) {
    switch (error.code) {
      case 'RequestTimeTooSkewed':
      case 'RequestExpired':
      case 'InvalidSignatureException':
      case 'SignatureDoesNotMatch':
      case 'AuthFailure':
      case 'RequestInTheFuture':
        return true;
      default: return false;
    }
  },

  /**
   * @api private
   */
  getSkewCorrectedDate: function getSkewCorrectedDate() {
    return new Date(Date.now() + this.config.systemClockOffset);
  },

  /**
   * @api private
   */
  applyClockOffset: function applyClockOffset(newServerTime) {
    if (newServerTime) {
      this.config.systemClockOffset = newServerTime - Date.now();
    }
  },

  /**
   * @api private
   */
  isClockSkewed: function isClockSkewed(newServerTime) {
    if (newServerTime) {
      return Math.abs(this.getSkewCorrectedDate().getTime() - newServerTime) >= 300000;
    }
  },

  /**
   * @api private
   */
  throttledError: function throttledError(error) {
    // this logic varies between services
    if (error.statusCode === 429) return true;
    switch (error.code) {
      case 'ProvisionedThroughputExceededException':
      case 'Throttling':
      case 'ThrottlingException':
      case 'RequestLimitExceeded':
      case 'RequestThrottled':
      case 'RequestThrottledException':
      case 'TooManyRequestsException':
      case 'TransactionInProgressException': //dynamodb
        return true;
      default:
        return false;
    }
  },

  /**
   * @api private
   */
  endpointFromTemplate: function endpointFromTemplate(endpoint) {
    if (typeof endpoint !== 'string') return endpoint;

    var e = endpoint;
    e = e.replace(/\{service\}/g, this.api.endpointPrefix);
    e = e.replace(/\{region\}/g, this.config.region);
    e = e.replace(/\{scheme\}/g, this.config.sslEnabled ? 'https' : 'http');
    return e;
  },

  /**
   * @api private
   */
  setEndpoint: function setEndpoint(endpoint) {
    this.endpoint = new AWS.Endpoint(endpoint, this.config);
  },

  /**
   * @api private
   */
  paginationConfig: function paginationConfig(operation, throwException) {
    var paginator = this.api.operations[operation].paginator;
    if (!paginator) {
      if (throwException) {
        var e = new Error();
        throw AWS.util.error(e, 'No pagination configuration for ' + operation);
      }
      return null;
    }

    return paginator;
  }
});

AWS.util.update(AWS.Service, {

  /**
   * Adds one method for each operation described in the api configuration
   *
   * @api private
   */
  defineMethods: function defineMethods(svc) {
    AWS.util.each(svc.prototype.api.operations, function iterator(method) {
      if (svc.prototype[method]) return;
      var operation = svc.prototype.api.operations[method];
      if (operation.authtype === 'none') {
        svc.prototype[method] = function (params, callback) {
          return this.makeUnauthenticatedRequest(method, params, callback);
        };
      } else {
        svc.prototype[method] = function (params, callback) {
          return this.makeRequest(method, params, callback);
        };
      }
    });
  },

  /**
   * Defines a new Service class using a service identifier and list of versions
   * including an optional set of features (functions) to apply to the class
   * prototype.
   *
   * @param serviceIdentifier [String] the identifier for the service
   * @param versions [Array<String>] a list of versions that work with this
   *   service
   * @param features [Object] an object to attach to the prototype
   * @return [Class<Service>] the service class defined by this function.
   */
  defineService: function defineService(serviceIdentifier, versions, features) {
    AWS.Service._serviceMap[serviceIdentifier] = true;
    if (!Array.isArray(versions)) {
      features = versions;
      versions = [];
    }

    var svc = inherit(AWS.Service, features || {});

    if (typeof serviceIdentifier === 'string') {
      AWS.Service.addVersions(svc, versions);

      var identifier = svc.serviceIdentifier || serviceIdentifier;
      svc.serviceIdentifier = identifier;
    } else { // defineService called with an API
      svc.prototype.api = serviceIdentifier;
      AWS.Service.defineMethods(svc);
    }
    AWS.SequentialExecutor.call(this.prototype);
    //util.clientSideMonitoring is only available in node
    if (!this.prototype.publisher && AWS.util.clientSideMonitoring) {
      var Publisher = AWS.util.clientSideMonitoring.Publisher;
      var configProvider = AWS.util.clientSideMonitoring.configProvider;
      var publisherConfig = configProvider();
      this.prototype.publisher = new Publisher(publisherConfig);
      if (publisherConfig.enabled) {
        //if csm is enabled in environment, SDK should send all metrics
        AWS.Service._clientSideMonitoring = true;
      }
    }
    AWS.SequentialExecutor.call(svc.prototype);
    AWS.Service.addDefaultMonitoringListeners(svc.prototype);
    return svc;
  },

  /**
   * @api private
   */
  addVersions: function addVersions(svc, versions) {
    if (!Array.isArray(versions)) versions = [versions];

    svc.services = svc.services || {};
    for (var i = 0; i < versions.length; i++) {
      if (svc.services[versions[i]] === undefined) {
        svc.services[versions[i]] = null;
      }
    }

    svc.apiVersions = Object.keys(svc.services).sort();
  },

  /**
   * @api private
   */
  defineServiceApi: function defineServiceApi(superclass, version, apiConfig) {
    var svc = inherit(superclass, {
      serviceIdentifier: superclass.serviceIdentifier
    });

    function setApi(api) {
      if (api.isApi) {
        svc.prototype.api = api;
      } else {
        svc.prototype.api = new Api(api);
      }
    }

    if (typeof version === 'string') {
      if (apiConfig) {
        setApi(apiConfig);
      } else {
        try {
          setApi(AWS.apiLoader(superclass.serviceIdentifier, version));
        } catch (err) {
          throw AWS.util.error(err, {
            message: 'Could not find API configuration ' +
              superclass.serviceIdentifier + '-' + version
          });
        }
      }
      if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {
        superclass.apiVersions = superclass.apiVersions.concat(version).sort();
      }
      superclass.services[version] = svc;
    } else {
      setApi(version);
    }

    AWS.Service.defineMethods(svc);
    return svc;
  },

  /**
   * @api private
   */
  hasService: function(identifier) {
    return Object.prototype.hasOwnProperty.call(AWS.Service._serviceMap, identifier);
  },

  /**
   * @param attachOn attach default monitoring listeners to object
   *
   * Each monitoring event should be emitted from service client to service constructor prototype and then
   * to global service prototype like bubbling up. These default monitoring events listener will transfer
   * the monitoring events to the upper layer.
   * @api private
   */
  addDefaultMonitoringListeners: function addDefaultMonitoringListeners(attachOn) {
    attachOn.addNamedListener('MONITOR_EVENTS_BUBBLE', 'apiCallAttempt', function EVENTS_BUBBLE(event) {
      var baseClass = Object.getPrototypeOf(attachOn);
      if (baseClass._events) baseClass.emit('apiCallAttempt', [event]);
    });
    attachOn.addNamedListener('CALL_EVENTS_BUBBLE', 'apiCall', function CALL_EVENTS_BUBBLE(event) {
      var baseClass = Object.getPrototypeOf(attachOn);
      if (baseClass._events) baseClass.emit('apiCall', [event]);
    });
  },

  /**
   * @api private
   */
  _serviceMap: {}
});

AWS.util.mixin(AWS.Service, AWS.SequentialExecutor);

/**
 * @api private
 */
module.exports = AWS.Service;

}).call(this,require('_process'))

},{"./core":23,"./model/api":43,"./region_config":58,"_process":95}],66:[function(require,module,exports){
var AWS = require('../core');

AWS.util.update(AWS.CognitoIdentity.prototype, {
  getOpenIdToken: function getOpenIdToken(params, callback) {
    return this.makeUnauthenticatedRequest('getOpenIdToken', params, callback);
  },

  getId: function getId(params, callback) {
    return this.makeUnauthenticatedRequest('getId', params, callback);
  },

  getCredentialsForIdentity: function getCredentialsForIdentity(params, callback) {
    return this.makeUnauthenticatedRequest('getCredentialsForIdentity', params, callback);
  }
});

},{"../core":23}],67:[function(require,module,exports){
(function (process){
var AWS = require('../core');
var v4Credentials = require('../signers/v4_credentials');
var resolveRegionalEndpointsFlag = require('../config_regional_endpoint');
var regionUtil = require('../region_config');

// Pull in managed upload extension
require('../s3/managed_upload');

/**
 * @api private
 */
var operationsWith200StatusCodeError = {
  'completeMultipartUpload': true,
  'copyObject': true,
  'uploadPartCopy': true
};

/**
 * @api private
 */
 var regionRedirectErrorCodes = [
  'AuthorizationHeaderMalformed', // non-head operations on virtual-hosted global bucket endpoints
  'BadRequest', // head operations on virtual-hosted global bucket endpoints
  'PermanentRedirect', // non-head operations on path-style or regional endpoints
  301 // head operations on path-style or regional endpoints
 ];

AWS.util.update(AWS.S3.prototype, {
  /**
   * @api private
   */
  getSignatureVersion: function getSignatureVersion(request) {
    var defaultApiVersion = this.api.signatureVersion;
    var userDefinedVersion = this._originalConfig ? this._originalConfig.signatureVersion : null;
    var regionDefinedVersion = this.config.signatureVersion;
    var isPresigned = request ? request.isPresigned() : false;
    /*
      1) User defined version specified:
        a) always return user defined version
      2) No user defined version specified:
        a) default to lowest version the region supports
        b) If using presigned urls, default to lowest version the region supports
    */
    if (userDefinedVersion) {
      userDefinedVersion = userDefinedVersion === 'v2' ? 's3' : userDefinedVersion;
      return userDefinedVersion;
    }
    if (isPresigned !== true) {
      defaultApiVersion = 'v4';
    } else if (regionDefinedVersion) {
      defaultApiVersion = regionDefinedVersion;
    }
    return defaultApiVersion;
  },

  /**
   * @api private
   */
  getSignerClass: function getSignerClass(request) {
    var signatureVersion = this.getSignatureVersion(request);
    return AWS.Signers.RequestSigner.getVersion(signatureVersion);
  },

  /**
   * @api private
   */
  validateService: function validateService() {
    var msg;
    var messages = [];

    // default to us-east-1 when no region is provided
    if (!this.config.region) this.config.region = 'us-east-1';

    if (!this.config.endpoint && this.config.s3BucketEndpoint) {
      messages.push('An endpoint must be provided when configuring ' +
                    '`s3BucketEndpoint` to true.');
    }
    if (messages.length === 1) {
      msg = messages[0];
    } else if (messages.length > 1) {
      msg = 'Multiple configuration errors:\n' + messages.join('\n');
    }
    if (msg) {
      throw AWS.util.error(new Error(),
        {name: 'InvalidEndpoint', message: msg});
    }
  },

  /**
   * @api private
   */
  shouldDisableBodySigning: function shouldDisableBodySigning(request) {
    var signerClass = this.getSignerClass();
    if (this.config.s3DisableBodySigning === true && signerClass === AWS.Signers.V4
        && request.httpRequest.endpoint.protocol === 'https:') {
      return true;
    }
    return false;
  },

  /**
   * @api private
   */
  setupRequestListeners: function setupRequestListeners(request) {
    var prependListener = true;
    request.addListener('validate', this.validateScheme);
    request.addListener('validate', this.validateBucketName, prependListener);
    request.addListener('validate', this.optInUsEast1RegionalEndpoint, prependListener);

    request.removeListener('validate',
      AWS.EventListeners.Core.VALIDATE_REGION);
    request.addListener('build', this.addContentType);
    request.addListener('build', this.computeContentMd5);
    request.addListener('build', this.computeSseCustomerKeyMd5);
    request.addListener('build', this.populateURI);
    request.addListener('afterBuild', this.addExpect100Continue);
    request.addListener('extractError', this.extractError);
    request.addListener('extractData', AWS.util.hoistPayloadMember);
    request.addListener('extractData', this.extractData);
    request.addListener('beforePresign', this.prepareSignedUrl);
    if (this.shouldDisableBodySigning(request))  {
      request.removeListener('afterBuild', AWS.EventListeners.Core.COMPUTE_SHA256);
      request.addListener('afterBuild', this.disableBodySigning);
    }
    //deal with ARNs supplied to Bucket
    if (this.isAccessPointApplicable(request)) {
      request.removeListener('validate', this.validateBucketName);
      request.addListener('validate', this.validateAccessPointArn, prependListener);
      request.addListener('validate', this.validateArnRegion);
      request.removeListener('build', this.populateURI);
      request.addListener('build', this.populateUriFromAccessPoint);
      return;
    }
    //listeners regarding region inference
    request.addListener('validate', this.validateBucketEndpoint);
    request.addListener('validate', this.correctBucketRegionFromCache);
    request.onAsync('extractError', this.requestBucketRegion);
    if (AWS.util.isBrowser()) {
      request.onAsync('retry', this.reqRegionForNetworkingError);
    }
  },

  /**
   * @api private
   */
  validateScheme: function(req) {
    var params = req.params,
        scheme = req.httpRequest.endpoint.protocol,
        sensitive = params.SSECustomerKey || params.CopySourceSSECustomerKey;
    if (sensitive && scheme !== 'https:') {
      var msg = 'Cannot send SSE keys over HTTP. Set \'sslEnabled\'' +
        'to \'true\' in your configuration';
      throw AWS.util.error(new Error(),
        { code: 'ConfigError', message: msg });
    }
  },

  /**
   * @api private
   */
  validateBucketEndpoint: function(req) {
    if (!req.params.Bucket && req.service.config.s3BucketEndpoint) {
      var msg = 'Cannot send requests to root API with `s3BucketEndpoint` set.';
      throw AWS.util.error(new Error(),
        { code: 'ConfigError', message: msg });
    }
  },

  /**
   * @api private
   */
  isAccessPointApplicable: function hasBucketInParams(req) {
    var inputShape = (req.service.api.operations[req.operation] || {}).input || {};
    var inputMembers = inputShape.members || {};
    if (
      req.operation === 'createBucket' ||
      !req.params.Bucket ||
      !inputMembers.Bucket
    ) return false;
    if (!AWS.util.ARN.validate(req.params.Bucket)) return false;
    return true;
  },

  /**
   * Validate ARN supplied in Bucket parameter is a valid access point ARN
   *
   * @api private
   */
  validateAccessPointArn: function validateAccessPointArn(req) {
    var parsedArn = AWS.util.ARN.parse(req.params.Bucket);
    //avoid duplicated parsing in the future
    req._parsedAccessPointArn = parsedArn;
    var parsedArn = req._parsedAccessPointArn;
    if (parsedArn.service !== 's3') {
      throw AWS.util.error(new Error(), {
        code: 'InvalidAccessPointARN',
        message: 'expect \'s3\' in access point ARN service component'
      });
    }
    if (!parsedArn.region) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidAccessPointARN',
        message: 'Access point ARN region is empty'
      });
    }
    if (
      parsedArn.resource.indexOf('accesspoint:') !== 0 &&
      parsedArn.resource.indexOf('accesspoint/') !== 0
    ) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidAccessPointARN',
        message: 'Access point ARN resource should begin with \'accesspoint/\''
      });
    }
    var delimiter = parsedArn.resource['accesspoint'.length]; //can be ':' or '/'
    if (parsedArn.resource.split(delimiter).length !== 2) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidAccessPointARN',
        message: 'Too many resource parameters in access point ARN'
      });
    }
    var accessPoint = parsedArn.resource.split(delimiter)[1];
    var accessPointPrefix = accessPoint + '-' + parsedArn.accountId;
    if (!req.service.isDnsCompatible(accessPointPrefix) || accessPointPrefix.match(/\./)) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidAccessPointARN',
        message: 'Access point ARN is not DNS compatible. Got ' + accessPoint
      });
    }
    //set parsed valid access point
    req._parsedAccessPointArn.accessPoint = accessPoint;
  },

  /**
   * @api private
   */
  validateArnRegion: function validateArnRegion(req) {
    var useArnRegion = req.service.loadUseArnRegionConfig(req);
    var regionFromArn = req._parsedAccessPointArn.region;
    var clientRegion = req.service.config.region;
    if (
      clientRegion.indexOf('fips') >= 0 ||
      regionFromArn.indexOf('fips') >= 0
    ) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'Access point endpoint is not compatible with FIPS region'
      });
    }
    if (!useArnRegion && regionFromArn !== clientRegion) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'Configured region conflicts with access point region'
      });
    } else if (
      useArnRegion &&
      regionUtil.getEndpointSuffix(regionFromArn) !== regionUtil.getEndpointSuffix(clientRegion)
    ) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'Configured region and access point region not in same partition'
      });
    }
    if (req.service.config.useAccelerateEndpoint) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'useAccelerateEndpoint config is not supported with access point ARN'
      });
    }
  },

  /**
   * @api private
   */
  loadUseArnRegionConfig: function loadUseArnRegionConfig(req) {
    var envName = 'AWS_S3_USE_ARN_REGION';
    var configName = 's3_use_arn_region';
    var useArnRegion = true;
    var originalConfig = req.service._originalConfig || {};
    if (req.service.config.s3UseArnRegion !== undefined) {
      return req.service.config.s3UseArnRegion;
    } else if (originalConfig.s3UseArnRegion !== undefined) {
      useArnRegion = originalConfig.s3UseArnRegion === true;
    } else if (AWS.util.isNode()) {
      //load from environmental variable AWS_USE_ARN_REGION
      if (process.env[envName]) {
        var value = process.env[envName].trim().toLowerCase();
        if (['false', 'true'].indexOf(value) < 0) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidConfiguration',
            message: envName + ' only accepts true or false. Got ' + process.env[envName],
            retryable: false
          });
        }
        useArnRegion = value === 'true';
      } else {  //load from shared config property use_arn_region
        var profiles = {};
        var profile = {};
        try {
          profiles = AWS.util.getProfilesFromSharedConfig(AWS.util.iniLoader);
          profile = profiles[process.env.AWS_PROFILE || AWS.util.defaultProfile];
        } catch (e) {}
        if (profile[configName]) {
          if (['false', 'true'].indexOf(profile[configName].trim().toLowerCase()) < 0) {
            throw AWS.util.error(new Error(), {
              code: 'InvalidConfiguration',
              message: configName + ' only accepts true or false. Got ' + profile[configName],
              retryable: false
            });
          }
          useArnRegion = profile[configName].trim().toLowerCase() === 'true';
        }
      }
    }
    req.service.config.s3UseArnRegion = useArnRegion;
    return useArnRegion;
  },

  /**
   * @api private
   */
  validateBucketName: function validateBucketName(req) {
    var service = req.service;
    var signatureVersion = service.getSignatureVersion(req);
    var bucket = req.params && req.params.Bucket;
    var key = req.params && req.params.Key;
    var slashIndex = bucket && bucket.indexOf('/');
    if (bucket && slashIndex >= 0) {
      if (typeof key === 'string' && slashIndex > 0) {
        req.params = AWS.util.copy(req.params);
        // Need to include trailing slash to match sigv2 behavior
        var prefix = bucket.substr(slashIndex + 1) || '';
        req.params.Key = prefix + '/' + key;
        req.params.Bucket = bucket.substr(0, slashIndex);
      } else if (signatureVersion === 'v4') {
        var msg = 'Bucket names cannot contain forward slashes. Bucket: ' + bucket;
        throw AWS.util.error(new Error(),
          { code: 'InvalidBucket', message: msg });
      }
    }
  },

  /**
   * @api private
   */
  isValidAccelerateOperation: function isValidAccelerateOperation(operation) {
    var invalidOperations = [
      'createBucket',
      'deleteBucket',
      'listBuckets'
    ];
    return invalidOperations.indexOf(operation) === -1;
  },

  /**
   * When us-east-1 region endpoint configuration is set, in stead of sending request to
   * global endpoint(e.g. 's3.amazonaws.com'), we will send request to
   * 's3.us-east-1.amazonaws.com'.
   * @api private
   */
  optInUsEast1RegionalEndpoint: function optInUsEast1RegionalEndpoint(req) {
    var service = req.service;
    var config = service.config;
    config.s3UsEast1RegionalEndpoint = resolveRegionalEndpointsFlag(service._originalConfig, {
      env: 'AWS_S3_US_EAST_1_REGIONAL_ENDPOINT',
      sharedConfig: 's3_us_east_1_regional_endpoint',
      clientConfig: 's3UsEast1RegionalEndpoint'
    });
    if (
      !(service._originalConfig || {}).endpoint &&
      req.httpRequest.region === 'us-east-1' &&
      config.s3UsEast1RegionalEndpoint === 'regional' &&
      req.httpRequest.endpoint.hostname.indexOf('s3.amazonaws.com') >= 0
    ) {
      var insertPoint = config.endpoint.indexOf('.amazonaws.com');
      regionalEndpoint = config.endpoint.substring(0, insertPoint) +
        '.us-east-1' + config.endpoint.substring(insertPoint);
      req.httpRequest.updateEndpoint(regionalEndpoint);
    }
  },

  /**
   * S3 prefers dns-compatible bucket names to be moved from the uri path
   * to the hostname as a sub-domain.  This is not possible, even for dns-compat
   * buckets when using SSL and the bucket name contains a dot ('.').  The
   * ssl wildcard certificate is only 1-level deep.
   *
   * @api private
   */
  populateURI: function populateURI(req) {
    var httpRequest = req.httpRequest;
    var b = req.params.Bucket;
    var service = req.service;
    var endpoint = httpRequest.endpoint;
    if (b) {
      if (!service.pathStyleBucketName(b)) {
        if (service.config.useAccelerateEndpoint && service.isValidAccelerateOperation(req.operation)) {
          if (service.config.useDualstack) {
            endpoint.hostname = b + '.s3-accelerate.dualstack.amazonaws.com';
          } else {
            endpoint.hostname = b + '.s3-accelerate.amazonaws.com';
          }
        } else if (!service.config.s3BucketEndpoint) {
          endpoint.hostname =
            b + '.' + endpoint.hostname;
        }

        var port = endpoint.port;
        if (port !== 80 && port !== 443) {
          endpoint.host = endpoint.hostname + ':' +
            endpoint.port;
        } else {
          endpoint.host = endpoint.hostname;
        }

        httpRequest.virtualHostedBucket = b; // needed for signing the request
        service.removeVirtualHostedBucketFromPath(req);
      }
    }
  },

  /**
   * Takes the bucket name out of the path if bucket is virtual-hosted
   *
   * @api private
   */
  removeVirtualHostedBucketFromPath: function removeVirtualHostedBucketFromPath(req) {
    var httpRequest = req.httpRequest;
    var bucket = httpRequest.virtualHostedBucket;
    if (bucket && httpRequest.path) {
      if (req.params && req.params.Key) {
        var encodedS3Key = '/' + AWS.util.uriEscapePath(req.params.Key);
        if (httpRequest.path.indexOf(encodedS3Key) === 0 && (httpRequest.path.length === encodedS3Key.length || httpRequest.path[encodedS3Key.length] === '?')) {
          //path only contains key or path contains only key and querystring
          return;
        }
      }
      httpRequest.path = httpRequest.path.replace(new RegExp('/' + bucket), '');
      if (httpRequest.path[0] !== '/') {
        httpRequest.path = '/' + httpRequest.path;
      }
    }
  },

  /**
   * When user supply an access point ARN in the Bucket parameter, we need to
   * populate the URI according to the ARN.
   * @api private
   */
  populateUriFromAccessPoint: function populateUriFromAccessPoint(req) {
    if (req.service._originalConfig.endpoint) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'Custom endpoint is not compatible with access point ARN'
      });
    }
    if (req.service.config.s3ForcePathStyle) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'Cannot construct path-style endpoint with access point'
      });
    }
    var accessPointArn = req._parsedAccessPointArn;
    var serviceName = req.service.config.useDualstack ?
      's3-accesspoint.dualstack':
      's3-accesspoint';
    var endpoint = req.httpRequest.endpoint;
    var dnsSuffix = regionUtil.getEndpointSuffix(accessPointArn.region);
    var useArnRegion = req.service.config.s3UseArnRegion;
    endpoint.hostname = [
      accessPointArn.accessPoint + '-' + accessPointArn.accountId,
      serviceName,
      useArnRegion ? accessPointArn.region : req.service.config.region,
      dnsSuffix
    ].join('.');
    endpoint.host = endpoint.hostname;
    var encodedArn = AWS.util.uriEscape(req.params.Bucket);
    var path = req.httpRequest.path;
    //remove the Bucket value from path
    req.httpRequest.path = path.replace(new RegExp('/' + encodedArn), '');
    if (req.httpRequest.path[0] !== '/') {
      req.httpRequest.path = '/' + req.httpRequest.path;
    }
    req.httpRequest.region = accessPointArn.region; //region used to sign
  },

  /**
   * Adds Expect: 100-continue header if payload is greater-or-equal 1MB
   * @api private
   */
  addExpect100Continue: function addExpect100Continue(req) {
    var len = req.httpRequest.headers['Content-Length'];
    if (AWS.util.isNode() && (len >= 1024 * 1024 || req.params.Body instanceof AWS.util.stream.Stream)) {
      req.httpRequest.headers['Expect'] = '100-continue';
    }
  },

  /**
   * Adds a default content type if none is supplied.
   *
   * @api private
   */
  addContentType: function addContentType(req) {
    var httpRequest = req.httpRequest;
    if (httpRequest.method === 'GET' || httpRequest.method === 'HEAD') {
      // Content-Type is not set in GET/HEAD requests
      delete httpRequest.headers['Content-Type'];
      return;
    }

    if (!httpRequest.headers['Content-Type']) { // always have a Content-Type
      httpRequest.headers['Content-Type'] = 'application/octet-stream';
    }

    var contentType = httpRequest.headers['Content-Type'];
    if (AWS.util.isBrowser()) {
      if (typeof httpRequest.body === 'string' && !contentType.match(/;\s*charset=/)) {
        var charset = '; charset=UTF-8';
        httpRequest.headers['Content-Type'] += charset;
      } else {
        var replaceFn = function(_, prefix, charsetName) {
          return prefix + charsetName.toUpperCase();
        };

        httpRequest.headers['Content-Type'] =
          contentType.replace(/(;\s*charset=)(.+)$/, replaceFn);
      }
    }
  },

  /**
   * @api private
   */
  computableChecksumOperations: {
    putBucketCors: true,
    putBucketLifecycle: true,
    putBucketLifecycleConfiguration: true,
    putBucketTagging: true,
    deleteObjects: true,
    putBucketReplication: true,
    putObjectLegalHold: true,
    putObjectRetention: true,
    putObjectLockConfiguration: true
  },

  /**
   * Checks whether checksums should be computed for the request.
   * If the request requires checksums to be computed, this will always
   * return true, otherwise it depends on whether {AWS.Config.computeChecksums}
   * is set.
   *
   * @param req [AWS.Request] the request to check against
   * @return [Boolean] whether to compute checksums for a request.
   * @api private
   */
  willComputeChecksums: function willComputeChecksums(req) {
    if (this.computableChecksumOperations[req.operation]) return true;
    if (!this.config.computeChecksums) return false;

    // TODO: compute checksums for Stream objects
    if (!AWS.util.Buffer.isBuffer(req.httpRequest.body) &&
        typeof req.httpRequest.body !== 'string') {
      return false;
    }

    var rules = req.service.api.operations[req.operation].input.members;

    // Sha256 signing disabled, and not a presigned url
    if (req.service.shouldDisableBodySigning(req) && !Object.prototype.hasOwnProperty.call(req.httpRequest.headers, 'presigned-expires')) {
      if (rules.ContentMD5 && !req.params.ContentMD5) {
        return true;
      }
    }

    // V4 signer uses SHA256 signatures so only compute MD5 if it is required
    if (req.service.getSignerClass(req) === AWS.Signers.V4) {
      if (rules.ContentMD5 && !rules.ContentMD5.required) return false;
    }

    if (rules.ContentMD5 && !req.params.ContentMD5) return true;
  },

  /**
   * A listener that computes the Content-MD5 and sets it in the header.
   * @see AWS.S3.willComputeChecksums
   * @api private
   */
  computeContentMd5: function computeContentMd5(req) {
    if (req.service.willComputeChecksums(req)) {
      var md5 = AWS.util.crypto.md5(req.httpRequest.body, 'base64');
      req.httpRequest.headers['Content-MD5'] = md5;
    }
  },

  /**
   * @api private
   */
  computeSseCustomerKeyMd5: function computeSseCustomerKeyMd5(req) {
    var keys = {
      SSECustomerKey: 'x-amz-server-side-encryption-customer-key-MD5',
      CopySourceSSECustomerKey: 'x-amz-copy-source-server-side-encryption-customer-key-MD5'
    };
    AWS.util.each(keys, function(key, header) {
      if (req.params[key]) {
        var value = AWS.util.crypto.md5(req.params[key], 'base64');
        req.httpRequest.headers[header] = value;
      }
    });
  },

  /**
   * Returns true if the bucket name should be left in the URI path for
   * a request to S3.  This function takes into account the current
   * endpoint protocol (e.g. http or https).
   *
   * @api private
   */
  pathStyleBucketName: function pathStyleBucketName(bucketName) {
    // user can force path style requests via the configuration
    if (this.config.s3ForcePathStyle) return true;
    if (this.config.s3BucketEndpoint) return false;

    if (this.isDnsCompatible(bucketName)) {
      return (this.config.sslEnabled && bucketName.match(/\./)) ? true : false;
    } else {
      return true; // not dns compatible names must always use path style
    }
  },

  /**
   * Returns true if the bucket name is DNS compatible.  Buckets created
   * outside of the classic region MUST be DNS compatible.
   *
   * @api private
   */
  isDnsCompatible: function isDnsCompatible(bucketName) {
    var b = bucketName;
    var domain = new RegExp(/^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/);
    var ipAddress = new RegExp(/(\d+\.){3}\d+/);
    var dots = new RegExp(/\.\./);
    return (b.match(domain) && !b.match(ipAddress) && !b.match(dots)) ? true : false;
  },

  /**
   * @return [Boolean] whether response contains an error
   * @api private
   */
  successfulResponse: function successfulResponse(resp) {
    var req = resp.request;
    var httpResponse = resp.httpResponse;
    if (operationsWith200StatusCodeError[req.operation] &&
        httpResponse.body.toString().match('<Error>')) {
      return false;
    } else {
      return httpResponse.statusCode < 300;
    }
  },

  /**
   * @return [Boolean] whether the error can be retried
   * @api private
   */
  retryableError: function retryableError(error, request) {
    if (operationsWith200StatusCodeError[request.operation] &&
        error.statusCode === 200) {
      return true;
    } else if (request._requestRegionForBucket &&
        request.service.bucketRegionCache[request._requestRegionForBucket]) {
      return false;
    } else if (error && error.code === 'RequestTimeout') {
      return true;
    } else if (error &&
        regionRedirectErrorCodes.indexOf(error.code) != -1 &&
        error.region && error.region != request.httpRequest.region) {
      request.httpRequest.region = error.region;
      if (error.statusCode === 301) {
        request.service.updateReqBucketRegion(request);
      }
      return true;
    } else {
      var _super = AWS.Service.prototype.retryableError;
      return _super.call(this, error, request);
    }
  },

  /**
   * Updates httpRequest with region. If region is not provided, then
   * the httpRequest will be updated based on httpRequest.region
   *
   * @api private
   */
  updateReqBucketRegion: function updateReqBucketRegion(request, region) {
    var httpRequest = request.httpRequest;
    if (typeof region === 'string' && region.length) {
      httpRequest.region = region;
    }
    if (!httpRequest.endpoint.host.match(/s3(?!-accelerate).*\.amazonaws\.com$/)) {
      return;
    }
    var service = request.service;
    var s3Config = service.config;
    var s3BucketEndpoint = s3Config.s3BucketEndpoint;
    if (s3BucketEndpoint) {
      delete s3Config.s3BucketEndpoint;
    }
    var newConfig = AWS.util.copy(s3Config);
    delete newConfig.endpoint;
    newConfig.region = httpRequest.region;

    httpRequest.endpoint = (new AWS.S3(newConfig)).endpoint;
    service.populateURI(request);
    s3Config.s3BucketEndpoint = s3BucketEndpoint;
    httpRequest.headers.Host = httpRequest.endpoint.host;

    if (request._asm.currentState === 'validate') {
      request.removeListener('build', service.populateURI);
      request.addListener('build', service.removeVirtualHostedBucketFromPath);
    }
  },

  /**
   * Provides a specialized parser for getBucketLocation -- all other
   * operations are parsed by the super class.
   *
   * @api private
   */
  extractData: function extractData(resp) {
    var req = resp.request;
    if (req.operation === 'getBucketLocation') {
      var match = resp.httpResponse.body.toString().match(/>(.+)<\/Location/);
      delete resp.data['_'];
      if (match) {
        resp.data.LocationConstraint = match[1];
      } else {
        resp.data.LocationConstraint = '';
      }
    }
    var bucket = req.params.Bucket || null;
    if (req.operation === 'deleteBucket' && typeof bucket === 'string' && !resp.error) {
      req.service.clearBucketRegionCache(bucket);
    } else {
      var headers = resp.httpResponse.headers || {};
      var region = headers['x-amz-bucket-region'] || null;
      if (!region && req.operation === 'createBucket' && !resp.error) {
        var createBucketConfiguration = req.params.CreateBucketConfiguration;
        if (!createBucketConfiguration) {
          region = 'us-east-1';
        } else if (createBucketConfiguration.LocationConstraint === 'EU') {
          region = 'eu-west-1';
        } else {
          region = createBucketConfiguration.LocationConstraint;
        }
      }
      if (region) {
          if (bucket && region !== req.service.bucketRegionCache[bucket]) {
            req.service.bucketRegionCache[bucket] = region;
          }
      }
    }
    req.service.extractRequestIds(resp);
  },

  /**
   * Extracts an error object from the http response.
   *
   * @api private
   */
  extractError: function extractError(resp) {
    var codes = {
      304: 'NotModified',
      403: 'Forbidden',
      400: 'BadRequest',
      404: 'NotFound'
    };

    var req = resp.request;
    var code = resp.httpResponse.statusCode;
    var body = resp.httpResponse.body || '';

    var headers = resp.httpResponse.headers || {};
    var region = headers['x-amz-bucket-region'] || null;
    var bucket = req.params.Bucket || null;
    var bucketRegionCache = req.service.bucketRegionCache;
    if (region && bucket && region !== bucketRegionCache[bucket]) {
      bucketRegionCache[bucket] = region;
    }

    var cachedRegion;
    if (codes[code] && body.length === 0) {
      if (bucket && !region) {
        cachedRegion = bucketRegionCache[bucket] || null;
        if (cachedRegion !== req.httpRequest.region) {
          region = cachedRegion;
        }
      }
      resp.error = AWS.util.error(new Error(), {
        code: codes[code],
        message: null,
        region: region
      });
    } else {
      var data = new AWS.XML.Parser().parse(body.toString());

      if (data.Region && !region) {
        region = data.Region;
        if (bucket && region !== bucketRegionCache[bucket]) {
          bucketRegionCache[bucket] = region;
        }
      } else if (bucket && !region && !data.Region) {
        cachedRegion = bucketRegionCache[bucket] || null;
        if (cachedRegion !== req.httpRequest.region) {
          region = cachedRegion;
        }
      }

      resp.error = AWS.util.error(new Error(), {
        code: data.Code || code,
        message: data.Message || null,
        region: region
      });
    }
    req.service.extractRequestIds(resp);
  },

  /**
   * If region was not obtained synchronously, then send async request
   * to get bucket region for errors resulting from wrong region.
   *
   * @api private
   */
  requestBucketRegion: function requestBucketRegion(resp, done) {
    var error = resp.error;
    var req = resp.request;
    var bucket = req.params.Bucket || null;

    if (!error || !bucket || error.region || req.operation === 'listObjects' ||
        (AWS.util.isNode() && req.operation === 'headBucket') ||
        (error.statusCode === 400 && req.operation !== 'headObject') ||
        regionRedirectErrorCodes.indexOf(error.code) === -1) {
      return done();
    }
    var reqOperation = AWS.util.isNode() ? 'headBucket' : 'listObjects';
    var reqParams = {Bucket: bucket};
    if (reqOperation === 'listObjects') reqParams.MaxKeys = 0;
    var regionReq = req.service[reqOperation](reqParams);
    regionReq._requestRegionForBucket = bucket;
    regionReq.send(function() {
      var region = req.service.bucketRegionCache[bucket] || null;
      error.region = region;
      done();
    });
  },

   /**
   * For browser only. If NetworkingError received, will attempt to obtain
   * the bucket region.
   *
   * @api private
   */
   reqRegionForNetworkingError: function reqRegionForNetworkingError(resp, done) {
    if (!AWS.util.isBrowser()) {
      return done();
    }
    var error = resp.error;
    var request = resp.request;
    var bucket = request.params.Bucket;
    if (!error || error.code !== 'NetworkingError' || !bucket ||
        request.httpRequest.region === 'us-east-1') {
      return done();
    }
    var service = request.service;
    var bucketRegionCache = service.bucketRegionCache;
    var cachedRegion = bucketRegionCache[bucket] || null;

    if (cachedRegion && cachedRegion !== request.httpRequest.region) {
      service.updateReqBucketRegion(request, cachedRegion);
      done();
    } else if (!service.isDnsCompatible(bucket)) {
      service.updateReqBucketRegion(request, 'us-east-1');
      if (bucketRegionCache[bucket] !== 'us-east-1') {
        bucketRegionCache[bucket] = 'us-east-1';
      }
      done();
    } else if (request.httpRequest.virtualHostedBucket) {
      var getRegionReq = service.listObjects({Bucket: bucket, MaxKeys: 0});
      service.updateReqBucketRegion(getRegionReq, 'us-east-1');
      getRegionReq._requestRegionForBucket = bucket;

      getRegionReq.send(function() {
        var region = service.bucketRegionCache[bucket] || null;
        if (region && region !== request.httpRequest.region) {
          service.updateReqBucketRegion(request, region);
        }
        done();
      });
    } else {
      // DNS-compatible path-style
      // (s3ForcePathStyle or bucket name with dot over https)
      // Cannot obtain region information for this case
      done();
    }
   },

  /**
   * Cache for bucket region.
   *
   * @api private
   */
   bucketRegionCache: {},

  /**
   * Clears bucket region cache.
   *
   * @api private
   */
   clearBucketRegionCache: function(buckets) {
    var bucketRegionCache = this.bucketRegionCache;
    if (!buckets) {
      buckets = Object.keys(bucketRegionCache);
    } else if (typeof buckets === 'string') {
      buckets = [buckets];
    }
    for (var i = 0; i < buckets.length; i++) {
      delete bucketRegionCache[buckets[i]];
    }
    return bucketRegionCache;
   },

   /**
    * Corrects request region if bucket's cached region is different
    *
    * @api private
    */
  correctBucketRegionFromCache: function correctBucketRegionFromCache(req) {
    var bucket = req.params.Bucket || null;
    if (bucket) {
      var service = req.service;
      var requestRegion = req.httpRequest.region;
      var cachedRegion = service.bucketRegionCache[bucket];
      if (cachedRegion && cachedRegion !== requestRegion) {
        service.updateReqBucketRegion(req, cachedRegion);
      }
    }
  },

  /**
   * Extracts S3 specific request ids from the http response.
   *
   * @api private
   */
  extractRequestIds: function extractRequestIds(resp) {
    var extendedRequestId = resp.httpResponse.headers ? resp.httpResponse.headers['x-amz-id-2'] : null;
    var cfId = resp.httpResponse.headers ? resp.httpResponse.headers['x-amz-cf-id'] : null;
    resp.extendedRequestId = extendedRequestId;
    resp.cfId = cfId;

    if (resp.error) {
      resp.error.requestId = resp.requestId || null;
      resp.error.extendedRequestId = extendedRequestId;
      resp.error.cfId = cfId;
    }
  },

  /**
   * Get a pre-signed URL for a given operation name.
   *
   * @note You must ensure that you have static or previously resolved
   *   credentials if you call this method synchronously (with no callback),
   *   otherwise it may not properly sign the request. If you cannot guarantee
   *   this (you are using an asynchronous credential provider, i.e., EC2
   *   IAM roles), you should always call this method with an asynchronous
   *   callback.
   * @note Not all operation parameters are supported when using pre-signed
   *   URLs. Certain parameters, such as `SSECustomerKey`, `ACL`, `Expires`,
   *   `ContentLength`, or `Tagging` must be provided as headers when sending a
   *   request. If you are using pre-signed URLs to upload from a browser and
   *   need to use these fields, see {createPresignedPost}.
   * @note The default signer allows altering the request by adding corresponding
   *   headers to set some parameters (e.g. Range) and these added parameters
   *   won't be signed. You must use signatureVersion v4 to to include these
   *   parameters in the signed portion of the URL and enforce exact matching
   *   between headers and signed params in the URL.
   * @note This operation cannot be used with a promise. See note above regarding
   *   asynchronous credentials and use with a callback.
   * @param operation [String] the name of the operation to call
   * @param params [map] parameters to pass to the operation. See the given
   *   operation for the expected operation parameters. In addition, you can
   *   also pass the "Expires" parameter to inform S3 how long the URL should
   *   work for.
   * @option params Expires [Integer] (900) the number of seconds to expire
   *   the pre-signed URL operation in. Defaults to 15 minutes.
   * @param callback [Function] if a callback is provided, this function will
   *   pass the URL as the second parameter (after the error parameter) to
   *   the callback function.
   * @return [String] if called synchronously (with no callback), returns the
   *   signed URL.
   * @return [null] nothing is returned if a callback is provided.
   * @example Pre-signing a getObject operation (synchronously)
   *   var params = {Bucket: 'bucket', Key: 'key'};
   *   var url = s3.getSignedUrl('getObject', params);
   *   console.log('The URL is', url);
   * @example Pre-signing a putObject (asynchronously)
   *   var params = {Bucket: 'bucket', Key: 'key'};
   *   s3.getSignedUrl('putObject', params, function (err, url) {
   *     console.log('The URL is', url);
   *   });
   * @example Pre-signing a putObject operation with a specific payload
   *   var params = {Bucket: 'bucket', Key: 'key', Body: 'body'};
   *   var url = s3.getSignedUrl('putObject', params);
   *   console.log('The URL is', url);
   * @example Passing in a 1-minute expiry time for a pre-signed URL
   *   var params = {Bucket: 'bucket', Key: 'key', Expires: 60};
   *   var url = s3.getSignedUrl('getObject', params);
   *   console.log('The URL is', url); // expires in 60 seconds
   */
  getSignedUrl: function getSignedUrl(operation, params, callback) {
    params = AWS.util.copy(params || {});
    var expires = params.Expires || 900;

    if (typeof expires !== 'number') {
      throw AWS.util.error(new Error(),
        { code: 'InvalidParameterException', message: 'The expiration must be a number, received ' + typeof expires });
    }

    delete params.Expires; // we can't validate this
    var request = this.makeRequest(operation, params);

    if (callback) {
      AWS.util.defer(function() {
        request.presign(expires, callback);
      });
    } else {
      return request.presign(expires, callback);
    }
  },

  /**
   * @!method  getSignedUrlPromise()
   *   Returns a 'thenable' promise that will be resolved with a pre-signed URL
   *   for a given operation name.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @note Not all operation parameters are supported when using pre-signed
   *      URLs. Certain parameters, such as `SSECustomerKey`, `ACL`, `Expires`,
   *      `ContentLength`, or `Tagging` must be provided as headers when sending a
   *      request. If you are using pre-signed URLs to upload from a browser and
   *      need to use these fields, see {createPresignedPost}.
   *   @param operation [String] the name of the operation to call
   *   @param params [map] parameters to pass to the operation. See the given
   *      operation for the expected operation parameters. In addition, you can
   *      also pass the "Expires" parameter to inform S3 how long the URL should
   *      work for.
   *   @option params Expires [Integer] (900) the number of seconds to expire
   *      the pre-signed URL operation in. Defaults to 15 minutes.
   *   @callback fulfilledCallback function(url)
   *     Called if the promise is fulfilled.
   *     @param url [String] the signed url
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] if an error occurred, this value will be filled
   *   @return [Promise] A promise that represents the state of the `refresh` call.
   *   @example Pre-signing a getObject operation
   *      var params = {Bucket: 'bucket', Key: 'key'};
   *      var promise = s3.getSignedUrlPromise('getObject', params);
   *      promise.then(function(url) {
   *        console.log('The URL is', url);
   *      }, function(err) { ... });
   *   @example Pre-signing a putObject operation with a specific payload
   *      var params = {Bucket: 'bucket', Key: 'key', Body: 'body'};
   *      var promise = s3.getSignedUrlPromise('putObject', params);
   *      promise.then(function(url) {
   *        console.log('The URL is', url);
   *      }, function(err) { ... });
   *   @example Passing in a 1-minute expiry time for a pre-signed URL
   *      var params = {Bucket: 'bucket', Key: 'key', Expires: 60};
   *      var promise = s3.getSignedUrlPromise('getObject', params);
   *      promise.then(function(url) {
   *        console.log('The URL is', url);
   *      }, function(err) { ... });
   */

  /**
   * Get a pre-signed POST policy to support uploading to S3 directly from an
   * HTML form.
   *
   * @param params [map]
   * @option params Bucket [String]     The bucket to which the post should be
   *                                    uploaded
   * @option params Expires [Integer]   (3600) The number of seconds for which
   *                                    the presigned policy should be valid.
   * @option params Conditions [Array]  An array of conditions that must be met
   *                                    for the presigned policy to allow the
   *                                    upload. This can include required tags,
   *                                    the accepted range for content lengths,
   *                                    etc.
   * @see http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-HTTPPOSTConstructPolicy.html
   * @option params Fields [map]        Fields to include in the form. All
   *                                    values passed in as fields will be
   *                                    signed as exact match conditions.
   * @param callback [Function]
   *
   * @note All fields passed in when creating presigned post data will be signed
   *   as exact match conditions. Any fields that will be interpolated by S3
   *   must be added to the fields hash after signing, and an appropriate
   *   condition for such fields must be explicitly added to the Conditions
   *   array passed to this function before signing.
   *
   * @example Presiging post data with a known key
   *   var params = {
   *     Bucket: 'bucket',
   *     Fields: {
   *       key: 'key'
   *     }
   *   };
   *   s3.createPresignedPost(params, function(err, data) {
   *     if (err) {
   *       console.error('Presigning post data encountered an error', err);
   *     } else {
   *       console.log('The post data is', data);
   *     }
   *   });
   *
   * @example Presigning post data with an interpolated key
   *   var params = {
   *     Bucket: 'bucket',
   *     Conditions: [
   *       ['starts-with', '$key', 'path/to/uploads/']
   *     ]
   *   };
   *   s3.createPresignedPost(params, function(err, data) {
   *     if (err) {
   *       console.error('Presigning post data encountered an error', err);
   *     } else {
   *       data.Fields.key = 'path/to/uploads/${filename}';
   *       console.log('The post data is', data);
   *     }
   *   });
   *
   * @note You must ensure that you have static or previously resolved
   *   credentials if you call this method synchronously (with no callback),
   *   otherwise it may not properly sign the request. If you cannot guarantee
   *   this (you are using an asynchronous credential provider, i.e., EC2
   *   IAM roles), you should always call this method with an asynchronous
   *   callback.
   *
   * @return [map]  If called synchronously (with no callback), returns a hash
   *                with the url to set as the form action and a hash of fields
   *                to include in the form.
   * @return [null] Nothing is returned if a callback is provided.
   *
   * @callback callback function (err, data)
   *  @param err [Error] the error object returned from the policy signer
   *  @param data [map] The data necessary to construct an HTML form
   *  @param data.url [String] The URL to use as the action of the form
   *  @param data.fields [map] A hash of fields that must be included in the
   *                           form for the upload to succeed. This hash will
   *                           include the signed POST policy, your access key
   *                           ID and security token (if present), etc. These
   *                           may be safely included as input elements of type
   *                           'hidden.'
   */
  createPresignedPost: function createPresignedPost(params, callback) {
    if (typeof params === 'function' && callback === undefined) {
      callback = params;
      params = null;
    }

    params = AWS.util.copy(params || {});
    var boundParams = this.config.params || {};
    var bucket = params.Bucket || boundParams.Bucket,
      self = this,
      config = this.config,
      endpoint = AWS.util.copy(this.endpoint);
    if (!config.s3BucketEndpoint) {
      endpoint.pathname = '/' + bucket;
    }

    function finalizePost() {
      return {
        url: AWS.util.urlFormat(endpoint),
        fields: self.preparePostFields(
          config.credentials,
          config.region,
          bucket,
          params.Fields,
          params.Conditions,
          params.Expires
        )
      };
    }

    if (callback) {
      config.getCredentials(function (err) {
        if (err) {
          callback(err);
        }

        callback(null, finalizePost());
      });
    } else {
      return finalizePost();
    }
  },

  /**
   * @api private
   */
  preparePostFields: function preparePostFields(
    credentials,
    region,
    bucket,
    fields,
    conditions,
    expiresInSeconds
  ) {
    var now = this.getSkewCorrectedDate();
    if (!credentials || !region || !bucket) {
      throw new Error('Unable to create a POST object policy without a bucket,'
        + ' region, and credentials');
    }
    fields = AWS.util.copy(fields || {});
    conditions = (conditions || []).slice(0);
    expiresInSeconds = expiresInSeconds || 3600;

    var signingDate = AWS.util.date.iso8601(now).replace(/[:\-]|\.\d{3}/g, '');
    var shortDate = signingDate.substr(0, 8);
    var scope = v4Credentials.createScope(shortDate, region, 's3');
    var credential = credentials.accessKeyId + '/' + scope;

    fields['bucket'] = bucket;
    fields['X-Amz-Algorithm'] = 'AWS4-HMAC-SHA256';
    fields['X-Amz-Credential'] = credential;
    fields['X-Amz-Date'] = signingDate;
    if (credentials.sessionToken) {
      fields['X-Amz-Security-Token'] = credentials.sessionToken;
    }
    for (var field in fields) {
      if (fields.hasOwnProperty(field)) {
        var condition = {};
        condition[field] = fields[field];
        conditions.push(condition);
      }
    }

    fields.Policy = this.preparePostPolicy(
      new Date(now.valueOf() + expiresInSeconds * 1000),
      conditions
    );
    fields['X-Amz-Signature'] = AWS.util.crypto.hmac(
      v4Credentials.getSigningKey(credentials, shortDate, region, 's3', true),
      fields.Policy,
      'hex'
    );

    return fields;
  },

  /**
   * @api private
   */
  preparePostPolicy: function preparePostPolicy(expiration, conditions) {
    return AWS.util.base64.encode(JSON.stringify({
      expiration: AWS.util.date.iso8601(expiration),
      conditions: conditions
    }));
  },

  /**
   * @api private
   */
  prepareSignedUrl: function prepareSignedUrl(request) {
    request.addListener('validate', request.service.noPresignedContentLength);
    request.removeListener('build', request.service.addContentType);
    if (!request.params.Body) {
      // no Content-MD5/SHA-256 if body is not provided
      request.removeListener('build', request.service.computeContentMd5);
    } else {
      request.addListener('afterBuild', AWS.EventListeners.Core.COMPUTE_SHA256);
    }
  },

  /**
   * @api private
   * @param request
   */
  disableBodySigning: function disableBodySigning(request) {
    var headers = request.httpRequest.headers;
    // Add the header to anything that isn't a presigned url, unless that presigned url had a body defined
    if (!Object.prototype.hasOwnProperty.call(headers, 'presigned-expires')) {
      headers['X-Amz-Content-Sha256'] = 'UNSIGNED-PAYLOAD';
    }
  },

  /**
   * @api private
   */
  noPresignedContentLength: function noPresignedContentLength(request) {
    if (request.params.ContentLength !== undefined) {
      throw AWS.util.error(new Error(), {code: 'UnexpectedParameter',
        message: 'ContentLength is not supported in pre-signed URLs.'});
    }
  },

  createBucket: function createBucket(params, callback) {
    // When creating a bucket *outside* the classic region, the location
    // constraint must be set for the bucket and it must match the endpoint.
    // This chunk of code will set the location constraint param based
    // on the region (when possible), but it will not override a passed-in
    // location constraint.
    if (typeof params === 'function' || !params) {
      callback = callback || params;
      params = {};
    }
    var hostname = this.endpoint.hostname;
    if (hostname !== this.api.globalEndpoint && !params.CreateBucketConfiguration) {
      params.CreateBucketConfiguration = { LocationConstraint: this.config.region };
    }
    return this.makeRequest('createBucket', params, callback);
  },

  /**
   * @see AWS.S3.ManagedUpload
   * @overload upload(params = {}, [options], [callback])
   *   Uploads an arbitrarily sized buffer, blob, or stream, using intelligent
   *   concurrent handling of parts if the payload is large enough. You can
   *   configure the concurrent queue size by setting `options`. Note that this
   *   is the only operation for which the SDK can retry requests with stream
   *   bodies.
   *
   *   @param (see AWS.S3.putObject)
   *   @option (see AWS.S3.ManagedUpload.constructor)
   *   @return [AWS.S3.ManagedUpload] the managed upload object that can call
   *     `send()` or track progress.
   *   @example Uploading a stream object
   *     var params = {Bucket: 'bucket', Key: 'key', Body: stream};
   *     s3.upload(params, function(err, data) {
   *       console.log(err, data);
   *     });
   *   @example Uploading a stream with concurrency of 1 and partSize of 10mb
   *     var params = {Bucket: 'bucket', Key: 'key', Body: stream};
   *     var options = {partSize: 10 * 1024 * 1024, queueSize: 1};
   *     s3.upload(params, options, function(err, data) {
   *       console.log(err, data);
   *     });
   * @callback callback function(err, data)
   *   @param err [Error] an error or null if no error occurred.
   *   @param data [map] The response data from the successful upload:
   *   @param data.Location [String] the URL of the uploaded object
   *   @param data.ETag [String] the ETag of the uploaded object
   *   @param data.Bucket [String]  the bucket to which the object was uploaded
   *   @param data.Key [String] the key to which the object was uploaded
   */
  upload: function upload(params, options, callback) {
    if (typeof options === 'function' && callback === undefined) {
      callback = options;
      options = null;
    }

    options = options || {};
    options = AWS.util.merge(options || {}, {service: this, params: params});

    var uploader = new AWS.S3.ManagedUpload(options);
    if (typeof callback === 'function') uploader.send(callback);
    return uploader;
  }
});

/**
 * @api private
 */
AWS.S3.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.getSignedUrlPromise = AWS.util.promisifyMethod('getSignedUrl', PromiseDependency);
};

/**
 * @api private
 */
AWS.S3.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.getSignedUrlPromise;
};

AWS.util.addPromises(AWS.S3);

}).call(this,require('_process'))

},{"../config_regional_endpoint":22,"../core":23,"../region_config":58,"../s3/managed_upload":63,"../signers/v4_credentials":76,"_process":95}],68:[function(require,module,exports){
var AWS = require('../core');
var resolveRegionalEndpointsFlag = require('../config_regional_endpoint');
var ENV_REGIONAL_ENDPOINT_ENABLED = 'AWS_STS_REGIONAL_ENDPOINTS';
var CONFIG_REGIONAL_ENDPOINT_ENABLED = 'sts_regional_endpoints';

AWS.util.update(AWS.STS.prototype, {
  /**
   * @overload credentialsFrom(data, credentials = null)
   *   Creates a credentials object from STS response data containing
   *   credentials information. Useful for quickly setting AWS credentials.
   *
   *   @note This is a low-level utility function. If you want to load temporary
   *     credentials into your process for subsequent requests to AWS resources,
   *     you should use {AWS.TemporaryCredentials} instead.
   *   @param data [map] data retrieved from a call to {getFederatedToken},
   *     {getSessionToken}, {assumeRole}, or {assumeRoleWithWebIdentity}.
   *   @param credentials [AWS.Credentials] an optional credentials object to
   *     fill instead of creating a new object. Useful when modifying an
   *     existing credentials object from a refresh call.
   *   @return [AWS.TemporaryCredentials] the set of temporary credentials
   *     loaded from a raw STS operation response.
   *   @example Using credentialsFrom to load global AWS credentials
   *     var sts = new AWS.STS();
   *     sts.getSessionToken(function (err, data) {
   *       if (err) console.log("Error getting credentials");
   *       else {
   *         AWS.config.credentials = sts.credentialsFrom(data);
   *       }
   *     });
   *   @see AWS.TemporaryCredentials
   */
  credentialsFrom: function credentialsFrom(data, credentials) {
    if (!data) return null;
    if (!credentials) credentials = new AWS.TemporaryCredentials();
    credentials.expired = false;
    credentials.accessKeyId = data.Credentials.AccessKeyId;
    credentials.secretAccessKey = data.Credentials.SecretAccessKey;
    credentials.sessionToken = data.Credentials.SessionToken;
    credentials.expireTime = data.Credentials.Expiration;
    return credentials;
  },

  assumeRoleWithWebIdentity: function assumeRoleWithWebIdentity(params, callback) {
    return this.makeUnauthenticatedRequest('assumeRoleWithWebIdentity', params, callback);
  },

  assumeRoleWithSAML: function assumeRoleWithSAML(params, callback) {
    return this.makeUnauthenticatedRequest('assumeRoleWithSAML', params, callback);
  },

  /**
   * @api private
   */
  setupRequestListeners: function setupRequestListeners(request) {
    request.addListener('validate', this.optInRegionalEndpoint, true);
  },

  /**
   * @api private
   */
  optInRegionalEndpoint: function optInRegionalEndpoint(req) {
    var service = req.service;
    var config = service.config;
    config.stsRegionalEndpoints = resolveRegionalEndpointsFlag(service._originalConfig, {
      env: ENV_REGIONAL_ENDPOINT_ENABLED,
      sharedConfig: CONFIG_REGIONAL_ENDPOINT_ENABLED,
      clientConfig: 'stsRegionalEndpoints'
    });
    if (
      config.stsRegionalEndpoints === 'regional' &&
      service.isGlobalEndpoint
    ) {
      //client will throw if region is not supplied; request will be signed with specified region
      if (!config.region) {
        throw AWS.util.error(new Error(),
          {code: 'ConfigError', message: 'Missing region in config'});
      }
      var insertPoint = config.endpoint.indexOf('.amazonaws.com');
      var regionalEndpoint = config.endpoint.substring(0, insertPoint) +
        '.' + config.region + config.endpoint.substring(insertPoint);
      req.httpRequest.updateEndpoint(regionalEndpoint);
      req.httpRequest.region = config.region;
    }
  }

});

},{"../config_regional_endpoint":22,"../core":23}],69:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;

/**
 * @api private
 */
var expiresHeader = 'presigned-expires';

/**
 * @api private
 */
function signedUrlBuilder(request) {
  var expires = request.httpRequest.headers[expiresHeader];
  var signerClass = request.service.getSignerClass(request);

  delete request.httpRequest.headers['User-Agent'];
  delete request.httpRequest.headers['X-Amz-User-Agent'];

  if (signerClass === AWS.Signers.V4) {
    if (expires > 604800) { // one week expiry is invalid
      var message = 'Presigning does not support expiry time greater ' +
                    'than a week with SigV4 signing.';
      throw AWS.util.error(new Error(), {
        code: 'InvalidExpiryTime', message: message, retryable: false
      });
    }
    request.httpRequest.headers[expiresHeader] = expires;
  } else if (signerClass === AWS.Signers.S3) {
    var now = request.service ? request.service.getSkewCorrectedDate() : AWS.util.date.getDate();
    request.httpRequest.headers[expiresHeader] = parseInt(
      AWS.util.date.unixTimestamp(now) + expires, 10).toString();
  } else {
    throw AWS.util.error(new Error(), {
      message: 'Presigning only supports S3 or SigV4 signing.',
      code: 'UnsupportedSigner', retryable: false
    });
  }
}

/**
 * @api private
 */
function signedUrlSigner(request) {
  var endpoint = request.httpRequest.endpoint;
  var parsedUrl = AWS.util.urlParse(request.httpRequest.path);
  var queryParams = {};

  if (parsedUrl.search) {
    queryParams = AWS.util.queryStringParse(parsedUrl.search.substr(1));
  }

  var auth = request.httpRequest.headers['Authorization'].split(' ');
  if (auth[0] === 'AWS') {
    auth = auth[1].split(':');
    queryParams['AWSAccessKeyId'] = auth[0];
    queryParams['Signature'] = auth[1];

    AWS.util.each(request.httpRequest.headers, function (key, value) {
      if (key === expiresHeader) key = 'Expires';
      if (key.indexOf('x-amz-meta-') === 0) {
        // Delete existing, potentially not normalized key
        delete queryParams[key];
        key = key.toLowerCase();
      }
      queryParams[key] = value;
    });
    delete request.httpRequest.headers[expiresHeader];
    delete queryParams['Authorization'];
    delete queryParams['Host'];
  } else if (auth[0] === 'AWS4-HMAC-SHA256') { // SigV4 signing
    auth.shift();
    var rest = auth.join(' ');
    var signature = rest.match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];
    queryParams['X-Amz-Signature'] = signature;
    delete queryParams['Expires'];
  }

  // build URL
  endpoint.pathname = parsedUrl.pathname;
  endpoint.search = AWS.util.queryParamsToString(queryParams);
}

/**
 * @api private
 */
AWS.Signers.Presign = inherit({
  /**
   * @api private
   */
  sign: function sign(request, expireTime, callback) {
    request.httpRequest.headers[expiresHeader] = expireTime || 3600;
    request.on('build', signedUrlBuilder);
    request.on('sign', signedUrlSigner);
    request.removeListener('afterBuild',
      AWS.EventListeners.Core.SET_CONTENT_LENGTH);
    request.removeListener('afterBuild',
      AWS.EventListeners.Core.COMPUTE_SHA256);

    request.emit('beforePresign', [request]);

    if (callback) {
      request.build(function() {
        if (this.response.error) callback(this.response.error);
        else {
          callback(null, AWS.util.urlFormat(request.httpRequest.endpoint));
        }
      });
    } else {
      request.build();
      if (request.response.error) throw request.response.error;
      return AWS.util.urlFormat(request.httpRequest.endpoint);
    }
  }
});

/**
 * @api private
 */
module.exports = AWS.Signers.Presign;

},{"../core":23}],70:[function(require,module,exports){
var AWS = require('../core');

var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.RequestSigner = inherit({
  constructor: function RequestSigner(request) {
    this.request = request;
  },

  setServiceClientId: function setServiceClientId(id) {
    this.serviceClientId = id;
  },

  getServiceClientId: function getServiceClientId() {
    return this.serviceClientId;
  }
});

AWS.Signers.RequestSigner.getVersion = function getVersion(version) {
  switch (version) {
    case 'v2': return AWS.Signers.V2;
    case 'v3': return AWS.Signers.V3;
    case 's3v4': return AWS.Signers.V4;
    case 'v4': return AWS.Signers.V4;
    case 's3': return AWS.Signers.S3;
    case 'v3https': return AWS.Signers.V3Https;
  }
  throw new Error('Unknown signing version ' + version);
};

require('./v2');
require('./v3');
require('./v3https');
require('./v4');
require('./s3');
require('./presign');

},{"../core":23,"./presign":69,"./s3":71,"./v2":72,"./v3":73,"./v3https":74,"./v4":75}],71:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.S3 = inherit(AWS.Signers.RequestSigner, {
  /**
   * When building the stringToSign, these sub resource params should be
   * part of the canonical resource string with their NON-decoded values
   */
  subResources: {
    'acl': 1,
    'accelerate': 1,
    'analytics': 1,
    'cors': 1,
    'lifecycle': 1,
    'delete': 1,
    'inventory': 1,
    'location': 1,
    'logging': 1,
    'metrics': 1,
    'notification': 1,
    'partNumber': 1,
    'policy': 1,
    'requestPayment': 1,
    'replication': 1,
    'restore': 1,
    'tagging': 1,
    'torrent': 1,
    'uploadId': 1,
    'uploads': 1,
    'versionId': 1,
    'versioning': 1,
    'versions': 1,
    'website': 1
  },

  // when building the stringToSign, these querystring params should be
  // part of the canonical resource string with their NON-encoded values
  responseHeaders: {
    'response-content-type': 1,
    'response-content-language': 1,
    'response-expires': 1,
    'response-cache-control': 1,
    'response-content-disposition': 1,
    'response-content-encoding': 1
  },

  addAuthorization: function addAuthorization(credentials, date) {
    if (!this.request.headers['presigned-expires']) {
      this.request.headers['X-Amz-Date'] = AWS.util.date.rfc822(date);
    }

    if (credentials.sessionToken) {
      // presigned URLs require this header to be lowercased
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }

    var signature = this.sign(credentials.secretAccessKey, this.stringToSign());
    var auth = 'AWS ' + credentials.accessKeyId + ':' + signature;

    this.request.headers['Authorization'] = auth;
  },

  stringToSign: function stringToSign() {
    var r = this.request;

    var parts = [];
    parts.push(r.method);
    parts.push(r.headers['Content-MD5'] || '');
    parts.push(r.headers['Content-Type'] || '');

    // This is the "Date" header, but we use X-Amz-Date.
    // The S3 signing mechanism requires us to pass an empty
    // string for this Date header regardless.
    parts.push(r.headers['presigned-expires'] || '');

    var headers = this.canonicalizedAmzHeaders();
    if (headers) parts.push(headers);
    parts.push(this.canonicalizedResource());

    return parts.join('\n');

  },

  canonicalizedAmzHeaders: function canonicalizedAmzHeaders() {

    var amzHeaders = [];

    AWS.util.each(this.request.headers, function (name) {
      if (name.match(/^x-amz-/i))
        amzHeaders.push(name);
    });

    amzHeaders.sort(function (a, b) {
      return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
    });

    var parts = [];
    AWS.util.arrayEach.call(this, amzHeaders, function (name) {
      parts.push(name.toLowerCase() + ':' + String(this.request.headers[name]));
    });

    return parts.join('\n');

  },

  canonicalizedResource: function canonicalizedResource() {

    var r = this.request;

    var parts = r.path.split('?');
    var path = parts[0];
    var querystring = parts[1];

    var resource = '';

    if (r.virtualHostedBucket)
      resource += '/' + r.virtualHostedBucket;

    resource += path;

    if (querystring) {

      // collect a list of sub resources and query params that need to be signed
      var resources = [];

      AWS.util.arrayEach.call(this, querystring.split('&'), function (param) {
        var name = param.split('=')[0];
        var value = param.split('=')[1];
        if (this.subResources[name] || this.responseHeaders[name]) {
          var subresource = { name: name };
          if (value !== undefined) {
            if (this.subResources[name]) {
              subresource.value = value;
            } else {
              subresource.value = decodeURIComponent(value);
            }
          }
          resources.push(subresource);
        }
      });

      resources.sort(function (a, b) { return a.name < b.name ? -1 : 1; });

      if (resources.length) {

        querystring = [];
        AWS.util.arrayEach(resources, function (res) {
          if (res.value === undefined) {
            querystring.push(res.name);
          } else {
            querystring.push(res.name + '=' + res.value);
          }
        });

        resource += '?' + querystring.join('&');
      }

    }

    return resource;

  },

  sign: function sign(secret, string) {
    return AWS.util.crypto.hmac(secret, string, 'base64', 'sha1');
  }
});

/**
 * @api private
 */
module.exports = AWS.Signers.S3;

},{"../core":23}],72:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.V2 = inherit(AWS.Signers.RequestSigner, {
  addAuthorization: function addAuthorization(credentials, date) {

    if (!date) date = AWS.util.date.getDate();

    var r = this.request;

    r.params.Timestamp = AWS.util.date.iso8601(date);
    r.params.SignatureVersion = '2';
    r.params.SignatureMethod = 'HmacSHA256';
    r.params.AWSAccessKeyId = credentials.accessKeyId;

    if (credentials.sessionToken) {
      r.params.SecurityToken = credentials.sessionToken;
    }

    delete r.params.Signature; // delete old Signature for re-signing
    r.params.Signature = this.signature(credentials);

    r.body = AWS.util.queryParamsToString(r.params);
    r.headers['Content-Length'] = r.body.length;
  },

  signature: function signature(credentials) {
    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
  },

  stringToSign: function stringToSign() {
    var parts = [];
    parts.push(this.request.method);
    parts.push(this.request.endpoint.host.toLowerCase());
    parts.push(this.request.pathname());
    parts.push(AWS.util.queryParamsToString(this.request.params));
    return parts.join('\n');
  }

});

/**
 * @api private
 */
module.exports = AWS.Signers.V2;

},{"../core":23}],73:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.V3 = inherit(AWS.Signers.RequestSigner, {
  addAuthorization: function addAuthorization(credentials, date) {

    var datetime = AWS.util.date.rfc822(date);

    this.request.headers['X-Amz-Date'] = datetime;

    if (credentials.sessionToken) {
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }

    this.request.headers['X-Amzn-Authorization'] =
      this.authorization(credentials, datetime);

  },

  authorization: function authorization(credentials) {
    return 'AWS3 ' +
      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
      'Algorithm=HmacSHA256,' +
      'SignedHeaders=' + this.signedHeaders() + ',' +
      'Signature=' + this.signature(credentials);
  },

  signedHeaders: function signedHeaders() {
    var headers = [];
    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
      headers.push(h.toLowerCase());
    });
    return headers.sort().join(';');
  },

  canonicalHeaders: function canonicalHeaders() {
    var headers = this.request.headers;
    var parts = [];
    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
      parts.push(h.toLowerCase().trim() + ':' + String(headers[h]).trim());
    });
    return parts.sort().join('\n') + '\n';
  },

  headersToSign: function headersToSign() {
    var headers = [];
    AWS.util.each(this.request.headers, function iterator(k) {
      if (k === 'Host' || k === 'Content-Encoding' || k.match(/^X-Amz/i)) {
        headers.push(k);
      }
    });
    return headers;
  },

  signature: function signature(credentials) {
    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
  },

  stringToSign: function stringToSign() {
    var parts = [];
    parts.push(this.request.method);
    parts.push('/');
    parts.push('');
    parts.push(this.canonicalHeaders());
    parts.push(this.request.body);
    return AWS.util.crypto.sha256(parts.join('\n'));
  }

});

/**
 * @api private
 */
module.exports = AWS.Signers.V3;

},{"../core":23}],74:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;

require('./v3');

/**
 * @api private
 */
AWS.Signers.V3Https = inherit(AWS.Signers.V3, {
  authorization: function authorization(credentials) {
    return 'AWS3-HTTPS ' +
      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
      'Algorithm=HmacSHA256,' +
      'Signature=' + this.signature(credentials);
  },

  stringToSign: function stringToSign() {
    return this.request.headers['X-Amz-Date'];
  }
});

/**
 * @api private
 */
module.exports = AWS.Signers.V3Https;

},{"../core":23,"./v3":73}],75:[function(require,module,exports){
var AWS = require('../core');
var v4Credentials = require('./v4_credentials');
var inherit = AWS.util.inherit;

/**
 * @api private
 */
var expiresHeader = 'presigned-expires';

/**
 * @api private
 */
AWS.Signers.V4 = inherit(AWS.Signers.RequestSigner, {
  constructor: function V4(request, serviceName, options) {
    AWS.Signers.RequestSigner.call(this, request);
    this.serviceName = serviceName;
    options = options || {};
    this.signatureCache = typeof options.signatureCache === 'boolean' ? options.signatureCache : true;
    this.operation = options.operation;
    this.signatureVersion = options.signatureVersion;
  },

  algorithm: 'AWS4-HMAC-SHA256',

  addAuthorization: function addAuthorization(credentials, date) {
    var datetime = AWS.util.date.iso8601(date).replace(/[:\-]|\.\d{3}/g, '');

    if (this.isPresigned()) {
      this.updateForPresigned(credentials, datetime);
    } else {
      this.addHeaders(credentials, datetime);
    }

    this.request.headers['Authorization'] =
      this.authorization(credentials, datetime);
  },

  addHeaders: function addHeaders(credentials, datetime) {
    this.request.headers['X-Amz-Date'] = datetime;
    if (credentials.sessionToken) {
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }
  },

  updateForPresigned: function updateForPresigned(credentials, datetime) {
    var credString = this.credentialString(datetime);
    var qs = {
      'X-Amz-Date': datetime,
      'X-Amz-Algorithm': this.algorithm,
      'X-Amz-Credential': credentials.accessKeyId + '/' + credString,
      'X-Amz-Expires': this.request.headers[expiresHeader],
      'X-Amz-SignedHeaders': this.signedHeaders()
    };

    if (credentials.sessionToken) {
      qs['X-Amz-Security-Token'] = credentials.sessionToken;
    }

    if (this.request.headers['Content-Type']) {
      qs['Content-Type'] = this.request.headers['Content-Type'];
    }
    if (this.request.headers['Content-MD5']) {
      qs['Content-MD5'] = this.request.headers['Content-MD5'];
    }
    if (this.request.headers['Cache-Control']) {
      qs['Cache-Control'] = this.request.headers['Cache-Control'];
    }

    // need to pull in any other X-Amz-* headers
    AWS.util.each.call(this, this.request.headers, function(key, value) {
      if (key === expiresHeader) return;
      if (this.isSignableHeader(key)) {
        var lowerKey = key.toLowerCase();
        // Metadata should be normalized
        if (lowerKey.indexOf('x-amz-meta-') === 0) {
          qs[lowerKey] = value;
        } else if (lowerKey.indexOf('x-amz-') === 0) {
          qs[key] = value;
        }
      }
    });

    var sep = this.request.path.indexOf('?') >= 0 ? '&' : '?';
    this.request.path += sep + AWS.util.queryParamsToString(qs);
  },

  authorization: function authorization(credentials, datetime) {
    var parts = [];
    var credString = this.credentialString(datetime);
    parts.push(this.algorithm + ' Credential=' +
      credentials.accessKeyId + '/' + credString);
    parts.push('SignedHeaders=' + this.signedHeaders());
    parts.push('Signature=' + this.signature(credentials, datetime));
    return parts.join(', ');
  },

  signature: function signature(credentials, datetime) {
    var signingKey = v4Credentials.getSigningKey(
      credentials,
      datetime.substr(0, 8),
      this.request.region,
      this.serviceName,
      this.signatureCache
    );
    return AWS.util.crypto.hmac(signingKey, this.stringToSign(datetime), 'hex');
  },

  stringToSign: function stringToSign(datetime) {
    var parts = [];
    parts.push('AWS4-HMAC-SHA256');
    parts.push(datetime);
    parts.push(this.credentialString(datetime));
    parts.push(this.hexEncodedHash(this.canonicalString()));
    return parts.join('\n');
  },

  canonicalString: function canonicalString() {
    var parts = [], pathname = this.request.pathname();
    if (this.serviceName !== 's3' && this.signatureVersion !== 's3v4') pathname = AWS.util.uriEscapePath(pathname);

    parts.push(this.request.method);
    parts.push(pathname);
    parts.push(this.request.search());
    parts.push(this.canonicalHeaders() + '\n');
    parts.push(this.signedHeaders());
    parts.push(this.hexEncodedBodyHash());
    return parts.join('\n');
  },

  canonicalHeaders: function canonicalHeaders() {
    var headers = [];
    AWS.util.each.call(this, this.request.headers, function (key, item) {
      headers.push([key, item]);
    });
    headers.sort(function (a, b) {
      return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : 1;
    });
    var parts = [];
    AWS.util.arrayEach.call(this, headers, function (item) {
      var key = item[0].toLowerCase();
      if (this.isSignableHeader(key)) {
        var value = item[1];
        if (typeof value === 'undefined' || value === null || typeof value.toString !== 'function') {
          throw AWS.util.error(new Error('Header ' + key + ' contains invalid value'), {
            code: 'InvalidHeader'
          });
        }
        parts.push(key + ':' +
          this.canonicalHeaderValues(value.toString()));
      }
    });
    return parts.join('\n');
  },

  canonicalHeaderValues: function canonicalHeaderValues(values) {
    return values.replace(/\s+/g, ' ').replace(/^\s+|\s+$/g, '');
  },

  signedHeaders: function signedHeaders() {
    var keys = [];
    AWS.util.each.call(this, this.request.headers, function (key) {
      key = key.toLowerCase();
      if (this.isSignableHeader(key)) keys.push(key);
    });
    return keys.sort().join(';');
  },

  credentialString: function credentialString(datetime) {
    return v4Credentials.createScope(
      datetime.substr(0, 8),
      this.request.region,
      this.serviceName
    );
  },

  hexEncodedHash: function hash(string) {
    return AWS.util.crypto.sha256(string, 'hex');
  },

  hexEncodedBodyHash: function hexEncodedBodyHash() {
    var request = this.request;
    if (this.isPresigned() && this.serviceName === 's3' && !request.body) {
      return 'UNSIGNED-PAYLOAD';
    } else if (request.headers['X-Amz-Content-Sha256']) {
      return request.headers['X-Amz-Content-Sha256'];
    } else {
      return this.hexEncodedHash(this.request.body || '');
    }
  },

  unsignableHeaders: [
    'authorization',
    'content-type',
    'content-length',
    'user-agent',
    expiresHeader,
    'expect',
    'x-amzn-trace-id'
  ],

  isSignableHeader: function isSignableHeader(key) {
    if (key.toLowerCase().indexOf('x-amz-') === 0) return true;
    return this.unsignableHeaders.indexOf(key) < 0;
  },

  isPresigned: function isPresigned() {
    return this.request.headers[expiresHeader] ? true : false;
  }

});

/**
 * @api private
 */
module.exports = AWS.Signers.V4;

},{"../core":23,"./v4_credentials":76}],76:[function(require,module,exports){
var AWS = require('../core');

/**
 * @api private
 */
var cachedSecret = {};

/**
 * @api private
 */
var cacheQueue = [];

/**
 * @api private
 */
var maxCacheEntries = 50;

/**
 * @api private
 */
var v4Identifier = 'aws4_request';

/**
 * @api private
 */
module.exports = {
  /**
   * @api private
   *
   * @param date [String]
   * @param region [String]
   * @param serviceName [String]
   * @return [String]
   */
  createScope: function createScope(date, region, serviceName) {
    return [
      date.substr(0, 8),
      region,
      serviceName,
      v4Identifier
    ].join('/');
  },

  /**
   * @api private
   *
   * @param credentials [Credentials]
   * @param date [String]
   * @param region [String]
   * @param service [String]
   * @param shouldCache [Boolean]
   * @return [String]
   */
  getSigningKey: function getSigningKey(
    credentials,
    date,
    region,
    service,
    shouldCache
  ) {
    var credsIdentifier = AWS.util.crypto
      .hmac(credentials.secretAccessKey, credentials.accessKeyId, 'base64');
    var cacheKey = [credsIdentifier, date, region, service].join('_');
    shouldCache = shouldCache !== false;
    if (shouldCache && (cacheKey in cachedSecret)) {
      return cachedSecret[cacheKey];
    }

    var kDate = AWS.util.crypto.hmac(
      'AWS4' + credentials.secretAccessKey,
      date,
      'buffer'
    );
    var kRegion = AWS.util.crypto.hmac(kDate, region, 'buffer');
    var kService = AWS.util.crypto.hmac(kRegion, service, 'buffer');

    var signingKey = AWS.util.crypto.hmac(kService, v4Identifier, 'buffer');
    if (shouldCache) {
      cachedSecret[cacheKey] = signingKey;
      cacheQueue.push(cacheKey);
      if (cacheQueue.length > maxCacheEntries) {
        // remove the oldest entry (not the least recently used)
        delete cachedSecret[cacheQueue.shift()];
      }
    }

    return signingKey;
  },

  /**
   * @api private
   *
   * Empties the derived signing key cache. Made available for testing purposes
   * only.
   */
  emptyCache: function emptyCache() {
    cachedSecret = {};
    cacheQueue = [];
  }
};

},{"../core":23}],77:[function(require,module,exports){
function AcceptorStateMachine(states, state) {
  this.currentState = state || null;
  this.states = states || {};
}

AcceptorStateMachine.prototype.runTo = function runTo(finalState, done, bindObject, inputError) {
  if (typeof finalState === 'function') {
    inputError = bindObject; bindObject = done;
    done = finalState; finalState = null;
  }

  var self = this;
  var state = self.states[self.currentState];
  state.fn.call(bindObject || self, inputError, function(err) {
    if (err) {
      if (state.fail) self.currentState = state.fail;
      else return done ? done.call(bindObject, err) : null;
    } else {
      if (state.accept) self.currentState = state.accept;
      else return done ? done.call(bindObject) : null;
    }
    if (self.currentState === finalState) {
      return done ? done.call(bindObject, err) : null;
    }

    self.runTo(finalState, done, bindObject, err);
  });
};

AcceptorStateMachine.prototype.addState = function addState(name, acceptState, failState, fn) {
  if (typeof acceptState === 'function') {
    fn = acceptState; acceptState = null; failState = null;
  } else if (typeof failState === 'function') {
    fn = failState; failState = null;
  }

  if (!this.currentState) this.currentState = name;
  this.states[name] = { accept: acceptState, fail: failState, fn: fn };
  return this;
};

/**
 * @api private
 */
module.exports = AcceptorStateMachine;

},{}],78:[function(require,module,exports){
(function (process,setImmediate){
/* eslint guard-for-in:0 */
var AWS;

/**
 * A set of utility methods for use with the AWS SDK.
 *
 * @!attribute abort
 *   Return this value from an iterator function {each} or {arrayEach}
 *   to break out of the iteration.
 *   @example Breaking out of an iterator function
 *     AWS.util.each({a: 1, b: 2, c: 3}, function(key, value) {
 *       if (key == 'b') return AWS.util.abort;
 *     });
 *   @see each
 *   @see arrayEach
 * @api private
 */
var util = {
  environment: 'nodejs',
  engine: function engine() {
    if (util.isBrowser() && typeof navigator !== 'undefined') {
      return navigator.userAgent;
    } else {
      var engine = process.platform + '/' + process.version;
      if (process.env.AWS_EXECUTION_ENV) {
        engine += ' exec-env/' + process.env.AWS_EXECUTION_ENV;
      }
      return engine;
    }
  },

  userAgent: function userAgent() {
    var name = util.environment;
    var agent = 'aws-sdk-' + name + '/' + require('./core').VERSION;
    if (name === 'nodejs') agent += ' ' + util.engine();
    return agent;
  },

  uriEscape: function uriEscape(string) {
    var output = encodeURIComponent(string);
    output = output.replace(/[^A-Za-z0-9_.~\-%]+/g, escape);

    // AWS percent-encodes some extra non-standard characters in a URI
    output = output.replace(/[*]/g, function(ch) {
      return '%' + ch.charCodeAt(0).toString(16).toUpperCase();
    });

    return output;
  },

  uriEscapePath: function uriEscapePath(string) {
    var parts = [];
    util.arrayEach(string.split('/'), function (part) {
      parts.push(util.uriEscape(part));
    });
    return parts.join('/');
  },

  urlParse: function urlParse(url) {
    return util.url.parse(url);
  },

  urlFormat: function urlFormat(url) {
    return util.url.format(url);
  },

  queryStringParse: function queryStringParse(qs) {
    return util.querystring.parse(qs);
  },

  queryParamsToString: function queryParamsToString(params) {
    var items = [];
    var escape = util.uriEscape;
    var sortedKeys = Object.keys(params).sort();

    util.arrayEach(sortedKeys, function(name) {
      var value = params[name];
      var ename = escape(name);
      var result = ename + '=';
      if (Array.isArray(value)) {
        var vals = [];
        util.arrayEach(value, function(item) { vals.push(escape(item)); });
        result = ename + '=' + vals.sort().join('&' + ename + '=');
      } else if (value !== undefined && value !== null) {
        result = ename + '=' + escape(value);
      }
      items.push(result);
    });

    return items.join('&');
  },

  readFileSync: function readFileSync(path) {
    if (util.isBrowser()) return null;
    return require('fs').readFileSync(path, 'utf-8');
  },

  base64: {
    encode: function encode64(string) {
      if (typeof string === 'number') {
        throw util.error(new Error('Cannot base64 encode number ' + string));
      }
      if (string === null || typeof string === 'undefined') {
        return string;
      }
      var buf = util.buffer.toBuffer(string);
      return buf.toString('base64');
    },

    decode: function decode64(string) {
      if (typeof string === 'number') {
        throw util.error(new Error('Cannot base64 decode number ' + string));
      }
      if (string === null || typeof string === 'undefined') {
        return string;
      }
      return util.buffer.toBuffer(string, 'base64');
    }

  },

  buffer: {
    /**
     * Buffer constructor for Node buffer and buffer pollyfill
     */
    toBuffer: function(data, encoding) {
      return (typeof util.Buffer.from === 'function' && util.Buffer.from !== Uint8Array.from) ?
        util.Buffer.from(data, encoding) : new util.Buffer(data, encoding);
    },

    alloc: function(size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new Error('size passed to alloc must be a number.');
      }
      if (typeof util.Buffer.alloc === 'function') {
        return util.Buffer.alloc(size, fill, encoding);
      } else {
        var buf = new util.Buffer(size);
        if (fill !== undefined && typeof buf.fill === 'function') {
          buf.fill(fill, undefined, undefined, encoding);
        }
        return buf;
      }
    },

    toStream: function toStream(buffer) {
      if (!util.Buffer.isBuffer(buffer)) buffer =  util.buffer.toBuffer(buffer);

      var readable = new (util.stream.Readable)();
      var pos = 0;
      readable._read = function(size) {
        if (pos >= buffer.length) return readable.push(null);

        var end = pos + size;
        if (end > buffer.length) end = buffer.length;
        readable.push(buffer.slice(pos, end));
        pos = end;
      };

      return readable;
    },

    /**
     * Concatenates a list of Buffer objects.
     */
    concat: function(buffers) {
      var length = 0,
          offset = 0,
          buffer = null, i;

      for (i = 0; i < buffers.length; i++) {
        length += buffers[i].length;
      }

      buffer = util.buffer.alloc(length);

      for (i = 0; i < buffers.length; i++) {
        buffers[i].copy(buffer, offset);
        offset += buffers[i].length;
      }

      return buffer;
    }
  },

  string: {
    byteLength: function byteLength(string) {
      if (string === null || string === undefined) return 0;
      if (typeof string === 'string') string = util.buffer.toBuffer(string);

      if (typeof string.byteLength === 'number') {
        return string.byteLength;
      } else if (typeof string.length === 'number') {
        return string.length;
      } else if (typeof string.size === 'number') {
        return string.size;
      } else if (typeof string.path === 'string') {
        return require('fs').lstatSync(string.path).size;
      } else {
        throw util.error(new Error('Cannot determine length of ' + string),
          { object: string });
      }
    },

    upperFirst: function upperFirst(string) {
      return string[0].toUpperCase() + string.substr(1);
    },

    lowerFirst: function lowerFirst(string) {
      return string[0].toLowerCase() + string.substr(1);
    }
  },

  ini: {
    parse: function string(ini) {
      var currentSection, map = {};
      util.arrayEach(ini.split(/\r?\n/), function(line) {
        line = line.split(/(^|\s)[;#]/)[0]; // remove comments
        var section = line.match(/^\s*\[([^\[\]]+)\]\s*$/);
        if (section) {
          currentSection = section[1];
        } else if (currentSection) {
          var item = line.match(/^\s*(.+?)\s*=\s*(.+?)\s*$/);
          if (item) {
            map[currentSection] = map[currentSection] || {};
            map[currentSection][item[1]] = item[2];
          }
        }
      });

      return map;
    }
  },

  fn: {
    noop: function() {},
    callback: function (err) { if (err) throw err; },

    /**
     * Turn a synchronous function into as "async" function by making it call
     * a callback. The underlying function is called with all but the last argument,
     * which is treated as the callback. The callback is passed passed a first argument
     * of null on success to mimick standard node callbacks.
     */
    makeAsync: function makeAsync(fn, expectedArgs) {
      if (expectedArgs && expectedArgs <= fn.length) {
        return fn;
      }

      return function() {
        var args = Array.prototype.slice.call(arguments, 0);
        var callback = args.pop();
        var result = fn.apply(null, args);
        callback(result);
      };
    }
  },

  /**
   * Date and time utility functions.
   */
  date: {

    /**
     * @return [Date] the current JavaScript date object. Since all
     *   AWS services rely on this date object, you can override
     *   this function to provide a special time value to AWS service
     *   requests.
     */
    getDate: function getDate() {
      if (!AWS) AWS = require('./core');
      if (AWS.config.systemClockOffset) { // use offset when non-zero
        return new Date(new Date().getTime() + AWS.config.systemClockOffset);
      } else {
        return new Date();
      }
    },

    /**
     * @return [String] the date in ISO-8601 format
     */
    iso8601: function iso8601(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
    },

    /**
     * @return [String] the date in RFC 822 format
     */
    rfc822: function rfc822(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.toUTCString();
    },

    /**
     * @return [Integer] the UNIX timestamp value for the current time
     */
    unixTimestamp: function unixTimestamp(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.getTime() / 1000;
    },

    /**
     * @param [String,number,Date] date
     * @return [Date]
     */
    from: function format(date) {
      if (typeof date === 'number') {
        return new Date(date * 1000); // unix timestamp
      } else {
        return new Date(date);
      }
    },

    /**
     * Given a Date or date-like value, this function formats the
     * date into a string of the requested value.
     * @param [String,number,Date] date
     * @param [String] formatter Valid formats are:
     #   * 'iso8601'
     #   * 'rfc822'
     #   * 'unixTimestamp'
     * @return [String]
     */
    format: function format(date, formatter) {
      if (!formatter) formatter = 'iso8601';
      return util.date[formatter](util.date.from(date));
    },

    parseTimestamp: function parseTimestamp(value) {
      if (typeof value === 'number') { // unix timestamp (number)
        return new Date(value * 1000);
      } else if (value.match(/^\d+$/)) { // unix timestamp
        return new Date(value * 1000);
      } else if (value.match(/^\d{4}/)) { // iso8601
        return new Date(value);
      } else if (value.match(/^\w{3},/)) { // rfc822
        return new Date(value);
      } else {
        throw util.error(
          new Error('unhandled timestamp format: ' + value),
          {code: 'TimestampParserError'});
      }
    }

  },

  crypto: {
    crc32Table: [
     0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419,
     0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4,
     0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07,
     0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
     0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856,
     0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
     0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
     0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3,
     0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A,
     0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599,
     0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
     0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190,
     0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
     0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E,
     0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED,
     0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
     0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3,
     0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
     0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
     0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5,
     0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010,
     0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17,
     0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6,
     0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615,
     0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
     0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344,
     0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
     0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A,
     0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1,
     0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C,
     0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
     0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
     0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE,
     0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31,
     0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C,
     0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B,
     0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
     0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1,
     0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
     0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278,
     0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7,
     0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66,
     0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
     0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8,
     0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B,
     0x2D02EF8D],

    crc32: function crc32(data) {
      var tbl = util.crypto.crc32Table;
      var crc = 0 ^ -1;

      if (typeof data === 'string') {
        data = util.buffer.toBuffer(data);
      }

      for (var i = 0; i < data.length; i++) {
        var code = data.readUInt8(i);
        crc = (crc >>> 8) ^ tbl[(crc ^ code) & 0xFF];
      }
      return (crc ^ -1) >>> 0;
    },

    hmac: function hmac(key, string, digest, fn) {
      if (!digest) digest = 'binary';
      if (digest === 'buffer') { digest = undefined; }
      if (!fn) fn = 'sha256';
      if (typeof string === 'string') string = util.buffer.toBuffer(string);
      return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);
    },

    md5: function md5(data, digest, callback) {
      return util.crypto.hash('md5', data, digest, callback);
    },

    sha256: function sha256(data, digest, callback) {
      return util.crypto.hash('sha256', data, digest, callback);
    },

    hash: function(algorithm, data, digest, callback) {
      var hash = util.crypto.createHash(algorithm);
      if (!digest) { digest = 'binary'; }
      if (digest === 'buffer') { digest = undefined; }
      if (typeof data === 'string') data = util.buffer.toBuffer(data);
      var sliceFn = util.arraySliceFn(data);
      var isBuffer = util.Buffer.isBuffer(data);
      //Identifying objects with an ArrayBuffer as buffers
      if (util.isBrowser() && typeof ArrayBuffer !== 'undefined' && data && data.buffer instanceof ArrayBuffer) isBuffer = true;

      if (callback && typeof data === 'object' &&
          typeof data.on === 'function' && !isBuffer) {
        data.on('data', function(chunk) { hash.update(chunk); });
        data.on('error', function(err) { callback(err); });
        data.on('end', function() { callback(null, hash.digest(digest)); });
      } else if (callback && sliceFn && !isBuffer &&
                 typeof FileReader !== 'undefined') {
        // this might be a File/Blob
        var index = 0, size = 1024 * 512;
        var reader = new FileReader();
        reader.onerror = function() {
          callback(new Error('Failed to read data.'));
        };
        reader.onload = function() {
          var buf = new util.Buffer(new Uint8Array(reader.result));
          hash.update(buf);
          index += buf.length;
          reader._continueReading();
        };
        reader._continueReading = function() {
          if (index >= data.size) {
            callback(null, hash.digest(digest));
            return;
          }

          var back = index + size;
          if (back > data.size) back = data.size;
          reader.readAsArrayBuffer(sliceFn.call(data, index, back));
        };

        reader._continueReading();
      } else {
        if (util.isBrowser() && typeof data === 'object' && !isBuffer) {
          data = new util.Buffer(new Uint8Array(data));
        }
        var out = hash.update(data).digest(digest);
        if (callback) callback(null, out);
        return out;
      }
    },

    toHex: function toHex(data) {
      var out = [];
      for (var i = 0; i < data.length; i++) {
        out.push(('0' + data.charCodeAt(i).toString(16)).substr(-2, 2));
      }
      return out.join('');
    },

    createHash: function createHash(algorithm) {
      return util.crypto.lib.createHash(algorithm);
    }

  },

  /** @!ignore */

  /* Abort constant */
  abort: {},

  each: function each(object, iterFunction) {
    for (var key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        var ret = iterFunction.call(this, key, object[key]);
        if (ret === util.abort) break;
      }
    }
  },

  arrayEach: function arrayEach(array, iterFunction) {
    for (var idx in array) {
      if (Object.prototype.hasOwnProperty.call(array, idx)) {
        var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));
        if (ret === util.abort) break;
      }
    }
  },

  update: function update(obj1, obj2) {
    util.each(obj2, function iterator(key, item) {
      obj1[key] = item;
    });
    return obj1;
  },

  merge: function merge(obj1, obj2) {
    return util.update(util.copy(obj1), obj2);
  },

  copy: function copy(object) {
    if (object === null || object === undefined) return object;
    var dupe = {};
    // jshint forin:false
    for (var key in object) {
      dupe[key] = object[key];
    }
    return dupe;
  },

  isEmpty: function isEmpty(obj) {
    for (var prop in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
        return false;
      }
    }
    return true;
  },

  arraySliceFn: function arraySliceFn(obj) {
    var fn = obj.slice || obj.webkitSlice || obj.mozSlice;
    return typeof fn === 'function' ? fn : null;
  },

  isType: function isType(obj, type) {
    // handle cross-"frame" objects
    if (typeof type === 'function') type = util.typeName(type);
    return Object.prototype.toString.call(obj) === '[object ' + type + ']';
  },

  typeName: function typeName(type) {
    if (Object.prototype.hasOwnProperty.call(type, 'name')) return type.name;
    var str = type.toString();
    var match = str.match(/^\s*function (.+)\(/);
    return match ? match[1] : str;
  },

  error: function error(err, options) {
    var originalError = null;
    if (typeof err.message === 'string' && err.message !== '') {
      if (typeof options === 'string' || (options && options.message)) {
        originalError = util.copy(err);
        originalError.message = err.message;
      }
    }
    err.message = err.message || null;

    if (typeof options === 'string') {
      err.message = options;
    } else if (typeof options === 'object' && options !== null) {
      util.update(err, options);
      if (options.message)
        err.message = options.message;
      if (options.code || options.name)
        err.code = options.code || options.name;
      if (options.stack)
        err.stack = options.stack;
    }

    if (typeof Object.defineProperty === 'function') {
      Object.defineProperty(err, 'name', {writable: true, enumerable: false});
      Object.defineProperty(err, 'message', {enumerable: true});
    }

    err.name = options && options.name || err.name || err.code || 'Error';
    err.time = new Date();

    if (originalError) err.originalError = originalError;

    return err;
  },

  /**
   * @api private
   */
  inherit: function inherit(klass, features) {
    var newObject = null;
    if (features === undefined) {
      features = klass;
      klass = Object;
      newObject = {};
    } else {
      var ctor = function ConstructorWrapper() {};
      ctor.prototype = klass.prototype;
      newObject = new ctor();
    }

    // constructor not supplied, create pass-through ctor
    if (features.constructor === Object) {
      features.constructor = function() {
        if (klass !== Object) {
          return klass.apply(this, arguments);
        }
      };
    }

    features.constructor.prototype = newObject;
    util.update(features.constructor.prototype, features);
    features.constructor.__super__ = klass;
    return features.constructor;
  },

  /**
   * @api private
   */
  mixin: function mixin() {
    var klass = arguments[0];
    for (var i = 1; i < arguments.length; i++) {
      // jshint forin:false
      for (var prop in arguments[i].prototype) {
        var fn = arguments[i].prototype[prop];
        if (prop !== 'constructor') {
          klass.prototype[prop] = fn;
        }
      }
    }
    return klass;
  },

  /**
   * @api private
   */
  hideProperties: function hideProperties(obj, props) {
    if (typeof Object.defineProperty !== 'function') return;

    util.arrayEach(props, function (key) {
      Object.defineProperty(obj, key, {
        enumerable: false, writable: true, configurable: true });
    });
  },

  /**
   * @api private
   */
  property: function property(obj, name, value, enumerable, isValue) {
    var opts = {
      configurable: true,
      enumerable: enumerable !== undefined ? enumerable : true
    };
    if (typeof value === 'function' && !isValue) {
      opts.get = value;
    }
    else {
      opts.value = value; opts.writable = true;
    }

    Object.defineProperty(obj, name, opts);
  },

  /**
   * @api private
   */
  memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {
    var cachedValue = null;

    // build enumerable attribute for each value with lazy accessor.
    util.property(obj, name, function() {
      if (cachedValue === null) {
        cachedValue = get();
      }
      return cachedValue;
    }, enumerable);
  },

  /**
   * TODO Remove in major version revision
   * This backfill populates response data without the
   * top-level payload name.
   *
   * @api private
   */
  hoistPayloadMember: function hoistPayloadMember(resp) {
    var req = resp.request;
    var operationName = req.operation;
    var operation = req.service.api.operations[operationName];
    var output = operation.output;
    if (output.payload && !operation.hasEventOutput) {
      var payloadMember = output.members[output.payload];
      var responsePayload = resp.data[output.payload];
      if (payloadMember.type === 'structure') {
        util.each(responsePayload, function(key, value) {
          util.property(resp.data, key, value, false);
        });
      }
    }
  },

  /**
   * Compute SHA-256 checksums of streams
   *
   * @api private
   */
  computeSha256: function computeSha256(body, done) {
    if (util.isNode()) {
      var Stream = util.stream.Stream;
      var fs = require('fs');
      if (typeof Stream === 'function' && body instanceof Stream) {
        if (typeof body.path === 'string') { // assume file object
          var settings = {};
          if (typeof body.start === 'number') {
            settings.start = body.start;
          }
          if (typeof body.end === 'number') {
            settings.end = body.end;
          }
          body = fs.createReadStream(body.path, settings);
        } else { // TODO support other stream types
          return done(new Error('Non-file stream objects are ' +
                                'not supported with SigV4'));
        }
      }
    }

    util.crypto.sha256(body, 'hex', function(err, sha) {
      if (err) done(err);
      else done(null, sha);
    });
  },

  /**
   * @api private
   */
  isClockSkewed: function isClockSkewed(serverTime) {
    if (serverTime) {
      util.property(AWS.config, 'isClockSkewed',
        Math.abs(new Date().getTime() - serverTime) >= 300000, false);
      return AWS.config.isClockSkewed;
    }
  },

  applyClockOffset: function applyClockOffset(serverTime) {
    if (serverTime)
      AWS.config.systemClockOffset = serverTime - new Date().getTime();
  },

  /**
   * @api private
   */
  extractRequestId: function extractRequestId(resp) {
    var requestId = resp.httpResponse.headers['x-amz-request-id'] ||
                     resp.httpResponse.headers['x-amzn-requestid'];

    if (!requestId && resp.data && resp.data.ResponseMetadata) {
      requestId = resp.data.ResponseMetadata.RequestId;
    }

    if (requestId) {
      resp.requestId = requestId;
    }

    if (resp.error) {
      resp.error.requestId = requestId;
    }
  },

  /**
   * @api private
   */
  addPromises: function addPromises(constructors, PromiseDependency) {
    var deletePromises = false;
    if (PromiseDependency === undefined && AWS && AWS.config) {
      PromiseDependency = AWS.config.getPromisesDependency();
    }
    if (PromiseDependency === undefined && typeof Promise !== 'undefined') {
      PromiseDependency = Promise;
    }
    if (typeof PromiseDependency !== 'function') deletePromises = true;
    if (!Array.isArray(constructors)) constructors = [constructors];

    for (var ind = 0; ind < constructors.length; ind++) {
      var constructor = constructors[ind];
      if (deletePromises) {
        if (constructor.deletePromisesFromClass) {
          constructor.deletePromisesFromClass();
        }
      } else if (constructor.addPromisesToClass) {
        constructor.addPromisesToClass(PromiseDependency);
      }
    }
  },

  /**
   * @api private
   * Return a function that will return a promise whose fate is decided by the
   * callback behavior of the given method with `methodName`. The method to be
   * promisified should conform to node.js convention of accepting a callback as
   * last argument and calling that callback with error as the first argument
   * and success value on the second argument.
   */
  promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {
    return function promise() {
      var self = this;
      var args = Array.prototype.slice.call(arguments);
      return new PromiseDependency(function(resolve, reject) {
        args.push(function(err, data) {
          if (err) {
            reject(err);
          } else {
            resolve(data);
          }
        });
        self[methodName].apply(self, args);
      });
    };
  },

  /**
   * @api private
   */
  isDualstackAvailable: function isDualstackAvailable(service) {
    if (!service) return false;
    var metadata = require('../apis/metadata.json');
    if (typeof service !== 'string') service = service.serviceIdentifier;
    if (typeof service !== 'string' || !metadata.hasOwnProperty(service)) return false;
    return !!metadata[service].dualstackAvailable;
  },

  /**
   * @api private
   */
  calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions, err) {
    if (!retryDelayOptions) retryDelayOptions = {};
    var customBackoff = retryDelayOptions.customBackoff || null;
    if (typeof customBackoff === 'function') {
      return customBackoff(retryCount, err);
    }
    var base = typeof retryDelayOptions.base === 'number' ? retryDelayOptions.base : 100;
    var delay = Math.random() * (Math.pow(2, retryCount) * base);
    return delay;
  },

  /**
   * @api private
   */
  handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {
    if (!options) options = {};
    var http = AWS.HttpClient.getInstance();
    var httpOptions = options.httpOptions || {};
    var retryCount = 0;

    var errCallback = function(err) {
      var maxRetries = options.maxRetries || 0;
      if (err && err.code === 'TimeoutError') err.retryable = true;
      var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions, err);
      if (err && err.retryable && retryCount < maxRetries && delay >= 0) {
        retryCount++;
        setTimeout(sendRequest, delay + (err.retryAfter || 0));
      } else {
        cb(err);
      }
    };

    var sendRequest = function() {
      var data = '';
      http.handleRequest(httpRequest, httpOptions, function(httpResponse) {
        httpResponse.on('data', function(chunk) { data += chunk.toString(); });
        httpResponse.on('end', function() {
          var statusCode = httpResponse.statusCode;
          if (statusCode < 300) {
            cb(null, data);
          } else {
            var retryAfter = parseInt(httpResponse.headers['retry-after'], 10) * 1000 || 0;
            var err = util.error(new Error(),
              {
                statusCode: statusCode,
                retryable: statusCode >= 500 || statusCode === 429
              }
            );
            if (retryAfter && err.retryable) err.retryAfter = retryAfter;
            errCallback(err);
          }
        });
      }, errCallback);
    };

    AWS.util.defer(sendRequest);
  },

  /**
   * @api private
   */
  uuid: {
    v4: function uuidV4() {
      return require('uuid').v4();
    }
  },

  /**
   * @api private
   */
  convertPayloadToString: function convertPayloadToString(resp) {
    var req = resp.request;
    var operation = req.operation;
    var rules = req.service.api.operations[operation].output || {};
    if (rules.payload && resp.data[rules.payload]) {
      resp.data[rules.payload] = resp.data[rules.payload].toString();
    }
  },

  /**
   * @api private
   */
  defer: function defer(callback) {
    if (typeof process === 'object' && typeof process.nextTick === 'function') {
      process.nextTick(callback);
    } else if (typeof setImmediate === 'function') {
      setImmediate(callback);
    } else {
      setTimeout(callback, 0);
    }
  },

  /**
   * @api private
   */
  getRequestPayloadShape: function getRequestPayloadShape(req) {
    var operations = req.service.api.operations;
    if (!operations) return undefined;
    var operation = (operations || {})[req.operation];
    if (!operation || !operation.input || !operation.input.payload) return undefined;
    return operation.input.members[operation.input.payload];
  },

  getProfilesFromSharedConfig: function getProfilesFromSharedConfig(iniLoader, filename) {
    var profiles = {};
    var profilesFromConfig = {};
    if (process.env[util.configOptInEnv]) {
      var profilesFromConfig = iniLoader.loadFrom({
        isConfig: true,
        filename: process.env[util.sharedConfigFileEnv]
      });
    }
    var profilesFromCreds = iniLoader.loadFrom({
      filename: filename ||
        (process.env[util.configOptInEnv] && process.env[util.sharedCredentialsFileEnv])
    });
    for (var i = 0, profileNames = Object.keys(profilesFromConfig); i < profileNames.length; i++) {
      profiles[profileNames[i]] = profilesFromConfig[profileNames[i]];
    }
    for (var i = 0, profileNames = Object.keys(profilesFromCreds); i < profileNames.length; i++) {
      profiles[profileNames[i]] = profilesFromCreds[profileNames[i]];
    }
    return profiles;
  },

  /**
   * @api private
   */
  ARN: {
    validate: function validateARN(str) {
      return str && str.indexOf('arn:') === 0 && str.split(':').length >= 6;
    },
    parse: function parseARN(arn) {
      var matched = arn.split(':');
      return {
        partition: matched[1],
        service: matched[2],
        region: matched[3],
        accountId: matched[4],
        resource: matched.slice(5).join(':')
      };
    },
    build: function buildARN(arnObject) {
      if (
        arnObject.service === undefined ||
        arnObject.region === undefined ||
        arnObject.accountId === undefined ||
        arnObject.resource === undefined
      ) throw util.error(new Error('Input ARN object is invalid'));
      return 'arn:'+ (arnObject.partition || 'aws') + ':' + arnObject.service +
        ':' + arnObject.region + ':' + arnObject.accountId + ':' + arnObject.resource;
    }
  },

  /**
   * @api private
   */
  defaultProfile: 'default',

  /**
   * @api private
   */
  configOptInEnv: 'AWS_SDK_LOAD_CONFIG',

  /**
   * @api private
   */
  sharedCredentialsFileEnv: 'AWS_SHARED_CREDENTIALS_FILE',

  /**
   * @api private
   */
  sharedConfigFileEnv: 'AWS_CONFIG_FILE',

  /**
   * @api private
   */
  imdsDisabledEnv: 'AWS_EC2_METADATA_DISABLED'
};

/**
 * @api private
 */
module.exports = util;

}).call(this,require('_process'),require("timers").setImmediate)

},{"../apis/metadata.json":3,"./core":23,"_process":95,"fs":88,"timers":103,"uuid":108}],79:[function(require,module,exports){
var util = require('../util');
var Shape = require('../model/shape');

function DomXmlParser() { }

DomXmlParser.prototype.parse = function(xml, shape) {
  if (xml.replace(/^\s+/, '') === '') return {};

  var result, error;
  try {
    if (window.DOMParser) {
      try {
        var parser = new DOMParser();
        result = parser.parseFromString(xml, 'text/xml');
      } catch (syntaxError) {
        throw util.error(new Error('Parse error in document'),
          {
            originalError: syntaxError,
            code: 'XMLParserError',
            retryable: true
          });
      }

      if (result.documentElement === null) {
        throw util.error(new Error('Cannot parse empty document.'),
          {
            code: 'XMLParserError',
            retryable: true
          });
      }

      var isError = result.getElementsByTagName('parsererror')[0];
      if (isError && (isError.parentNode === result ||
          isError.parentNode.nodeName === 'body' ||
          isError.parentNode.parentNode === result ||
          isError.parentNode.parentNode.nodeName === 'body')) {
        var errorElement = isError.getElementsByTagName('div')[0] || isError;
        throw util.error(new Error(errorElement.textContent || 'Parser error in document'),
          {
            code: 'XMLParserError',
            retryable: true
          });
      }
    } else if (window.ActiveXObject) {
      result = new window.ActiveXObject('Microsoft.XMLDOM');
      result.async = false;

      if (!result.loadXML(xml)) {
        throw util.error(new Error('Parse error in document'),
          {
            code: 'XMLParserError',
            retryable: true
          });
      }
    } else {
      throw new Error('Cannot load XML parser');
    }
  } catch (e) {
    error = e;
  }

  if (result && result.documentElement && !error) {
    var data = parseXml(result.documentElement, shape);
    var metadata = getElementByTagName(result.documentElement, 'ResponseMetadata');
    if (metadata) {
      data.ResponseMetadata = parseXml(metadata, {});
    }
    return data;
  } else if (error) {
    throw util.error(error || new Error(), {code: 'XMLParserError', retryable: true});
  } else { // empty xml document
    return {};
  }
};

function getElementByTagName(xml, tag) {
  var elements = xml.getElementsByTagName(tag);
  for (var i = 0, iLen = elements.length; i < iLen; i++) {
    if (elements[i].parentNode === xml) {
      return elements[i];
    }
  }
}

function parseXml(xml, shape) {
  if (!shape) shape = {};
  switch (shape.type) {
    case 'structure': return parseStructure(xml, shape);
    case 'map': return parseMap(xml, shape);
    case 'list': return parseList(xml, shape);
    case undefined: case null: return parseUnknown(xml);
    default: return parseScalar(xml, shape);
  }
}

function parseStructure(xml, shape) {
  var data = {};
  if (xml === null) return data;

  util.each(shape.members, function(memberName, memberShape) {
    if (memberShape.isXmlAttribute) {
      if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {
        var value = xml.attributes[memberShape.name].value;
        data[memberName] = parseXml({textContent: value}, memberShape);
      }
    } else {
      var xmlChild = memberShape.flattened ? xml :
        getElementByTagName(xml, memberShape.name);
      if (xmlChild) {
        data[memberName] = parseXml(xmlChild, memberShape);
      } else if (!memberShape.flattened && memberShape.type === 'list') {
        data[memberName] = memberShape.defaultValue;
      }
    }
  });

  return data;
}

function parseMap(xml, shape) {
  var data = {};
  var xmlKey = shape.key.name || 'key';
  var xmlValue = shape.value.name || 'value';
  var tagName = shape.flattened ? shape.name : 'entry';

  var child = xml.firstElementChild;
  while (child) {
    if (child.nodeName === tagName) {
      var key = getElementByTagName(child, xmlKey).textContent;
      var value = getElementByTagName(child, xmlValue);
      data[key] = parseXml(value, shape.value);
    }
    child = child.nextElementSibling;
  }
  return data;
}

function parseList(xml, shape) {
  var data = [];
  var tagName = shape.flattened ? shape.name : (shape.member.name || 'member');

  var child = xml.firstElementChild;
  while (child) {
    if (child.nodeName === tagName) {
      data.push(parseXml(child, shape.member));
    }
    child = child.nextElementSibling;
  }
  return data;
}

function parseScalar(xml, shape) {
  if (xml.getAttribute) {
    var encoding = xml.getAttribute('encoding');
    if (encoding === 'base64') {
      shape = new Shape.create({type: encoding});
    }
  }

  var text = xml.textContent;
  if (text === '') text = null;
  if (typeof shape.toType === 'function') {
    return shape.toType(text);
  } else {
    return text;
  }
}

function parseUnknown(xml) {
  if (xml === undefined || xml === null) return '';

  // empty object
  if (!xml.firstElementChild) {
    if (xml.parentNode.parentNode === null) return {};
    if (xml.childNodes.length === 0) return '';
    else return xml.textContent;
  }

  // object, parse as structure
  var shape = {type: 'structure', members: {}};
  var child = xml.firstElementChild;
  while (child) {
    var tag = child.nodeName;
    if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {
      // multiple tags of the same name makes it a list
      shape.members[tag].type = 'list';
    } else {
      shape.members[tag] = {name: tag};
    }
    child = child.nextElementSibling;
  }
  return parseStructure(xml, shape);
}

/**
 * @api private
 */
module.exports = DomXmlParser;

},{"../model/shape":48,"../util":78}],80:[function(require,module,exports){
var util = require('../util');
var XmlNode = require('./xml-node').XmlNode;
var XmlText = require('./xml-text').XmlText;

function XmlBuilder() { }

XmlBuilder.prototype.toXML = function(params, shape, rootElement, noEmpty) {
  var xml = new XmlNode(rootElement);
  applyNamespaces(xml, shape, true);
  serialize(xml, params, shape);
  return xml.children.length > 0 || noEmpty ? xml.toString() : '';
};

function serialize(xml, value, shape) {
  switch (shape.type) {
    case 'structure': return serializeStructure(xml, value, shape);
    case 'map': return serializeMap(xml, value, shape);
    case 'list': return serializeList(xml, value, shape);
    default: return serializeScalar(xml, value, shape);
  }
}

function serializeStructure(xml, params, shape) {
  util.arrayEach(shape.memberNames, function(memberName) {
    var memberShape = shape.members[memberName];
    if (memberShape.location !== 'body') return;

    var value = params[memberName];
    var name = memberShape.name;
    if (value !== undefined && value !== null) {
      if (memberShape.isXmlAttribute) {
        xml.addAttribute(name, value);
      } else if (memberShape.flattened) {
        serialize(xml, value, memberShape);
      } else {
        var element = new XmlNode(name);
        xml.addChildNode(element);
        applyNamespaces(element, memberShape);
        serialize(element, value, memberShape);
      }
    }
  });
}

function serializeMap(xml, map, shape) {
  var xmlKey = shape.key.name || 'key';
  var xmlValue = shape.value.name || 'value';

  util.each(map, function(key, value) {
    var entry = new XmlNode(shape.flattened ? shape.name : 'entry');
    xml.addChildNode(entry);

    var entryKey = new XmlNode(xmlKey);
    var entryValue = new XmlNode(xmlValue);
    entry.addChildNode(entryKey);
    entry.addChildNode(entryValue);

    serialize(entryKey, key, shape.key);
    serialize(entryValue, value, shape.value);
  });
}

function serializeList(xml, list, shape) {
  if (shape.flattened) {
    util.arrayEach(list, function(value) {
      var name = shape.member.name || shape.name;
      var element = new XmlNode(name);
      xml.addChildNode(element);
      serialize(element, value, shape.member);
    });
  } else {
    util.arrayEach(list, function(value) {
      var name = shape.member.name || 'member';
      var element = new XmlNode(name);
      xml.addChildNode(element);
      serialize(element, value, shape.member);
    });
  }
}

function serializeScalar(xml, value, shape) {
  xml.addChildNode(
    new XmlText(shape.toWireFormat(value))
  );
}

function applyNamespaces(xml, shape, isRoot) {
  var uri, prefix = 'xmlns';
  if (shape.xmlNamespaceUri) {
    uri = shape.xmlNamespaceUri;
    if (shape.xmlNamespacePrefix) prefix += ':' + shape.xmlNamespacePrefix;
  } else if (isRoot && shape.api.xmlNamespaceUri) {
    uri = shape.api.xmlNamespaceUri;
  }

  if (uri) xml.addAttribute(prefix, uri);
}

/**
 * @api private
 */
module.exports = XmlBuilder;

},{"../util":78,"./xml-node":83,"./xml-text":84}],81:[function(require,module,exports){
/**
 * Escapes characters that can not be in an XML attribute.
 */
function escapeAttribute(value) {
    return value.replace(/&/g, '&amp;').replace(/'/g, '&apos;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

/**
 * @api private
 */
module.exports = {
    escapeAttribute: escapeAttribute
};

},{}],82:[function(require,module,exports){
/**
 * Escapes characters that can not be in an XML element.
 */
function escapeElement(value) {
    return value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

/**
 * @api private
 */
module.exports = {
    escapeElement: escapeElement
};

},{}],83:[function(require,module,exports){
var escapeAttribute = require('./escape-attribute').escapeAttribute;

/**
 * Represents an XML node.
 * @api private
 */
function XmlNode(name, children) {
    if (children === void 0) { children = []; }
    this.name = name;
    this.children = children;
    this.attributes = {};
}
XmlNode.prototype.addAttribute = function (name, value) {
    this.attributes[name] = value;
    return this;
};
XmlNode.prototype.addChildNode = function (child) {
    this.children.push(child);
    return this;
};
XmlNode.prototype.removeAttribute = function (name) {
    delete this.attributes[name];
    return this;
};
XmlNode.prototype.toString = function () {
    var hasChildren = Boolean(this.children.length);
    var xmlText = '<' + this.name;
    // add attributes
    var attributes = this.attributes;
    for (var i = 0, attributeNames = Object.keys(attributes); i < attributeNames.length; i++) {
        var attributeName = attributeNames[i];
        var attribute = attributes[attributeName];
        if (typeof attribute !== 'undefined' && attribute !== null) {
            xmlText += ' ' + attributeName + '=\"' + escapeAttribute('' + attribute) + '\"';
        }
    }
    return xmlText += !hasChildren ? '/>' : '>' + this.children.map(function (c) { return c.toString(); }).join('') + '</' + this.name + '>';
};

/**
 * @api private
 */
module.exports = {
    XmlNode: XmlNode
};

},{"./escape-attribute":81}],84:[function(require,module,exports){
var escapeElement = require('./escape-element').escapeElement;

/**
 * Represents an XML text value.
 * @api private
 */
function XmlText(value) {
    this.value = value;
}

XmlText.prototype.toString = function () {
    return escapeElement('' + this.value);
};

/**
 * @api private
 */
module.exports = {
    XmlText: XmlText
};

},{"./escape-element":82}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LRU_1 = require("./utils/LRU");
var CACHE_SIZE = 1000;
/**
 * Inspired node-lru-cache[https://github.com/isaacs/node-lru-cache]
 */
var EndpointCache = /** @class */ (function () {
    function EndpointCache(maxSize) {
        if (maxSize === void 0) { maxSize = CACHE_SIZE; }
        this.maxSize = maxSize;
        this.cache = new LRU_1.LRUCache(maxSize);
    }
    ;
    Object.defineProperty(EndpointCache.prototype, "size", {
        get: function () {
            return this.cache.length;
        },
        enumerable: true,
        configurable: true
    });
    EndpointCache.prototype.put = function (key, value) {
      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        var endpointRecord = this.populateValue(value);
        this.cache.put(keyString, endpointRecord);
    };
    EndpointCache.prototype.get = function (key) {
      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        var now = Date.now();
        var records = this.cache.get(keyString);
        if (records) {
            for (var i = 0; i < records.length; i++) {
                var record = records[i];
                if (record.Expire < now) {
                    this.cache.remove(keyString);
                    return undefined;
                }
            }
        }
        return records;
    };
    EndpointCache.getKeyString = function (key) {
        var identifiers = [];
        var identifierNames = Object.keys(key).sort();
        for (var i = 0; i < identifierNames.length; i++) {
            var identifierName = identifierNames[i];
            if (key[identifierName] === undefined)
                continue;
            identifiers.push(key[identifierName]);
        }
        return identifiers.join(' ');
    };
    EndpointCache.prototype.populateValue = function (endpoints) {
        var now = Date.now();
        return endpoints.map(function (endpoint) { return ({
            Address: endpoint.Address || '',
            Expire: now + (endpoint.CachePeriodInMinutes || 1) * 60 * 1000
        }); });
    };
    EndpointCache.prototype.empty = function () {
        this.cache.empty();
    };
    EndpointCache.prototype.remove = function (key) {
      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        this.cache.remove(keyString);
    };
    return EndpointCache;
}());
exports.EndpointCache = EndpointCache;
},{"./utils/LRU":86}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LinkedListNode = /** @class */ (function () {
    function LinkedListNode(key, value) {
        this.key = key;
        this.value = value;
    }
    return LinkedListNode;
}());
var LRUCache = /** @class */ (function () {
    function LRUCache(size) {
        this.nodeMap = {};
        this.size = 0;
        if (typeof size !== 'number' || size < 1) {
            throw new Error('Cache size can only be positive number');
        }
        this.sizeLimit = size;
    }
    Object.defineProperty(LRUCache.prototype, "length", {
        get: function () {
            return this.size;
        },
        enumerable: true,
        configurable: true
    });
    LRUCache.prototype.prependToList = function (node) {
        if (!this.headerNode) {
            this.tailNode = node;
        }
        else {
            this.headerNode.prev = node;
            node.next = this.headerNode;
        }
        this.headerNode = node;
        this.size++;
    };
    LRUCache.prototype.removeFromTail = function () {
        if (!this.tailNode) {
            return undefined;
        }
        var node = this.tailNode;
        var prevNode = node.prev;
        if (prevNode) {
            prevNode.next = undefined;
        }
        node.prev = undefined;
        this.tailNode = prevNode;
        this.size--;
        return node;
    };
    LRUCache.prototype.detachFromList = function (node) {
        if (this.headerNode === node) {
            this.headerNode = node.next;
        }
        if (this.tailNode === node) {
            this.tailNode = node.prev;
        }
        if (node.prev) {
            node.prev.next = node.next;
        }
        if (node.next) {
            node.next.prev = node.prev;
        }
        node.next = undefined;
        node.prev = undefined;
        this.size--;
    };
    LRUCache.prototype.get = function (key) {
        if (this.nodeMap[key]) {
            var node = this.nodeMap[key];
            this.detachFromList(node);
            this.prependToList(node);
            return node.value;
        }
    };
    LRUCache.prototype.remove = function (key) {
        if (this.nodeMap[key]) {
            var node = this.nodeMap[key];
            this.detachFromList(node);
            delete this.nodeMap[key];
        }
    };
    LRUCache.prototype.put = function (key, value) {
        if (this.nodeMap[key]) {
            this.remove(key);
        }
        else if (this.size === this.sizeLimit) {
            var tailNode = this.removeFromTail();
            var key_1 = tailNode.key;
            delete this.nodeMap[key_1];
        }
        var newNode = new LinkedListNode(key, value);
        this.nodeMap[key] = newNode;
        this.prependToList(newNode);
    };
    LRUCache.prototype.empty = function () {
        var keys = Object.keys(this.nodeMap);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var node = this.nodeMap[key];
            this.detachFromList(node);
            delete this.nodeMap[key];
        }
    };
    return LRUCache;
}());
exports.LRUCache = LRUCache;
},{}],87:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],88:[function(require,module,exports){

},{}],89:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

}).call(this,require("buffer").Buffer)

},{"base64-js":87,"buffer":89,"ieee754":92}],90:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],91:[function(require,module,exports){
(function (global,Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"base64-js":87,"buffer":89,"ieee754":92,"isarray":93}],92:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],93:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],94:[function(require,module,exports){
(function(exports) {
  "use strict";

  function isArray(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    } else {
      return false;
    }
  }

  function isObject(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Object]";
    } else {
      return false;
    }
  }

  function strictDeepEqual(first, second) {
    // Check the scalar case first.
    if (first === second) {
      return true;
    }

    // Check if they are the same type.
    var firstType = Object.prototype.toString.call(first);
    if (firstType !== Object.prototype.toString.call(second)) {
      return false;
    }
    // We know that first and second have the same type so we can just check the
    // first type from now on.
    if (isArray(first) === true) {
      // Short circuit if they're not the same length;
      if (first.length !== second.length) {
        return false;
      }
      for (var i = 0; i < first.length; i++) {
        if (strictDeepEqual(first[i], second[i]) === false) {
          return false;
        }
      }
      return true;
    }
    if (isObject(first) === true) {
      // An object is equal if it has the same key/value pairs.
      var keysSeen = {};
      for (var key in first) {
        if (hasOwnProperty.call(first, key)) {
          if (strictDeepEqual(first[key], second[key]) === false) {
            return false;
          }
          keysSeen[key] = true;
        }
      }
      // Now check that there aren't any keys in second that weren't
      // in first.
      for (var key2 in second) {
        if (hasOwnProperty.call(second, key2)) {
          if (keysSeen[key2] !== true) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }

  function isFalse(obj) {
    // From the spec:
    // A false value corresponds to the following values:
    // Empty list
    // Empty object
    // Empty string
    // False boolean
    // null value

    // First check the scalar values.
    if (obj === "" || obj === false || obj === null) {
        return true;
    } else if (isArray(obj) && obj.length === 0) {
        // Check for an empty array.
        return true;
    } else if (isObject(obj)) {
        // Check for an empty object.
        for (var key in obj) {
            // If there are any keys, then
            // the object is not empty so the object
            // is not false.
            if (obj.hasOwnProperty(key)) {
              return false;
            }
        }
        return true;
    } else {
        return false;
    }
  }

  function objValues(obj) {
    var keys = Object.keys(obj);
    var values = [];
    for (var i = 0; i < keys.length; i++) {
      values.push(obj[keys[i]]);
    }
    return values;
  }

  function merge(a, b) {
      var merged = {};
      for (var key in a) {
          merged[key] = a[key];
      }
      for (var key2 in b) {
          merged[key2] = b[key2];
      }
      return merged;
  }

  var trimLeft;
  if (typeof String.prototype.trimLeft === "function") {
    trimLeft = function(str) {
      return str.trimLeft();
    };
  } else {
    trimLeft = function(str) {
      return str.match(/^\s*(.*)/)[1];
    };
  }

  // Type constants used to define functions.
  var TYPE_NUMBER = 0;
  var TYPE_ANY = 1;
  var TYPE_STRING = 2;
  var TYPE_ARRAY = 3;
  var TYPE_OBJECT = 4;
  var TYPE_BOOLEAN = 5;
  var TYPE_EXPREF = 6;
  var TYPE_NULL = 7;
  var TYPE_ARRAY_NUMBER = 8;
  var TYPE_ARRAY_STRING = 9;

  var TOK_EOF = "EOF";
  var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
  var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
  var TOK_RBRACKET = "Rbracket";
  var TOK_RPAREN = "Rparen";
  var TOK_COMMA = "Comma";
  var TOK_COLON = "Colon";
  var TOK_RBRACE = "Rbrace";
  var TOK_NUMBER = "Number";
  var TOK_CURRENT = "Current";
  var TOK_EXPREF = "Expref";
  var TOK_PIPE = "Pipe";
  var TOK_OR = "Or";
  var TOK_AND = "And";
  var TOK_EQ = "EQ";
  var TOK_GT = "GT";
  var TOK_LT = "LT";
  var TOK_GTE = "GTE";
  var TOK_LTE = "LTE";
  var TOK_NE = "NE";
  var TOK_FLATTEN = "Flatten";
  var TOK_STAR = "Star";
  var TOK_FILTER = "Filter";
  var TOK_DOT = "Dot";
  var TOK_NOT = "Not";
  var TOK_LBRACE = "Lbrace";
  var TOK_LBRACKET = "Lbracket";
  var TOK_LPAREN= "Lparen";
  var TOK_LITERAL= "Literal";

  // The "&", "[", "<", ">" tokens
  // are not in basicToken because
  // there are two token variants
  // ("&&", "[?", "<=", ">=").  This is specially handled
  // below.

  var basicTokens = {
    ".": TOK_DOT,
    "*": TOK_STAR,
    ",": TOK_COMMA,
    ":": TOK_COLON,
    "{": TOK_LBRACE,
    "}": TOK_RBRACE,
    "]": TOK_RBRACKET,
    "(": TOK_LPAREN,
    ")": TOK_RPAREN,
    "@": TOK_CURRENT
  };

  var operatorStartToken = {
      "<": true,
      ">": true,
      "=": true,
      "!": true
  };

  var skipChars = {
      " ": true,
      "\t": true,
      "\n": true
  };


  function isAlpha(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             ch === "_";
  }

  function isNum(ch) {
      return (ch >= "0" && ch <= "9") ||
             ch === "-";
  }
  function isAlphaNum(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             (ch >= "0" && ch <= "9") ||
             ch === "_";
  }

  function Lexer() {
  }
  Lexer.prototype = {
      tokenize: function(stream) {
          var tokens = [];
          this._current = 0;
          var start;
          var identifier;
          var token;
          while (this._current < stream.length) {
              if (isAlpha(stream[this._current])) {
                  start = this._current;
                  identifier = this._consumeUnquotedIdentifier(stream);
                  tokens.push({type: TOK_UNQUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (basicTokens[stream[this._current]] !== undefined) {
                  tokens.push({type: basicTokens[stream[this._current]],
                              value: stream[this._current],
                              start: this._current});
                  this._current++;
              } else if (isNum(stream[this._current])) {
                  token = this._consumeNumber(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "[") {
                  // No need to increment this._current.  This happens
                  // in _consumeLBracket
                  token = this._consumeLBracket(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "\"") {
                  start = this._current;
                  identifier = this._consumeQuotedIdentifier(stream);
                  tokens.push({type: TOK_QUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "'") {
                  start = this._current;
                  identifier = this._consumeRawStringLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "`") {
                  start = this._current;
                  var literal = this._consumeLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: literal,
                               start: start});
              } else if (operatorStartToken[stream[this._current]] !== undefined) {
                  tokens.push(this._consumeOperator(stream));
              } else if (skipChars[stream[this._current]] !== undefined) {
                  // Ignore whitespace.
                  this._current++;
              } else if (stream[this._current] === "&") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "&") {
                      this._current++;
                      tokens.push({type: TOK_AND, value: "&&", start: start});
                  } else {
                      tokens.push({type: TOK_EXPREF, value: "&", start: start});
                  }
              } else if (stream[this._current] === "|") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "|") {
                      this._current++;
                      tokens.push({type: TOK_OR, value: "||", start: start});
                  } else {
                      tokens.push({type: TOK_PIPE, value: "|", start: start});
                  }
              } else {
                  var error = new Error("Unknown character:" + stream[this._current]);
                  error.name = "LexerError";
                  throw error;
              }
          }
          return tokens;
      },

      _consumeUnquotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
              this._current++;
          }
          return stream.slice(start, this._current);
      },

      _consumeQuotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "\"" && this._current < maxLength) {
              // You can escape a double quote and you can escape an escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "\"")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          return JSON.parse(stream.slice(start, this._current));
      },

      _consumeRawStringLiteral: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "'" && this._current < maxLength) {
              // You can escape a single quote and you can escape an escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "'")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          var literal = stream.slice(start + 1, this._current - 1);
          return literal.replace("\\'", "'");
      },

      _consumeNumber: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (isNum(stream[this._current]) && this._current < maxLength) {
              this._current++;
          }
          var value = parseInt(stream.slice(start, this._current));
          return {type: TOK_NUMBER, value: value, start: start};
      },

      _consumeLBracket: function(stream) {
          var start = this._current;
          this._current++;
          if (stream[this._current] === "?") {
              this._current++;
              return {type: TOK_FILTER, value: "[?", start: start};
          } else if (stream[this._current] === "]") {
              this._current++;
              return {type: TOK_FLATTEN, value: "[]", start: start};
          } else {
              return {type: TOK_LBRACKET, value: "[", start: start};
          }
      },

      _consumeOperator: function(stream) {
          var start = this._current;
          var startingChar = stream[start];
          this._current++;
          if (startingChar === "!") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_NE, value: "!=", start: start};
              } else {
                return {type: TOK_NOT, value: "!", start: start};
              }
          } else if (startingChar === "<") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_LTE, value: "<=", start: start};
              } else {
                  return {type: TOK_LT, value: "<", start: start};
              }
          } else if (startingChar === ">") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_GTE, value: ">=", start: start};
              } else {
                  return {type: TOK_GT, value: ">", start: start};
              }
          } else if (startingChar === "=") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_EQ, value: "==", start: start};
              }
          }
      },

      _consumeLiteral: function(stream) {
          this._current++;
          var start = this._current;
          var maxLength = stream.length;
          var literal;
          while(stream[this._current] !== "`" && this._current < maxLength) {
              // You can escape a literal char or you can escape the escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "`")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          var literalString = trimLeft(stream.slice(start, this._current));
          literalString = literalString.replace("\\`", "`");
          if (this._looksLikeJSON(literalString)) {
              literal = JSON.parse(literalString);
          } else {
              // Try to JSON parse it as "<literal>"
              literal = JSON.parse("\"" + literalString + "\"");
          }
          // +1 gets us to the ending "`", +1 to move on to the next char.
          this._current++;
          return literal;
      },

      _looksLikeJSON: function(literalString) {
          var startingChars = "[{\"";
          var jsonLiterals = ["true", "false", "null"];
          var numberLooking = "-0123456789";

          if (literalString === "") {
              return false;
          } else if (startingChars.indexOf(literalString[0]) >= 0) {
              return true;
          } else if (jsonLiterals.indexOf(literalString) >= 0) {
              return true;
          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
              try {
                  JSON.parse(literalString);
                  return true;
              } catch (ex) {
                  return false;
              }
          } else {
              return false;
          }
      }
  };

      var bindingPower = {};
      bindingPower[TOK_EOF] = 0;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_RBRACKET] = 0;
      bindingPower[TOK_RPAREN] = 0;
      bindingPower[TOK_COMMA] = 0;
      bindingPower[TOK_RBRACE] = 0;
      bindingPower[TOK_NUMBER] = 0;
      bindingPower[TOK_CURRENT] = 0;
      bindingPower[TOK_EXPREF] = 0;
      bindingPower[TOK_PIPE] = 1;
      bindingPower[TOK_OR] = 2;
      bindingPower[TOK_AND] = 3;
      bindingPower[TOK_EQ] = 5;
      bindingPower[TOK_GT] = 5;
      bindingPower[TOK_LT] = 5;
      bindingPower[TOK_GTE] = 5;
      bindingPower[TOK_LTE] = 5;
      bindingPower[TOK_NE] = 5;
      bindingPower[TOK_FLATTEN] = 9;
      bindingPower[TOK_STAR] = 20;
      bindingPower[TOK_FILTER] = 21;
      bindingPower[TOK_DOT] = 40;
      bindingPower[TOK_NOT] = 45;
      bindingPower[TOK_LBRACE] = 50;
      bindingPower[TOK_LBRACKET] = 55;
      bindingPower[TOK_LPAREN] = 60;

  function Parser() {
  }

  Parser.prototype = {
      parse: function(expression) {
          this._loadTokens(expression);
          this.index = 0;
          var ast = this.expression(0);
          if (this._lookahead(0) !== TOK_EOF) {
              var t = this._lookaheadToken(0);
              var error = new Error(
                  "Unexpected token type: " + t.type + ", value: " + t.value);
              error.name = "ParserError";
              throw error;
          }
          return ast;
      },

      _loadTokens: function(expression) {
          var lexer = new Lexer();
          var tokens = lexer.tokenize(expression);
          tokens.push({type: TOK_EOF, value: "", start: expression.length});
          this.tokens = tokens;
      },

      expression: function(rbp) {
          var leftToken = this._lookaheadToken(0);
          this._advance();
          var left = this.nud(leftToken);
          var currentToken = this._lookahead(0);
          while (rbp < bindingPower[currentToken]) {
              this._advance();
              left = this.led(currentToken, left);
              currentToken = this._lookahead(0);
          }
          return left;
      },

      _lookahead: function(number) {
          return this.tokens[this.index + number].type;
      },

      _lookaheadToken: function(number) {
          return this.tokens[this.index + number];
      },

      _advance: function() {
          this.index++;
      },

      nud: function(token) {
        var left;
        var right;
        var expression;
        switch (token.type) {
          case TOK_LITERAL:
            return {type: "Literal", value: token.value};
          case TOK_UNQUOTEDIDENTIFIER:
            return {type: "Field", name: token.value};
          case TOK_QUOTEDIDENTIFIER:
            var node = {type: "Field", name: token.value};
            if (this._lookahead(0) === TOK_LPAREN) {
                throw new Error("Quoted identifier not allowed for function names.");
            } else {
                return node;
            }
            break;
          case TOK_NOT:
            right = this.expression(bindingPower.Not);
            return {type: "NotExpression", children: [right]};
          case TOK_STAR:
            left = {type: "Identity"};
            right = null;
            if (this._lookahead(0) === TOK_RBRACKET) {
                // This can happen in a multiselect,
                // [a, b, *]
                right = {type: "Identity"};
            } else {
                right = this._parseProjectionRHS(bindingPower.Star);
            }
            return {type: "ValueProjection", children: [left, right]};
          case TOK_FILTER:
            return this.led(token.type, {type: "Identity"});
          case TOK_LBRACE:
            return this._parseMultiselectHash();
          case TOK_FLATTEN:
            left = {type: TOK_FLATTEN, children: [{type: "Identity"}]};
            right = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [left, right]};
          case TOK_LBRACKET:
            if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice({type: "Identity"}, right);
            } else if (this._lookahead(0) === TOK_STAR &&
                       this._lookahead(1) === TOK_RBRACKET) {
                this._advance();
                this._advance();
                right = this._parseProjectionRHS(bindingPower.Star);
                return {type: "Projection",
                        children: [{type: "Identity"}, right]};
            } else {
                return this._parseMultiselectList();
            }
            break;
          case TOK_CURRENT:
            return {type: TOK_CURRENT};
          case TOK_EXPREF:
            expression = this.expression(bindingPower.Expref);
            return {type: "ExpressionReference", children: [expression]};
          case TOK_LPAREN:
            var args = [];
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            return args[0];
          default:
            this._errorToken(token);
        }
      },

      led: function(tokenName, left) {
        var right;
        switch(tokenName) {
          case TOK_DOT:
            var rbp = bindingPower.Dot;
            if (this._lookahead(0) !== TOK_STAR) {
                right = this._parseDotRHS(rbp);
                return {type: "Subexpression", children: [left, right]};
            } else {
                // Creating a projection.
                this._advance();
                right = this._parseProjectionRHS(rbp);
                return {type: "ValueProjection", children: [left, right]};
            }
            break;
          case TOK_PIPE:
            right = this.expression(bindingPower.Pipe);
            return {type: TOK_PIPE, children: [left, right]};
          case TOK_OR:
            right = this.expression(bindingPower.Or);
            return {type: "OrExpression", children: [left, right]};
          case TOK_AND:
            right = this.expression(bindingPower.And);
            return {type: "AndExpression", children: [left, right]};
          case TOK_LPAREN:
            var name = left.name;
            var args = [];
            var expression, node;
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              if (this._lookahead(0) === TOK_COMMA) {
                this._match(TOK_COMMA);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            node = {type: "Function", name: name, children: args};
            return node;
          case TOK_FILTER:
            var condition = this.expression(0);
            this._match(TOK_RBRACKET);
            if (this._lookahead(0) === TOK_FLATTEN) {
              right = {type: "Identity"};
            } else {
              right = this._parseProjectionRHS(bindingPower.Filter);
            }
            return {type: "FilterProjection", children: [left, right, condition]};
          case TOK_FLATTEN:
            var leftNode = {type: TOK_FLATTEN, children: [left]};
            var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [leftNode, rightNode]};
          case TOK_EQ:
          case TOK_NE:
          case TOK_GT:
          case TOK_GTE:
          case TOK_LT:
          case TOK_LTE:
            return this._parseComparator(left, tokenName);
          case TOK_LBRACKET:
            var token = this._lookaheadToken(0);
            if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice(left, right);
            } else {
                this._match(TOK_STAR);
                this._match(TOK_RBRACKET);
                right = this._parseProjectionRHS(bindingPower.Star);
                return {type: "Projection", children: [left, right]};
            }
            break;
          default:
            this._errorToken(this._lookaheadToken(0));
        }
      },

      _match: function(tokenType) {
          if (this._lookahead(0) === tokenType) {
              this._advance();
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Expected " + tokenType + ", got: " + t.type);
              error.name = "ParserError";
              throw error;
          }
      },

      _errorToken: function(token) {
          var error = new Error("Invalid token (" +
                                token.type + "): \"" +
                                token.value + "\"");
          error.name = "ParserError";
          throw error;
      },


      _parseIndexExpression: function() {
          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
              return this._parseSliceExpression();
          } else {
              var node = {
                  type: "Index",
                  value: this._lookaheadToken(0).value};
              this._advance();
              this._match(TOK_RBRACKET);
              return node;
          }
      },

      _projectIfSlice: function(left, right) {
          var indexExpr = {type: "IndexExpression", children: [left, right]};
          if (right.type === "Slice") {
              return {
                  type: "Projection",
                  children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
              };
          } else {
              return indexExpr;
          }
      },

      _parseSliceExpression: function() {
          // [start:end:step] where each part is optional, as well as the last
          // colon.
          var parts = [null, null, null];
          var index = 0;
          var currentToken = this._lookahead(0);
          while (currentToken !== TOK_RBRACKET && index < 3) {
              if (currentToken === TOK_COLON) {
                  index++;
                  this._advance();
              } else if (currentToken === TOK_NUMBER) {
                  parts[index] = this._lookaheadToken(0).value;
                  this._advance();
              } else {
                  var t = this._lookahead(0);
                  var error = new Error("Syntax error, unexpected token: " +
                                        t.value + "(" + t.type + ")");
                  error.name = "Parsererror";
                  throw error;
              }
              currentToken = this._lookahead(0);
          }
          this._match(TOK_RBRACKET);
          return {
              type: "Slice",
              children: parts
          };
      },

      _parseComparator: function(left, comparator) {
        var right = this.expression(bindingPower[comparator]);
        return {type: "Comparator", name: comparator, children: [left, right]};
      },

      _parseDotRHS: function(rbp) {
          var lookahead = this._lookahead(0);
          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
          if (exprTokens.indexOf(lookahead) >= 0) {
              return this.expression(rbp);
          } else if (lookahead === TOK_LBRACKET) {
              this._match(TOK_LBRACKET);
              return this._parseMultiselectList();
          } else if (lookahead === TOK_LBRACE) {
              this._match(TOK_LBRACE);
              return this._parseMultiselectHash();
          }
      },

      _parseProjectionRHS: function(rbp) {
          var right;
          if (bindingPower[this._lookahead(0)] < 10) {
              right = {type: "Identity"};
          } else if (this._lookahead(0) === TOK_LBRACKET) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_FILTER) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_DOT) {
              this._match(TOK_DOT);
              right = this._parseDotRHS(rbp);
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Sytanx error, unexpected token: " +
                                    t.value + "(" + t.type + ")");
              error.name = "ParserError";
              throw error;
          }
          return right;
      },

      _parseMultiselectList: function() {
          var expressions = [];
          while (this._lookahead(0) !== TOK_RBRACKET) {
              var expression = this.expression(0);
              expressions.push(expression);
              if (this._lookahead(0) === TOK_COMMA) {
                  this._match(TOK_COMMA);
                  if (this._lookahead(0) === TOK_RBRACKET) {
                    throw new Error("Unexpected token Rbracket");
                  }
              }
          }
          this._match(TOK_RBRACKET);
          return {type: "MultiSelectList", children: expressions};
      },

      _parseMultiselectHash: function() {
        var pairs = [];
        var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
        var keyToken, keyName, value, node;
        for (;;) {
          keyToken = this._lookaheadToken(0);
          if (identifierTypes.indexOf(keyToken.type) < 0) {
            throw new Error("Expecting an identifier token, got: " +
                            keyToken.type);
          }
          keyName = keyToken.value;
          this._advance();
          this._match(TOK_COLON);
          value = this.expression(0);
          node = {type: "KeyValuePair", name: keyName, value: value};
          pairs.push(node);
          if (this._lookahead(0) === TOK_COMMA) {
            this._match(TOK_COMMA);
          } else if (this._lookahead(0) === TOK_RBRACE) {
            this._match(TOK_RBRACE);
            break;
          }
        }
        return {type: "MultiSelectHash", children: pairs};
      }
  };


  function TreeInterpreter(runtime) {
    this.runtime = runtime;
  }

  TreeInterpreter.prototype = {
      search: function(node, value) {
          return this.visit(node, value);
      },

      visit: function(node, value) {
          var matched, current, result, first, second, field, left, right, collected, i;
          switch (node.type) {
            case "Field":
              if (value === null ) {
                  return null;
              } else if (isObject(value)) {
                  field = value[node.name];
                  if (field === undefined) {
                      return null;
                  } else {
                      return field;
                  }
              } else {
                return null;
              }
              break;
            case "Subexpression":
              result = this.visit(node.children[0], value);
              for (i = 1; i < node.children.length; i++) {
                  result = this.visit(node.children[1], result);
                  if (result === null) {
                      return null;
                  }
              }
              return result;
            case "IndexExpression":
              left = this.visit(node.children[0], value);
              right = this.visit(node.children[1], left);
              return right;
            case "Index":
              if (!isArray(value)) {
                return null;
              }
              var index = node.value;
              if (index < 0) {
                index = value.length + index;
              }
              result = value[index];
              if (result === undefined) {
                result = null;
              }
              return result;
            case "Slice":
              if (!isArray(value)) {
                return null;
              }
              var sliceParams = node.children.slice(0);
              var computed = this.computeSliceParams(value.length, sliceParams);
              var start = computed[0];
              var stop = computed[1];
              var step = computed[2];
              result = [];
              if (step > 0) {
                  for (i = start; i < stop; i += step) {
                      result.push(value[i]);
                  }
              } else {
                  for (i = start; i > stop; i += step) {
                      result.push(value[i]);
                  }
              }
              return result;
            case "Projection":
              // Evaluate left child.
              var base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              collected = [];
              for (i = 0; i < base.length; i++) {
                current = this.visit(node.children[1], base[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "ValueProjection":
              // Evaluate left child.
              base = this.visit(node.children[0], value);
              if (!isObject(base)) {
                return null;
              }
              collected = [];
              var values = objValues(base);
              for (i = 0; i < values.length; i++) {
                current = this.visit(node.children[1], values[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "FilterProjection":
              base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              var filtered = [];
              var finalResults = [];
              for (i = 0; i < base.length; i++) {
                matched = this.visit(node.children[2], base[i]);
                if (!isFalse(matched)) {
                  filtered.push(base[i]);
                }
              }
              for (var j = 0; j < filtered.length; j++) {
                current = this.visit(node.children[1], filtered[j]);
                if (current !== null) {
                  finalResults.push(current);
                }
              }
              return finalResults;
            case "Comparator":
              first = this.visit(node.children[0], value);
              second = this.visit(node.children[1], value);
              switch(node.name) {
                case TOK_EQ:
                  result = strictDeepEqual(first, second);
                  break;
                case TOK_NE:
                  result = !strictDeepEqual(first, second);
                  break;
                case TOK_GT:
                  result = first > second;
                  break;
                case TOK_GTE:
                  result = first >= second;
                  break;
                case TOK_LT:
                  result = first < second;
                  break;
                case TOK_LTE:
                  result = first <= second;
                  break;
                default:
                  throw new Error("Unknown comparator: " + node.name);
              }
              return result;
            case TOK_FLATTEN:
              var original = this.visit(node.children[0], value);
              if (!isArray(original)) {
                return null;
              }
              var merged = [];
              for (i = 0; i < original.length; i++) {
                current = original[i];
                if (isArray(current)) {
                  merged.push.apply(merged, current);
                } else {
                  merged.push(current);
                }
              }
              return merged;
            case "Identity":
              return value;
            case "MultiSelectList":
              if (value === null) {
                return null;
              }
              collected = [];
              for (i = 0; i < node.children.length; i++) {
                  collected.push(this.visit(node.children[i], value));
              }
              return collected;
            case "MultiSelectHash":
              if (value === null) {
                return null;
              }
              collected = {};
              var child;
              for (i = 0; i < node.children.length; i++) {
                child = node.children[i];
                collected[child.name] = this.visit(child.value, value);
              }
              return collected;
            case "OrExpression":
              matched = this.visit(node.children[0], value);
              if (isFalse(matched)) {
                  matched = this.visit(node.children[1], value);
              }
              return matched;
            case "AndExpression":
              first = this.visit(node.children[0], value);

              if (isFalse(first) === true) {
                return first;
              }
              return this.visit(node.children[1], value);
            case "NotExpression":
              first = this.visit(node.children[0], value);
              return isFalse(first);
            case "Literal":
              return node.value;
            case TOK_PIPE:
              left = this.visit(node.children[0], value);
              return this.visit(node.children[1], left);
            case TOK_CURRENT:
              return value;
            case "Function":
              var resolvedArgs = [];
              for (i = 0; i < node.children.length; i++) {
                  resolvedArgs.push(this.visit(node.children[i], value));
              }
              return this.runtime.callFunction(node.name, resolvedArgs);
            case "ExpressionReference":
              var refNode = node.children[0];
              // Tag the node with a specific attribute so the type
              // checker verify the type.
              refNode.jmespathType = TOK_EXPREF;
              return refNode;
            default:
              throw new Error("Unknown node type: " + node.type);
          }
      },

      computeSliceParams: function(arrayLength, sliceParams) {
        var start = sliceParams[0];
        var stop = sliceParams[1];
        var step = sliceParams[2];
        var computed = [null, null, null];
        if (step === null) {
          step = 1;
        } else if (step === 0) {
          var error = new Error("Invalid slice, step cannot be 0");
          error.name = "RuntimeError";
          throw error;
        }
        var stepValueNegative = step < 0 ? true : false;

        if (start === null) {
            start = stepValueNegative ? arrayLength - 1 : 0;
        } else {
            start = this.capSliceRange(arrayLength, start, step);
        }

        if (stop === null) {
            stop = stepValueNegative ? -1 : arrayLength;
        } else {
            stop = this.capSliceRange(arrayLength, stop, step);
        }
        computed[0] = start;
        computed[1] = stop;
        computed[2] = step;
        return computed;
      },

      capSliceRange: function(arrayLength, actualValue, step) {
          if (actualValue < 0) {
              actualValue += arrayLength;
              if (actualValue < 0) {
                  actualValue = step < 0 ? -1 : 0;
              }
          } else if (actualValue >= arrayLength) {
              actualValue = step < 0 ? arrayLength - 1 : arrayLength;
          }
          return actualValue;
      }

  };

  function Runtime(interpreter) {
    this._interpreter = interpreter;
    this.functionTable = {
        // name: [function, <signature>]
        // The <signature> can be:
        //
        // {
        //   args: [[type1, type2], [type1, type2]],
        //   variadic: true|false
        // }
        //
        // Each arg in the arg list is a list of valid types
        // (if the function is overloaded and supports multiple
        // types.  If the type is "any" then no type checking
        // occurs on the argument.  Variadic is optional
        // and if not provided is assumed to be false.
        abs: {_func: this._functionAbs, _signature: [{types: [TYPE_NUMBER]}]},
        avg: {_func: this._functionAvg, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        ceil: {_func: this._functionCeil, _signature: [{types: [TYPE_NUMBER]}]},
        contains: {
            _func: this._functionContains,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]},
                        {types: [TYPE_ANY]}]},
        "ends_with": {
            _func: this._functionEndsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        floor: {_func: this._functionFloor, _signature: [{types: [TYPE_NUMBER]}]},
        length: {
            _func: this._functionLength,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},
        map: {
            _func: this._functionMap,
            _signature: [{types: [TYPE_EXPREF]}, {types: [TYPE_ARRAY]}]},
        max: {
            _func: this._functionMax,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "merge": {
            _func: this._functionMerge,
            _signature: [{types: [TYPE_OBJECT], variadic: true}]
        },
        "max_by": {
          _func: this._functionMaxBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        sum: {_func: this._functionSum, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        "starts_with": {
            _func: this._functionStartsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        min: {
            _func: this._functionMin,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "min_by": {
          _func: this._functionMinBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        type: {_func: this._functionType, _signature: [{types: [TYPE_ANY]}]},
        keys: {_func: this._functionKeys, _signature: [{types: [TYPE_OBJECT]}]},
        values: {_func: this._functionValues, _signature: [{types: [TYPE_OBJECT]}]},
        sort: {_func: this._functionSort, _signature: [{types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},
        "sort_by": {
          _func: this._functionSortBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        join: {
            _func: this._functionJoin,
            _signature: [
                {types: [TYPE_STRING]},
                {types: [TYPE_ARRAY_STRING]}
            ]
        },
        reverse: {
            _func: this._functionReverse,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]}]},
        "to_array": {_func: this._functionToArray, _signature: [{types: [TYPE_ANY]}]},
        "to_string": {_func: this._functionToString, _signature: [{types: [TYPE_ANY]}]},
        "to_number": {_func: this._functionToNumber, _signature: [{types: [TYPE_ANY]}]},
        "not_null": {
            _func: this._functionNotNull,
            _signature: [{types: [TYPE_ANY], variadic: true}]
        }
    };
  }

  Runtime.prototype = {
    callFunction: function(name, resolvedArgs) {
      var functionEntry = this.functionTable[name];
      if (functionEntry === undefined) {
          throw new Error("Unknown function: " + name + "()");
      }
      this._validateArgs(name, resolvedArgs, functionEntry._signature);
      return functionEntry._func.call(this, resolvedArgs);
    },

    _validateArgs: function(name, args, signature) {
        // Validating the args requires validating
        // the correct arity and the correct type of each arg.
        // If the last argument is declared as variadic, then we need
        // a minimum number of args to be required.  Otherwise it has to
        // be an exact amount.
        var pluralized;
        if (signature[signature.length - 1].variadic) {
            if (args.length < signature.length) {
                pluralized = signature.length === 1 ? " argument" : " arguments";
                throw new Error("ArgumentError: " + name + "() " +
                                "takes at least" + signature.length + pluralized +
                                " but received " + args.length);
            }
        } else if (args.length !== signature.length) {
            pluralized = signature.length === 1 ? " argument" : " arguments";
            throw new Error("ArgumentError: " + name + "() " +
                            "takes " + signature.length + pluralized +
                            " but received " + args.length);
        }
        var currentSpec;
        var actualType;
        var typeMatched;
        for (var i = 0; i < signature.length; i++) {
            typeMatched = false;
            currentSpec = signature[i].types;
            actualType = this._getTypeName(args[i]);
            for (var j = 0; j < currentSpec.length; j++) {
                if (this._typeMatches(actualType, currentSpec[j], args[i])) {
                    typeMatched = true;
                    break;
                }
            }
            if (!typeMatched) {
                throw new Error("TypeError: " + name + "() " +
                                "expected argument " + (i + 1) +
                                " to be type " + currentSpec +
                                " but received type " + actualType +
                                " instead.");
            }
        }
    },

    _typeMatches: function(actual, expected, argValue) {
        if (expected === TYPE_ANY) {
            return true;
        }
        if (expected === TYPE_ARRAY_STRING ||
            expected === TYPE_ARRAY_NUMBER ||
            expected === TYPE_ARRAY) {
            // The expected type can either just be array,
            // or it can require a specific subtype (array of numbers).
            //
            // The simplest case is if "array" with no subtype is specified.
            if (expected === TYPE_ARRAY) {
                return actual === TYPE_ARRAY;
            } else if (actual === TYPE_ARRAY) {
                // Otherwise we need to check subtypes.
                // I think this has potential to be improved.
                var subtype;
                if (expected === TYPE_ARRAY_NUMBER) {
                  subtype = TYPE_NUMBER;
                } else if (expected === TYPE_ARRAY_STRING) {
                  subtype = TYPE_STRING;
                }
                for (var i = 0; i < argValue.length; i++) {
                    if (!this._typeMatches(
                            this._getTypeName(argValue[i]), subtype,
                                             argValue[i])) {
                        return false;
                    }
                }
                return true;
            }
        } else {
            return actual === expected;
        }
    },
    _getTypeName: function(obj) {
        switch (Object.prototype.toString.call(obj)) {
            case "[object String]":
              return TYPE_STRING;
            case "[object Number]":
              return TYPE_NUMBER;
            case "[object Array]":
              return TYPE_ARRAY;
            case "[object Boolean]":
              return TYPE_BOOLEAN;
            case "[object Null]":
              return TYPE_NULL;
            case "[object Object]":
              // Check if it's an expref.  If it has, it's been
              // tagged with a jmespathType attr of 'Expref';
              if (obj.jmespathType === TOK_EXPREF) {
                return TYPE_EXPREF;
              } else {
                return TYPE_OBJECT;
              }
        }
    },

    _functionStartsWith: function(resolvedArgs) {
        return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
    },

    _functionEndsWith: function(resolvedArgs) {
        var searchStr = resolvedArgs[0];
        var suffix = resolvedArgs[1];
        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
    },

    _functionReverse: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        if (typeName === TYPE_STRING) {
          var originalStr = resolvedArgs[0];
          var reversedStr = "";
          for (var i = originalStr.length - 1; i >= 0; i--) {
              reversedStr += originalStr[i];
          }
          return reversedStr;
        } else {
          var reversedArray = resolvedArgs[0].slice(0);
          reversedArray.reverse();
          return reversedArray;
        }
    },

    _functionAbs: function(resolvedArgs) {
      return Math.abs(resolvedArgs[0]);
    },

    _functionCeil: function(resolvedArgs) {
        return Math.ceil(resolvedArgs[0]);
    },

    _functionAvg: function(resolvedArgs) {
        var sum = 0;
        var inputArray = resolvedArgs[0];
        for (var i = 0; i < inputArray.length; i++) {
            sum += inputArray[i];
        }
        return sum / inputArray.length;
    },

    _functionContains: function(resolvedArgs) {
        return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
    },

    _functionFloor: function(resolvedArgs) {
        return Math.floor(resolvedArgs[0]);
    },

    _functionLength: function(resolvedArgs) {
       if (!isObject(resolvedArgs[0])) {
         return resolvedArgs[0].length;
       } else {
         // As far as I can tell, there's no way to get the length
         // of an object without O(n) iteration through the object.
         return Object.keys(resolvedArgs[0]).length;
       }
    },

    _functionMap: function(resolvedArgs) {
      var mapped = [];
      var interpreter = this._interpreter;
      var exprefNode = resolvedArgs[0];
      var elements = resolvedArgs[1];
      for (var i = 0; i < elements.length; i++) {
          mapped.push(interpreter.visit(exprefNode, elements[i]));
      }
      return mapped;
    },

    _functionMerge: function(resolvedArgs) {
      var merged = {};
      for (var i = 0; i < resolvedArgs.length; i++) {
        var current = resolvedArgs[i];
        for (var key in current) {
          merged[key] = current[key];
        }
      }
      return merged;
    },

    _functionMax: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.max.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var maxElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (maxElement.localeCompare(elements[i]) < 0) {
                  maxElement = elements[i];
              }
          }
          return maxElement;
        }
      } else {
          return null;
      }
    },

    _functionMin: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.min.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var minElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (elements[i].localeCompare(minElement) < 0) {
                  minElement = elements[i];
              }
          }
          return minElement;
        }
      } else {
        return null;
      }
    },

    _functionSum: function(resolvedArgs) {
      var sum = 0;
      var listToSum = resolvedArgs[0];
      for (var i = 0; i < listToSum.length; i++) {
        sum += listToSum[i];
      }
      return sum;
    },

    _functionType: function(resolvedArgs) {
        switch (this._getTypeName(resolvedArgs[0])) {
          case TYPE_NUMBER:
            return "number";
          case TYPE_STRING:
            return "string";
          case TYPE_ARRAY:
            return "array";
          case TYPE_OBJECT:
            return "object";
          case TYPE_BOOLEAN:
            return "boolean";
          case TYPE_EXPREF:
            return "expref";
          case TYPE_NULL:
            return "null";
        }
    },

    _functionKeys: function(resolvedArgs) {
        return Object.keys(resolvedArgs[0]);
    },

    _functionValues: function(resolvedArgs) {
        var obj = resolvedArgs[0];
        var keys = Object.keys(obj);
        var values = [];
        for (var i = 0; i < keys.length; i++) {
            values.push(obj[keys[i]]);
        }
        return values;
    },

    _functionJoin: function(resolvedArgs) {
        var joinChar = resolvedArgs[0];
        var listJoin = resolvedArgs[1];
        return listJoin.join(joinChar);
    },

    _functionToArray: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
            return resolvedArgs[0];
        } else {
            return [resolvedArgs[0]];
        }
    },

    _functionToString: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
            return resolvedArgs[0];
        } else {
            return JSON.stringify(resolvedArgs[0]);
        }
    },

    _functionToNumber: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        var convertedValue;
        if (typeName === TYPE_NUMBER) {
            return resolvedArgs[0];
        } else if (typeName === TYPE_STRING) {
            convertedValue = +resolvedArgs[0];
            if (!isNaN(convertedValue)) {
                return convertedValue;
            }
        }
        return null;
    },

    _functionNotNull: function(resolvedArgs) {
        for (var i = 0; i < resolvedArgs.length; i++) {
            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
                return resolvedArgs[i];
            }
        }
        return null;
    },

    _functionSort: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        sortedArray.sort();
        return sortedArray;
    },

    _functionSortBy: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        if (sortedArray.length === 0) {
            return sortedArray;
        }
        var interpreter = this._interpreter;
        var exprefNode = resolvedArgs[1];
        var requiredType = this._getTypeName(
            interpreter.visit(exprefNode, sortedArray[0]));
        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
            throw new Error("TypeError");
        }
        var that = this;
        // In order to get a stable sort out of an unstable
        // sort algorithm, we decorate/sort/undecorate (DSU)
        // by creating a new list of [index, element] pairs.
        // In the cmp function, if the evaluated elements are
        // equal, then the index will be used as the tiebreaker.
        // After the decorated list has been sorted, it will be
        // undecorated to extract the original elements.
        var decorated = [];
        for (var i = 0; i < sortedArray.length; i++) {
          decorated.push([i, sortedArray[i]]);
        }
        decorated.sort(function(a, b) {
          var exprA = interpreter.visit(exprefNode, a[1]);
          var exprB = interpreter.visit(exprefNode, b[1]);
          if (that._getTypeName(exprA) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprA));
          } else if (that._getTypeName(exprB) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprB));
          }
          if (exprA > exprB) {
            return 1;
          } else if (exprA < exprB) {
            return -1;
          } else {
            // If they're equal compare the items by their
            // order to maintain relative order of equal keys
            // (i.e. to get a stable sort).
            return a[0] - b[0];
          }
        });
        // Undecorate: extract out the original list elements.
        for (var j = 0; j < decorated.length; j++) {
          sortedArray[j] = decorated[j][1];
        }
        return sortedArray;
    },

    _functionMaxBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var maxNumber = -Infinity;
      var maxRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current > maxNumber) {
          maxNumber = current;
          maxRecord = resolvedArray[i];
        }
      }
      return maxRecord;
    },

    _functionMinBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var minNumber = Infinity;
      var minRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current < minNumber) {
          minNumber = current;
          minRecord = resolvedArray[i];
        }
      }
      return minRecord;
    },

    createKeyFunction: function(exprefNode, allowedTypes) {
      var that = this;
      var interpreter = this._interpreter;
      var keyFunc = function(x) {
        var current = interpreter.visit(exprefNode, x);
        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
          var msg = "TypeError: expected one of " + allowedTypes +
                    ", received " + that._getTypeName(current);
          throw new Error(msg);
        }
        return current;
      };
      return keyFunc;
    }

  };

  function compile(stream) {
    var parser = new Parser();
    var ast = parser.parse(stream);
    return ast;
  }

  function tokenize(stream) {
      var lexer = new Lexer();
      return lexer.tokenize(stream);
  }

  function search(data, expression) {
      var parser = new Parser();
      // This needs to be improved.  Both the interpreter and runtime depend on
      // each other.  The runtime needs the interpreter to support exprefs.
      // There's likely a clean way to avoid the cyclic dependency.
      var runtime = new Runtime();
      var interpreter = new TreeInterpreter(runtime);
      runtime._interpreter = interpreter;
      var node = parser.parse(expression);
      return interpreter.search(node, data);
  }

  exports.tokenize = tokenize;
  exports.compile = compile;
  exports.search = search;
  exports.strictDeepEqual = strictDeepEqual;
})(typeof exports === "undefined" ? this.jmespath = {} : exports);

},{}],95:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],96:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],97:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],98:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],99:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":97,"./encode":98}],100:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

},{}],101:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

},{}],102:[function(require,module,exports){
arguments[4][99][0].apply(exports,arguments)
},{"./decode":100,"./encode":101,"dup":99}],103:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":95,"timers":103}],104:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":96,"querystring":99}],105:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],106:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],107:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":106,"_process":95,"inherits":105}],108:[function(require,module,exports){
var v1 = require('./v1');
var v4 = require('./v4');

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;

},{"./v1":111,"./v4":112}],109:[function(require,module,exports){
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;

},{}],110:[function(require,module,exports){
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

},{}],111:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;

},{"./lib/bytesToUuid":109,"./lib/rng":110}],112:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

},{"./lib/bytesToUuid":109,"./lib/rng":110}],113:[function(require,module,exports){
"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var AWS = __importStar(require("aws-sdk/global"));
var console_wrapper_1 = require("./../utils/console_wrapper");
console_wrapper_1.log('cognito loaded.', 2 /* BASIC */);
var CredentialsProvider = /** @class */ (function () {
    function CredentialsProvider(identityPoolId, region) {
        this.region = region;
        AWS.config.region = region;
        this.creds = new AWS.CognitoIdentityCredentials({
            IdentityPoolId: identityPoolId,
        });
        this.creds.get(function (error) {
            error
                ? console_wrapper_1.log(error.message, 3 /* DETAILED */)
                : console_wrapper_1.log('No error was reported.', 3 /* DETAILED */);
        });
        AWS.config.credentials = this.creds;
    }
    CredentialsProvider.get = function (identityPoolId, region) {
        if (identityPoolId === void 0) { identityPoolId = CredentialsProvider.ipID; }
        if (region === void 0) { region = CredentialsProvider.region; }
        return new CredentialsProvider(identityPoolId, region);
    };
    Object.defineProperty(CredentialsProvider.prototype, "credentials", {
        get: function () {
            return this.creds;
        },
        enumerable: true,
        configurable: true
    });
    CredentialsProvider.ipID = 'us-east-2:94f763ec-3864-4e89-810d-6d2ba70172ba';
    CredentialsProvider.region = 'us-east-2';
    return CredentialsProvider;
}());
exports.CredentialsProvider = CredentialsProvider;
},{"./../utils/console_wrapper":130,"aws-sdk/global":9}],114:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var cognito_1 = require("./cognito");
var s3_1 = require("./s3");
console_wrapper_1.log('mturk loaded.', 2 /* BASIC */);
var MturkClient = /** @class */ (function () {
    function MturkClient() {
    }
    MturkClient.init = function (bucketName, keyPrefix) {
        MturkClient.s3 = s3_1.S3Client.get(bucketName, keyPrefix);
        Object.assign(window, {
            s3: MturkClient.s3,
            cog: MturkClient.cognito,
            sub: MturkClient.submit,
        });
    };
    MturkClient.submit = function (name, data) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, console_wrapper_1.error(function () { return __awaiter(_this, void 0, void 0, function () {
                        var strData, ret;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    strData = JSON.stringify(data);
                                    console.log(strData);
                                    return [4 /*yield*/, MturkClient.s3.upload(name, strData)];
                                case 1:
                                    ret = _a.sent();
                                    ret = ret;
                                    return [2 /*return*/];
                            }
                        });
                    }); })];
            });
        });
    };
    MturkClient.keyGen = function (hitID, assignmentID) {
        return hitID + "_" + assignmentID + "_log.json";
    };
    MturkClient.updateCognito = function (cp) {
        MturkClient.cognito = cp;
    };
    MturkClient.updateS3 = function (s3) {
        MturkClient.s3 = s3;
    };
    // TODO: Change these back to private after debugging.
    MturkClient.cognito = cognito_1.CredentialsProvider.get();
    return MturkClient;
}());
exports.MturkClient = MturkClient;
},{"../utils/console_wrapper":130,"./cognito":113,"./s3":115}],115:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var s3_1 = __importDefault(require("aws-sdk/clients/s3"));
var console_wrapper_1 = require("../utils/console_wrapper");
console_wrapper_1.log('s3 loaded.', 2 /* BASIC */);
var S3Client = /** @class */ (function () {
    function S3Client(bucketName, keyPrefix) {
        this.bucketName = bucketName;
        this.keyPrefix = keyPrefix;
        this.s3 = new s3_1.default({
            apiVersion: S3Client.apiVersion,
        });
    }
    S3Client.get = function (bucket, keyPrefix) {
        if (bucket === void 0) { bucket = S3Client.bucketName; }
        return new S3Client(bucket, keyPrefix);
    };
    Object.defineProperty(S3Client.prototype, "bucket", {
        get: function () {
            return this.bucketName;
        },
        enumerable: true,
        configurable: true
    });
    S3Client.prototype.upload = function (name, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.s3.putObject({
                Key: _this.keyPrefix + '/' + name,
                Body: data,
                Bucket: _this.bucket,
            }, function (err, success) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(success);
                }
            });
        });
    };
    S3Client.bucketName = '';
    S3Client.apiVersion = '2006-03-01';
    S3Client.keyPrefix = '';
    return S3Client;
}());
exports.S3Client = S3Client;
},{"../utils/console_wrapper":130,"aws-sdk/clients/s3":11}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
console.log('data loaded.');
var urlParams = new URLSearchParams(window.location.hash.split('?')[1]);
exports.urlData = {
    raw: urlParams.toString(),
    assignmentID: urlParams.get('assignmentId'),
    hitID: urlParams.get('hitId'),
    workerID: urlParams.get('workerId'),
    submitTo: urlParams.get('turkSubmitTo'),
};
var Data = /** @class */ (function () {
    function Data(rawMturkURLData) {
        this.logs = {};
        this.data = {};
        this.errors = [];
        this.urlData = rawMturkURLData;
    }
    Data.prototype.serialize = function () {
        return JSON.stringify(this);
    };
    return Data;
}());
exports.Data = Data;
exports.data = new Data(exports.urlData);
Object.assign(window, { data: exports.data });
},{}],117:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var funcs_1 = require("../utils/funcs");
console_wrapper_1.log("event loaded.", 2 /* BASIC */);
function objectToTrackerEvent(obj, action) {
    obj.action = action;
    obj.time = funcs_1.now();
}
exports.objectToTrackerEvent = objectToTrackerEvent;
function isTrackerEvent(obj) {
    return obj.action !== undefined && obj.time !== undefined;
}
exports.isTrackerEvent = isTrackerEvent;
var BaseTrackerEvent = /** @class */ (function () {
    function BaseTrackerEvent(action, eventInitDict) {
        this.custEv = new CustomEvent(action, eventInitDict);
        this.action = action;
        this.time = funcs_1.now();
    }
    Object.defineProperty(BaseTrackerEvent.prototype, "detail", {
        get: function () {
            return this.custEv.detail;
        },
        enumerable: true,
        configurable: true
    });
    return BaseTrackerEvent;
}());
exports.BaseTrackerEvent = BaseTrackerEvent;
// tslint:disable-next-line: max-classes-per-file
var ClickEvent = /** @class */ (function (_super) {
    __extends(ClickEvent, _super);
    function ClickEvent(x, y, id, eventInitDict) {
        var _this = _super.call(this, "click" /* CLICK */, eventInitDict) || this;
        _this.detail.x = x;
        _this.detail.y = y;
        _this.detail.id = id;
        return _this;
    }
    return ClickEvent;
}(BaseTrackerEvent));
exports.ClickEvent = ClickEvent;
// tslint:disable-next-line: max-classes-per-file
var ButtonEvent = /** @class */ (function (_super) {
    __extends(ButtonEvent, _super);
    function ButtonEvent(key, id, eventInitDict) {
        var _this = _super.call(this, "click" /* CLICK */, eventInitDict) || this;
        _this.detail.key = key;
        _this.detail.id = id;
        return _this;
    }
    return ButtonEvent;
}(BaseTrackerEvent));
exports.ButtonEvent = ButtonEvent;
// tslint:disable-next-line: max-classes-per-file
var HistoryEvent = /** @class */ (function (_super) {
    __extends(HistoryEvent, _super);
    function HistoryEvent(url, extra, eventInitDict) {
        var _this = _super.call(this, "history" /* HISTORY */, eventInitDict) || this;
        _this.detail.url = url;
        _this.detail.extra = extra;
        return _this;
    }
    return HistoryEvent;
}(BaseTrackerEvent));
exports.HistoryEvent = HistoryEvent;
},{"../utils/console_wrapper":130,"../utils/funcs":131}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var event_1 = require("./event");
console_wrapper_1.log("receiver loaded.", 2 /* BASIC */);
var EventReceiver = /** @class */ (function () {
    function EventReceiver() {
        this.map = new Map();
        this.emitter = new EventTarget();
    }
    EventReceiver.prototype.register = function (eventType, callback) {
        this.emitter.addEventListener(eventType, function (event) {
            var trackEv = event
                .detail;
            if (event_1.isTrackerEvent(trackEv) && callback) {
                callback(trackEv);
            }
        });
        if (callback) {
            this.map.set(eventType, callback);
        }
    };
    EventReceiver.prototype.doEvent = function (event) {
        var callback = this.map.get("" + event.action);
        if (callback) {
            callback(event);
        }
    };
    return EventReceiver;
}());
exports.EventReceiver = EventReceiver;
},{"../utils/console_wrapper":130,"./event":117}],119:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var router_1 = require("../router/router");
var console_wrapper_1 = require("../utils/console_wrapper");
var history_1 = require("./../router/history");
var document_1 = require("./document");
var elements_1 = require("./elements");
console_wrapper_1.log("banner loaded.", 2 /* BASIC */);
var TopBanner = /** @class */ (function () {
    function TopBanner() {
    }
    TopBanner.show = function () {
        TopBanner.showing = true;
        document_1.D.display(elements_1.Elements.ddUp, true);
        document_1.D.display(elements_1.Elements.ddDown, false);
        document_1.D.display(elements_1.Elements.ddContent, true);
    };
    TopBanner.hide = function () {
        TopBanner.showing = false;
        document_1.D.display(elements_1.Elements.ddDown, true);
        document_1.D.display(elements_1.Elements.ddUp, false);
        document_1.D.display(elements_1.Elements.ddContent, false);
    };
    TopBanner.doDisplayChange = function () {
        TopBanner.showing ? TopBanner.hide() : TopBanner.show();
    };
    TopBanner.setup = function () {
        document_1.D.addEventListener(elements_1.Elements.ddArrow, "click", TopBanner.doDisplayChange);
    };
    TopBanner.showing = true;
    return TopBanner;
}());
exports.TopBanner = TopBanner;
document_1.D.addEventListener("mturk-top-banner-back", "click", function (e) {
    if (history_1.History.canBackward()) {
        router_1.Router.loadWithPathPrefix(history_1.History.backward());
    }
    else {
        alert("There is no page history to go back for at this time!");
    }
});
},{"../router/router":128,"../utils/console_wrapper":130,"./../router/history":127,"./document":120,"./elements":121}],120:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("./../utils/console_wrapper");
console_wrapper_1.log("document loaded.", 2 /* BASIC */);
var D = /** @class */ (function () {
    function D() {
    }
    D.elem = function (elem) {
        if (typeof elem === "string") {
            return D.id(elem);
        }
        else {
            return elem;
        }
    };
    D.display = function (elem, show) {
        elem = D.elem(elem);
        if (show) {
            elem.classList.remove("none");
            elem.classList.add("display");
        }
        else {
            elem.classList.remove("display");
            elem.classList.add("none");
        }
    };
    D.id = function (id) {
        var element = D.doc.getElementById(id);
        if (element === null) {
            throw new Error("Element was not found, id: <" + id + ">.");
        }
        else {
            return element;
        }
    };
    D.claz = function (claz) {
        return D.doc.getElementsByClassName(claz);
    };
    D.tag = function (tag) {
        return D.doc.getElementsByTagName(tag);
    };
    D.image = function (id, url) {
        console_wrapper_1.error(function () { return D.id(id).setAttribute("src", url); });
    };
    D.addEventListener = function (elem, type, listener) {
        elem = this.elem(elem);
        var wrapperFunc = function (e) {
            try {
                listener(e);
            }
            catch (err) {
                console.error(err);
            }
        };
        elem.addEventListener(type, wrapperFunc);
        return wrapperFunc;
    };
    D.each = function (elem, apply) {
        elem = this.elem(elem);
        var children = elem.children;
        for (var i = 0; i < children.length; i++) {
            apply(children[i]);
        }
    };
    D.eachRecur = function (elem, apply) {
        elem = this.elem(elem);
        var children = elem.children;
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            apply(child);
            D.eachRecur(child, apply);
        }
    };
    D.create = function (tagName, options) {
        return document.createElement(tagName, options);
    };
    D.doc = document;
    return D;
}());
exports.D = D;
},{"./../utils/console_wrapper":130}],121:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var document_1 = require("./document");
console_wrapper_1.log('element loaded.', 2 /* BASIC */);
/**
 * These are elements that are in every single project. Even if they are not used they should
 * be place in the project and display should be set to none. This simplifies configuration
 * and some common functions and allows less null checks to be performed overall. If the
 * element does not exist at run time an empty div with that id is created and its display
 * is set to none then appended to the body.
 */
/**
 * Attempts to get an element, if unsuccessful, creates div with id and appends to body.
 *
 * @param id - the id of the element to retrieve.
 */
function makeElemIfNotExist(id) {
    var elem;
    try {
        elem = document_1.D.id(id);
    }
    catch (err) {
        elem = document_1.D.create('div');
        elem.id = id;
        elem.style.display = 'none';
        document.body.append(elem);
    }
    return elem;
}
/**
 * Commonly accessed elements, allows for clearer dom manip on these elements.
 */
exports.Elements = {
    document: document_1.D.doc.documentElement,
    wrapper: makeElemIfNotExist('wrapper'),
    htmlLoc: makeElemIfNotExist('html-loc'),
    innerBody: makeElemIfNotExist('inner-body'),
    ddDown: makeElemIfNotExist('mturk-top-banner-drop-down-button'),
    ddUp: makeElemIfNotExist('mturk-top-banner-collapse-button'),
    ddContent: makeElemIfNotExist('mturk-top-banner-drop-down-content'),
    backButton: makeElemIfNotExist('mturk-top-banner-back'),
    ddArrow: makeElemIfNotExist('mturk-top-banner-arrow'),
    mtTopBannerText: makeElemIfNotExist('mturk-top-banner-text'),
    mtScenarioContext: makeElemIfNotExist('scenario_context'),
    mtScenarioQuestion: makeElemIfNotExist('scenario_question'),
    logFileInput: makeElemIfNotExist('mturk-top-banner-drop-down-content-log-file-input'),
    submitForm: makeElemIfNotExist('mturk-submit-form'),
    modal: makeElemIfNotExist('modal'),
};
},{"../utils/console_wrapper":130,"./document":120}],122:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var elements_1 = require("./../dom/elements");
console_wrapper_1.log('html loc loaded.', 2 /* BASIC */);
var AppEnum;
(function (AppEnum) {
    AppEnum["INFORMATION_FORAGING"] = "information-foraging";
    AppEnum["COGNITIVE_LOAD"] = "cognitive-load";
    AppEnum["GENDER_MAG"] = "gender-mag";
    AppEnum["ERROR"] = "error";
})(AppEnum = exports.AppEnum || (exports.AppEnum = {}));
var ModeEnum;
(function (ModeEnum) {
    ModeEnum["REAL"] = "real";
    ModeEnum["SANDBOX"] = "sandbox";
    ModeEnum["TEST"] = "test";
    ModeEnum["ERROR"] = "error";
})(ModeEnum = exports.ModeEnum || (exports.ModeEnum = {}));
var HTMLLoc = /** @class */ (function () {
    function HTMLLoc() {
    }
    HTMLLoc.setup = function () {
        HTMLLoc.app = HTMLLoc.elem.dataset.app || AppEnum.ERROR;
        HTMLLoc.mode =
            HTMLLoc.elem.dataset.mode || ModeEnum.ERROR;
        HTMLLoc.scenario = HTMLLoc.elem.dataset.scenario || 'error';
    };
    HTMLLoc.elem = elements_1.Elements.htmlLoc;
    return HTMLLoc;
}());
exports.HTMLLoc = HTMLLoc;
},{"../utils/console_wrapper":130,"./../dom/elements":121}],123:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("./../utils/console_wrapper");
var document_1 = require("./document");
var elements_1 = require("./elements");
console_wrapper_1.log('modal loaded.', 2 /* BASIC */);
var Modal = /** @class */ (function () {
    function Modal() {
    }
    Modal.display = function (src) {
        Modal.elem.setAttribute('style', "left: " + Math.round(window.pageXOffset) + "px; top: " + Math.round(window.pageYOffset) + "px;");
        Modal.elem.classList.replace('hide-modal', 'show-modal');
        document_1.D.each(Modal.elem, function (node) {
            node.src = src;
        });
        document.body.classList.add('noscroll');
    };
    Modal.hide = function () {
        Modal.elem.classList.replace('show-modal', 'hide-modal');
        document_1.D.each(Modal.elem, function (node) {
            node.src = '';
        });
        document.body.classList.remove('noscroll');
    };
    Modal.elem = elements_1.Elements.modal;
    return Modal;
}());
exports.Modal = Modal;
document_1.D.addEventListener(Modal.elem, 'click', function (e) {
    Modal.hide();
});
document_1.D.each(Modal.elem, function (node) {
    document_1.D.addEventListener(node, 'click', function (e) {
        e.preventDefault();
    });
});
},{"./../utils/console_wrapper":130,"./document":120,"./elements":121}],124:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var funcs_1 = require("./../utils/funcs");
console_wrapper_1.log("scroll loaded.", 2 /* BASIC */);
/**
 * Linear implementation of scrolling.
 * Follows the singleton pattern, call do to start a scroll operation.
 *
 * If a scroll is called when another scroll has already begun an
 * error will be thrown, but the first scroll will continue until completion.
 */
var Scroll = /** @class */ (function () {
    function Scroll(endPos, duration, complete) {
        this.endPos = endPos;
        this.duration = duration;
        this.complete = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            document.dispatchEvent(new CustomEvent("scroll"));
            complete(args);
        };
    }
    Scroll.callback = function (endPos, duration, complete) {
        if (duration === void 0) { duration = 200; }
        if (complete === void 0) { complete = funcs_1.noop; }
        if (Scroll.running) {
            throw new Error("Cannot make multiple calls to scroll at the same time.");
        }
        Scroll.running = true;
        var oldComplete = complete;
        complete = function () {
            Scroll.running = false;
            console_wrapper_1.error(oldComplete);
        };
        this.instance.update(endPos, duration, complete).attemptScroll();
    };
    Scroll.promise = function (endPos, duration) {
        var _this = this;
        if (duration === void 0) { duration = 200; }
        if (Scroll.running) {
            throw new Error("Cannot make multiple calls to scroll at the same time.");
        }
        Scroll.running = true;
        return new Promise(function (resolve, reject) {
            try {
                var runResolver = function () {
                    Scroll.running = false;
                    resolve();
                };
                _this.instance.update(endPos, duration, runResolver).attemptScroll();
            }
            catch (err) {
                Scroll.running = false;
                reject(err);
            }
        });
    };
    Object.defineProperty(Scroll, "isRunning", {
        get: function () {
            return Scroll.running;
        },
        enumerable: true,
        configurable: true
    });
    Scroll.prototype.update = function (endPos, duration, complete) {
        this.endPos = endPos;
        this.duration = duration;
        this.complete = complete;
        return this;
    };
    Scroll.prototype.calcScrollAmount = function () {
        var curTime = funcs_1.now();
        var steps = Math.max(1, (this.duration - curTime) / Scroll.STEP_IN_MS);
        var curPos = window.pageYOffset;
        return Math.ceil((this.endPos - curPos) / steps);
    };
    Scroll.prototype.scroll = function () {
        window.scroll(0, this.calcScrollAmount());
        if (window.pageYOffset === this.endPos) {
            this.complete();
        }
        else {
            requestAnimationFrame(this.scroll);
        }
    };
    Scroll.prototype.attemptScroll = function () {
        if ("requestAnimationFrame" in window === false) {
            window.scroll(0, this.endPos);
        }
        this.scroll();
    };
    Scroll.STEP_IN_MS = 17;
    Scroll.running = false;
    Scroll.instance = new Scroll(0, 0, funcs_1.noop);
    return Scroll;
}());
exports.Scroll = Scroll;
},{"../utils/console_wrapper":130,"./../utils/funcs":131}],125:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var funcs_1 = require("../utils/funcs");
var mturk_1 = require("./../aws/mturk");
var data_1 = require("./../data-log/data");
var console_wrapper_1 = require("./../utils/console_wrapper");
var document_1 = require("./document");
var elements_1 = require("./elements");
console_wrapper_1.log('submit form loaded.', 2 /* BASIC */);
var AllowSubmissionDefault = {
    allow: function () { return null; },
    preSubmit: funcs_1.noop,
};
var SubmitForm = /** @class */ (function () {
    function SubmitForm() {
    }
    SubmitForm.setup = function (allowSubmission) {
        var _this = this;
        if (allowSubmission === void 0) { allowSubmission = AllowSubmissionDefault; }
        if (data_1.data.urlData.assignmentID !== null) {
            document_1.D.id('assignment-id').value =
                data_1.data.urlData.assignmentID;
        }
        if (data_1.data.urlData.hitID !== null) {
            document_1.D.id('hit-id').value = data_1.data.urlData.hitID;
        }
        SubmitForm.submitFunc = function (event) { return __awaiter(_this, void 0, void 0, function () {
            var allowed, hitID, assignmnetID;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        event.preventDefault();
                        allowed = allowSubmission.allow();
                        if (!(allowed === null)) return [3 /*break*/, 2];
                        allowSubmission.preSubmit();
                        hitID = data_1.data.urlData.hitID;
                        if (hitID === null) {
                            hitID = 'hitid' + Math.round(Math.random() * 100000);
                        }
                        assignmnetID = data_1.data.urlData.assignmentID;
                        if (assignmnetID === null) {
                            assignmnetID =
                                'assignmnetid' + Math.round(Math.random() * 100000);
                        }
                        return [4 /*yield*/, mturk_1.MturkClient.submit(mturk_1.MturkClient.keyGen(hitID, assignmnetID), data_1.data)];
                    case 1:
                        _a.sent();
                        console.log('hello');
                        SubmitForm.elem.removeEventListener('submit', SubmitForm.submitFunc);
                        SubmitForm.elem.submit();
                        return [3 /*break*/, 3];
                    case 2:
                        alert(allowed);
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        }); };
        SubmitForm.elem.addEventListener('submit', SubmitForm.submitFunc);
    };
    SubmitForm.elem = elements_1.Elements.submitForm;
    SubmitForm.allowSubmitDefault = { allow: function () { return true; }, preSubmit: funcs_1.noop };
    return SubmitForm;
}());
exports.SubmitForm = SubmitForm;
},{"../utils/funcs":131,"./../aws/mturk":114,"./../data-log/data":116,"./../utils/console_wrapper":130,"./document":120,"./elements":121}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var banner_1 = require("./banner");
var html_loc_1 = require("./html_loc");
var TrackerElements = /** @class */ (function () {
    function TrackerElements() {
    }
    TrackerElements.setupTrackerElements = function () {
        // setup dom elements
        banner_1.TopBanner.setup();
        html_loc_1.HTMLLoc.setup();
    };
    return TrackerElements;
}());
exports.TrackerElements = TrackerElements;
},{"./banner":119,"./html_loc":122}],127:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tracker_1 = require("./../tracker/tracker");
function newHistoryEntry(currURL, hasPrevURL, prevEntry, extra) {
    tracker_1.Tracker.getEventDispatchFunc('history')({ url: currURL, extra: extra });
    return {
        currURL: currURL,
        hasPrevURL: hasPrevURL,
        prevEntry: prevEntry,
        extra: extra,
        nextEntries: [],
    };
}
var History = /** @class */ (function () {
    function History() {
    }
    History.forward = function (url, extra) {
        var histEnt = newHistoryEntry(url, true, History.currhistory, extra);
        History.currhistory.nextEntries.push(histEnt);
        History.currhistory = histEnt;
        return url;
    };
    History.canBackward = function () {
        var _a, _b;
        return (History.currhistory.hasPrevURL &&
            !((_b = (_a = History.currhistory.prevEntry) === null || _a === void 0 ? void 0 : _a.extra) === null || _b === void 0 ? void 0 : _b.wrapper));
    };
    History.backward = function () {
        if (!History.canBackward()) {
            throw new Error('Cannot go back any further.');
        }
        console.log(History.currhistory.prevEntry);
        var prevEntry = History.currhistory.prevEntry;
        var nextURL = prevEntry.currURL;
        var histEnt = newHistoryEntry(nextURL, prevEntry.hasPrevURL, prevEntry.prevEntry, { back: true });
        History.currhistory = histEnt;
        return nextURL;
    };
    History.setup = function (url, extra) {
        History.firstHistory = newHistoryEntry(url, false, undefined, extra);
        History.currhistory = History.firstHistory;
    };
    return History;
}());
exports.History = History;
},{"./../tracker/tracker":129}],128:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var document_1 = require("../dom/document");
var elements_1 = require("../dom/elements");
var modal_1 = require("../dom/modal");
var console_wrapper_1 = require("../utils/console_wrapper");
var funcs_1 = require("../utils/funcs");
var html_loader_1 = require("../utils/html_loader");
var history_1 = require("./history");
console_wrapper_1.log('router loaded.', 2 /* BASIC */);
function testOn(elem, config) {
    return (elem.tagName === config.module &&
        (config.mode === 1 /* ON */ ||
            config.mode === 2 /* STANDARD_ALLOWANCES */));
}
function testAllowance(config) {
    return config.mode === 2 /* STANDARD_ALLOWANCES */;
}
var Router = /** @class */ (function () {
    function Router() {
    }
    Router.configure = function (configs, pathPrefix) {
        configs.forEach(function (config) {
            Router.configs.set(config.module, Router.upgradeConfig(config));
        });
        Router.pathPrefix = pathPrefix;
    };
    Router.setup = function (elem) {
        document_1.D.eachRecur(elem, function (node) {
            var e_1, _a;
            try {
                for (var _b = __values(Router.configs.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var config = _c.value;
                    if (testOn(node, config)) {
                        config.setup(config, node);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    };
    Router.STANDARD_LINK_LISTENER = function (e) {
        return console_wrapper_1.error(function () {
            e.preventDefault();
            var target = e.target;
            var url = target.href;
            history_1.History.forward(Router.getPathName(url));
            var ret = html_loader_1.HTMLLoader.loadURL(url, elements_1.Elements.htmlLoc);
            window.dispatchEvent(new CustomEvent('newPageLoad'));
            return ret;
        });
    };
    Router.ON_COMPLETE_SLL = function (post) {
        var _this = this;
        return function (e) {
            console_wrapper_1.error(function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, Router.STANDARD_LINK_LISTENER(e)];
                        case 1:
                            _a.sent();
                            post(e);
                            return [2 /*return*/];
                    }
                });
            }); });
        };
    };
    Router.IMAGE_LINK_LISTENER = function (e) {
        return console_wrapper_1.error(function () {
            // TODO: Load modal or load nothing at all, fix this
            e.preventDefault();
            var target = e.target;
            var url = target.src;
            history_1.History.forward(Router.getPathName(url));
            return html_loader_1.HTMLLoader.loadURL(url, elements_1.Elements.htmlLoc);
        });
    };
    Router.FORM_OFF_LISTENER = function (e) {
        e.preventDefault();
        console.error('All forms except for the one in the top header are inactive.');
    };
    Router.defaultAllowancesOn = function () {
        Router.registerAllowance({ regex: Router.EMPTY, func: Router.EMPTY_RESPONDER }, { regex: Router.HASH_TAGS, func: Router.HASH_TAG_RESPONDER }, { regex: Router.AT_SYMBOL, func: Router.AT_SYMBOL_RESPONDER });
    };
    Router.defaultAllowancesOff = function () {
        Router.unregisterAllowance(Router.EMPTY, Router.HASH_TAGS, Router.AT_SYMBOL);
    };
    Router.registerAllowance = function () {
        var regexs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            regexs[_i] = arguments[_i];
        }
        regexs.forEach(function (regex) {
            return Router.linkAllowances.set(regex.regex, regex.func);
        });
    };
    Router.unregisterAllowance = function () {
        var regexs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            regexs[_i] = arguments[_i];
        }
        regexs.forEach(function (regex) { return Router.linkAllowances.delete(regex); });
    };
    Router.clearAllowances = function () {
        Router.linkAllowances.clear();
    };
    Router.load = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var ret;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        history_1.History.forward(Router.getPathName(url));
                        return [4 /*yield*/, html_loader_1.HTMLLoader.loadURL(url, elements_1.Elements.htmlLoc)];
                    case 1:
                        ret = _a.sent();
                        window.dispatchEvent(new CustomEvent('newPageLoad'));
                        return [2 /*return*/, ret];
                }
            });
        });
    };
    Router.loadWithPathPrefix = function (page) {
        return __awaiter(this, void 0, void 0, function () {
            var ret;
            return __generator(this, function (_a) {
                ret = html_loader_1.HTMLLoader.loadURL(Router.pathPrefix + page, elements_1.Elements.htmlLoc);
                window.dispatchEvent(new CustomEvent('newPageLoad'));
                return [2 /*return*/, ret];
            });
        });
    };
    Router.upgradeConfig = function (config) {
        return {
            module: config.module,
            mode: config.mode,
            setup: Router.SetupFunctions[config.module],
        };
    };
    Router.getPathName = function (url) {
        var ret = Router.pathRegex.exec(url);
        return ret === null ? url : ret.length > 1 ? ret[1] : url;
    };
    Router.HASH_TAGS = new RegExp('#');
    Router.EMPTY = new RegExp('^$');
    Router.AT_SYMBOL = new RegExp('@');
    Router.HASH_TAG_RESPONDER = funcs_1.noop;
    Router.EMPTY_RESPONDER = function (event) { return event.preventDefault(); };
    Router.AT_SYMBOL_RESPONDER = function (event) {
        return event.preventDefault();
    };
    Router.pathPrefix = '';
    Router.SetupFunctions = {
        A: function (config, elem) {
            var aNode = elem;
            if (testAllowance(config)) {
                var passesRegexTest_1 = true;
                var href_1 = aNode.href;
                Router.linkAllowances.forEach(function (func, regex) {
                    var test = regex.test(href_1);
                    passesRegexTest_1 = passesRegexTest_1 && !test;
                    if (test) {
                        document_1.D.addEventListener(elem, 'click', func);
                    }
                });
                if (passesRegexTest_1) {
                    if (href_1.substr(href_1.length - 3) === 'pdf') {
                        document_1.D.addEventListener(elem, 'click', function (e) {
                            e.preventDefault();
                            modal_1.Modal.display(href_1);
                        });
                    }
                    else {
                        document_1.D.addEventListener(elem, 'click', function (e) {
                            return Router.STANDARD_LINK_LISTENER(e);
                        });
                    }
                }
            }
            else {
                document_1.D.addEventListener(elem, 'click', function (e) {
                    return Router.STANDARD_LINK_LISTENER(e);
                });
            }
        },
        IMG: function (config, elem) {
            var imgNode = elem;
            if (testAllowance(config)) {
                var passesRegexTest_2 = true;
                Router.linkAllowances.forEach(function (func, regex) {
                    var test = !regex.test(imgNode.src);
                    passesRegexTest_2 = passesRegexTest_2 && test;
                    if (test) {
                        document_1.D.addEventListener(elem, 'click', func);
                    }
                });
                if (passesRegexTest_2) {
                    document_1.D.addEventListener(elem, 'click', function (e) {
                        return Router.STANDARD_LINK_LISTENER(e);
                    });
                }
            }
            else {
                document_1.D.addEventListener(elem, 'click', function (e) {
                    return Router.STANDARD_LINK_LISTENER(e);
                });
            }
        },
        FORM: function (config, elem) {
            var formNode = elem;
            if (testAllowance(config)) {
                var passesRegexTest_3 = true;
                Router.linkAllowances.forEach(function (func, regex) {
                    var test = !regex.test(formNode.src);
                    passesRegexTest_3 = passesRegexTest_3 && test;
                    if (test) {
                        document_1.D.addEventListener(elem, 'click', func);
                    }
                });
                if (passesRegexTest_3) {
                    document_1.D.addEventListener(elem, 'submit', Router.FORM_OFF_LISTENER);
                }
            }
            else {
                document_1.D.addEventListener(elem, 'submit', Router.FORM_OFF_LISTENER);
            }
        },
    };
    Router.configs = new Map();
    Router.linkAllowances = new Map();
    Router.pathRegex = /\/([\w]+.html)/;
    return Router;
}());
exports.Router = Router;
},{"../dom/document":120,"../dom/elements":121,"../dom/modal":123,"../utils/console_wrapper":130,"../utils/funcs":131,"../utils/html_loader":132,"./history":127}],129:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var event_1 = require("../data-log/event");
var receiver_1 = require("../data-log/receiver");
var elements_1 = require("../dom/elements");
var tracker_elems_1 = require("../dom/tracker_elems");
var console_wrapper_1 = require("../utils/console_wrapper");
var mturk_1 = require("./../aws/mturk");
var data_1 = require("./../data-log/data");
var submit_form_1 = require("./../dom/submit_form");
console_wrapper_1.log('tracker loaded.', 2 /* BASIC */);
var Tracker = /** @class */ (function () {
    function Tracker() {
    }
    Tracker.loadScenario = function (scen) {
        var sub = scen.scenario;
        if (sub.length > 50) {
            sub = sub.substring(0, 50);
            var inds = [
                sub.lastIndexOf(' '),
                sub.lastIndexOf('.'),
                sub.lastIndexOf(','),
                sub.lastIndexOf('?'),
                sub.lastIndexOf('!'),
            ];
            var ind = Math.max.apply(Math, __spread(inds));
            sub = sub.substring(0, ind) + '...';
        }
        elements_1.Elements.mtTopBannerText.innerText = sub;
        elements_1.Elements.mtScenarioContext.innerText = scen.scenario;
        elements_1.Elements.mtScenarioQuestion.innerText = scen.question;
        elements_1.Elements.htmlLoc.dataset.task = scen.tag;
    };
    Tracker.start = function (config) {
        console_wrapper_1.setDebugLevel(config.debugLevel);
        // configure tracker specific elements
        tracker_elems_1.TrackerElements.setupTrackerElements();
        submit_form_1.SubmitForm.setup(config.allowSubmission);
        mturk_1.MturkClient.init(config.bucketName, config.keyPrefix);
        data_1.data.data.task = elements_1.Elements.htmlLoc.dataset.task;
        config.setup();
    };
    Tracker.registerEvent = function (eventType) {
        data_1.data.logs[eventType] = [];
        this.receiver.register(eventType, function (event) {
            data_1.data.logs[eventType].push(event);
        });
        return this.getEventDispatchFunc(eventType);
    };
    Tracker.getEventDispatchFunc = function (eventType) {
        var _this = this;
        return function (evData) {
            if (typeof evData === 'object') {
                if (!event_1.isTrackerEvent(evData)) {
                    event_1.objectToTrackerEvent(evData, eventType);
                }
                _this.receiver.doEvent(evData);
            }
        };
    };
    Tracker.attachData = function (key, attribute) {
        data_1.data.data[key] = attribute;
    };
    Tracker.computeAttribute = function (name, compute) {
        data_1.data.data[name] = compute(data_1.data.data[name]);
    };
    Tracker.lastPos = { x: 0, y: 0, time: 0 };
    Tracker.receiver = new receiver_1.EventReceiver();
    return Tracker;
}());
exports.Tracker = Tracker;
},{"../data-log/event":117,"../data-log/receiver":118,"../dom/elements":121,"../dom/tracker_elems":126,"../utils/console_wrapper":130,"./../aws/mturk":114,"./../data-log/data":116,"./../dom/submit_form":125}],130:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var data_1 = require("./../data-log/data");
log("console wrapper loaded.", 2 /* BASIC */);
function error(func) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, errorHO(func)()];
        });
    });
}
exports.error = error;
function errorHO(func) {
    var _this = this;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                try {
                    return [2 /*return*/, func(args)];
                }
                catch (error) {
                    data_1.data.errors.push(error);
                    console.error(error);
                }
                return [2 /*return*/];
            });
        });
    };
}
exports.errorHO = errorHO;
var debugLevel = 2 /* BASIC */;
function setDebugLevel(level) {
    debugLevel = level;
}
exports.setDebugLevel = setDebugLevel;
function log(message, importance) {
    if (debugLevel >= importance) {
        console.log(message);
    }
}
exports.log = log;
},{"./../data-log/data":116}],131:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("./console_wrapper");
console_wrapper_1.log("funcs loaded.", 2 /* BASIC */);
// tslint:disable-next-line: no-empty
function noop() { }
exports.noop = noop;
function now() {
    return new Date().getTime();
}
exports.now = now;
},{"./console_wrapper":130}],132:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var document_1 = require("../dom/document");
var console_wrapper_1 = require("./console_wrapper");
var funcs_1 = require("./funcs");
console_wrapper_1.log('html loader loaded.', 2 /* BASIC */);
var HTMLLoader = /** @class */ (function () {
    function HTMLLoader() {
    }
    HTMLLoader.finish = function () {
        HTMLLoader.finished = true;
        HTMLLoader.flattenTSLoadTags();
    };
    HTMLLoader.isFinished = function () {
        return HTMLLoader.finished;
    };
    HTMLLoader.cacheHTML = function (name, content) {
        if (HTMLLoader.finished) {
            throw new Error('Cannot cache new HTML entities after the application has been started.');
        }
        var tsl = document.createElement('ts-load');
        tsl.dataset.name = name;
        tsl.innerHTML = content;
        this.CACHE[name] = tsl;
    };
    HTMLLoader.registerPostLoadFunc = function (func) {
        console_wrapper_1.log('regsiter post load function', 3 /* DETAILED */);
        HTMLLoader.postLoadFunc = func;
    };
    HTMLLoader.load = function (html, elem) {
        return new Promise(function (resolve, reject) {
            try {
                console_wrapper_1.log('begin load', 3 /* DETAILED */);
                var context = document_1.D.elem(elem);
                var range = document.createRange();
                range.selectNodeContents(context);
                var frag = range.createContextualFragment(html);
                HTMLLoader.removeTagsFromDocumentFragment(frag, 'script');
                HTMLLoader.loadAllCachedElements(frag);
                context.innerHTML = '';
                context.appendChild(frag);
                console_wrapper_1.log('end load', 3 /* DETAILED */);
                HTMLLoader.postLoadFunc();
                resolve(true);
            }
            catch (err) {
                reject(err);
            }
        });
    };
    HTMLLoader.loadURL = function (url, elem) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = HTMLLoader).load;
                        return [4 /*yield*/, HTMLLoader.getHTML(url)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent(), elem])];
                }
            });
        });
    };
    HTMLLoader.getHTML = function (url) {
        return new Promise(function (resolve, reject) {
            try {
                console_wrapper_1.log('begin request', 3 /* DETAILED */);
                var request_1 = new XMLHttpRequest();
                request_1.open('GET', url, true);
                request_1.send(null);
                request_1.onreadystatechange = function () {
                    if (request_1.readyState === 4) {
                        console_wrapper_1.log('resolve request', 3 /* DETAILED */);
                        resolve(request_1.responseText);
                    }
                };
            }
            catch (err) {
                reject(err);
            }
        });
    };
    HTMLLoader.removeTagsFromDocumentFragment = function (frag, tagName) {
        frag.querySelectorAll(tagName).forEach(function (tag) { return frag.removeChild(tag); });
    };
    HTMLLoader.flattenTSLoadTags = function () {
        console_wrapper_1.log('Flattening', 3 /* DETAILED */);
        var s = new Set();
        Object.keys(HTMLLoader.CACHE).forEach(function (name) {
            return (HTMLLoader.CACHE[name] = HTMLLoader.flattenTSLoadTag(HTMLLoader.getCachedContent(name), s, 0));
        });
    };
    HTMLLoader.multipleTabs = function (n) {
        var ret = '';
        for (var i = 0; i < n; i++) {
            ret += '\t';
        }
        return ret;
    };
    HTMLLoader.flattenTSLoadTag = function (elem, flattened, count) {
        var tabs = HTMLLoader.multipleTabs(count);
        if (count > 100) {
            alert('Check the console, an error has occurred.');
            throw new Error('It seems like you might have infinitely recursively nested tags.' +
                '\nHere are all of the tags that have been flattened so far: ' +
                flattened +
                '\nHere is the name of the current element: ' +
                elem.getAttribute('data-name'));
        }
        var name = elem.getAttribute('data-name');
        if (name === null) {
            return null;
        }
        var content = HTMLLoader.getCachedContent(name);
        if (content === null) {
            return null;
        }
        if (flattened.has(name)) {
            return content;
        }
        content.querySelectorAll('script').forEach(function (e) { return e.remove(); });
        content.querySelectorAll('ts-load').forEach(function (e) {
            var child = HTMLLoader.flattenTSLoadTag(e, flattened, count + 1);
            if (child !== null) {
                e.replaceWith(child);
            }
        });
        flattened.add(name);
        return content;
    };
    HTMLLoader.getCachedContent = function (name) {
        if (name === undefined || name === null) {
            return null;
        }
        var content = HTMLLoader.CACHE[name];
        if (content === undefined || content === null) {
            return null;
        }
        return content.cloneNode(true);
    };
    HTMLLoader.loadAllCachedElements = function (frag) {
        frag.querySelectorAll('ts-load').forEach(function (elem) {
            var name = elem.getAttribute('data-name');
            var content = HTMLLoader.getCachedContent(name);
            if (content != null) {
                elem.replaceWith(content);
            }
        });
    };
    HTMLLoader.CACHE = {};
    HTMLLoader.finished = false;
    HTMLLoader.postLoadFunc = funcs_1.noop;
    return HTMLLoader;
}());
exports.HTMLLoader = HTMLLoader;
},{"../dom/document":120,"./console_wrapper":130,"./funcs":131}],133:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var elements_1 = require("../dom/elements");
var document_1 = require("./../dom/document");
var console_wrapper_1 = require("./console_wrapper");
console_wrapper_1.log("id generator loaded", 2 /* BASIC */);
var IDGenerator = /** @class */ (function () {
    function IDGenerator() {
    }
    IDGenerator.reset = function () {
        IDGenerator.idCount = 0;
    };
    Object.defineProperty(IDGenerator, "next", {
        get: function () {
            IDGenerator.idCount += 1;
            return IDGenerator.prefix + IDGenerator.idCount;
        },
        enumerable: true,
        configurable: true
    });
    IDGenerator.applyID = function (elem) {
        elem.id = elem.id ? elem.id : IDGenerator.next;
    };
    /**
     * Recursively adds ids to all elements that are below the given
     * element in the heirarchy.
     *
     * @param elem - the element to start applying ids to its children.
     *                  Will not apply an id to this element.
     */
    IDGenerator.applyRecur = function (elem) {
        document_1.D.eachRecur(elem, this.applyID);
    };
    /**
     * Attaches ids to all html elements in the target location in the DOM that do not have ids.
     */
    IDGenerator.attachIdsToAllElements = function () {
        IDGenerator.applyRecur(elements_1.Elements.htmlLoc);
    };
    IDGenerator.idCount = 0;
    IDGenerator.prefix = "auto_gen_id_unq_";
    return IDGenerator;
}());
exports.IDGenerator = IDGenerator;
},{"../dom/elements":121,"./../dom/document":120,"./console_wrapper":130}],134:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("./console_wrapper");
console_wrapper_1.log("ready loaded", 2 /* BASIC */);
var ready = false;
var resolveFunc;
var rejectFunc;
var readyPromise = new Promise(function (resolve, reject) {
    resolveFunc = resolve;
    rejectFunc = reject;
});
document.addEventListener("DOMContentLoaded", function () {
    console_wrapper_1.log("document is ready", 3 /* DETAILED */);
    ready = true;
    resolveFunc(true);
});
function isReady() {
    return ready;
}
exports.isReady = isReady;
function waitUntilReady() {
    return ready ? Promise.resolve(true) : readyPromise;
}
exports.waitUntilReady = waitUntilReady;
},{"./console_wrapper":130}],135:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var document_1 = require("./../core/dom/document");
var Accordion = /** @class */ (function () {
    function Accordion(outer) {
        var _this = this;
        this.outer = outer;
        document_1.D.addEventListener(outer, "click", function () {
            /* Toggle between adding and removing the "active" class,
                      to highlight the button that controls the panel */
            _this.outer.classList.toggle("active");
            /* Toggle between hiding and showing the active panel */
            var panel = _this.outer.nextElementSibling;
            if (panel.style.display === "block") {
                panel.style.display = "none";
            }
            else {
                panel.style.display = "block";
            }
        });
    }
    Accordion.setupAll = function () {
        Accordion.discardAll();
        var accordions = document_1.D.claz("accordion");
        for (var accIndex = 0; accIndex < accordions.length; ++accIndex) {
            var elem = accordions.item(accIndex);
            if (elem == null) {
                continue;
            }
            Accordion.accordions.push(new Accordion(elem));
        }
    };
    Accordion.discardAll = function () {
        Accordion.accordions = [];
    };
    Accordion.accordions = [];
    return Accordion;
}());
exports.Accordion = Accordion;
},{"./../core/dom/document":120}],136:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function doSomething() {
    console.log("Put some code in here!");
}
exports.doSomething = doSomething;
},{}],137:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var html_loader_1 = require("../core/utils/html_loader");
var accordion_1 = require("./accordion");
var do_something_1 = require("./do-something");
var html_imports_1 = require("./html-imports");
var slideshow_1 = require("./slideshow");
// Put all function calls that need to be made on every page load inside the setupAll function body.
function PutStudentPageLoadOperationsInsideThisStudentBody() {
    // TODO: Put all operations that you want to happen on ever page load in this function.
    // For example you could write: Sticky.setup()
    do_something_1.doSomething();
}
exports.PutStudentPageLoadOperationsInsideThisStudentBody = PutStudentPageLoadOperationsInsideThisStudentBody;
function setupAll() {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, new Promise(function (r) { return setTimeout(r, 100); })];
                case 1:
                    _a.sent();
                    console.log('reloading');
                    slideshow_1.Slideshow.setupAll();
                    accordion_1.Accordion.setupAll();
                    PutStudentPageLoadOperationsInsideThisStudentBody();
                    console.log('reloaded');
                    return [2 /*return*/];
            }
        });
    });
}
exports.setupAll = setupAll;
html_imports_1.itemsToCache.forEach(function (item) {
    html_loader_1.HTMLLoader.cacheHTML(item.name, item.content);
});
window.HTMLLoader = html_loader_1.HTMLLoader;
console.log('dynamic-dom loaded');
// Do not touch this line, needed to reinitialize code in the dynamic-dom.ts setupAll function
window.addEventListener('newPageLoad', function () { return setupAll(); });
},{"../core/utils/html_loader":132,"./accordion":135,"./do-something":136,"./html-imports":138,"./slideshow":142}],138:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// An HTMLContent object should look like the following:
// {
//     name: 'footer',
//     content: require('./html/footer.html'),
// }
// Then you can reference that content in your html using the following tag with the corresponding name attribute.
// <ts-load data-name="header"></ts-load>
// You can specify as many as you want inside of the array and they will all be bundled up with your website.
// Make sure to make a corresponding html file in the html file folder for each element you specify.
exports.itemsToCache = [
    // Feel free to change the content inside any of the html files in the html file folder to suit your needs.
    {
        name: 'header',
        content: require('./html/header.html'),
    },
    {
        name: 'footer',
        content: require('./html/footer.html'),
    },
    {
        name: 'nested',
        content: require('./html/nested.html'),
    },
];
},{"./html/footer.html":139,"./html/header.html":140,"./html/nested.html":141}],139:[function(require,module,exports){
module.exports = "<footer id=\"colophon\" class=\"footer\" role=\"contentinfo\">\n  <div class=\"container\">\n    <div class=\"footer-widgets\">\n      <aside class=\"widget site-contact\">\n        <h2 class=\"footer-widget-title\">Nursery School</h2>\n        <p>6926 Forest Park Parkway</p>\n        <p>St. Louis, MO 63130</p>\n        <p class=\"phone\">314-935-6689 <span>|</span> Fax: 314-935-7249</p>\n        <p>\n          <a href=\"files/mailto:nursery@wustl.edu\">nursery@wustl.edu</a>\n        </p>\n      </aside>\n\n      <div class=\"widget-wrapper\">\n        <aside id=\"text-4\" class=\"widget widget_text widget-count-2\">\n          <h2 class=\"footer-widget-title\">Hours of Operation</h2>\n          <div class=\"textwidget\">\n            <p>\n              Classes meet Mon. through Fri.<br />\n              Morning: 9-11:45 a.m.<br />\n              Afternoon: 12:30-3:15 p.m.<br />\n              Full day: 9 a.m.-3:15 p.m.\n            </p>\n          </div>\n        </aside>\n        <aside id=\"text-3\" class=\"widget widget_text widget-count-2\">\n          <h2 class=\"footer-widget-title\">Apply for the Nursery School</h2>\n          <div class=\"textwidget\">\n            <p>\n              Experience the innovative approach and dynamic teaching\n              environment of the Washington University Nursery School.\n            </p>\n            <a href=\"files/apply.html\">Register Now</a>\n          </div>\n        </aside>\n      </div>\n    </div>\n    <div class=\"site-info\">\n      <p class=\"footer-copyright\">©2019 Washington University in St. Louis</p>\n    </div>\n  </div>\n</footer>";

},{}],140:[function(require,module,exports){
module.exports = "<div id=\"wustl-branding\">\n  <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"321\" height=\"28\" viewBox=\"0 0 321 28\" class=\"washu-logo\"\n    aria-labelledby=\"title\">\n    <title id=\"title\">Washington University in St. Louis</title>\n    <path fill=\"#FFF\"\n      d=\"M10.46 1.76c-.09 0-4.41.04-10.46-1.21V18c0 .27.01.47.01.47v.02c.04.81.28 1.45.77 2 .32.34.76.7 1.38 1.05.17.1.35.18.55.28.15.07.31.14.47.2.14.06.55.24.69.29l6.59 2.5 6.59-2.5c.15-.05.56-.24.69-.29.16-.07.32-.14.47-.2.19-.1.38-.18.55-.28.62-.35 1.06-.7 1.38-1.05.48-.55.73-1.19.77-2v-.02s0-.19.01-.47V.55C14.86 1.8 10.55 1.76 10.46 1.76z\">\n    </path>\n    <path fill=\"#007360\"\n      d=\"M10.46 2.8c-.09 0-4.03.04-9.56-1.1v15.95c0 .25.01.43.01.44v.02c.04.74.25 1.33.7 1.83.29.31.7.64 1.26.95.15.09.32.17.5.26.14.07.28.13.44.19.12.05.5.22.63.27l6.03 2.29 6.03-2.29c.13-.05.51-.22.63-.27.15-.06.3-.13.44-.19.18-.09.35-.17.5-.26.56-.31.97-.64 1.26-.95.44-.5.66-1.09.7-1.83v-.02s0-.18.01-.44V1.7c-5.55 1.14-9.5 1.1-9.58 1.1z\">\n    </path>\n    <path fill=\"#E1C4AC\"\n      d=\"M10.46 3.75c-.08 0-3.68.04-8.74-1.02v4.08c5.05 1.05 8.67 1.02 8.74 1.02s3.68.04 8.74-1.02V2.73c-5.06 1.05-8.66 1.02-8.74 1.02z\">\n    </path>\n    <path fill=\"#A51417\"\n      d=\"M10.46 7.83c-.08 0-3.68.04-8.74-1.02v9.05c5.05 1.05 8.67 1.02 8.74 1.02s3.68.04 8.74-1.02V6.82c-5.06 1.04-8.66 1.01-8.74 1.01z\">\n    </path>\n    <path fill=\"#E1C4AC\"\n      d=\"M1.72 17.72c.03.69.23 1.23.64 1.68.26.28.64.58 1.15.87.15.08.29.15.46.23.13.06.26.12.4.17.11.05.46.2.58.24L10.46 23l5.51-2.09c.12-.04.46-.2.58-.24.14-.06.27-.12.4-.17.16-.08.32-.15.46-.23.51-.29.88-.58 1.15-.87.41-.46.6-1 .64-1.68v-.02s0-.16.01-.4v-1.44c-5.05 1.05-8.67 1.02-8.74 1.02s-3.68.04-8.74-1.02v1.45c-.02.25-.01.41-.01.41z\">\n    </path>\n    <path fill=\"#007360\"\n      d=\"M4.8 3.69l.41 1.23 1.29.01-1.04.77.39 1.24-1.05-.76-1.05.76.39-1.24-1.04-.77 1.29-.01.41-1.23zm11.31 0l.42 1.23 1.29.01-1.04.77.39 1.24-1.06-.76-1.05.76.39-1.24-1.04-.77 1.29-.01.41-1.23zm-5.65.48l.42 1.23 1.29.01-1.04.77.39 1.24-1.06-.76-1.06.75.39-1.24-1.04-.77 1.3-.01.41-1.22zM10.46 17.21l-.46.45v1.22l.23.65v1.09h.45v-1.09l.23-.65v-1.22l-.45-.45zm.22 4.41v-.65h-.45v.65l-.23.42.46.56.46-.56-.24-.42zm.33-.65v.5l.29.31.51-.41v-.41h-.8zm.54-2.04l-.54.6v1.09h.44v-.65l.43-.46.55.36.35-.36v-.58h-1.23zm-1.64 2.04v.5l-.29.31-.52-.41v-.41h.81zm-.55-2.04l.54.6v1.09h-.43v-.65l-.43-.46-.55.36-.35-.36v-.58h1.22z\">\n    </path>\n    <path fill=\"#E1C4AC\"\n      d=\"M14.62 9.27v5.19h-3.49l-.25.21-.43.37-.43-.37-.25-.21H6.29V9.27l-.74.54v5.38h4.12l.37.31.43.38.43-.38.37-.31h4.12V9.81l-.77-.54z\">\n    </path>\n    <path fill=\"#E1C4AC\"\n      d=\"M11.02 8.83l-.14.11-.43.38-.43-.38-.12-.11H7.03v4.89h2.88l.2.17.35.31.36-.31.19-.17h2.88V8.83h-2.87zM16.11 10.35v3.31c.95-.14 1.98-.31 3.08-.54V9.81a50.5 50.5 0 0 1-3.08.54zm-11.31 0c-.95-.14-1.98-.31-3.08-.54v3.31c1.1.23 2.14.41 3.08.54v-3.31z\">\n    </path>\n    <path fill=\"#007360\"\n      d=\"M16.11 16.76l-.31.32v.86l.15.46v.77h.31v-.77l.16-.46v-.86l-.31-.32zm.16 3.09v-.45h-.31v.46l-.15.3.31.4.32-.4-.17-.31zm.23-.45v.35l.2.22.36-.28v-.29h-.56zm.38-1.43l-.38.43v.77h.31v-.46l.3-.33.38.25.24-.25v-.41h-.85zm-1.14 1.43v.35l-.21.22-.35-.28v-.29h.56zm-.39-1.43l.39.43v.77h-.31v-.46l-.3-.33-.39.25-.24-.25v-.41h.85zM4.8 16.76l-.32.32v.86l.16.46v.77h.31v-.77l.15-.46v-.86l-.3-.32zm.16 3.09v-.45h-.31v.46l-.16.3.32.4.31-.4-.16-.31zm.22-.45v.35l.21.22.35-.28v-.29h-.56zm.39-1.43l-.39.43v.77h.31v-.46l.3-.33.39.25.24-.25v-.41h-.85zM4.42 19.4v.35l-.2.22-.36-.28v-.29h.56zm-.38-1.43l.38.43v.77h-.31v-.46l-.3-.33-.38.25-.24-.25v-.41h.85z\">\n    </path>\n    <g fill=\"#FFF\" class=\"washu-logo-text\">\n      <path\n        d=\"M232.47 8.16c.33 0 1.07-1.2 1.07-1.57 0-.36-.74-1.6-1.07-1.6-.3 0-1.07 1.26-1.07 1.6s.76 1.57 1.07 1.57zm13.82 12.03v-5.08c0-2.34-.76-5.76-4.22-5.76-2.51 0-3.81 2.38-3.76 2.01V9.59c0-.31-.15-.49-.31-.49-.6 0-1.04 1.01-3.06 1.62-.13.03-.5.04-.51.27 0 .65 2.03-.84 1.99 1.68v7.64c0 1.43-.7 1.55-1.21 1.68-.03 0-.06-.01-.1 0-.52-.03-1.63-.23-1.63-1.35V9.59c0-.31-.15-.49-.31-.49-.6 0-.98 1.08-2.63 1.64-.13.03-.37.06-.37.24 0 .65 1.49-.61 1.42 1.69v7.27c.06 1.86-.96 2.04-1.52 2.04-.84-.01-.63.1-.63.36.03.31.53.33 1.37.34.29 0 1-.11 1.82-.11 1.07 0 1.87.12 2.41.12.31 0 1.15-.13 2.53-.13 1.5 0 2.02.13 2.46.13.39 0 .83-.17.57-.44-.42-.41-2.28.06-2.28-2.06V13.1c-.03-.49.88-2.4 3.06-2.4 2.1 0 3.03 2.31 3.03 3.85v5.76c-.03 2.27-.8 1.55-1.11 2-.17.25.13.37.46.37s.88-.13 1.87-.13c1.27 0 1.82.12 2.16.12.26 0 .73-.2.45-.44-.68-.5-1.97.3-1.95-2.04zM48.91 2.4c.37-.05.55-.19.55-.19 0-.24-.05-.3-.39-.3-.65 0-1.05.11-1.69.11-.71 0-1.25-.08-1.85-.08-.34 0-.31.11-.31.3 0 .21.65.08 1.02.89.21.44.13 1.36-.08 1.9l-5.01 13.74-2.14-6.1-.83-2.23s-.13.06.46-1.79l1.17-3.52c.57-1.73 1.14-2.64 1.88-2.65.92-.02.92-.57.21-.57s-1.13.06-1.75.06c-.65 0-.99-.06-1.69-.06-.26 0-.55.08-.52.3.03.21.42.14.71.3.47.24.78 1.25.45 2.3l-1.38 4.42-1.58-4.13c-.31-.78-.73-2.52.03-2.67.73-.15.63-.52.18-.52-.86 0-1.32.11-2.15.11-.91 0-1.59-.11-2.45-.11-.18 0-.52.03-.42.38.05.21.49.14.76.3 1.05.68 1.25 1.55 1.62 2.52l2.3 6.48c.42 1.16.45.74.11 1.73l-2 5.5-4.95-14.11c-.39-1.06-.6-1.79.26-2.2.37-.19.47-.22.52-.3.05-.07.1-.32-.45-.3-.89.03-1.43.11-2.32.11-.94 0-1.59-.11-2.45-.11-.29 0-.34.14-.34.35 0 .33.71.11 1.31.81.34.38.99 1.66 1.14 2.12L32.8 22.3c.11.25.14.76.48.76.27 0 .33-.57.42-.79l3.13-8.59 3.05 8.16c.13.33.31 1.22.63 1.22.26 0 .36-.43.49-.83l5.9-16.87c.5-1.36 1.07-2.79 2.01-2.96zm65.46 6.71c-3.26 0-5.77 3.28-5.77 7.13 0 1.96.52 3.51 1.42 4.63-.31.21-.92.7-2.15.7-1.07 0-1.68-.64-1.74-2V11.2l3.38-.01c.22 0 .65-1.44.67-1.52.04-.18.1-.33.12-.46.04-.28-.17-.3-.37-.01-.15.15-.32.55-.99.55h-2.81c0-2.41.03-3.51-.35-3.51-.36 0-.3.1-.63 1.17-.44 1.44-1.79 2.23-2.63 2.68-.38.09-.81.12-1.29.01-.74-.16-1.6-1.06-3.83-1.06-2.38 0-4.46 1.95-4.46 4.55 0 1.4.62 2.76 1.71 3.48-.2.12-1.53 1.24-1.37 2.56 0 0-.03 1.37 1.05 1.82-.33.14-.67.36-.96.63-.7-.26-1.72-.06-1.72-1.91V15.1c0-2.34-.76-5.76-4.22-5.76-2.51 0-3.81 2.38-3.76 2.01V9.59c0-.31-.15-.49-.31-.49-.6 0-.73.99-2.91 1.55-.13.03-.43.1-.44.34 0 .65 1.75-.71 1.76 1.68v7.64c0 1.65-1.31 1.65-1.54 1.67-.1 0-.19 0-.31.01-.55-.05-1.51-.3-1.51-1.34V9.59c0-.31-.15-.49-.31-.49-.6 0-.98 1.08-2.63 1.64-.13.03-.37.06-.37.24 0 .65 1.49-.61 1.42 1.69v7.27c.06 1.78-.86 2.01-1.43 2.03-.69-.09-1.22-.37-1.22-1.41v-5.14c0-2.65-1.01-6.07-4.33-6.07-1.47 0-2.75.81-3.73 1.92V2.41c0-.31-.15-.48-.31-.49-.4-.03-1.07 1.19-2.96 1.63-.13.03-.62.07-.62.25 0 .65 1.97-.31 1.99 1.69V20.6c0 1.51-1.3 1.31-1.53 1.79-.04.21.08.31.26.31.42 0 1.55-.12 2.35-.12s2.1.12 2.64.12c.31 0 .44-.06.44-.44-.27-.52-2.28.28-2.28-2.37v-6.5c0-1.57 1.87-2.78 3.03-2.78.91 0 3.14.71 3.14 4.53v5.64c0 1.11-1.18 1.23-1.27 1.57 0 .24.15.34.42.34.28 0 1.11-.12 2.12-.12.56 0 1.07.03 1.5.06.23.05.57.05.99.05.28 0 1-.11 1.82-.11s1.48.07 1.99.11c.1.01.2.01.3.01.04 0 .08.01.12.01h.01c.32.01.61 0 .74 0 .31 0 .83-.13 2.2-.13 1.5 0 2.02.13 2.46.13.39 0 .83-.17.57-.44-.42-.41-2.28.06-2.28-2.06v-7.09c-.03-.49.88-2.4 3.06-2.4 2.1 0 3.03 2.31 3.03 3.85v5.76c0 2-.8 1.55-1.11 2-.17.25.13.37.46.37s.88-.13 1.87-.13c.93 0 1.53.07 1.91.1-.29.42-.48.9-.51 1.4-.14 2.51 2.93 3.41 5.51 3.37 5.12-.07 6.57-3.62 5.51-5.51-1.09-1.95-3.44-1.87-5.68-1.86-4.2.02-3.41-2.59-1.69-2.49.4.02.2.14 1.57.14 2.43 0 4.76-1.66 4.7-4.38-.01-.23.05-1.03-.53-2.14 1.14.01.69 0 2.41 0l-.01 7.63c0 3.45 1.64 4.03 2.87 4.03 1.74 0 3.01-1.15 3.24-1.68 1.03 1.1 2.46 1.68 4.12 1.68 3.19 0 5.6-2.93 5.6-6.78 0-5.8-3.65-6.96-5.61-6.96zM95.62 21.72c.21-.01.27.08 2.64.17 2.45.06 3.33.77 3.49 1.4.26 1.12-.53 3.52-4.05 3.29-2.22-.15-2.87-1.2-3.03-1.44-.84-1.16-.16-3.35.95-3.42zm2.01-4.57c-2.08 0-2.78-2-2.78-3.91 0-1.96.59-3.58 2.67-3.58 2.11 0 2.95 2.16 2.95 4.07.01 1.93-.87 3.42-2.84 3.42zm16.99 4.81c-3.03 0-4.22-3.76-4.22-6.82 0-2.65 1.04-5.1 3.57-5.1 3.08 0 4.19 3.29 4.19 6.51.01 3.87-1.36 5.41-3.54 5.41z\">\n      </path>\n      <path\n        d=\"M131.11 20.19v-5.08c0-2.34-.76-5.76-4.22-5.76-2.51 0-3.81 2.38-3.76 2.01V9.59c0-.31-.15-.49-.31-.49-.6 0-1.04 1.01-3.07 1.62-.13.03-.5.04-.51.27 0 .65 2.03-.84 2 1.68v7.64c0 2-1.35 1.52-1.66 2.04-.15.27.25.33.59.33.31 0 .83-.13 2.2-.13 1.5 0 2.02.13 2.46.13.39 0 .83-.17.57-.44-.42-.41-2.28.06-2.28-2.06v-7.09c-.03-.49.88-2.4 3.06-2.4 2.1 0 3.03 2.31 3.03 3.85v5.76c-.03 2.27-.8 1.55-1.11 2-.17.25.13.37.46.37s.88-.13 1.87-.13c1.27 0 1.82.12 2.16.12.26 0 .73-.2.44-.44-.65-.49-1.94.31-1.92-2.03zM77.41 8.16c.33 0 1.07-1.2 1.07-1.57 0-.36-.74-1.6-1.07-1.6-.3 0-1.07 1.26-1.07 1.6.02.35.77 1.57 1.07 1.57zm-17.3 6.96c-.51-.24-1.27-.68-1.65-.88-1.63-.89-2.27-1.47-2.31-2.3-.08-1.44 1.15-2.19 2.21-2.08 2.54-.04 2.88 2.8 3.14 2.8.39 0 .28-.37.28-1.21 0-.21.03-1.27-.13-1.52-.31-.46-2.1-.74-2.55-.74-.11 0-.52-.01-.6-.02-.13 0-.28.02-.28.02-1.81-.03-3.5 1.11-3.45 3.53.05 2.21 2.64 3.47 4.04 4.3 1.04.59 2.26 1.15 2.24 2.57-.02 1.61-1.27 2.68-2.61 2.6-3.15-.05-2.72-4-3.28-4-.39 0-.31 1-.31 1.52 0 .51-.01.98-.01 1.38-.07.36-.2.7-.54.72-1.24.08-.94-1.9-.94-2.95v-6.43c-.06-1.97-1.54-3.25-3.8-3.25-3.09 0-5.31 3.81-4.25 5 .25.28 1.26-.8 1.32-.86s.08-.13.08-.13c-.01-1.3.97-2.95 2.37-3.09 1.6-.15 2.4 1.04 2.4 2.65v2.09c-6.06 1.21-6.93 3.22-6.93 4.87 0 2.21 1.55 3.2 3.23 3.2 1.45 0 2.88-.69 3.96-1.8.34 1.03 1.01 1.65 2.02 1.62.35-.01.41.09 1.46-.37.37-.1.35-.09.77-.01.56.19 1.32.57 2.66.57 2.03.03 3.85-1.85 3.85-4.17 0-1.5-.43-2.41-2.39-3.63zm-8.43 4.32c0 1.65-1.68 2.52-2.6 2.52-1.38 0-2.33-.89-2.33-2.66 0-2.73 3.28-3.23 4.94-3.67-.01-.01-.01 3.81-.01 3.81zm219.99.19c-.31 0-1.07 1.29-1.07 1.63 0 .34.77 1.6 1.07 1.6.33 0 1.07-1.23 1.07-1.6s-.73-1.63-1.07-1.63zm33.71 1.12V9.92c0-.61-.34-.77-.44-.77-.39 0-.61.1-.88.16-.27.1-.58.23-1.29.23-.13 0-.79-.12-.76.25.04.37 1.57.15 1.58 1.23v7.83c-.12 1.37-1.27 2.88-2.66 2.88-.32 0-2.39-.22-2.37-3.65V9.92c0-.61-.34-.77-.44-.77-.39 0-.61.1-.88.16-.27.1-.61.22-1.32.19-.38-.02-.79-.07-.73.29.06.32 1.59 0 1.59 1.23v7.51c0 2.74 1.61 4.32 3.56 4.32 1.3 0 2.49-.28 3.24-1.8h.05v1.32c0 .13.03.48.22.48.37 0 .56-.3.83-.4.29-.07.37-.33 1.28-.42.39-.04.82-.24.82-.5-.11-.53-1.4.06-1.4-.78zM290.09 9.11c-3.26 0-5.77 3.28-5.77 7.13 0 1.73.42 3.15 1.13 4.23-.79.57-2.23 1.1-4.96 1.1-2.13 0-1.93-.74-1.93-2.55V4.57c0-2.66 1.99-1.89 2.03-2.37.03-.34-.28-.26-.61-.26-.38 0-1.07.15-2.52.15-1.25 0-2.34-.12-2.88-.12-.33 0-.63.1-.52.35.25.57 2.14.05 2.14 1.65v15.1c0 1.44.21 2.36-.45 2.73-.81.49-1.76.51-1.68.83.05.19.45.2.68.2 1.02 0 2.42-.13 3.44-.15 1.94-.06 3.86.13 5.79.13 1.12 0 1.4-.22 2.22-1.33.01-.02.02-.03.04-.05 1.01.94 2.34 1.44 3.87 1.44 3.19 0 5.6-2.93 5.6-6.78.01-5.82-3.65-6.98-5.62-6.98zm.26 12.85c-3.03 0-4.22-3.76-4.22-6.82 0-2.65 1.04-5.1 3.57-5.1 3.08 0 4.19 3.29 4.19 6.51.01 3.87-1.36 5.41-3.54 5.41zm-32.03-10.49c-.75-.37-1.85-1.04-2.39-1.36-2.37-1.37-3.3-2.26-3.37-3.52-.12-2.21 2.04-3.52 3.58-3.35 1.96 0 3.57 1.19 4.24 3.73.07.27.31.89.56.89.22 0 .26-.2.24-.45l-.33-4.02c-.02-.33-.14-.42-.27-.42-.22 0-.36.33-.56.33-.31 0-1.1-1.11-3.8-1.09-.18-.01-.43.02-.43.02-2.63-.05-5.1 1.7-5.02 5.4.07 3.37 3.85 5.3 5.89 6.59 1.51.9 3.09 2.34 3.04 3.95-.08 2.47-1.63 4.08-3.58 3.94-4.59-.08-3.96-6.13-4.78-6.13-.56 0-.45 1.52-.46 2.32 0 1.92-.08 3.49.14 3.77.07.09.29.05.74.05.9 0 2 1.05 4.65 1.05 2.95.05 5.38-2.69 5.38-6.25-.01-2.19-.62-3.58-3.47-5.45zm51.69-3.31c.33 0 1.07-1.2 1.07-1.57 0-.36-.74-1.6-1.07-1.6-.3 0-1.07 1.26-1.07 1.6s.76 1.57 1.07 1.57zM312.64 22c-.52-.03-1.63-.23-1.63-1.35V9.59c0-.31-.15-.49-.31-.49-.6 0-.98 1.08-2.63 1.64-.13.03-.37.06-.37.24 0 .65 1.49-.61 1.42 1.69v7.27c.06 1.86-.96 2.04-1.52 2.04-.84-.01-.63.1-.63.36.03.31.53.33 1.37.34.28 0 1-.11 1.82-.11 1.07 0 1.87.12 2.41.12.33 0 .76-.8.07-.69zm5.98-6.88c-.51-.24-1.27-.68-1.65-.88-1.63-.89-2.27-1.47-2.31-2.3-.08-1.44 1.15-2.19 2.21-2.08 2.54-.05 2.88 2.8 3.14 2.8.39 0 .28-.37.28-1.21 0-.21.03-1.27-.13-1.52-.31-.46-2.11-.74-2.55-.74-.11 0-.52-.01-.6-.01-.13 0-.28.01-.28.01-1.81-.03-3.5 1.11-3.44 3.53.05 2.21 2.64 3.46 4.04 4.3 1.04.59 2.26 1.15 2.24 2.57-.02 1.61-1.27 2.68-2.61 2.6-3.15-.05-2.72-4-3.28-4-.39 0-.31 1-.31 1.52-.01 1.25-.06 2.28.1 2.46.05.06.2.03.5.03.62 0 1.38.69 3.19.69 2.03.03 3.85-1.85 3.85-4.17-.01-1.48-.43-2.39-2.39-3.6zm-48.73 5.66c-.26.13-.85.77-2.28.77-1.07 0-1.68-.64-1.74-2v-8.82l3.38-.01c.22 0 .65-1.44.67-1.52.04-.18.1-.33.12-.46.04-.28-.17-.3-.37-.01-.15.15-.32.55-.99.55h-2.81c0-2.41.03-3.04-.35-3.04-.36 0-.3.1-.63 1.17-.54 1.79-2.52 2.58-3.15 2.97-.15.08-.15.11-.15.19-.01.23.75.14 2.31.17l-.01 8.07c0 3.45 1.64 4.03 2.87 4.03 1.87 0 3.21-1.34 3.28-1.8.03-.25 0-.28-.15-.26zm-81.32-1.09c-.57 0-1.42 1.62-3.66 1.62-1.58 0-4.17-1.53-4.17-6.66h6.9c.6 0 .88.03.88-.52 0-1.25-1.4-4.95-4.59-4.95-3.24 0-5.08 3.33-5.08 7.31 0 2.05 1.35 6.38 5.24 6.38 2.33 0 4.59-2.24 4.59-2.95-.01-.11-.01-.23-.11-.23zm-5.08-9.81c1.42 0 2.88 1.56 2.88 3.3 0 .46-.15.62-.52.62h-5.11c0-1.71 1.13-3.92 2.75-3.92zm-31.7-7.33c.1-.16-.25-.24-.37-.24-.42 0-1.37.11-1.8.11-.89 0-1.64-.09-2.53-.09-.07 0-.46.05-.46.18-.01.63 2.13-.11 2.13 2.6v10.57c0 3.13-.99 6.41-5.29 6.41-3.09 0-4.76-1.94-4.76-6.17V4.41c0-1.91 1.49-1.49 1.52-1.92.03-.41-1.33-.16-1.43-.16-.71 0-1.21.08-1.95.08-.62 0-1.37-.1-1.97-.1-.12 0-.53-.02-.61.15-.23.56 1.91.26 1.91 1.83v10.92c0 4.08 1.14 8.08 7.17 7.97 7.14-.12 7.01-6.54 7.01-7.83V5.12c.01-2.43 1.2-2.2 1.43-2.57zm28.19 7.24c.17-.2.22-.53-.57-.46-.45 0-.77.08-1.22.08-.57 0-.68-.02-1.22-.04-.68-.02-.86.05-.82.25.12.6 1.55.01 1.36 1.8-.16 1.5-.65 2.79-1.14 4.07l-1.73 4.62-2.54-7.7c-.31-.96-.45-1.47-.45-1.57 0-.96 1.16-.75 1.42-1.14.16-.26-.17-.4-.54-.4-.31 0-.67.11-1.63.13-.79.02-1.36.02-1.7-.05-.89-.16-.82.33-.51.48s.46.01.91 1.36l3.91 11.06c.08.22.18.77.52.77.39 0 .39-.39.88-1.69 0 0 3.75-10.48 4-10.86.51-.74.89-.5 1.07-.71zm14.47-.5c-1.07 0-1.8 1.28-2.33 2.16h-.05V9.53c0-.3-.15-.48-.3-.48-.41 0-.72.81-2.87 1.33-.13.03-.48.1-.48.28 0 .64 1.82-.19 1.82 1.93v8.07c0 1.25-1.29 1.12-1.29 1.77 0 .18.08.27.28.27.17 0 .63-.12 2.32-.12 1.41 0 2.02.12 2.37.12.28 0 .41-.06.41-.34 0-.98-2.25.48-2.25-2.34v-6.88c0-.4.6-1.8 1.64-1.8.91 0 1.02.7 1.5.7.3 0 .91-.91.91-1.38-.01-.58-1.16-1.37-1.68-1.37zm32.55.1c-.27 0-.96.04-1.59.04-.76 0-1.13-.09-1.45-.09-.48 0-.96 0-.87.32.1.36 1.73.23 1.73 2.01 0 .23 0 .52-.33 1.71l-2.08 6.63-2.9-8.15s-.14-.26-.14-.79c0-1.32 1.54-1.17 1.6-1.41.05-.19-.21-.4-.62-.4h-3.63c-.02 0-.03.01-.05.01h-2.81c0-2.41.03-3.04-.35-3.04-.36 0-.3.1-.63 1.17-.54 1.79-2.52 2.58-3.15 2.97-.15.08-.15.11-.15.19-.01.22.76.14 2.31.17l-.01 8.07c0 3.45 1.64 4.03 2.87 4.03 1.87 0 3.21-1.33 3.28-1.8 0-.27-.04-.29-.18-.27-.26.13-.85.77-2.28.77-1.07 0-1.68-.64-1.74-2V10.7s2.5-.01 3.21-.01c.04.06.08.13.1.19l2.99 8.45c.24.69.39.92.68 2.14.19.79.12 1.51.12 1.51-.29 1.27-1.07 1.99-2.26 4.34-.12.22 1.71-.02 1.81-.05.15-.05.13-.09.31-.42l1.32-3.93 3.69-11.34c.54-1.98 1.39-1.62 1.53-1.89.12-.13 0-.3-.33-.3z\">\n      </path>\n      <path\n        d=\"M222.22 22.76l-.07.19V23l.07-.24zm-14.74-14.6c.33 0 1.07-1.2 1.07-1.57 0-.36-.74-1.6-1.07-1.6-.3 0-1.07 1.26-1.07 1.6s.76 1.57 1.07 1.57zM210.11 22c-.52-.03-1.63-.23-1.63-1.35V9.59c0-.31-.15-.49-.31-.49-.6 0-.98 1.08-2.63 1.64-.13.03-.37.06-.37.24 0 .65 1.49-.61 1.42 1.69v7.27c.06 1.86-.96 2.04-1.52 2.04-.84-.01-.63.1-.63.36.03.31.53.33 1.37.34.28 0 1-.11 1.82-.11 1.07 0 1.87.12 2.41.12.33 0 .76-.8.07-.69zM166.52 8.16c.33 0 1.07-1.2 1.07-1.57 0-.36-.74-1.6-1.07-1.6-.3 0-1.07 1.26-1.07 1.6s.77 1.57 1.07 1.57zM169.17 22c-.52-.03-1.63-.23-1.63-1.35V9.59c0-.31-.15-.49-.31-.49-.6 0-.98 1.08-2.63 1.64-.13.03-.37.06-.37.24 0 .65 1.49-.61 1.42 1.69v7.27c.06 1.86-.96 2.04-1.52 2.04h-.17c-.54-.1-1.06-.32-1.05-1.79v-5.08c0-2.34-.76-5.76-4.22-5.76-2.51 0-3.81 2.38-3.76 2.01V9.59c0-.31-.15-.49-.31-.49-.6 0-1.04 1.01-3.07 1.62-.13.03-.5.04-.51.27 0 .65 2.03-.84 2 1.68v7.64c0 2-1.35 1.52-1.66 2.04-.15.27.25.33.59.33.31 0 .83-.13 2.2-.13 1.5 0 2.02.13 2.46.13.39 0 .83-.17.57-.44-.42-.41-2.28.06-2.28-2.06v-7.09c-.03-.49.88-2.4 3.06-2.4 2.1 0 3.03 2.31 3.03 3.85v5.76c-.03 2.27-.8 1.55-1.11 2-.17.25.13.37.46.37s.88-.13 1.87-.13c1.27 0 1.82.12 2.16.12.04 0 .09-.01.13-.01.11 0 .21.01.34.01.28 0 1-.11 1.82-.11 1.07 0 1.87.12 2.41.12.34.02.75-.78.08-.67zm32.72-6.89c-.51-.24-1.27-.68-1.65-.88-1.63-.89-2.27-1.47-2.31-2.3-.08-1.44 1.15-2.19 2.21-2.08 2.54-.05 2.88 2.8 3.14 2.8.39 0 .28-.37.28-1.21 0-.21.03-1.27-.13-1.52-.31-.46-2.1-.74-2.55-.74-.11 0-.52-.01-.6-.02-.13 0-.28.02-.28.02-1.81-.03-3.5 1.11-3.45 3.53.05 2.21 2.64 3.46 4.04 4.3 1.04.59 2.26 1.15 2.24 2.57-.02 1.62-1.27 2.68-2.61 2.6-3.15-.05-2.72-4-3.28-4-.39 0-.31 1-.31 1.52 0 1.25-.06 2.28.1 2.46.05.06.2.03.5.03.62 0 1.38.69 3.19.69 2.03.03 3.85-1.85 3.85-4.17 0-1.47-.42-2.38-2.38-3.6z\">\n      </path>\n    </g>\n  </svg>\n</div>\n<header role=\"banner\">\n  <div class=\"container\">\n    <a class=\"site-title\" href=\"files/index.html\">Nursery School</a>\n  </div>\n  <div id=\"main-menu-container\">\n    <div class=\"container\">\n      <div class=\"navbar\">\n        <div class=\"dropdown\">\n          <button class=\"dropbtn\">\n            <a id=\"about\" href=\"files/about.html\">About\n            </a>\n          </button>\n          <div class=\"dropdown-content\">\n            <a id=\"tuition\" href=\"files/tuition.html\">Tuition</a>\n            <a id=\"staff\" href=\"files/staff.html\">Staff</a>\n            <a id=\"parent-handbook\" href=\"files/parent_handbook.html\">Parent Handbook</a>\n          </div>\n        </div>\n        <div class=\"dropdown\">\n          <button class=\"dropbtn\">\n            <a id=\"classrooms\" href=\"files/classrooms.html\">Classrooms\n            </a>\n          </button>\n          <div class=\"dropdown-content\">\n            <a id=\"curriculum-overview\" href=\"files/curriculum_overview.html\">Curriculum Overview</a>\n            <a id=\"teddy-bears\" href=\"files/teddy_bears.html\">Teddy Bears</a>\n            <a id=\"panda-bears\" href=\"files/panda_bears.html\">Panda Bears</a>\n            <a id=\"bear-cubs\" href=\"files/bear_cubs.html\">Bear Cubs</a>\n            <a id=\"big-bears\" href=\"files/big_bears.html\">Big Bears</a>\n            <a id=\"sun-bears\" href=\"files/sun_bears.html\">Sun Bears</a>\n            <a id=\"bear-tracks\" href=\"files/bear_tracks.html\">Bear Tracks</a>\n            <a id=\"enrichment-program\" href=\"files/enrichment_programs.html\">Enrichment Program</a>\n          </div>\n        </div>\n        <a id=\"calendar\" href=\"files/calendar.html\">Calendar</a>\n        <a id=\"summer-camp\" href=\"files/summer_camp.html\">Summer Camp</a>\n        <div class=\"dropdown\">\n          <button class=\"dropbtn\">\n            <a id=\"get-involved\" href=\"files/get_involved.html\">Get Involved</a>\n          </button>\n          <div class=\"dropdown-content\">\n            <a id=\"nursery-school-merchandise\" href=\"files/nursery_school_merchandise.html\">Nursery School\n              Merchandise</a>\n            <a id=\"parent-association\" href=\"files/parent_association.html\">Parent Association</a>\n          </div>\n        </div>\n\n        <a id=\"apply\" href=\"files/apply.html\">Apply</a>\n        <a id=\"forms\" href=\"files/forms.html\">Forms</a>\n\n        <a id=\"parent-resources\" href=\"files/parent_resources.html\">Parent Resources</a>\n      </div>\n    </div>\n  </div>\n</header>";

},{}],141:[function(require,module,exports){
module.exports = "<ts-load data-name=\"footer\"></ts-load>";

},{}],142:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var document_1 = require("./../core/dom/document");
var Slideshow = /** @class */ (function () {
    function Slideshow(outer) {
        var _this = this;
        this.outer = outer;
        this.slideIndex = 0;
        this.slideCount = 0;
        this.slides = [];
        this.dots = [];
        document_1.D.eachRecur(this.outer, function (elem) {
            var cList = elem.classList;
            if (cList.contains("prev-slideshow-button")) {
                document_1.D.addEventListener(elem, "click", function () { return _this.minusSlide(1); });
            }
            else if (cList.contains("next-slideshow-button")) {
                document_1.D.addEventListener(elem, "click", function () { return _this.plusSlide(1); });
            }
            else if (cList.contains("slideshow-entry")) {
                _this.slides.push(elem);
            }
            else if (cList.contains("slideshow-dot")) {
                _this.dots.push(elem);
            }
        });
        var _loop_1 = function (i) {
            document_1.D.addEventListener(this_1.dots[i], "click", function () { return _this.showSlide(i); });
        };
        var this_1 = this;
        for (var i = 0; i < this.dots.length; ++i) {
            _loop_1(i);
        }
        this.slideCount = this.slides.length;
        this.showSlide(this.slideIndex);
    }
    Slideshow.setupAll = function () {
        Slideshow.discardAll();
        var slideshows = document_1.D.claz("slideshow");
        for (var ssIndex = 0; ssIndex < slideshows.length; ++ssIndex) {
            var elem = slideshows.item(ssIndex);
            if (elem == null) {
                continue;
            }
            Slideshow.slideshows.push(new Slideshow(elem));
        }
    };
    Slideshow.discardAll = function () {
        Slideshow.slideshows = [];
    };
    Slideshow.prototype.plusSlide = function (n) {
        this.showSlide((this.slideIndex += n));
    };
    Slideshow.prototype.minusSlide = function (n) {
        this.showSlide((this.slideIndex -= n));
    };
    Slideshow.prototype.showSlide = function (index) {
        this.slideIndex = index % this.slideCount;
        this.slideIndex = Math.max(this.slideIndex, -1 * this.slideIndex);
        for (var i = 0; i < this.slides.length; ++i) {
            this.slides[i].style.display = "none";
        }
        for (var i = 0; i < this.dots.length; i++) {
            this.dots[i].classList.remove("active");
        }
        this.slides[this.slideIndex].style.display = "block";
        this.dots[this.slideIndex].classList.add("active");
    };
    Slideshow.slideshows = [];
    return Slideshow;
}());
exports.Slideshow = Slideshow;
},{"./../core/dom/document":120}],143:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var data_1 = require("./../core/data-log/data");
var document_1 = require("./../core/dom/document");
var elements_1 = require("./../core/dom/elements");
var scroll_1 = require("./../core/dom/scroll");
var history_1 = require("./../core/router/history");
var router_1 = require("./../core/router/router");
var tracker_1 = require("./../core/tracker/tracker");
var html_loader_1 = require("./../core/utils/html_loader");
var id_generator_1 = require("./../core/utils/id_generator");
var ready_1 = require("./../core/utils/ready");
var setup = function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, ready_1.waitUntilReady()];
            case 1:
                _a.sent();
                // const scenarioTag = window.location.hash.split('?')[0].replace('#', '');
                // const scenario = scenarios.find((scen) => scen.tag === scenarioTag);
                // if (scenario === null || scenario === undefined) {
                //     alert('This HIT is broken and cannot be completed at this time.');
                //     return;
                // }
                // Tracker.loadScenario(scenario);
                tracker_1.Tracker.start({
                    keyPrefix: 'information-foraging',
                    bucketName: 'cse-256-log',
                    allowSubmission: {
                        allow: function () {
                            try {
                                var textArea = document_1.D.id('text-area');
                                console.log(textArea.value);
                                if (textArea.value === '') {
                                    return 'You must fill out the text box to turn this HIT in.';
                                }
                                else {
                                    return null;
                                }
                            }
                            catch (error) {
                                console.log(error);
                                return 'There was an error fill out the form and try again.';
                            }
                        },
                        preSubmit: function () {
                            data_1.data.data.response = document_1.D.id('text-area').value;
                            return;
                        },
                    },
                    debugLevel: 1 /* NONE */,
                    setup: function () {
                        return __awaiter(this, void 0, void 0, function () {
                            var sElem;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        // configure router
                                        router_1.Router.defaultAllowancesOn();
                                        router_1.Router.configure([
                                            {
                                                mode: 2 /* STANDARD_ALLOWANCES */,
                                                module: "A" /* A */,
                                            },
                                            { mode: 0 /* OFF */, module: "FORM" /* FORM */ },
                                            {
                                                mode: 2 /* STANDARD_ALLOWANCES */,
                                                module: "IMG" /* IMG */,
                                            },
                                        ], '/files/');
                                        history_1.History.setup(window.location.href, { wrapper: true });
                                        // configure html loader post operation
                                        html_loader_1.HTMLLoader.finish();
                                        html_loader_1.HTMLLoader.registerPostLoadFunc(function () {
                                            id_generator_1.IDGenerator.reset();
                                            id_generator_1.IDGenerator.attachIdsToAllElements();
                                            router_1.Router.setup(elements_1.Elements.htmlLoc);
                                            scroll_1.Scroll.promise(0);
                                        });
                                        // configure listeners on html loc
                                        document_1.D.addEventListener(elements_1.Elements.htmlLoc, "click" /* CLICK */, function (e) {
                                            var ev = e;
                                            var obj = {
                                                x: ev.clientX,
                                                y: ev.clientY,
                                                id: ev.target.id,
                                            };
                                            tracker_1.Tracker.getEventDispatchFunc("click" /* CLICK */)(obj);
                                        });
                                        document_1.D.addEventListener(elements_1.Elements.document, 'keypress', function (e) {
                                            var ev = e;
                                            var obj = {
                                                key: ev.key,
                                                id: ev.srcElement.id,
                                            };
                                            tracker_1.Tracker.getEventDispatchFunc("button" /* BUTTON */)(obj);
                                        });
                                        sElem = document.scrollingElement;
                                        document.addEventListener('scroll', function (e) {
                                            var dx = sElem.scrollLeft;
                                            var dy = sElem.scrollTop;
                                            var dtime = new Date().getTime();
                                            if (Math.abs(tracker_1.Tracker.lastPos.x - dx) > 10 ||
                                                (Math.abs(tracker_1.Tracker.lastPos.y - dy) > 10 &&
                                                    dtime - tracker_1.Tracker.lastPos.time > 100)) {
                                                tracker_1.Tracker.lastPos.x = dx;
                                                tracker_1.Tracker.lastPos.y = dy;
                                                tracker_1.Tracker.lastPos.time = dtime;
                                                var obj = { x: dx, y: dy };
                                                tracker_1.Tracker.getEventDispatchFunc("scroll" /* SCROLL */)(obj);
                                            }
                                        });
                                        // configure tracked events
                                        tracker_1.Tracker.registerEvent("history" /* HISTORY */);
                                        tracker_1.Tracker.registerEvent("button" /* BUTTON */);
                                        tracker_1.Tracker.registerEvent("click" /* CLICK */);
                                        tracker_1.Tracker.registerEvent("scroll" /* SCROLL */);
                                        // load first page
                                        return [4 /*yield*/, router_1.Router.load('/files/index.html')];
                                    case 1:
                                        // load first page
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        });
                    },
                });
                return [2 /*return*/];
        }
    });
}); };
setup();
},{"./../core/data-log/data":116,"./../core/dom/document":120,"./../core/dom/elements":121,"./../core/dom/scroll":124,"./../core/router/history":127,"./../core/router/router":128,"./../core/tracker/tracker":129,"./../core/utils/html_loader":132,"./../core/utils/id_generator":133,"./../core/utils/ready":134}]},{},[137,143])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9hcGlzL2NvZ25pdG8taWRlbnRpdHktMjAxNC0wNi0zMC5taW4uanNvbiIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvY29nbml0by1pZGVudGl0eS0yMDE0LTA2LTMwLnBhZ2luYXRvcnMuanNvbiIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvbWV0YWRhdGEuanNvbiIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvczMtMjAwNi0wMy0wMS5taW4uanNvbiIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvczMtMjAwNi0wMy0wMS5wYWdpbmF0b3JzLmpzb24iLCJub2RlX21vZHVsZXMvYXdzLXNkay9hcGlzL3MzLTIwMDYtMDMtMDEud2FpdGVyczIuanNvbiIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvc3RzLTIwMTEtMDYtMTUubWluLmpzb24iLCJub2RlX21vZHVsZXMvYXdzLXNkay9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvY2xpZW50cy9jb2duaXRvaWRlbnRpdHkuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9jbGllbnRzL3MzLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvY2xpZW50cy9zdHMuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvYXBpX2xvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9icm93c2VyQ3J5cHRvTGliLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2Jyb3dzZXJIYXNoVXRpbHMuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvYnJvd3NlckhtYWMuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvYnJvd3Nlck1kNS5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9icm93c2VyU2hhMS5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9icm93c2VyU2hhMjU2LmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2Jyb3dzZXJfbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jb25maWdfcmVnaW9uYWxfZW5kcG9pbnQuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy9jaGFpbmFibGVfdGVtcG9yYXJ5X2NyZWRlbnRpYWxzLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NyZWRlbnRpYWxzL2NvZ25pdG9faWRlbnRpdHlfY3JlZGVudGlhbHMuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvY3JlZGVudGlhbF9wcm92aWRlcl9jaGFpbi5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy9zYW1sX2NyZWRlbnRpYWxzLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NyZWRlbnRpYWxzL3RlbXBvcmFyeV9jcmVkZW50aWFscy5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy93ZWJfaWRlbnRpdHlfY3JlZGVudGlhbHMuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZGlzY292ZXJfZW5kcG9pbnQuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZXZlbnQtc3RyZWFtL2J1ZmZlcmVkLWNyZWF0ZS1ldmVudC1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZXZlbnQtc3RyZWFtL2V2ZW50LW1lc3NhZ2UtY2h1bmtlci5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9ldmVudC1zdHJlYW0vaW50NjQuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZXZlbnQtc3RyZWFtL3BhcnNlLWV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2V2ZW50LXN0cmVhbS9wYXJzZS1tZXNzYWdlLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2V2ZW50LXN0cmVhbS9zcGxpdC1tZXNzYWdlLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2V2ZW50X2xpc3RlbmVycy5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9odHRwLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2h0dHAveGhyLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2pzb24vYnVpbGRlci5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9qc29uL3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tb2RlbC9hcGkuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbW9kZWwvY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tb2RlbC9vcGVyYXRpb24uanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbW9kZWwvcGFnaW5hdG9yLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL21vZGVsL3Jlc291cmNlX3dhaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tb2RlbC9zaGFwZS5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9wYXJhbV92YWxpZGF0b3IuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcHJvdG9jb2wvaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9wcm90b2NvbC9qc29uLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3Byb3RvY29sL3F1ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3Byb3RvY29sL3Jlc3QuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcHJvdG9jb2wvcmVzdF9qc29uLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3Byb3RvY29sL3Jlc3RfeG1sLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3F1ZXJ5L3F1ZXJ5X3BhcmFtX3NlcmlhbGl6ZXIuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcmVhbGNsb2NrL2Jyb3dzZXJDbG9jay5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9yZWdpb25fY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3JlZ2lvbl9jb25maWdfZGF0YS5qc29uIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3JlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcmVzb3VyY2Vfd2FpdGVyLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3Jlc3BvbnNlLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3MzL21hbmFnZWRfdXBsb2FkLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NlcXVlbnRpYWxfZXhlY3V0b3IuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2VydmljZS5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zZXJ2aWNlcy9jb2duaXRvaWRlbnRpdHkuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2VydmljZXMvczMuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2VydmljZXMvc3RzLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvcHJlc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3JlcXVlc3Rfc2lnbmVyLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvczMuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2lnbmVycy92Mi5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3YzLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvdjNodHRwcy5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3Y0LmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvdjRfY3JlZGVudGlhbHMuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc3RhdGVfbWFjaGluZS5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3htbC9icm93c2VyX3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi94bWwvYnVpbGRlci5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi94bWwvZXNjYXBlLWF0dHJpYnV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi94bWwvZXNjYXBlLWVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIveG1sL3htbC1ub2RlLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3htbC94bWwtdGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL3ZlbmRvci9lbmRwb2ludC1jYWNoZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL3ZlbmRvci9lbmRwb2ludC1jYWNoZS91dGlscy9MUlUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ptZXNwYXRoL2ptZXNwYXRoLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdXVpZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2xpYi9ieXRlc1RvVXVpZC5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2xpYi9ybmctYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL3YxLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvdjQuanMiLCJzY3JpcHRzL3RzL2NvcmUvYXdzL2NvZ25pdG8udHMiLCJzY3JpcHRzL3RzL2NvcmUvYXdzL210dXJrLnRzIiwic2NyaXB0cy90cy9jb3JlL2F3cy9zMy50cyIsInNjcmlwdHMvdHMvY29yZS9kYXRhLWxvZy9kYXRhLnRzIiwic2NyaXB0cy90cy9jb3JlL2RhdGEtbG9nL2V2ZW50LnRzIiwic2NyaXB0cy90cy9jb3JlL2RhdGEtbG9nL3JlY2VpdmVyLnRzIiwic2NyaXB0cy90cy9jb3JlL2RvbS9iYW5uZXIudHMiLCJzY3JpcHRzL3RzL2NvcmUvZG9tL2RvY3VtZW50LnRzIiwic2NyaXB0cy90cy9jb3JlL2RvbS9lbGVtZW50cy50cyIsInNjcmlwdHMvdHMvY29yZS9kb20vaHRtbF9sb2MudHMiLCJzY3JpcHRzL3RzL2NvcmUvZG9tL21vZGFsLnRzIiwic2NyaXB0cy90cy9jb3JlL2RvbS9zY3JvbGwudHMiLCJzY3JpcHRzL3RzL2NvcmUvZG9tL3N1Ym1pdF9mb3JtLnRzIiwic2NyaXB0cy90cy9jb3JlL2RvbS90cmFja2VyX2VsZW1zLnRzIiwic2NyaXB0cy90cy9jb3JlL3JvdXRlci9oaXN0b3J5LnRzIiwic2NyaXB0cy90cy9jb3JlL3JvdXRlci9yb3V0ZXIudHMiLCJzY3JpcHRzL3RzL2NvcmUvdHJhY2tlci90cmFja2VyLnRzIiwic2NyaXB0cy90cy9jb3JlL3V0aWxzL2NvbnNvbGVfd3JhcHBlci50cyIsInNjcmlwdHMvdHMvY29yZS91dGlscy9mdW5jcy50cyIsInNjcmlwdHMvdHMvY29yZS91dGlscy9odG1sX2xvYWRlci50cyIsInNjcmlwdHMvdHMvY29yZS91dGlscy9pZF9nZW5lcmF0b3IudHMiLCJzY3JpcHRzL3RzL2NvcmUvdXRpbHMvcmVhZHkudHMiLCJzY3JpcHRzL3RzL2R5bmFtaWMtZG9tL2FjY29yZGlvbi50cyIsInNjcmlwdHMvdHMvZHluYW1pYy1kb20vZG8tc29tZXRoaW5nLmpzIiwic2NyaXB0cy90cy9keW5hbWljLWRvbS9keW5hbWljLWRvbS50cyIsInNjcmlwdHMvdHMvZHluYW1pYy1kb20vaHRtbC1pbXBvcnRzLnRzIiwic2NyaXB0cy90cy9keW5hbWljLWRvbS9odG1sL2Zvb3Rlci5odG1sIiwic2NyaXB0cy90cy9keW5hbWljLWRvbS9odG1sL2hlYWRlci5odG1sIiwic2NyaXB0cy90cy9keW5hbWljLWRvbS9odG1sL25lc3RlZC5odG1sIiwic2NyaXB0cy90cy9keW5hbWljLWRvbS9zbGlkZXNob3cudHMiLCJzY3JpcHRzL3RzL3RyYWNrZXIvdHJhY2tlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy84S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDelRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbm1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDallBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3htQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0eUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3B6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4MkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1Z0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdndEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3dkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25vREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0JBLGtEQUFzQztBQUN0Qyw4REFBaUU7QUFDakUscUJBQUcsQ0FBQyxpQkFBaUIsZ0JBQXVCLENBQUM7QUFDN0M7SUFhSSw2QkFBWSxjQUFzQixFQUFVLE1BQWM7UUFBZCxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQ3RELEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUMzQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksR0FBRyxDQUFDLDBCQUEwQixDQUFDO1lBQzVDLGNBQWMsRUFBRSxjQUFjO1NBQ2pDLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQUMsS0FBSztZQUNqQixLQUFLO2dCQUNELENBQUMsQ0FBQyxxQkFBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLG1CQUEwQjtnQkFDN0MsQ0FBQyxDQUFDLHFCQUFHLENBQUMsd0JBQXdCLG1CQUEwQixDQUFDO1FBQ2pFLENBQUMsQ0FBQyxDQUFDO1FBQ0gsR0FBRyxDQUFDLE1BQU0sQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztJQUN4QyxDQUFDO0lBcEJhLHVCQUFHLEdBQWpCLFVBQ0ksY0FBeUMsRUFDekMsTUFBbUM7UUFEbkMsK0JBQUEsRUFBQSxpQkFBaUIsbUJBQW1CLENBQUMsSUFBSTtRQUN6Qyx1QkFBQSxFQUFBLFNBQVMsbUJBQW1CLENBQUMsTUFBTTtRQUVuQyxPQUFPLElBQUksbUJBQW1CLENBQUMsY0FBYyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFpQkQsc0JBQVcsNENBQVc7YUFBdEI7WUFDSSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDdEIsQ0FBQzs7O09BQUE7SUEzQmEsd0JBQUksR0FBRyxnREFBZ0QsQ0FBQztJQUN4RCwwQkFBTSxHQUFHLFdBQVcsQ0FBQztJQTJCdkMsMEJBQUM7Q0E3QkQsQUE2QkMsSUFBQTtBQTdCWSxrREFBbUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGaEMsNERBQXNFO0FBQ3RFLHFDQUFnRDtBQUNoRCwyQkFBZ0M7QUFDaEMscUJBQUcsQ0FBQyxlQUFlLGdCQUF1QixDQUFDO0FBQzNDO0lBQUE7SUFrQ0EsQ0FBQztJQWpDaUIsZ0JBQUksR0FBbEIsVUFBbUIsVUFBa0IsRUFBRSxTQUFpQjtRQUNwRCxXQUFXLENBQUMsRUFBRSxHQUFHLGFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ3JELE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2xCLEVBQUUsRUFBRSxXQUFXLENBQUMsRUFBRTtZQUNsQixHQUFHLEVBQUUsV0FBVyxDQUFDLE9BQU87WUFDeEIsR0FBRyxFQUFFLFdBQVcsQ0FBQyxNQUFNO1NBQzFCLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFbUIsa0JBQU0sR0FBMUIsVUFBMkIsSUFBWSxFQUFFLElBQVM7Ozs7Z0JBQzlDLHNCQUFPLHVCQUFLLENBQUM7Ozs7O29DQUNILE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO29DQUNyQyxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO29DQUNYLHFCQUFNLFdBQVcsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsRUFBQTs7b0NBQWhELEdBQUcsR0FBRyxTQUEwQztvQ0FDcEQsR0FBRyxHQUFHLEdBQXlCLENBQUM7Ozs7eUJBQ25DLENBQUMsRUFBQzs7O0tBQ047SUFFYSxrQkFBTSxHQUFwQixVQUFxQixLQUFhLEVBQUUsWUFBb0I7UUFDcEQsT0FBVSxLQUFLLFNBQUksWUFBWSxjQUFXLENBQUM7SUFDL0MsQ0FBQztJQUVhLHlCQUFhLEdBQTNCLFVBQTRCLEVBQXVCO1FBQy9DLFdBQVcsQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO0lBQzdCLENBQUM7SUFFYSxvQkFBUSxHQUF0QixVQUF1QixFQUFZO1FBQy9CLFdBQVcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO0lBQ3hCLENBQUM7SUFFRCxzREFBc0Q7SUFDeEMsbUJBQU8sR0FBRyw2QkFBbUIsQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUV0RCxrQkFBQztDQWxDRCxBQWtDQyxJQUFBO0FBbENZLGtDQUFXOzs7Ozs7O0FDTHhCLDBEQUFvQztBQUVwQyw0REFBK0Q7QUFDL0QscUJBQUcsQ0FBQyxZQUFZLGdCQUF1QixDQUFDO0FBQ3hDO0lBV0ksa0JBQW9CLFVBQWtCLEVBQVUsU0FBaUI7UUFBN0MsZUFBVSxHQUFWLFVBQVUsQ0FBUTtRQUFVLGNBQVMsR0FBVCxTQUFTLENBQVE7UUFDN0QsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLFlBQUUsQ0FBQztZQUNiLFVBQVUsRUFBRSxRQUFRLENBQUMsVUFBVTtTQUNsQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBVmEsWUFBRyxHQUFqQixVQUFrQixNQUFvQyxFQUFFLFNBQWlCO1FBQXZELHVCQUFBLEVBQUEsU0FBaUIsUUFBUSxDQUFDLFVBQVU7UUFDbEQsT0FBTyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQVVELHNCQUFXLDRCQUFNO2FBQWpCO1lBQ0ksT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQzNCLENBQUM7OztPQUFBO0lBRU0seUJBQU0sR0FBYixVQUNJLElBQVksRUFDWixJQUFTO1FBRmIsaUJBb0JDO1FBaEJHLE9BQU8sSUFBSSxPQUFPLENBQUMsVUFBQyxPQUFPLEVBQUUsTUFBTTtZQUMvQixLQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FDYjtnQkFDSSxHQUFHLEVBQUUsS0FBSSxDQUFDLFNBQVMsR0FBRyxHQUFHLEdBQUcsSUFBSTtnQkFDaEMsSUFBSSxFQUFFLElBQUk7Z0JBQ1YsTUFBTSxFQUFFLEtBQUksQ0FBQyxNQUFNO2FBQ3RCLEVBQ0QsVUFBQyxHQUFpQixFQUFFLE9BQTJCO2dCQUMzQyxJQUFJLEdBQUcsRUFBRTtvQkFDTCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQ2Y7cUJBQU07b0JBQ0gsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2lCQUNwQjtZQUNMLENBQUMsQ0FDSixDQUFDO1FBQ04sQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBeENhLG1CQUFVLEdBQUcsRUFBRSxDQUFDO0lBQ2hCLG1CQUFVLEdBQUcsWUFBWSxDQUFDO0lBQzFCLGtCQUFTLEdBQUcsRUFBRSxDQUFDO0lBdUNqQyxlQUFDO0NBMUNELEFBMENDLElBQUE7QUExQ1ksNEJBQVE7Ozs7QUNIckIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQztBQVM1QixJQUFNLFNBQVMsR0FBRyxJQUFJLGVBQWUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUU3RCxRQUFBLE9BQU8sR0FBaUI7SUFDakMsR0FBRyxFQUFFLFNBQVMsQ0FBQyxRQUFRLEVBQUU7SUFDekIsWUFBWSxFQUFFLFNBQVMsQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDO0lBQzNDLEtBQUssRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQztJQUM3QixRQUFRLEVBQUUsU0FBUyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7SUFDbkMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDO0NBQzFDLENBQUM7QUFFRjtJQU1JLGNBQVksZUFBNkI7UUFMbEMsU0FBSSxHQUE0QyxFQUFFLENBQUM7UUFDbkQsU0FBSSxHQUEyQixFQUFFLENBQUM7UUFDbEMsV0FBTSxHQUFVLEVBQUUsQ0FBQztRQUl0QixJQUFJLENBQUMsT0FBTyxHQUFHLGVBQWUsQ0FBQztJQUNuQyxDQUFDO0lBRU0sd0JBQVMsR0FBaEI7UUFDSSxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUNMLFdBQUM7QUFBRCxDQWJBLEFBYUMsSUFBQTtBQWJZLG9CQUFJO0FBZUosUUFBQSxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsZUFBTyxDQUFDLENBQUM7QUFFdEMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsRUFBRSxJQUFJLGNBQUEsRUFBRSxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckNoQyw0REFBK0Q7QUFDL0Qsd0NBQXFDO0FBQ3JDLHFCQUFHLENBQUMsZUFBZSxnQkFBdUIsQ0FBQztBQWEzQyxTQUFnQixvQkFBb0IsQ0FBQyxHQUFRLEVBQUUsTUFBYztJQUMzRCxHQUFHLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztJQUNwQixHQUFHLENBQUMsSUFBSSxHQUFHLFdBQUcsRUFBRSxDQUFDO0FBQ25CLENBQUM7QUFIRCxvREFHQztBQUVELFNBQWdCLGNBQWMsQ0FBQyxHQUFRO0lBQ3JDLE9BQU8sR0FBRyxDQUFDLE1BQU0sS0FBSyxTQUFTLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxTQUFTLENBQUM7QUFDNUQsQ0FBQztBQUZELHdDQUVDO0FBRUQ7SUFJRSwwQkFBWSxNQUFjLEVBQUUsYUFBOEM7UUFDeEUsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLFdBQVcsQ0FBQyxNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDckQsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLElBQUksR0FBRyxXQUFHLEVBQUUsQ0FBQztJQUNwQixDQUFDO0lBRUQsc0JBQVcsb0NBQU07YUFBakI7WUFDRSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQzVCLENBQUM7OztPQUFBO0lBQ0gsdUJBQUM7QUFBRCxDQWJBLEFBYUMsSUFBQTtBQWJZLDRDQUFnQjtBQWU3QixpREFBaUQ7QUFDakQ7SUFBZ0MsOEJBSTlCO0lBQ0Esb0JBQ0UsQ0FBUyxFQUNULENBQVMsRUFDVCxFQUFVLEVBQ1YsYUFFYTtRQU5mLFlBUUUsdUNBQXdCLGFBQWEsQ0FBQyxTQUl2QztRQUhDLEtBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNsQixLQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbEIsS0FBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDOztJQUN0QixDQUFDO0lBQ0gsaUJBQUM7QUFBRCxDQWxCQSxBQWtCQyxDQWxCK0IsZ0JBQWdCLEdBa0IvQztBQWxCWSxnQ0FBVTtBQW9CdkIsaURBQWlEO0FBQ2pEO0lBQWlDLCtCQUE2QztJQUM1RSxxQkFDRSxHQUFXLEVBQ1gsRUFBVSxFQUNWLGFBQXdFO1FBSDFFLFlBS0UsdUNBQXdCLGFBQWEsQ0FBQyxTQUd2QztRQUZDLEtBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUN0QixLQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7O0lBQ3RCLENBQUM7SUFDSCxrQkFBQztBQUFELENBVkEsQUFVQyxDQVZnQyxnQkFBZ0IsR0FVaEQ7QUFWWSxrQ0FBVztBQVl4QixpREFBaUQ7QUFDakQ7SUFBa0MsZ0NBR2hDO0lBQ0Esc0JBQ0UsR0FBVyxFQUNYLEtBQVcsRUFDWCxhQUE0RDtRQUg5RCxZQUtFLDJDQUEwQixhQUFhLENBQUMsU0FHekM7UUFGQyxLQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDdEIsS0FBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDOztJQUM1QixDQUFDO0lBQ0gsbUJBQUM7QUFBRCxDQWJBLEFBYUMsQ0FiaUMsZ0JBQWdCLEdBYWpEO0FBYlksb0NBQVk7Ozs7QUMxRXpCLDREQUErRDtBQUMvRCxpQ0FBdUQ7QUFDdkQscUJBQUcsQ0FBQyxrQkFBa0IsZ0JBQXVCLENBQUM7QUFDOUM7SUFBQTtRQUNVLFFBQUcsR0FBRyxJQUFJLEdBQUcsRUFBeUMsQ0FBQztRQUN2RCxZQUFPLEdBQUcsSUFBSSxXQUFXLEVBQUUsQ0FBQztJQXFCdEMsQ0FBQztJQW5CUSxnQ0FBUSxHQUFmLFVBQWdCLFNBQWlCLEVBQUUsUUFBd0M7UUFDekUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsVUFBQyxLQUFZO1lBQ3BELElBQU0sT0FBTyxHQUFLLEtBQWlDO2lCQUNoRCxNQUFzQixDQUFDO1lBQzFCLElBQUksc0JBQWMsQ0FBQyxPQUFPLENBQUMsSUFBSSxRQUFRLEVBQUU7Z0JBQ3ZDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUNuQjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxRQUFRLEVBQUU7WUFDWixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDbkM7SUFDSCxDQUFDO0lBRU0sK0JBQU8sR0FBZCxVQUFlLEtBQW1CO1FBQ2hDLElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDakQsSUFBSSxRQUFRLEVBQUU7WUFDWixRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDakI7SUFDSCxDQUFDO0lBQ0gsb0JBQUM7QUFBRCxDQXZCQSxBQXVCQyxJQUFBO0FBdkJZLHNDQUFhOzs7O0FDSDFCLDJDQUEwQztBQUMxQyw0REFBK0Q7QUFDL0QsK0NBQThDO0FBQzlDLHVDQUErQjtBQUMvQix1Q0FBc0M7QUFDdEMscUJBQUcsQ0FBQyxnQkFBZ0IsZ0JBQXVCLENBQUM7QUFDNUM7SUFBQTtJQXVCQSxDQUFDO0lBdEJlLGNBQUksR0FBbEI7UUFDRSxTQUFTLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztRQUN6QixZQUFDLENBQUMsT0FBTyxDQUFDLG1CQUFRLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQy9CLFlBQUMsQ0FBQyxPQUFPLENBQUMsbUJBQVEsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDbEMsWUFBQyxDQUFDLE9BQU8sQ0FBQyxtQkFBUSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRWEsY0FBSSxHQUFsQjtRQUNFLFNBQVMsQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQzFCLFlBQUMsQ0FBQyxPQUFPLENBQUMsbUJBQVEsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDakMsWUFBQyxDQUFDLE9BQU8sQ0FBQyxtQkFBUSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNoQyxZQUFDLENBQUMsT0FBTyxDQUFDLG1CQUFRLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7SUFFYSx5QkFBZSxHQUE3QjtRQUNFLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzFELENBQUM7SUFDYSxlQUFLLEdBQW5CO1FBQ0UsWUFBQyxDQUFDLGdCQUFnQixDQUFDLG1CQUFRLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxTQUFTLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDM0UsQ0FBQztJQUVjLGlCQUFPLEdBQUcsSUFBSSxDQUFDO0lBQ2hDLGdCQUFDO0NBdkJELEFBdUJDLElBQUE7QUF2QlksOEJBQVM7QUF5QnRCLFlBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyx1QkFBdUIsRUFBRSxPQUFPLEVBQUUsVUFBQyxDQUFDO0lBQ3JELElBQUksaUJBQU8sQ0FBQyxXQUFXLEVBQUUsRUFBRTtRQUN6QixlQUFNLENBQUMsa0JBQWtCLENBQUMsaUJBQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0tBQy9DO1NBQU07UUFDTCxLQUFLLENBQUMsdURBQXVELENBQUMsQ0FBQztLQUNoRTtBQUNILENBQUMsQ0FBQyxDQUFDOzs7O0FDckNILDhEQUF3RTtBQUN4RSxxQkFBRyxDQUFDLGtCQUFrQixnQkFBdUIsQ0FBQztBQUM5QztJQUFBO0lBb0ZBLENBQUM7SUFqRmUsTUFBSSxHQUFsQixVQUFtQixJQUFzQjtRQUN2QyxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUM1QixPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDbkI7YUFBTTtZQUNMLE9BQU8sSUFBZSxDQUFDO1NBQ3hCO0lBQ0gsQ0FBQztJQUVhLFNBQU8sR0FBckIsVUFBc0IsSUFBc0IsRUFBRSxJQUFhO1FBQ3pELElBQUksR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BCLElBQUksSUFBSSxFQUFFO1lBQ1IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDOUIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDL0I7YUFBTTtZQUNMLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQzVCO0lBQ0gsQ0FBQztJQUVhLElBQUUsR0FBaEIsVUFBaUIsRUFBVTtRQUN6QixJQUFNLE9BQU8sR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN6QyxJQUFJLE9BQU8sS0FBSyxJQUFJLEVBQUU7WUFDcEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBK0IsRUFBRSxPQUFJLENBQUMsQ0FBQztTQUN4RDthQUFNO1lBQ0wsT0FBTyxPQUFPLENBQUM7U0FDaEI7SUFDSCxDQUFDO0lBQ2EsTUFBSSxHQUFsQixVQUFtQixJQUFZO1FBQzdCLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBQ2EsS0FBRyxHQUFqQixVQUFrQixHQUFXO1FBQzNCLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBQ2EsT0FBSyxHQUFuQixVQUFvQixFQUFVLEVBQUUsR0FBVztRQUN6Qyx1QkFBSyxDQUFDLGNBQU0sT0FBQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLEVBQWpDLENBQWlDLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRWEsa0JBQWdCLEdBQTlCLFVBQ0UsSUFBc0IsRUFDdEIsSUFBWSxFQUNaLFFBQTJCO1FBRTNCLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZCLElBQU0sV0FBVyxHQUFHLFVBQUMsQ0FBUTtZQUMzQixJQUFJO2dCQUNGLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNiO1lBQUMsT0FBTyxHQUFHLEVBQUU7Z0JBQ1osT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNwQjtRQUNILENBQUMsQ0FBQztRQUNELElBQWdCLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ3RELE9BQU8sV0FBVyxDQUFDO0lBQ3JCLENBQUM7SUFFYSxNQUFJLEdBQWxCLFVBQW1CLElBQXNCLEVBQUUsS0FBNkI7UUFDdEUsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdkIsSUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUMvQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN4QyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDcEI7SUFDSCxDQUFDO0lBRWEsV0FBUyxHQUF2QixVQUNFLElBQXNCLEVBQ3RCLEtBQTZCO1FBRTdCLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZCLElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDL0IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDeEMsSUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzFCLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNiLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQzNCO0lBQ0gsQ0FBQztJQUVhLFFBQU0sR0FBcEIsVUFDRSxPQUFVLEVBQ1YsT0FBZ0M7UUFFaEMsT0FBTyxRQUFRLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBbEZhLEtBQUcsR0FBYSxRQUFRLENBQUM7SUFtRnpDLFFBQUM7Q0FwRkQsQUFvRkMsSUFBQTtBQXBGWSxjQUFDOzs7O0FDRmQsNERBQStEO0FBQy9ELHVDQUErQjtBQUMvQixxQkFBRyxDQUFDLGlCQUFpQixnQkFBdUIsQ0FBQztBQUM3Qzs7Ozs7O0dBTUc7QUFFSDs7OztHQUlHO0FBQ0gsU0FBUyxrQkFBa0IsQ0FBQyxFQUFVO0lBQ2xDLElBQUksSUFBSSxDQUFDO0lBQ1QsSUFBSTtRQUNBLElBQUksR0FBRyxZQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQ25CO0lBQUMsT0FBTyxHQUFHLEVBQUU7UUFDVixJQUFJLEdBQUcsWUFBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQztRQUNiLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztRQUM1QixRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUM5QjtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2hCLENBQUM7QUFFRDs7R0FFRztBQUNVLFFBQUEsUUFBUSxHQUFHO0lBQ3BCLFFBQVEsRUFBRSxZQUFDLENBQUMsR0FBRyxDQUFDLGVBQWU7SUFDL0IsT0FBTyxFQUFFLGtCQUFrQixDQUFDLFNBQVMsQ0FBQztJQUN0QyxPQUFPLEVBQUUsa0JBQWtCLENBQUMsVUFBVSxDQUFDO0lBQ3ZDLFNBQVMsRUFBRSxrQkFBa0IsQ0FBQyxZQUFZLENBQUM7SUFDM0MsTUFBTSxFQUFFLGtCQUFrQixDQUFDLG1DQUFtQyxDQUFDO0lBQy9ELElBQUksRUFBRSxrQkFBa0IsQ0FBQyxrQ0FBa0MsQ0FBQztJQUM1RCxTQUFTLEVBQUUsa0JBQWtCLENBQUMsb0NBQW9DLENBQUM7SUFDbkUsVUFBVSxFQUFFLGtCQUFrQixDQUFDLHVCQUF1QixDQUFDO0lBQ3ZELE9BQU8sRUFBRSxrQkFBa0IsQ0FBQyx3QkFBd0IsQ0FBQztJQUNyRCxlQUFlLEVBQUUsa0JBQWtCLENBQUMsdUJBQXVCLENBQUM7SUFDNUQsaUJBQWlCLEVBQUUsa0JBQWtCLENBQUMsa0JBQWtCLENBQUM7SUFDekQsa0JBQWtCLEVBQUUsa0JBQWtCLENBQUMsbUJBQW1CLENBQUM7SUFDM0QsWUFBWSxFQUFFLGtCQUFrQixDQUM1QixtREFBbUQsQ0FDdEQ7SUFDRCxVQUFVLEVBQUUsa0JBQWtCLENBQUMsbUJBQW1CLENBQUM7SUFDbkQsS0FBSyxFQUFFLGtCQUFrQixDQUFDLE9BQU8sQ0FBQztDQUNyQyxDQUFDOzs7O0FDbERGLDREQUErRDtBQUMvRCw4Q0FBNkM7QUFDN0MscUJBQUcsQ0FBQyxrQkFBa0IsZ0JBQXVCLENBQUM7QUFDOUMsSUFBWSxPQUtYO0FBTEQsV0FBWSxPQUFPO0lBQ2Ysd0RBQTZDLENBQUE7SUFDN0MsNENBQWlDLENBQUE7SUFDakMsb0NBQXlCLENBQUE7SUFDekIsMEJBQWUsQ0FBQTtBQUNuQixDQUFDLEVBTFcsT0FBTyxHQUFQLGVBQU8sS0FBUCxlQUFPLFFBS2xCO0FBRUQsSUFBWSxRQUtYO0FBTEQsV0FBWSxRQUFRO0lBQ2hCLHlCQUFhLENBQUE7SUFDYiwrQkFBbUIsQ0FBQTtJQUNuQix5QkFBYSxDQUFBO0lBQ2IsMkJBQWUsQ0FBQTtBQUNuQixDQUFDLEVBTFcsUUFBUSxHQUFSLGdCQUFRLEtBQVIsZ0JBQVEsUUFLbkI7QUFFRDtJQUFBO0lBWUEsQ0FBQztJQU5pQixhQUFLLEdBQW5CO1FBQ0ksT0FBTyxDQUFDLEdBQUcsR0FBSSxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFlLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQztRQUNyRSxPQUFPLENBQUMsSUFBSTtZQUNQLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQWlCLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQztRQUM5RCxPQUFPLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsSUFBSSxPQUFPLENBQUM7SUFDaEUsQ0FBQztJQVZhLFlBQUksR0FBRyxtQkFBUSxDQUFDLE9BQU8sQ0FBQztJQVcxQyxjQUFDO0NBWkQsQUFZQyxJQUFBO0FBWlksMEJBQU87Ozs7QUNqQnBCLDhEQUFpRTtBQUNqRSx1Q0FBK0I7QUFDL0IsdUNBQXNDO0FBQ3RDLHFCQUFHLENBQUMsZUFBZSxnQkFBdUIsQ0FBQztBQUMzQztJQUFBO0lBd0JBLENBQUM7SUFyQmlCLGFBQU8sR0FBckIsVUFBc0IsR0FBVztRQUM3QixLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FDbkIsT0FBTyxFQUNQLFdBQVMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLGlCQUFZLElBQUksQ0FBQyxLQUFLLENBQ3pELE1BQU0sQ0FBQyxXQUFXLENBQ3JCLFFBQUssQ0FDVCxDQUFDO1FBQ0YsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxZQUFZLENBQUMsQ0FBQztRQUN6RCxZQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsVUFBQyxJQUFJO1lBQ25CLElBQTBCLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUMxQyxDQUFDLENBQUMsQ0FBQztRQUNILFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRWEsVUFBSSxHQUFsQjtRQUNJLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDekQsWUFBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFVBQUMsSUFBSTtZQUNuQixJQUEwQixDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUM7UUFDekMsQ0FBQyxDQUFDLENBQUM7UUFDSCxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQXRCYSxVQUFJLEdBQUcsbUJBQVEsQ0FBQyxLQUFLLENBQUM7SUF1QnhDLFlBQUM7Q0F4QkQsQUF3QkMsSUFBQTtBQXhCWSxzQkFBSztBQTBCbEIsWUFBQyxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLFVBQUMsQ0FBQztJQUN0QyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDakIsQ0FBQyxDQUFDLENBQUM7QUFDSCxZQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsVUFBQyxJQUFJO0lBQ3BCLFlBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLFVBQUMsQ0FBQztRQUNoQyxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDdkIsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMsQ0FBQzs7OztBQ3JDSCw0REFBc0U7QUFDdEUsMENBQTZDO0FBQzdDLHFCQUFHLENBQUMsZ0JBQWdCLGdCQUF1QixDQUFDO0FBQzVDOzs7Ozs7R0FNRztBQUNIO0lBMkNFLGdCQUNVLE1BQWMsRUFDZCxRQUFnQixFQUN4QixRQUErQjtRQUZ2QixXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQ2QsYUFBUSxHQUFSLFFBQVEsQ0FBUTtRQUd4QixJQUFJLENBQUMsUUFBUSxHQUFHO1lBQUMsY0FBWTtpQkFBWixVQUFZLEVBQVoscUJBQVksRUFBWixJQUFZO2dCQUFaLHlCQUFZOztZQUMzQixRQUFRLENBQUMsYUFBYSxDQUFDLElBQUksV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDbEQsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2pCLENBQUMsQ0FBQztJQUNKLENBQUM7SUFqRGEsZUFBUSxHQUF0QixVQUNFLE1BQWMsRUFDZCxRQUFzQixFQUN0QixRQUFzQztRQUR0Qyx5QkFBQSxFQUFBLGNBQXNCO1FBQ3RCLHlCQUFBLEVBQUEsV0FBa0MsWUFBSTtRQUV0QyxJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUU7WUFDbEIsTUFBTSxJQUFJLEtBQUssQ0FBQyx3REFBd0QsQ0FBQyxDQUFDO1NBQzNFO1FBQ0QsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDdEIsSUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDO1FBQzdCLFFBQVEsR0FBRztZQUNULE1BQU0sQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1lBQ3ZCLHVCQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDckIsQ0FBQyxDQUFDO1FBQ0YsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUNuRSxDQUFDO0lBRWEsY0FBTyxHQUFyQixVQUFzQixNQUFjLEVBQUUsUUFBc0I7UUFBNUQsaUJBaUJDO1FBakJxQyx5QkFBQSxFQUFBLGNBQXNCO1FBQzFELElBQUksTUFBTSxDQUFDLE9BQU8sRUFBRTtZQUNsQixNQUFNLElBQUksS0FBSyxDQUFDLHdEQUF3RCxDQUFDLENBQUM7U0FDM0U7UUFDRCxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztRQUN0QixPQUFPLElBQUksT0FBTyxDQUFDLFVBQUMsT0FBbUIsRUFBRSxNQUEyQjtZQUNsRSxJQUFJO2dCQUNGLElBQU0sV0FBVyxHQUFHO29CQUNsQixNQUFNLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztvQkFDdkIsT0FBTyxFQUFFLENBQUM7Z0JBQ1osQ0FBQyxDQUFDO2dCQUNGLEtBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsV0FBVyxDQUFDLENBQUMsYUFBYSxFQUFFLENBQUM7YUFDckU7WUFBQyxPQUFPLEdBQUcsRUFBRTtnQkFDWixNQUFNLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztnQkFDdkIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ2I7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFpQkQsc0JBQWtCLG1CQUFTO2FBQTNCO1lBQ0UsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDO1FBQ3hCLENBQUM7OztPQUFBO0lBRU8sdUJBQU0sR0FBZCxVQUNFLE1BQWMsRUFDZCxRQUFnQixFQUNoQixRQUErQjtRQUUvQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFTyxpQ0FBZ0IsR0FBeEI7UUFDRSxJQUFNLE9BQU8sR0FBRyxXQUFHLEVBQUUsQ0FBQztRQUN0QixJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3pFLElBQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUM7UUFDbEMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRU8sdUJBQU0sR0FBZDtRQUNFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7UUFDMUMsSUFBSSxNQUFNLENBQUMsV0FBVyxLQUFLLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDdEMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQ2pCO2FBQU07WUFDTCxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDcEM7SUFDSCxDQUFDO0lBRU8sOEJBQWEsR0FBckI7UUFDRSxJQUFJLHVCQUF1QixJQUFJLE1BQU0sS0FBSyxLQUFLLEVBQUU7WUFDL0MsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQy9CO1FBQ0QsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ2hCLENBQUM7SUF6RmEsaUJBQVUsR0FBRyxFQUFFLENBQUM7SUFzQ2YsY0FBTyxHQUFHLEtBQUssQ0FBQztJQUNoQixlQUFRLEdBQUcsSUFBSSxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxZQUFJLENBQUMsQ0FBQztJQW1EbkQsYUFBQztDQTNGRCxBQTJGQyxJQUFBO0FBM0ZZLHdCQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVm5CLHdDQUFzQztBQUN0Qyx3Q0FBNkM7QUFDN0MsMkNBQTBDO0FBQzFDLDhEQUFpRTtBQUNqRSx1Q0FBK0I7QUFDL0IsdUNBQXNDO0FBQ3RDLHFCQUFHLENBQUMscUJBQXFCLGdCQUF1QixDQUFDO0FBTWpELElBQU0sc0JBQXNCLEdBQW9CO0lBQzVDLEtBQUssRUFBRSxjQUFNLE9BQUEsSUFBSSxFQUFKLENBQUk7SUFDakIsU0FBUyxFQUFFLFlBQUk7Q0FDbEIsQ0FBQztBQUVGO0lBQUE7SUE4Q0EsQ0FBQztJQTFDaUIsZ0JBQUssR0FBbkIsVUFDSSxlQUF5RDtRQUQ3RCxpQkF1Q0M7UUF0Q0csZ0NBQUEsRUFBQSx3Q0FBeUQ7UUFFekQsSUFBSSxXQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksS0FBSyxJQUFJLEVBQUU7WUFDbkMsWUFBQyxDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQXNCLENBQUMsS0FBSztnQkFDN0MsV0FBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUM7U0FDakM7UUFDRCxJQUFJLFdBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxLQUFLLElBQUksRUFBRTtZQUM1QixZQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBc0IsQ0FBQyxLQUFLLEdBQUcsV0FBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7U0FDbkU7UUFDRCxVQUFVLENBQUMsVUFBVSxHQUFHLFVBQU8sS0FBSzs7Ozs7d0JBQ2hDLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQzt3QkFDakIsT0FBTyxHQUFHLGVBQWUsQ0FBQyxLQUFLLEVBQUUsQ0FBQzs2QkFDcEMsQ0FBQSxPQUFPLEtBQUssSUFBSSxDQUFBLEVBQWhCLHdCQUFnQjt3QkFDaEIsZUFBZSxDQUFDLFNBQVMsRUFBRSxDQUFDO3dCQUN4QixLQUFLLEdBQUcsV0FBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7d0JBQy9CLElBQUksS0FBSyxLQUFLLElBQUksRUFBRTs0QkFDaEIsS0FBSyxHQUFHLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsQ0FBQzt5QkFDeEQ7d0JBQ0csWUFBWSxHQUFHLFdBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDO3dCQUM3QyxJQUFJLFlBQVksS0FBSyxJQUFJLEVBQUU7NEJBQ3ZCLFlBQVk7Z0NBQ1IsY0FBYyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxDQUFDO3lCQUMzRDt3QkFDRCxxQkFBTSxtQkFBVyxDQUFDLE1BQU0sQ0FDcEIsbUJBQVcsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLFlBQVksQ0FBQyxFQUN2QyxXQUFJLENBQ1AsRUFBQTs7d0JBSEQsU0FHQyxDQUFDO3dCQUNGLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7d0JBQ3JCLFVBQVUsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQy9CLFFBQVEsRUFDUixVQUFVLENBQUMsVUFBVSxDQUN4QixDQUFDO3dCQUNGLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7Ozt3QkFFekIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDOzs7OzthQUV0QixDQUFDO1FBQ0YsVUFBVSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7SUExQ2EsZUFBSSxHQUFHLG1CQUFRLENBQUMsVUFBNkIsQ0FBQztJQUM5Qyw2QkFBa0IsR0FBRyxFQUFFLEtBQUssRUFBRSxjQUFNLE9BQUEsSUFBSSxFQUFKLENBQUksRUFBRSxTQUFTLEVBQUUsWUFBSSxFQUFFLENBQUM7SUE0QzlFLGlCQUFDO0NBOUNELEFBOENDLElBQUE7QUE5Q1ksZ0NBQVU7Ozs7QUNqQnZCLG1DQUFxQztBQUNyQyx1Q0FBcUM7QUFFckM7SUFBQTtJQU1BLENBQUM7SUFMZSxvQ0FBb0IsR0FBbEM7UUFDRSxxQkFBcUI7UUFDckIsa0JBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNsQixrQkFBTyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ2xCLENBQUM7SUFDSCxzQkFBQztBQUFELENBTkEsQUFNQyxJQUFBO0FBTlksMENBQWU7Ozs7QUNINUIsZ0RBQStDO0FBVS9DLFNBQVMsZUFBZSxDQUNwQixPQUFlLEVBQ2YsVUFBbUIsRUFDbkIsU0FBd0IsRUFDeEIsS0FBVztJQUVYLGlCQUFPLENBQUMsb0JBQW9CLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLEtBQUssT0FBQSxFQUFFLENBQUMsQ0FBQztJQUNqRSxPQUFPO1FBQ0gsT0FBTyxTQUFBO1FBQ1AsVUFBVSxZQUFBO1FBQ1YsU0FBUyxXQUFBO1FBQ1QsS0FBSyxPQUFBO1FBQ0wsV0FBVyxFQUFFLEVBQUU7S0FDbEIsQ0FBQztBQUNOLENBQUM7QUFFRDtJQUFBO0lBdUNBLENBQUM7SUF0Q2lCLGVBQU8sR0FBckIsVUFBc0IsR0FBVyxFQUFFLEtBQVc7UUFDMUMsSUFBTSxPQUFPLEdBQUcsZUFBZSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN2RSxPQUFPLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDOUMsT0FBTyxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUM7UUFDOUIsT0FBTyxHQUFHLENBQUM7SUFDZixDQUFDO0lBRWEsbUJBQVcsR0FBekI7O1FBQ0ksT0FBTyxDQUNILE9BQU8sQ0FBQyxXQUFXLENBQUMsVUFBVTtZQUM5QixjQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsU0FBUywwQ0FBRSxLQUFLLDBDQUFFLE9BQU8sQ0FBQSxDQUNqRCxDQUFDO0lBQ04sQ0FBQztJQUVhLGdCQUFRLEdBQXRCO1FBQ0ksSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsRUFBRTtZQUN4QixNQUFNLElBQUksS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7U0FDbEQ7UUFDRCxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDM0MsSUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxTQUF5QixDQUFDO1FBQ2hFLElBQU0sT0FBTyxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUM7UUFDbEMsSUFBTSxPQUFPLEdBQUcsZUFBZSxDQUMzQixPQUFPLEVBQ1AsU0FBUyxDQUFDLFVBQVUsRUFDcEIsU0FBUyxDQUFDLFNBQVMsRUFDbkIsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQ2pCLENBQUM7UUFDRixPQUFPLENBQUMsV0FBVyxHQUFHLE9BQU8sQ0FBQztRQUM5QixPQUFPLE9BQU8sQ0FBQztJQUNuQixDQUFDO0lBRWEsYUFBSyxHQUFuQixVQUFvQixHQUFXLEVBQUUsS0FBVztRQUN4QyxPQUFPLENBQUMsWUFBWSxHQUFHLGVBQWUsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNyRSxPQUFPLENBQUMsV0FBVyxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUM7SUFDL0MsQ0FBQztJQUlMLGNBQUM7QUFBRCxDQXZDQSxBQXVDQyxJQUFBO0FBdkNZLDBCQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQnBCLDRDQUFvQztBQUNwQyw0Q0FBMkM7QUFDM0Msc0NBQXFDO0FBQ3JDLDREQUFzRTtBQUN0RSx3Q0FBc0M7QUFDdEMsb0RBQWtEO0FBQ2xELHFDQUFvQztBQUNwQyxxQkFBRyxDQUFDLGdCQUFnQixnQkFBdUIsQ0FBQztBQXdCNUMsU0FBUyxNQUFNLENBQUMsSUFBYSxFQUFFLE1BQW9CO0lBQy9DLE9BQU8sQ0FDSCxJQUFJLENBQUMsT0FBTyxLQUFLLE1BQU0sQ0FBQyxNQUFNO1FBQzlCLENBQUMsTUFBTSxDQUFDLElBQUksZUFBa0I7WUFDMUIsTUFBTSxDQUFDLElBQUksZ0NBQW1DLENBQUMsQ0FDdEQsQ0FBQztBQUNOLENBQUM7QUFDRCxTQUFTLGFBQWEsQ0FBQyxNQUFvQjtJQUN2QyxPQUFPLE1BQU0sQ0FBQyxJQUFJLGdDQUFtQyxDQUFDO0FBQzFELENBQUM7QUFFRDtJQUFBO0lBaU5BLENBQUM7SUFyTWlCLGdCQUFTLEdBQXZCLFVBQXdCLE9BQXVCLEVBQUUsVUFBa0I7UUFDL0QsT0FBTyxDQUFDLE9BQU8sQ0FBQyxVQUFDLE1BQU07WUFDbkIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDcEUsQ0FBQyxDQUFDLENBQUM7UUFDSCxNQUFNLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztJQUNuQyxDQUFDO0lBRWEsWUFBSyxHQUFuQixVQUFvQixJQUFzQjtRQUN0QyxZQUFDLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxVQUFDLElBQUk7OztnQkFDbkIsS0FBcUIsSUFBQSxLQUFBLFNBQUEsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQSxnQkFBQSw0QkFBRTtvQkFBekMsSUFBTSxNQUFNLFdBQUE7b0JBQ2IsSUFBSSxNQUFNLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxFQUFFO3dCQUN0QixNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztxQkFDOUI7aUJBQ0o7Ozs7Ozs7OztRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVhLDZCQUFzQixHQUFwQyxVQUFxQyxDQUFhO1FBQzlDLE9BQU8sdUJBQUssQ0FBQztZQUNULENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUNuQixJQUFNLE1BQU0sR0FBRyxDQUFDLENBQUMsTUFBMkIsQ0FBQztZQUM3QyxJQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ3hCLGlCQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUN6QyxJQUFNLEdBQUcsR0FBRyx3QkFBVSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsbUJBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN0RCxNQUFNLENBQUMsYUFBYSxDQUFDLElBQUksV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7WUFDckQsT0FBTyxHQUFHLENBQUM7UUFDZixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFYSxzQkFBZSxHQUE3QixVQUE4QixJQUE0QjtRQUExRCxpQkFPQztRQU5HLE9BQU8sVUFBQyxDQUFhO1lBQ2pCLHVCQUFLLENBQUM7OztnQ0FDRixxQkFBTSxNQUFNLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxDQUFDLEVBQUE7OzRCQUF0QyxTQUFzQyxDQUFDOzRCQUN2QyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7Ozs7aUJBQ1gsQ0FBQyxDQUFDO1FBQ1AsQ0FBQyxDQUFDO0lBQ04sQ0FBQztJQUVhLDBCQUFtQixHQUFqQyxVQUFrQyxDQUFhO1FBQzNDLE9BQU8sdUJBQUssQ0FBQztZQUNULG9EQUFvRDtZQUNwRCxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDbkIsSUFBTSxNQUFNLEdBQUcsQ0FBQyxDQUFDLE1BQTBCLENBQUM7WUFDNUMsSUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQztZQUN2QixpQkFBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDekMsT0FBTyx3QkFBVSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsbUJBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNyRCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFYSx3QkFBaUIsR0FBL0IsVUFBZ0MsQ0FBUTtRQUNwQyxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDbkIsT0FBTyxDQUFDLEtBQUssQ0FDVCw4REFBOEQsQ0FDakUsQ0FBQztJQUNOLENBQUM7SUFFYSwwQkFBbUIsR0FBakM7UUFDSSxNQUFNLENBQUMsaUJBQWlCLENBQ3BCLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxlQUFlLEVBQUUsRUFDckQsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUUsTUFBTSxDQUFDLGtCQUFrQixFQUFFLEVBQzVELEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSxDQUNoRSxDQUFDO0lBQ04sQ0FBQztJQUNhLDJCQUFvQixHQUFsQztRQUNJLE1BQU0sQ0FBQyxtQkFBbUIsQ0FDdEIsTUFBTSxDQUFDLEtBQUssRUFDWixNQUFNLENBQUMsU0FBUyxFQUNoQixNQUFNLENBQUMsU0FBUyxDQUNuQixDQUFDO0lBQ04sQ0FBQztJQUNhLHdCQUFpQixHQUEvQjtRQUNJLGdCQUFnRTthQUFoRSxVQUFnRSxFQUFoRSxxQkFBZ0UsRUFBaEUsSUFBZ0U7WUFBaEUsMkJBQWdFOztRQUVoRSxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQUMsS0FBSztZQUNqQixPQUFBLE1BQU0sQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQztRQUFsRCxDQUFrRCxDQUNyRCxDQUFDO0lBQ04sQ0FBQztJQUNhLDBCQUFtQixHQUFqQztRQUFrQyxnQkFBbUI7YUFBbkIsVUFBbUIsRUFBbkIscUJBQW1CLEVBQW5CLElBQW1CO1lBQW5CLDJCQUFtQjs7UUFDakQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFDLEtBQUssSUFBSyxPQUFBLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFuQyxDQUFtQyxDQUFDLENBQUM7SUFDbkUsQ0FBQztJQUNhLHNCQUFlLEdBQTdCO1FBQ0ksTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNsQyxDQUFDO0lBRW1CLFdBQUksR0FBeEIsVUFBeUIsR0FBVzs7Ozs7O3dCQUNoQyxpQkFBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7d0JBQzdCLHFCQUFNLHdCQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxtQkFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFBOzt3QkFBckQsR0FBRyxHQUFHLFNBQStDO3dCQUMzRCxNQUFNLENBQUMsYUFBYSxDQUFDLElBQUksV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7d0JBQ3JELHNCQUFPLEdBQUcsRUFBQzs7OztLQUNkO0lBRW1CLHlCQUFrQixHQUF0QyxVQUF1QyxJQUFZOzs7O2dCQUN6QyxHQUFHLEdBQUcsd0JBQVUsQ0FBQyxPQUFPLENBQzFCLE1BQU0sQ0FBQyxVQUFVLEdBQUcsSUFBSSxFQUN4QixtQkFBUSxDQUFDLE9BQU8sQ0FDbkIsQ0FBQztnQkFDRixNQUFNLENBQUMsYUFBYSxDQUFDLElBQUksV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7Z0JBQ3JELHNCQUFPLEdBQUcsRUFBQzs7O0tBQ2Q7SUF3RmMsb0JBQWEsR0FBNUIsVUFBNkIsTUFBb0I7UUFDN0MsT0FBTztZQUNILE1BQU0sRUFBRSxNQUFNLENBQUMsTUFBTTtZQUNyQixJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUk7WUFDakIsS0FBSyxFQUFFLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztTQUM5QyxDQUFDO0lBQ04sQ0FBQztJQUNjLGtCQUFXLEdBQTFCLFVBQTJCLEdBQVc7UUFDbEMsSUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdkMsT0FBTyxHQUFHLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztJQUM5RCxDQUFDO0lBL01hLGdCQUFTLEdBQUcsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDNUIsWUFBSyxHQUFHLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3pCLGdCQUFTLEdBQUcsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFNUIseUJBQWtCLEdBQUcsWUFBSSxDQUFDO0lBQzFCLHNCQUFlLEdBQUcsVUFBQyxLQUFZLElBQUssT0FBQSxLQUFLLENBQUMsY0FBYyxFQUFFLEVBQXRCLENBQXNCLENBQUM7SUFDM0QsMEJBQW1CLEdBQUcsVUFBQyxLQUFZO1FBQzdDLE9BQUEsS0FBSyxDQUFDLGNBQWMsRUFBRTtJQUF0QixDQUFzQixDQUFDO0lBRWIsaUJBQVUsR0FBRyxFQUFFLENBQUM7SUFzR2YscUJBQWMsR0FBRztRQUM1QixDQUFDLEVBQUUsVUFBQyxNQUF3QixFQUFFLElBQWE7WUFDdkMsSUFBTSxLQUFLLEdBQUcsSUFBeUIsQ0FBQztZQUN4QyxJQUFJLGFBQWEsQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDdkIsSUFBSSxpQkFBZSxHQUFHLElBQUksQ0FBQztnQkFDM0IsSUFBTSxNQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQztnQkFDeEIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsVUFBQyxJQUFJLEVBQUUsS0FBSztvQkFDdEMsSUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFJLENBQUMsQ0FBQztvQkFDOUIsaUJBQWUsR0FBRyxpQkFBZSxJQUFJLENBQUMsSUFBSSxDQUFDO29CQUMzQyxJQUFJLElBQUksRUFBRTt3QkFDTixZQUFDLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztxQkFDM0M7Z0JBQ0wsQ0FBQyxDQUFDLENBQUM7Z0JBQ0gsSUFBSSxpQkFBZSxFQUFFO29CQUNqQixJQUFJLE1BQUksQ0FBQyxNQUFNLENBQUMsTUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsS0FBSyxLQUFLLEVBQUU7d0JBQ3hDLFlBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLFVBQUMsQ0FBQzs0QkFDaEMsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDOzRCQUNuQixhQUFLLENBQUMsT0FBTyxDQUFDLE1BQUksQ0FBQyxDQUFDO3dCQUN4QixDQUFDLENBQUMsQ0FBQztxQkFDTjt5QkFBTTt3QkFDSCxZQUFDLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxVQUFDLENBQUM7NEJBQ2hDLE9BQUEsTUFBTSxDQUFDLHNCQUFzQixDQUFDLENBQWUsQ0FBQzt3QkFBOUMsQ0FBOEMsQ0FDakQsQ0FBQztxQkFDTDtpQkFDSjthQUNKO2lCQUFNO2dCQUNILFlBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLFVBQUMsQ0FBQztvQkFDaEMsT0FBQSxNQUFNLENBQUMsc0JBQXNCLENBQUMsQ0FBZSxDQUFDO2dCQUE5QyxDQUE4QyxDQUNqRCxDQUFDO2FBQ0w7UUFDTCxDQUFDO1FBQ0QsR0FBRyxFQUFFLFVBQUMsTUFBd0IsRUFBRSxJQUFhO1lBQ3pDLElBQU0sT0FBTyxHQUFHLElBQXdCLENBQUM7WUFDekMsSUFBSSxhQUFhLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQ3ZCLElBQUksaUJBQWUsR0FBRyxJQUFJLENBQUM7Z0JBQzNCLE1BQU0sQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLFVBQUMsSUFBSSxFQUFFLEtBQUs7b0JBQ3RDLElBQU0sSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ3RDLGlCQUFlLEdBQUcsaUJBQWUsSUFBSSxJQUFJLENBQUM7b0JBQzFDLElBQUksSUFBSSxFQUFFO3dCQUNOLFlBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO3FCQUMzQztnQkFDTCxDQUFDLENBQUMsQ0FBQztnQkFDSCxJQUFJLGlCQUFlLEVBQUU7b0JBQ2pCLFlBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLFVBQUMsQ0FBQzt3QkFDaEMsT0FBQSxNQUFNLENBQUMsc0JBQXNCLENBQUMsQ0FBZSxDQUFDO29CQUE5QyxDQUE4QyxDQUNqRCxDQUFDO2lCQUNMO2FBQ0o7aUJBQU07Z0JBQ0gsWUFBQyxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsVUFBQyxDQUFDO29CQUNoQyxPQUFBLE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFlLENBQUM7Z0JBQTlDLENBQThDLENBQ2pELENBQUM7YUFDTDtRQUNMLENBQUM7UUFDRCxJQUFJLEVBQUUsVUFBQyxNQUF3QixFQUFFLElBQWE7WUFDMUMsSUFBTSxRQUFRLEdBQUcsSUFBdUIsQ0FBQztZQUN6QyxJQUFJLGFBQWEsQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDdkIsSUFBSSxpQkFBZSxHQUFHLElBQUksQ0FBQztnQkFDM0IsTUFBTSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsVUFBQyxJQUFJLEVBQUUsS0FBSztvQkFDdEMsSUFBTSxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDdkMsaUJBQWUsR0FBRyxpQkFBZSxJQUFJLElBQUksQ0FBQztvQkFDMUMsSUFBSSxJQUFJLEVBQUU7d0JBQ04sWUFBQyxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7cUJBQzNDO2dCQUNMLENBQUMsQ0FBQyxDQUFDO2dCQUNILElBQUksaUJBQWUsRUFBRTtvQkFDakIsWUFBQyxDQUFDLGdCQUFnQixDQUNkLElBQUksRUFDSixRQUFRLEVBQ1IsTUFBTSxDQUFDLGlCQUFpQixDQUMzQixDQUFDO2lCQUNMO2FBQ0o7aUJBQU07Z0JBQ0gsWUFBQyxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUM7YUFDaEU7UUFDTCxDQUFDO0tBQ0osQ0FBQztJQUVhLGNBQU8sR0FBRyxJQUFJLEdBQUcsRUFBa0MsQ0FBQztJQUVwRCxxQkFBYyxHQUF1QyxJQUFJLEdBQUcsRUFHeEUsQ0FBQztJQUVXLGdCQUFTLEdBQUcsZ0JBQWdCLENBQUM7SUFhaEQsYUFBQztDQWpORCxBQWlOQyxJQUFBO0FBak5ZLHdCQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQ25CLDJDQUF5RTtBQUN6RSxpREFBcUQ7QUFDckQsNENBQTJDO0FBQzNDLHNEQUF1RDtBQUN2RCw0REFBOEU7QUFFOUUsd0NBQTZDO0FBQzdDLDJDQUEwQztBQUMxQyxvREFBbUU7QUFFbkUscUJBQUcsQ0FBQyxpQkFBaUIsZ0JBQXVCLENBQUM7QUFVN0M7SUFBQTtJQThEQSxDQUFDO0lBM0RpQixvQkFBWSxHQUExQixVQUEyQixJQUFjO1FBQ3JDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDeEIsSUFBSSxHQUFHLENBQUMsTUFBTSxHQUFHLEVBQUUsRUFBRTtZQUNqQixHQUFHLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDM0IsSUFBTSxJQUFJLEdBQUc7Z0JBQ1QsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUM7Z0JBQ3BCLEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDO2dCQUNwQixHQUFHLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQztnQkFDcEIsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUM7Z0JBQ3BCLEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDO2FBQ3ZCLENBQUM7WUFDRixJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxPQUFSLElBQUksV0FBUSxJQUFJLEVBQUMsQ0FBQztZQUM5QixHQUFHLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDO1NBQ3ZDO1FBRUQsbUJBQVEsQ0FBQyxlQUFlLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQztRQUN6QyxtQkFBUSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQ3JELG1CQUFRLENBQUMsa0JBQWtCLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDdEQsbUJBQVEsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO0lBQzdDLENBQUM7SUFFYSxhQUFLLEdBQW5CLFVBQW9CLE1BQTRCO1FBQzVDLCtCQUFhLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2pDLHNDQUFzQztRQUN0QywrQkFBZSxDQUFDLG9CQUFvQixFQUFFLENBQUM7UUFDdkMsd0JBQVUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQ3pDLG1CQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3RELFdBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLG1CQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFDL0MsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ25CLENBQUM7SUFFYSxxQkFBYSxHQUEzQixVQUE0QixTQUFpQjtRQUN6QyxXQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUMxQixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsVUFBQyxLQUFLO1lBQ3BDLFdBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3JDLENBQUMsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVhLDRCQUFvQixHQUFsQyxVQUFtQyxTQUFpQjtRQUFwRCxpQkFTQztRQVJHLE9BQU8sVUFBQyxNQUFXO1lBQ2YsSUFBSSxPQUFPLE1BQU0sS0FBSyxRQUFRLEVBQUU7Z0JBQzVCLElBQUksQ0FBQyxzQkFBYyxDQUFDLE1BQU0sQ0FBQyxFQUFFO29CQUN6Qiw0QkFBb0IsQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7aUJBQzNDO2dCQUNELEtBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ2pDO1FBQ0wsQ0FBQyxDQUFDO0lBQ04sQ0FBQztJQUVhLGtCQUFVLEdBQXhCLFVBQXlCLEdBQVcsRUFBRSxTQUFjO1FBQ2hELFdBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDO0lBQy9CLENBQUM7SUFFYSx3QkFBZ0IsR0FBOUIsVUFBK0IsSUFBWSxFQUFFLE9BQTBCO1FBQ25FLFdBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLFdBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUMvQyxDQUFDO0lBMURhLGVBQU8sR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUM7SUE0RGpDLGdCQUFRLEdBQUcsSUFBSSx3QkFBYSxFQUFFLENBQUM7SUFDbEQsY0FBQztDQTlERCxBQThEQyxJQUFBO0FBOURZLDBCQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEJwQiwyQ0FBMEM7QUFDMUMsR0FBRyxDQUFDLHlCQUF5QixnQkFBdUIsQ0FBQztBQUNyRCxTQUFzQixLQUFLLENBQ3pCLElBQXlCOzs7WUFFekIsc0JBQU8sT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUM7OztDQUN4QjtBQUpELHNCQUlDO0FBRUQsU0FBZ0IsT0FBTyxDQUNyQixJQUF5QjtJQUQzQixpQkFXQztJQVJDLE9BQU87UUFBTyxjQUFZO2FBQVosVUFBWSxFQUFaLHFCQUFZLEVBQVosSUFBWTtZQUFaLHlCQUFZOzs7O2dCQUN4QixJQUFJO29CQUNGLHNCQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBQztpQkFDbkI7Z0JBQUMsT0FBTyxLQUFLLEVBQUU7b0JBQ2QsV0FBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ3hCLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQ3RCOzs7O0tBQ0YsQ0FBQztBQUNKLENBQUM7QUFYRCwwQkFXQztBQVFELElBQUksVUFBVSxnQkFBdUMsQ0FBQztBQUV0RCxTQUFnQixhQUFhLENBQUMsS0FBcUI7SUFDakQsVUFBVSxHQUFHLEtBQUssQ0FBQztBQUNyQixDQUFDO0FBRkQsc0NBRUM7QUFFRCxTQUFnQixHQUFHLENBQUMsT0FBZSxFQUFFLFVBQTBCO0lBQzdELElBQUksVUFBVSxJQUFJLFVBQVUsRUFBRTtRQUM1QixPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0tBQ3RCO0FBQ0gsQ0FBQztBQUpELGtCQUlDOzs7O0FDckNELHFEQUF3RDtBQUN4RCxxQkFBRyxDQUFDLGVBQWUsZ0JBQXVCLENBQUM7QUFDM0MscUNBQXFDO0FBQ3JDLFNBQWdCLElBQUksS0FBSSxDQUFDO0FBQXpCLG9CQUF5QjtBQUN6QixTQUFnQixHQUFHO0lBQ2pCLE9BQU8sSUFBSSxJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUM5QixDQUFDO0FBRkQsa0JBRUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNORCw0Q0FBb0M7QUFDcEMscURBQXdEO0FBQ3hELGlDQUErQjtBQUMvQixxQkFBRyxDQUFDLHFCQUFxQixnQkFBdUIsQ0FBQztBQUlqRDtJQUFBO0lBcUtBLENBQUM7SUFsS2lCLGlCQUFNLEdBQXBCO1FBQ0ksVUFBVSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDM0IsVUFBVSxDQUFDLGlCQUFpQixFQUFFLENBQUM7SUFDbkMsQ0FBQztJQUVhLHFCQUFVLEdBQXhCO1FBQ0ksT0FBTyxVQUFVLENBQUMsUUFBUSxDQUFDO0lBQy9CLENBQUM7SUFFYSxvQkFBUyxHQUF2QixVQUF3QixJQUFZLEVBQUUsT0FBZTtRQUNqRCxJQUFJLFVBQVUsQ0FBQyxRQUFRLEVBQUU7WUFDckIsTUFBTSxJQUFJLEtBQUssQ0FDWCx3RUFBd0UsQ0FDM0UsQ0FBQztTQUNMO1FBQ0QsSUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUM5QyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDeEIsR0FBRyxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUM7UUFDeEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDM0IsQ0FBQztJQUVhLCtCQUFvQixHQUFsQyxVQUFtQyxJQUFlO1FBQzlDLHFCQUFHLENBQUMsNkJBQTZCLG1CQUEwQixDQUFDO1FBQzVELFVBQVUsQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO0lBQ25DLENBQUM7SUFFYSxlQUFJLEdBQWxCLFVBQW1CLElBQVksRUFBRSxJQUFzQjtRQUNuRCxPQUFPLElBQUksT0FBTyxDQUFVLFVBQUMsT0FBTyxFQUFFLE1BQU07WUFDeEMsSUFBSTtnQkFDQSxxQkFBRyxDQUFDLFlBQVksbUJBQTBCLENBQUM7Z0JBQzNDLElBQU0sT0FBTyxHQUFHLFlBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzdCLElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQkFDckMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUNsQyxJQUFNLElBQUksR0FBRyxLQUFLLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ2xELFVBQVUsQ0FBQyw4QkFBOEIsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7Z0JBQzFELFVBQVUsQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDdkMsT0FBTyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7Z0JBQ3ZCLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzFCLHFCQUFHLENBQUMsVUFBVSxtQkFBMEIsQ0FBQztnQkFDekMsVUFBVSxDQUFDLFlBQVksRUFBRSxDQUFDO2dCQUMxQixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDakI7WUFBQyxPQUFPLEdBQUcsRUFBRTtnQkFDVixNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDZjtRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVtQixrQkFBTyxHQUEzQixVQUE0QixHQUFXLEVBQUUsSUFBc0I7Ozs7Ozt3QkFDcEQsS0FBQSxDQUFBLEtBQUEsVUFBVSxDQUFBLENBQUMsSUFBSSxDQUFBO3dCQUFDLHFCQUFNLFVBQVUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUE7NEJBQXBELHNCQUFPLGNBQWdCLFNBQTZCLEVBQUUsSUFBSSxFQUFDLEVBQUM7Ozs7S0FDL0Q7SUFFYSxrQkFBTyxHQUFyQixVQUFzQixHQUFXO1FBQzdCLE9BQU8sSUFBSSxPQUFPLENBQVMsVUFBQyxPQUFPLEVBQUUsTUFBTTtZQUN2QyxJQUFJO2dCQUNBLHFCQUFHLENBQUMsZUFBZSxtQkFBMEIsQ0FBQztnQkFDOUMsSUFBTSxTQUFPLEdBQUcsSUFBSSxjQUFjLEVBQUUsQ0FBQztnQkFDckMsU0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUMvQixTQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNuQixTQUFPLENBQUMsa0JBQWtCLEdBQUc7b0JBQ3pCLElBQUksU0FBTyxDQUFDLFVBQVUsS0FBSyxDQUFDLEVBQUU7d0JBQzFCLHFCQUFHLENBQUMsaUJBQWlCLG1CQUEwQixDQUFDO3dCQUNoRCxPQUFPLENBQUMsU0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO3FCQUNqQztnQkFDTCxDQUFDLENBQUM7YUFDTDtZQUFDLE9BQU8sR0FBRyxFQUFFO2dCQUNWLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNmO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBTWMseUNBQThCLEdBQTdDLFVBQ0ksSUFBc0IsRUFDdEIsT0FBZTtRQUVmLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQyxHQUFHLElBQUssT0FBQSxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFyQixDQUFxQixDQUFDLENBQUM7SUFDM0UsQ0FBQztJQUVjLDRCQUFpQixHQUFoQztRQUNJLHFCQUFHLENBQUMsWUFBWSxtQkFBMEIsQ0FBQztRQUMzQyxJQUFNLENBQUMsR0FBRyxJQUFJLEdBQUcsRUFBVSxDQUFDO1FBQzVCLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FDakMsVUFBQyxJQUFJO1lBQ0QsT0FBQSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsVUFBVSxDQUFDLGdCQUFnQixDQUNqRCxVQUFVLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFZLEVBQzVDLENBQUMsRUFDRCxDQUFDLENBQ08sQ0FBQztRQUpiLENBSWEsQ0FDcEIsQ0FBQztJQUNOLENBQUM7SUFFYyx1QkFBWSxHQUEzQixVQUE0QixDQUFTO1FBQ2pDLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztRQUNiLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDeEIsR0FBRyxJQUFJLElBQUksQ0FBQztTQUNmO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDZixDQUFDO0lBRWMsMkJBQWdCLEdBQS9CLFVBQ0ksSUFBYSxFQUNiLFNBQXNCLEVBQ3RCLEtBQWE7UUFFYixJQUFNLElBQUksR0FBRyxVQUFVLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzVDLElBQUksS0FBSyxHQUFHLEdBQUcsRUFBRTtZQUNiLEtBQUssQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO1lBQ25ELE1BQU0sSUFBSSxLQUFLLENBQ1gsa0VBQWtFO2dCQUM5RCw4REFBOEQ7Z0JBQzlELFNBQVM7Z0JBQ1QsNkNBQTZDO2dCQUM3QyxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUNyQyxDQUFDO1NBQ0w7UUFDRCxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzVDLElBQUksSUFBSSxLQUFLLElBQUksRUFBRTtZQUNmLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFDRCxJQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbEQsSUFBSSxPQUFPLEtBQUssSUFBSSxFQUFFO1lBQ2xCLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFDRCxJQUFJLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDckIsT0FBTyxPQUFPLENBQUM7U0FDbEI7UUFDRCxPQUFPLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQUMsQ0FBQyxJQUFLLE9BQUEsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFWLENBQVUsQ0FBQyxDQUFDO1FBQzlELE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQyxDQUFDO1lBQzFDLElBQU0sS0FBSyxHQUFHLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEVBQUUsU0FBUyxFQUFFLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNuRSxJQUFJLEtBQUssS0FBSyxJQUFJLEVBQUU7Z0JBQ2hCLENBQUMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDeEI7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUNILFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDcEIsT0FBTyxPQUFPLENBQUM7SUFDbkIsQ0FBQztJQUVjLDJCQUFnQixHQUEvQixVQUNJLElBQStCO1FBRS9CLElBQUksSUFBSSxLQUFLLFNBQVMsSUFBSSxJQUFJLEtBQUssSUFBSSxFQUFFO1lBQ3JDLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFDRCxJQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZDLElBQUksT0FBTyxLQUFLLFNBQVMsSUFBSSxPQUFPLEtBQUssSUFBSSxFQUFFO1lBQzNDLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFDRCxPQUFPLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFZLENBQUM7SUFDOUMsQ0FBQztJQUVjLGdDQUFxQixHQUFwQyxVQUFxQyxJQUFzQjtRQUN2RCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQUMsSUFBSTtZQUMxQyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQzVDLElBQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNsRCxJQUFJLE9BQU8sSUFBSSxJQUFJLEVBQUU7Z0JBQ2pCLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDN0I7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFuS2EsZ0JBQUssR0FBVSxFQUFFLENBQUM7SUF3RWpCLG1CQUFRLEdBQUcsS0FBSyxDQUFDO0lBRWpCLHVCQUFZLEdBQWMsWUFBSSxDQUFDO0lBMEZsRCxpQkFBQztDQXJLRCxBQXFLQyxJQUFBO0FBcktZLGdDQUFVOzs7O0FDUHZCLDRDQUEyQztBQUMzQyw4Q0FBc0M7QUFDdEMscURBQXdEO0FBQ3hELHFCQUFHLENBQUMscUJBQXFCLGdCQUF1QixDQUFDO0FBQ2pEO0lBQUE7SUFrQ0EsQ0FBQztJQWpDZSxpQkFBSyxHQUFuQjtRQUNFLFdBQVcsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFRCxzQkFBa0IsbUJBQUk7YUFBdEI7WUFDRSxXQUFXLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQztZQUN6QixPQUFPLFdBQVcsQ0FBQyxNQUFNLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQztRQUNsRCxDQUFDOzs7T0FBQTtJQUVhLG1CQUFPLEdBQXJCLFVBQXNCLElBQWE7UUFDakMsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO0lBQ2pELENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDVyxzQkFBVSxHQUF4QixVQUF5QixJQUFzQjtRQUM3QyxZQUFDLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQUVEOztPQUVHO0lBQ1csa0NBQXNCLEdBQXBDO1FBQ0UsV0FBVyxDQUFDLFVBQVUsQ0FBQyxtQkFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFYyxtQkFBTyxHQUFHLENBQUMsQ0FBQztJQUNaLGtCQUFNLEdBQUcsa0JBQWtCLENBQUM7SUFDN0Msa0JBQUM7Q0FsQ0QsQUFrQ0MsSUFBQTtBQWxDWSxrQ0FBVzs7OztBQ0p4QixxREFBd0Q7QUFFeEQscUJBQUcsQ0FBQyxjQUFjLGdCQUF1QixDQUFDO0FBRTFDLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQztBQUVsQixJQUFJLFdBQWtDLENBQUM7QUFDdkMsSUFBSSxVQUFVLENBQUM7QUFDZixJQUFNLFlBQVksR0FBRyxJQUFJLE9BQU8sQ0FBQyxVQUFDLE9BQThCLEVBQUUsTUFBTTtJQUN0RSxXQUFXLEdBQUcsT0FBTyxDQUFDO0lBQ3RCLFVBQVUsR0FBRyxNQUFNLENBQUM7QUFDdEIsQ0FBQyxDQUFDLENBQUM7QUFFSCxRQUFRLENBQUMsZ0JBQWdCLENBQUMsa0JBQWtCLEVBQUU7SUFDNUMscUJBQUcsQ0FBQyxtQkFBbUIsbUJBQTBCLENBQUM7SUFDbEQsS0FBSyxHQUFHLElBQUksQ0FBQztJQUNiLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNwQixDQUFDLENBQUMsQ0FBQztBQUVILFNBQWdCLE9BQU87SUFDckIsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRkQsMEJBRUM7QUFDRCxTQUFnQixjQUFjO0lBQzVCLE9BQU8sS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUM7QUFDdEQsQ0FBQztBQUZELHdDQUVDOzs7O0FDeEJELG1EQUEyQztBQUUzQztJQW1CRSxtQkFBb0IsS0FBYztRQUFsQyxpQkFjQztRQWRtQixVQUFLLEdBQUwsS0FBSyxDQUFTO1FBQ2hDLFlBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFO1lBQ2pDO3dFQUM0RDtZQUM1RCxLQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFdEMsd0RBQXdEO1lBQ3hELElBQU0sS0FBSyxHQUFHLEtBQUksQ0FBQyxLQUFLLENBQUMsa0JBQWlDLENBQUM7WUFDM0QsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sS0FBSyxPQUFPLEVBQUU7Z0JBQ25DLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQzthQUM5QjtpQkFBTTtnQkFDTCxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7YUFDL0I7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFoQ2Esa0JBQVEsR0FBdEI7UUFDRSxTQUFTLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDdkIsSUFBTSxVQUFVLEdBQUcsWUFBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN2QyxLQUFLLElBQUksUUFBUSxHQUFHLENBQUMsRUFBRSxRQUFRLEdBQUcsVUFBVSxDQUFDLE1BQU0sRUFBRSxFQUFFLFFBQVEsRUFBRTtZQUMvRCxJQUFNLElBQUksR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3ZDLElBQUksSUFBSSxJQUFJLElBQUksRUFBRTtnQkFDaEIsU0FBUzthQUNWO1lBQ0QsU0FBUyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUNoRDtJQUNILENBQUM7SUFFYSxvQkFBVSxHQUF4QjtRQUNFLFNBQVMsQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDO0lBQzVCLENBQUM7SUFFYyxvQkFBVSxHQUFnQixFQUFFLENBQUM7SUFpQjlDLGdCQUFDO0NBbENELEFBa0NDLElBQUE7QUFsQ1ksOEJBQVM7Ozs7QUNGdEIsU0FBZ0IsV0FBVztJQUN6QixPQUFPLENBQUMsR0FBRyxDQUFDLHdCQUF3QixDQUFDLENBQUM7QUFDeEMsQ0FBQztBQUZELGtDQUVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRkQseURBQXVEO0FBQ3ZELHlDQUF3QztBQUN4QywrQ0FBNkM7QUFDN0MsK0NBQTJEO0FBQzNELHlDQUF3QztBQUV4QyxvR0FBb0c7QUFDcEcsU0FBZ0IsaURBQWlEO0lBQzdELHVGQUF1RjtJQUN2Riw4Q0FBOEM7SUFDOUMsMEJBQVcsRUFBRSxDQUFDO0FBQ2xCLENBQUM7QUFKRCw4R0FJQztBQUVELFNBQXNCLFFBQVE7Ozs7d0JBQzFCLHFCQUFNLElBQUksT0FBTyxDQUFDLFVBQUMsQ0FBTSxJQUFLLE9BQUEsVUFBVSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBbEIsQ0FBa0IsQ0FBQyxFQUFBOztvQkFBakQsU0FBaUQsQ0FBQztvQkFDbEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztvQkFDekIscUJBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztvQkFDckIscUJBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztvQkFDckIsaURBQWlELEVBQUUsQ0FBQztvQkFDcEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQzs7Ozs7Q0FDM0I7QUFQRCw0QkFPQztBQUVELDJCQUFZLENBQUMsT0FBTyxDQUFDLFVBQUMsSUFBaUI7SUFDbkMsd0JBQVUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDbEQsQ0FBQyxDQUFDLENBQUM7QUFDRixNQUFjLENBQUMsVUFBVSxHQUFHLHdCQUFVLENBQUM7QUFFeEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0FBQ2xDLDhGQUE4RjtBQUM5RixNQUFNLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxFQUFFLGNBQU0sT0FBQSxRQUFRLEVBQUUsRUFBVixDQUFVLENBQUMsQ0FBQzs7OztBQ3JCekQsd0RBQXdEO0FBQ3hELElBQUk7QUFDSixzQkFBc0I7QUFDdEIsOENBQThDO0FBQzlDLElBQUk7QUFFSixrSEFBa0g7QUFDbEgseUNBQXlDO0FBRXpDLDZHQUE2RztBQUM3RyxvR0FBb0c7QUFFdkYsUUFBQSxZQUFZLEdBQUc7SUFDeEIsMkdBQTJHO0lBQzNHO1FBQ0ksSUFBSSxFQUFFLFFBQVE7UUFDZCxPQUFPLEVBQUUsT0FBTyxDQUFDLG9CQUFvQixDQUFDO0tBQ3pDO0lBQ0Q7UUFDSSxJQUFJLEVBQUUsUUFBUTtRQUNkLE9BQU8sRUFBRSxPQUFPLENBQUMsb0JBQW9CLENBQUM7S0FDekM7SUFDRDtRQUNJLElBQUksRUFBRSxRQUFRO1FBQ2QsT0FBTyxFQUFFLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQztLQUN6QztDQUVKLENBQUM7O0FDbkNGO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOzs7O0FDREEsbURBQTJDO0FBRTNDO0lBd0JFLG1CQUFvQixLQUFjO1FBQWxDLGlCQWtCQztRQWxCbUIsVUFBSyxHQUFMLEtBQUssQ0FBUztRQUwxQixlQUFVLEdBQUcsQ0FBQyxDQUFDO1FBQ2YsZUFBVSxHQUFHLENBQUMsQ0FBQztRQUNmLFdBQU0sR0FBYyxFQUFFLENBQUM7UUFDdkIsU0FBSSxHQUFjLEVBQUUsQ0FBQztRQUczQixZQUFDLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsVUFBQyxJQUFJO1lBQzNCLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7WUFDN0IsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLHVCQUF1QixDQUFDLEVBQUU7Z0JBQzNDLFlBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFsQixDQUFrQixDQUFDLENBQUM7YUFDN0Q7aUJBQU0sSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLHVCQUF1QixDQUFDLEVBQUU7Z0JBQ2xELFlBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFqQixDQUFpQixDQUFDLENBQUM7YUFDNUQ7aUJBQU0sSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLEVBQUU7Z0JBQzVDLEtBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3hCO2lCQUFNLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsRUFBRTtnQkFDMUMsS0FBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDdEI7UUFDSCxDQUFDLENBQUMsQ0FBQztnQ0FDTSxDQUFDO1lBQ1IsWUFBQyxDQUFDLGdCQUFnQixDQUFDLE9BQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxjQUFNLE9BQUEsS0FBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBakIsQ0FBaUIsQ0FBQyxDQUFDOzs7UUFEckUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQztvQkFBaEMsQ0FBQztTQUVUO1FBQ0QsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUNyQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBekNhLGtCQUFRLEdBQXRCO1FBQ0UsU0FBUyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3ZCLElBQU0sVUFBVSxHQUFHLFlBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDdkMsS0FBSyxJQUFJLE9BQU8sR0FBRyxDQUFDLEVBQUUsT0FBTyxHQUFHLFVBQVUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxPQUFPLEVBQUU7WUFDNUQsSUFBTSxJQUFJLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN0QyxJQUFJLElBQUksSUFBSSxJQUFJLEVBQUU7Z0JBQ2hCLFNBQVM7YUFDVjtZQUNELFNBQVMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDaEQ7SUFDSCxDQUFDO0lBRWEsb0JBQVUsR0FBeEI7UUFDRSxTQUFTLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztJQUM1QixDQUFDO0lBNkJNLDZCQUFTLEdBQWhCLFVBQWlCLENBQVM7UUFDeEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBQ00sOEJBQVUsR0FBakIsVUFBa0IsQ0FBUztRQUN6QixJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFDTSw2QkFBUyxHQUFoQixVQUFpQixLQUFhO1FBQzVCLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7UUFDMUMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xFLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRTtZQUMxQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBaUIsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztTQUN4RDtRQUNELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDekM7UUFDQSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQWlCLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDdEUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBNUNjLG9CQUFVLEdBQWdCLEVBQUUsQ0FBQztJQTZDOUMsZ0JBQUM7Q0E5REQsQUE4REMsSUFBQTtBQTlEWSw4QkFBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0Z0QixnREFBK0M7QUFFL0MsbURBQTJDO0FBQzNDLG1EQUFrRDtBQUNsRCwrQ0FBOEM7QUFDOUMsb0RBQW1EO0FBQ25ELGtEQUEyRTtBQUMzRSxxREFBb0Q7QUFFcEQsMkRBQXlEO0FBQ3pELDZEQUEyRDtBQUMzRCwrQ0FBdUQ7QUFHdkQsSUFBTSxLQUFLLEdBQUc7OztvQkFDVixxQkFBTSxzQkFBYyxFQUFFLEVBQUE7O2dCQUF0QixTQUFzQixDQUFDO2dCQUN2QiwyRUFBMkU7Z0JBQzNFLHVFQUF1RTtnQkFDdkUscURBQXFEO2dCQUNyRCx5RUFBeUU7Z0JBQ3pFLGNBQWM7Z0JBQ2QsSUFBSTtnQkFDSixrQ0FBa0M7Z0JBQ2xDLGlCQUFPLENBQUMsS0FBSyxDQUFDO29CQUNWLFNBQVMsRUFBRSxzQkFBc0I7b0JBQ2pDLFVBQVUsRUFBRSxhQUFhO29CQUN6QixlQUFlLEVBQUU7d0JBQ2IsS0FBSyxFQUFMOzRCQUNJLElBQUk7Z0NBQ0EsSUFBTSxRQUFRLEdBQUcsWUFBQyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQXdCLENBQUM7Z0NBQzFELE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dDQUM1QixJQUFJLFFBQVEsQ0FBQyxLQUFLLEtBQUssRUFBRSxFQUFFO29DQUN2QixPQUFPLHFEQUFxRCxDQUFDO2lDQUNoRTtxQ0FBTTtvQ0FDSCxPQUFPLElBQUksQ0FBQztpQ0FDZjs2QkFDSjs0QkFBQyxPQUFPLEtBQUssRUFBRTtnQ0FDWixPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dDQUNuQixPQUFPLHFEQUFxRCxDQUFDOzZCQUNoRTt3QkFDTCxDQUFDO3dCQUNELFNBQVMsRUFBVDs0QkFDSSxXQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsR0FBSSxZQUFDLENBQUMsRUFBRSxDQUN0QixXQUFXLENBQ1UsQ0FBQyxLQUFLLENBQUM7NEJBQ2hDLE9BQU87d0JBQ1gsQ0FBQztxQkFDSjtvQkFFRCxVQUFVLGNBQXFCO29CQUV6QixLQUFLLEVBQVg7Ozs7Ozt3Q0FDSSxtQkFBbUI7d0NBQ25CLGVBQU0sQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO3dDQUM3QixlQUFNLENBQUMsU0FBUyxDQUNaOzRDQUNJO2dEQUNJLElBQUksNkJBQWdDO2dEQUNwQyxNQUFNLGFBQWdCOzZDQUN6Qjs0Q0FDRCxFQUFFLElBQUksYUFBZ0IsRUFBRSxNQUFNLG1CQUFtQixFQUFFOzRDQUNuRDtnREFDSSxJQUFJLDZCQUFnQztnREFDcEMsTUFBTSxpQkFBa0I7NkNBQzNCO3lDQUNKLEVBQ0QsU0FBUyxDQUNaLENBQUM7d0NBQ0YsaUJBQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQzt3Q0FDdkQsdUNBQXVDO3dDQUN2Qyx3QkFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDO3dDQUNwQix3QkFBVSxDQUFDLG9CQUFvQixDQUFDOzRDQUM1QiwwQkFBVyxDQUFDLEtBQUssRUFBRSxDQUFDOzRDQUNwQiwwQkFBVyxDQUFDLHNCQUFzQixFQUFFLENBQUM7NENBQ3JDLGVBQU0sQ0FBQyxLQUFLLENBQUMsbUJBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQzs0Q0FDL0IsZUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQzt3Q0FDdEIsQ0FBQyxDQUFDLENBQUM7d0NBQ0gsa0NBQWtDO3dDQUNsQyxZQUFDLENBQUMsZ0JBQWdCLENBQUMsbUJBQVEsQ0FBQyxPQUFPLHVCQUFvQixVQUFDLENBQUM7NENBQ3JELElBQU0sRUFBRSxHQUFHLENBQWUsQ0FBQzs0Q0FDM0IsSUFBTSxHQUFHLEdBQUc7Z0RBQ1IsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxPQUFPO2dEQUNiLENBQUMsRUFBRSxFQUFFLENBQUMsT0FBTztnREFDYixFQUFFLEVBQUcsRUFBRSxDQUFDLE1BQXNCLENBQUMsRUFBRTs2Q0FDcEMsQ0FBQzs0Q0FDRixpQkFBTyxDQUFDLG9CQUFvQixxQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQzt3Q0FDeEQsQ0FBQyxDQUFDLENBQUM7d0NBQ0gsWUFBQyxDQUFDLGdCQUFnQixDQUFDLG1CQUFRLENBQUMsUUFBUSxFQUFFLFVBQVUsRUFBRSxVQUFDLENBQUM7NENBQ2hELElBQU0sRUFBRSxHQUFHLENBQWtCLENBQUM7NENBQzlCLElBQU0sR0FBRyxHQUFHO2dEQUNSLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRztnREFDWCxFQUFFLEVBQUcsRUFBRSxDQUFDLFVBQTBCLENBQUMsRUFBRTs2Q0FDeEMsQ0FBQzs0Q0FDRixpQkFBTyxDQUFDLG9CQUFvQix1QkFBbUIsQ0FBQyxHQUFHLENBQUMsQ0FBQzt3Q0FDekQsQ0FBQyxDQUFDLENBQUM7d0NBRUcsS0FBSyxHQUFHLFFBQVEsQ0FBQyxnQkFBMkIsQ0FBQzt3Q0FDbkQsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxVQUFDLENBQUM7NENBQ2xDLElBQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUM7NENBQzVCLElBQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUM7NENBQzNCLElBQU0sS0FBSyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7NENBQ25DLElBQ0ksSUFBSSxDQUFDLEdBQUcsQ0FBQyxpQkFBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsRUFBRTtnREFDckMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGlCQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFO29EQUNsQyxLQUFLLEdBQUcsaUJBQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUN6QztnREFDRSxpQkFBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dEQUN2QixpQkFBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dEQUN2QixpQkFBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDO2dEQUM3QixJQUFNLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDO2dEQUM3QixpQkFBTyxDQUFDLG9CQUFvQix1QkFBbUIsQ0FBQyxHQUFHLENBQUMsQ0FBQzs2Q0FDeEQ7d0NBQ0wsQ0FBQyxDQUFDLENBQUM7d0NBQ0gsMkJBQTJCO3dDQUMzQixpQkFBTyxDQUFDLGFBQWEseUJBQW9CLENBQUM7d0NBQzFDLGlCQUFPLENBQUMsYUFBYSx1QkFBbUIsQ0FBQzt3Q0FDekMsaUJBQU8sQ0FBQyxhQUFhLHFCQUFrQixDQUFDO3dDQUN4QyxpQkFBTyxDQUFDLGFBQWEsdUJBQW1CLENBQUM7d0NBQ3pDLGtCQUFrQjt3Q0FDbEIscUJBQU0sZUFBTSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxFQUFBOzt3Q0FEdEMsa0JBQWtCO3dDQUNsQixTQUFzQyxDQUFDOzs7OztxQkFDMUM7aUJBQ0osQ0FBQyxDQUFDOzs7O0tBQ04sQ0FBQztBQUVGLEtBQUssRUFBRSxDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcInZlcnNpb25cIjogXCIyLjBcIixcbiAgXCJtZXRhZGF0YVwiOiB7XG4gICAgXCJhcGlWZXJzaW9uXCI6IFwiMjAxNC0wNi0zMFwiLFxuICAgIFwiZW5kcG9pbnRQcmVmaXhcIjogXCJjb2duaXRvLWlkZW50aXR5XCIsXG4gICAgXCJqc29uVmVyc2lvblwiOiBcIjEuMVwiLFxuICAgIFwicHJvdG9jb2xcIjogXCJqc29uXCIsXG4gICAgXCJzZXJ2aWNlRnVsbE5hbWVcIjogXCJBbWF6b24gQ29nbml0byBJZGVudGl0eVwiLFxuICAgIFwic2VydmljZUlkXCI6IFwiQ29nbml0byBJZGVudGl0eVwiLFxuICAgIFwic2lnbmF0dXJlVmVyc2lvblwiOiBcInY0XCIsXG4gICAgXCJ0YXJnZXRQcmVmaXhcIjogXCJBV1NDb2duaXRvSWRlbnRpdHlTZXJ2aWNlXCIsXG4gICAgXCJ1aWRcIjogXCJjb2duaXRvLWlkZW50aXR5LTIwMTQtMDYtMzBcIlxuICB9LFxuICBcIm9wZXJhdGlvbnNcIjoge1xuICAgIFwiQ3JlYXRlSWRlbnRpdHlQb29sXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xOYW1lXCIsXG4gICAgICAgICAgXCJBbGxvd1VuYXV0aGVudGljYXRlZElkZW50aXRpZXNcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sTmFtZVwiOiB7fSxcbiAgICAgICAgICBcIkFsbG93VW5hdXRoZW50aWNhdGVkSWRlbnRpdGllc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQWxsb3dDbGFzc2ljRmxvd1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3VwcG9ydGVkTG9naW5Qcm92aWRlcnNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRGV2ZWxvcGVyUHJvdmlkZXJOYW1lXCI6IHt9LFxuICAgICAgICAgIFwiT3BlbklkQ29ubmVjdFByb3ZpZGVyQVJOc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb2duaXRvSWRlbnRpdHlQcm92aWRlcnNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNiXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU2FtbFByb3ZpZGVyQVJOc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2dcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xUYWdzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTaFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInNoYXBlXCI6IFwiU2tcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWxldGVJZGVudGl0aWVzXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eUlkc1RvRGVsZXRlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5SWRzVG9EZWxldGVcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge31cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiVW5wcm9jZXNzZWRJZGVudGl0eUlkc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiSWRlbnRpdHlJZFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIkVycm9yQ29kZVwiOiB7fVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkRlbGV0ZUlkZW50aXR5UG9vbFwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZXNjcmliZUlkZW50aXR5XCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eUlkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIjoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJzaGFwZVwiOiBcIlN2XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVzY3JpYmVJZGVudGl0eVBvb2xcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwic2hhcGVcIjogXCJTa1wiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHlcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiOiB7fSxcbiAgICAgICAgICBcIkxvZ2luc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzEwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ3VzdG9tUm9sZUFyblwiOiB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIjoge30sXG4gICAgICAgICAgXCJDcmVkZW50aWFsc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiQWNjZXNzS2V5SWRcIjoge30sXG4gICAgICAgICAgICAgIFwiU2VjcmV0S2V5XCI6IHt9LFxuICAgICAgICAgICAgICBcIlNlc3Npb25Ub2tlblwiOiB7fSxcbiAgICAgICAgICAgICAgXCJFeHBpcmF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldElkXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJBY2NvdW50SWRcIjoge30sXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiOiB7fSxcbiAgICAgICAgICBcIkxvZ2luc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzEwXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldElkZW50aXR5UG9vbFJvbGVzXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiOiB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCI6IHt9LFxuICAgICAgICAgIFwiUm9sZXNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxY1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJvbGVNYXBwaW5nc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0T3BlbklkVG9rZW5cIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiOiB7fSxcbiAgICAgICAgICBcIkxvZ2luc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzEwXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiOiB7fSxcbiAgICAgICAgICBcIlRva2VuXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0T3BlbklkVG9rZW5Gb3JEZXZlbG9wZXJJZGVudGl0eVwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIixcbiAgICAgICAgICBcIkxvZ2luc1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiOiB7fSxcbiAgICAgICAgICBcIklkZW50aXR5SWRcIjoge30sXG4gICAgICAgICAgXCJMb2dpbnNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxMFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlRva2VuRHVyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIjoge30sXG4gICAgICAgICAgXCJUb2tlblwiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkxpc3RJZGVudGl0aWVzXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiLFxuICAgICAgICAgIFwiTWF4UmVzdWx0c1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiOiB7fSxcbiAgICAgICAgICBcIk1heFJlc3VsdHNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk5leHRUb2tlblwiOiB7fSxcbiAgICAgICAgICBcIkhpZGVEaXNhYmxlZFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIjoge30sXG4gICAgICAgICAgXCJJZGVudGl0aWVzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlN2XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTmV4dFRva2VuXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiTGlzdElkZW50aXR5UG9vbHNcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIk1heFJlc3VsdHNcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiTWF4UmVzdWx0c1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTmV4dFRva2VuXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIjoge30sXG4gICAgICAgICAgICAgICAgXCJJZGVudGl0eVBvb2xOYW1lXCI6IHt9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTmV4dFRva2VuXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiTGlzdFRhZ3NGb3JSZXNvdXJjZVwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiUmVzb3VyY2VBcm5cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUmVzb3VyY2VBcm5cIjoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJUYWdzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTaFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkxvb2t1cERldmVsb3BlcklkZW50aXR5XCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiOiB7fSxcbiAgICAgICAgICBcIklkZW50aXR5SWRcIjoge30sXG4gICAgICAgICAgXCJEZXZlbG9wZXJVc2VySWRlbnRpZmllclwiOiB7fSxcbiAgICAgICAgICBcIk1heFJlc3VsdHNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk5leHRUb2tlblwiOiB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIjoge30sXG4gICAgICAgICAgXCJEZXZlbG9wZXJVc2VySWRlbnRpZmllckxpc3RcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTmV4dFRva2VuXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiTWVyZ2VEZXZlbG9wZXJJZGVudGl0aWVzXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJTb3VyY2VVc2VySWRlbnRpZmllclwiLFxuICAgICAgICAgIFwiRGVzdGluYXRpb25Vc2VySWRlbnRpZmllclwiLFxuICAgICAgICAgIFwiRGV2ZWxvcGVyUHJvdmlkZXJOYW1lXCIsXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJTb3VyY2VVc2VySWRlbnRpZmllclwiOiB7fSxcbiAgICAgICAgICBcIkRlc3RpbmF0aW9uVXNlcklkZW50aWZpZXJcIjoge30sXG4gICAgICAgICAgXCJEZXZlbG9wZXJQcm92aWRlck5hbWVcIjoge30sXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiOiB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTZXRJZGVudGl0eVBvb2xSb2xlc1wiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIixcbiAgICAgICAgICBcIlJvbGVzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCI6IHt9LFxuICAgICAgICAgIFwiUm9sZXNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxY1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJvbGVNYXBwaW5nc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiVGFnUmVzb3VyY2VcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIlJlc291cmNlQXJuXCIsXG4gICAgICAgICAgXCJUYWdzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlJlc291cmNlQXJuXCI6IHt9LFxuICAgICAgICAgIFwiVGFnc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2hcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJVbmxpbmtEZXZlbG9wZXJJZGVudGl0eVwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiLFxuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIixcbiAgICAgICAgICBcIkRldmVsb3BlclByb3ZpZGVyTmFtZVwiLFxuICAgICAgICAgIFwiRGV2ZWxvcGVyVXNlcklkZW50aWZpZXJcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiOiB7fSxcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCI6IHt9LFxuICAgICAgICAgIFwiRGV2ZWxvcGVyUHJvdmlkZXJOYW1lXCI6IHt9LFxuICAgICAgICAgIFwiRGV2ZWxvcGVyVXNlcklkZW50aWZpZXJcIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJVbmxpbmtJZGVudGl0eVwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiLFxuICAgICAgICAgIFwiTG9naW5zXCIsXG4gICAgICAgICAgXCJMb2dpbnNUb1JlbW92ZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eUlkXCI6IHt9LFxuICAgICAgICAgIFwiTG9naW5zXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMTBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJMb2dpbnNUb1JlbW92ZVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU3dcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJVbnRhZ1Jlc291cmNlXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJSZXNvdXJjZUFyblwiLFxuICAgICAgICAgIFwiVGFnS2V5c1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSZXNvdXJjZUFyblwiOiB7fSxcbiAgICAgICAgICBcIlRhZ0tleXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge31cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiVXBkYXRlSWRlbnRpdHlQb29sXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInNoYXBlXCI6IFwiU2tcIlxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJzaGFwZVwiOiBcIlNrXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwic2hhcGVzXCI6IHtcbiAgICBcIlM1XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm1hcFwiLFxuICAgICAgXCJrZXlcIjoge30sXG4gICAgICBcInZhbHVlXCI6IHt9XG4gICAgfSxcbiAgICBcIlM5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgIFwibWVtYmVyXCI6IHt9XG4gICAgfSxcbiAgICBcIlNiXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJQcm92aWRlck5hbWVcIjoge30sXG4gICAgICAgICAgXCJDbGllbnRJZFwiOiB7fSxcbiAgICAgICAgICBcIlNlcnZlclNpZGVUb2tlbkNoZWNrXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTZ1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICBcIm1lbWJlclwiOiB7fVxuICAgIH0sXG4gICAgXCJTaFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJtYXBcIixcbiAgICAgIFwia2V5XCI6IHt9LFxuICAgICAgXCJ2YWx1ZVwiOiB7fVxuICAgIH0sXG4gICAgXCJTa1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICBcIklkZW50aXR5UG9vbElkXCIsXG4gICAgICAgIFwiSWRlbnRpdHlQb29sTmFtZVwiLFxuICAgICAgICBcIkFsbG93VW5hdXRoZW50aWNhdGVkSWRlbnRpdGllc1wiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiOiB7fSxcbiAgICAgICAgXCJJZGVudGl0eVBvb2xOYW1lXCI6IHt9LFxuICAgICAgICBcIkFsbG93VW5hdXRoZW50aWNhdGVkSWRlbnRpdGllc1wiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiQWxsb3dDbGFzc2ljRmxvd1wiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiU3VwcG9ydGVkTG9naW5Qcm92aWRlcnNcIjoge1xuICAgICAgICAgIFwic2hhcGVcIjogXCJTNVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiRGV2ZWxvcGVyUHJvdmlkZXJOYW1lXCI6IHt9LFxuICAgICAgICBcIk9wZW5JZENvbm5lY3RQcm92aWRlckFSTnNcIjoge1xuICAgICAgICAgIFwic2hhcGVcIjogXCJTOVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiQ29nbml0b0lkZW50aXR5UHJvdmlkZXJzXCI6IHtcbiAgICAgICAgICBcInNoYXBlXCI6IFwiU2JcIlxuICAgICAgICB9LFxuICAgICAgICBcIlNhbWxQcm92aWRlckFSTnNcIjoge1xuICAgICAgICAgIFwic2hhcGVcIjogXCJTZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiSWRlbnRpdHlQb29sVGFnc1wiOiB7XG4gICAgICAgICAgXCJzaGFwZVwiOiBcIlNoXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTdlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiSWRlbnRpdHlJZFwiOiB7fSxcbiAgICAgICAgXCJMb2dpbnNcIjoge1xuICAgICAgICAgIFwic2hhcGVcIjogXCJTd1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiQ3JlYXRpb25EYXRlXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICB9LFxuICAgICAgICBcIkxhc3RNb2RpZmllZERhdGVcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiU3dcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgXCJtZW1iZXJcIjoge31cbiAgICB9LFxuICAgIFwiUzEwXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm1hcFwiLFxuICAgICAgXCJrZXlcIjoge30sXG4gICAgICBcInZhbHVlXCI6IHt9XG4gICAgfSxcbiAgICBcIlMxY1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJtYXBcIixcbiAgICAgIFwia2V5XCI6IHt9LFxuICAgICAgXCJ2YWx1ZVwiOiB7fVxuICAgIH0sXG4gICAgXCJTMWVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibWFwXCIsXG4gICAgICBcImtleVwiOiB7fSxcbiAgICAgIFwidmFsdWVcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJUeXBlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlR5cGVcIjoge30sXG4gICAgICAgICAgXCJBbWJpZ3VvdXNSb2xlUmVzb2x1dGlvblwiOiB7fSxcbiAgICAgICAgICBcIlJ1bGVzQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICBcIlJ1bGVzXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIlJ1bGVzXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJDbGFpbVwiLFxuICAgICAgICAgICAgICAgICAgICBcIk1hdGNoVHlwZVwiLFxuICAgICAgICAgICAgICAgICAgICBcIlZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiUm9sZUFSTlwiXG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJDbGFpbVwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgXCJNYXRjaFR5cGVcIjoge30sXG4gICAgICAgICAgICAgICAgICAgIFwiVmFsdWVcIjoge30sXG4gICAgICAgICAgICAgICAgICAgIFwiUm9sZUFSTlwiOiB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJwYWdpbmF0aW9uXCI6IHtcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcImFjbVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQUNNXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJhcGlnYXRld2F5XCI6IHtcbiAgICBcIm5hbWVcIjogXCJBUElHYXRld2F5XCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJhcHBsaWNhdGlvbmF1dG9zY2FsaW5nXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImFwcGxpY2F0aW9uLWF1dG9zY2FsaW5nXCIsXG4gICAgXCJuYW1lXCI6IFwiQXBwbGljYXRpb25BdXRvU2NhbGluZ1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiYXBwc3RyZWFtXCI6IHtcbiAgICBcIm5hbWVcIjogXCJBcHBTdHJlYW1cIlxuICB9LFxuICBcImF1dG9zY2FsaW5nXCI6IHtcbiAgICBcIm5hbWVcIjogXCJBdXRvU2NhbGluZ1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiYmF0Y2hcIjoge1xuICAgIFwibmFtZVwiOiBcIkJhdGNoXCJcbiAgfSxcbiAgXCJidWRnZXRzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJCdWRnZXRzXCJcbiAgfSxcbiAgXCJjbG91ZGRpcmVjdG9yeVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ2xvdWREaXJlY3RvcnlcIixcbiAgICBcInZlcnNpb25zXCI6IFtcbiAgICAgIFwiMjAxNi0wNS0xMCpcIlxuICAgIF1cbiAgfSxcbiAgXCJjbG91ZGZvcm1hdGlvblwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ2xvdWRGb3JtYXRpb25cIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImNsb3VkZnJvbnRcIjoge1xuICAgIFwibmFtZVwiOiBcIkNsb3VkRnJvbnRcIixcbiAgICBcInZlcnNpb25zXCI6IFtcbiAgICAgIFwiMjAxMy0wNS0xMipcIixcbiAgICAgIFwiMjAxMy0xMS0xMSpcIixcbiAgICAgIFwiMjAxNC0wNS0zMSpcIixcbiAgICAgIFwiMjAxNC0xMC0yMSpcIixcbiAgICAgIFwiMjAxNC0xMS0wNipcIixcbiAgICAgIFwiMjAxNS0wNC0xNypcIixcbiAgICAgIFwiMjAxNS0wNy0yNypcIixcbiAgICAgIFwiMjAxNS0wOS0xNypcIixcbiAgICAgIFwiMjAxNi0wMS0xMypcIixcbiAgICAgIFwiMjAxNi0wMS0yOCpcIixcbiAgICAgIFwiMjAxNi0wOC0wMSpcIixcbiAgICAgIFwiMjAxNi0wOC0yMCpcIixcbiAgICAgIFwiMjAxNi0wOS0wNypcIixcbiAgICAgIFwiMjAxNi0wOS0yOSpcIixcbiAgICAgIFwiMjAxNi0xMS0yNSpcIixcbiAgICAgIFwiMjAxNy0wMy0yNSpcIixcbiAgICAgIFwiMjAxNy0xMC0zMCpcIixcbiAgICAgIFwiMjAxOC0wNi0xOCpcIixcbiAgICAgIFwiMjAxOC0xMS0wNSpcIlxuICAgIF0sXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJjbG91ZGhzbVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ2xvdWRIU01cIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImNsb3Vkc2VhcmNoXCI6IHtcbiAgICBcIm5hbWVcIjogXCJDbG91ZFNlYXJjaFwiXG4gIH0sXG4gIFwiY2xvdWRzZWFyY2hkb21haW5cIjoge1xuICAgIFwibmFtZVwiOiBcIkNsb3VkU2VhcmNoRG9tYWluXCJcbiAgfSxcbiAgXCJjbG91ZHRyYWlsXCI6IHtcbiAgICBcIm5hbWVcIjogXCJDbG91ZFRyYWlsXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJjbG91ZHdhdGNoXCI6IHtcbiAgICBcInByZWZpeFwiOiBcIm1vbml0b3JpbmdcIixcbiAgICBcIm5hbWVcIjogXCJDbG91ZFdhdGNoXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJjbG91ZHdhdGNoZXZlbnRzXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImV2ZW50c1wiLFxuICAgIFwibmFtZVwiOiBcIkNsb3VkV2F0Y2hFdmVudHNcIixcbiAgICBcInZlcnNpb25zXCI6IFtcbiAgICAgIFwiMjAxNC0wMi0wMypcIlxuICAgIF0sXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJjbG91ZHdhdGNobG9nc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJsb2dzXCIsXG4gICAgXCJuYW1lXCI6IFwiQ2xvdWRXYXRjaExvZ3NcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImNvZGVidWlsZFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ29kZUJ1aWxkXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJjb2RlY29tbWl0XCI6IHtcbiAgICBcIm5hbWVcIjogXCJDb2RlQ29tbWl0XCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJjb2RlZGVwbG95XCI6IHtcbiAgICBcIm5hbWVcIjogXCJDb2RlRGVwbG95XCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJjb2RlcGlwZWxpbmVcIjoge1xuICAgIFwibmFtZVwiOiBcIkNvZGVQaXBlbGluZVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiY29nbml0b2lkZW50aXR5XCI6IHtcbiAgICBcInByZWZpeFwiOiBcImNvZ25pdG8taWRlbnRpdHlcIixcbiAgICBcIm5hbWVcIjogXCJDb2duaXRvSWRlbnRpdHlcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImNvZ25pdG9pZGVudGl0eXNlcnZpY2Vwcm92aWRlclwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJjb2duaXRvLWlkcFwiLFxuICAgIFwibmFtZVwiOiBcIkNvZ25pdG9JZGVudGl0eVNlcnZpY2VQcm92aWRlclwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiY29nbml0b3N5bmNcIjoge1xuICAgIFwicHJlZml4XCI6IFwiY29nbml0by1zeW5jXCIsXG4gICAgXCJuYW1lXCI6IFwiQ29nbml0b1N5bmNcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImNvbmZpZ3NlcnZpY2VcIjoge1xuICAgIFwicHJlZml4XCI6IFwiY29uZmlnXCIsXG4gICAgXCJuYW1lXCI6IFwiQ29uZmlnU2VydmljZVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiY3VyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJDVVJcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImRhdGFwaXBlbGluZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRGF0YVBpcGVsaW5lXCJcbiAgfSxcbiAgXCJkZXZpY2VmYXJtXCI6IHtcbiAgICBcIm5hbWVcIjogXCJEZXZpY2VGYXJtXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJkaXJlY3Rjb25uZWN0XCI6IHtcbiAgICBcIm5hbWVcIjogXCJEaXJlY3RDb25uZWN0XCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJkaXJlY3RvcnlzZXJ2aWNlXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImRzXCIsXG4gICAgXCJuYW1lXCI6IFwiRGlyZWN0b3J5U2VydmljZVwiXG4gIH0sXG4gIFwiZGlzY292ZXJ5XCI6IHtcbiAgICBcIm5hbWVcIjogXCJEaXNjb3ZlcnlcIlxuICB9LFxuICBcImRtc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiRE1TXCJcbiAgfSxcbiAgXCJkeW5hbW9kYlwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRHluYW1vREJcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImR5bmFtb2Ric3RyZWFtc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJzdHJlYW1zLmR5bmFtb2RiXCIsXG4gICAgXCJuYW1lXCI6IFwiRHluYW1vREJTdHJlYW1zXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJlYzJcIjoge1xuICAgIFwibmFtZVwiOiBcIkVDMlwiLFxuICAgIFwidmVyc2lvbnNcIjogW1xuICAgICAgXCIyMDEzLTA2LTE1KlwiLFxuICAgICAgXCIyMDEzLTEwLTE1KlwiLFxuICAgICAgXCIyMDE0LTAyLTAxKlwiLFxuICAgICAgXCIyMDE0LTA1LTAxKlwiLFxuICAgICAgXCIyMDE0LTA2LTE1KlwiLFxuICAgICAgXCIyMDE0LTA5LTAxKlwiLFxuICAgICAgXCIyMDE0LTEwLTAxKlwiLFxuICAgICAgXCIyMDE1LTAzLTAxKlwiLFxuICAgICAgXCIyMDE1LTA0LTE1KlwiLFxuICAgICAgXCIyMDE1LTEwLTAxKlwiLFxuICAgICAgXCIyMDE2LTA0LTAxKlwiLFxuICAgICAgXCIyMDE2LTA5LTE1KlwiXG4gICAgXSxcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImVjclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRUNSXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJlY3NcIjoge1xuICAgIFwibmFtZVwiOiBcIkVDU1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZWZzXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImVsYXN0aWNmaWxlc3lzdGVtXCIsXG4gICAgXCJuYW1lXCI6IFwiRUZTXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJlbGFzdGljYWNoZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRWxhc3RpQ2FjaGVcIixcbiAgICBcInZlcnNpb25zXCI6IFtcbiAgICAgIFwiMjAxMi0xMS0xNSpcIixcbiAgICAgIFwiMjAxNC0wMy0yNCpcIixcbiAgICAgIFwiMjAxNC0wNy0xNSpcIixcbiAgICAgIFwiMjAxNC0wOS0zMCpcIlxuICAgIF0sXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJlbGFzdGljYmVhbnN0YWxrXCI6IHtcbiAgICBcIm5hbWVcIjogXCJFbGFzdGljQmVhbnN0YWxrXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJlbGJcIjoge1xuICAgIFwicHJlZml4XCI6IFwiZWxhc3RpY2xvYWRiYWxhbmNpbmdcIixcbiAgICBcIm5hbWVcIjogXCJFTEJcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImVsYnYyXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImVsYXN0aWNsb2FkYmFsYW5jaW5ndjJcIixcbiAgICBcIm5hbWVcIjogXCJFTEJ2MlwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZW1yXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImVsYXN0aWNtYXByZWR1Y2VcIixcbiAgICBcIm5hbWVcIjogXCJFTVJcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImVzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJFU1wiXG4gIH0sXG4gIFwiZWxhc3RpY3RyYW5zY29kZXJcIjoge1xuICAgIFwibmFtZVwiOiBcIkVsYXN0aWNUcmFuc2NvZGVyXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJmaXJlaG9zZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRmlyZWhvc2VcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImdhbWVsaWZ0XCI6IHtcbiAgICBcIm5hbWVcIjogXCJHYW1lTGlmdFwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZ2xhY2llclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiR2xhY2llclwiXG4gIH0sXG4gIFwiaGVhbHRoXCI6IHtcbiAgICBcIm5hbWVcIjogXCJIZWFsdGhcIlxuICB9LFxuICBcImlhbVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiSUFNXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJpbXBvcnRleHBvcnRcIjoge1xuICAgIFwibmFtZVwiOiBcIkltcG9ydEV4cG9ydFwiXG4gIH0sXG4gIFwiaW5zcGVjdG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJJbnNwZWN0b3JcIixcbiAgICBcInZlcnNpb25zXCI6IFtcbiAgICAgIFwiMjAxNS0wOC0xOCpcIlxuICAgIF0sXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJpb3RcIjoge1xuICAgIFwibmFtZVwiOiBcIklvdFwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiaW90ZGF0YVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJpb3QtZGF0YVwiLFxuICAgIFwibmFtZVwiOiBcIklvdERhdGFcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImtpbmVzaXNcIjoge1xuICAgIFwibmFtZVwiOiBcIktpbmVzaXNcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImtpbmVzaXNhbmFseXRpY3NcIjoge1xuICAgIFwibmFtZVwiOiBcIktpbmVzaXNBbmFseXRpY3NcIlxuICB9LFxuICBcImttc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiS01TXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJsYW1iZGFcIjoge1xuICAgIFwibmFtZVwiOiBcIkxhbWJkYVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwibGV4cnVudGltZVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJydW50aW1lLmxleFwiLFxuICAgIFwibmFtZVwiOiBcIkxleFJ1bnRpbWVcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImxpZ2h0c2FpbFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTGlnaHRzYWlsXCJcbiAgfSxcbiAgXCJtYWNoaW5lbGVhcm5pbmdcIjoge1xuICAgIFwibmFtZVwiOiBcIk1hY2hpbmVMZWFybmluZ1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwibWFya2V0cGxhY2Vjb21tZXJjZWFuYWx5dGljc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiTWFya2V0cGxhY2VDb21tZXJjZUFuYWx5dGljc1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwibWFya2V0cGxhY2VtZXRlcmluZ1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJtZXRlcmluZ21hcmtldHBsYWNlXCIsXG4gICAgXCJuYW1lXCI6IFwiTWFya2V0cGxhY2VNZXRlcmluZ1wiXG4gIH0sXG4gIFwibXR1cmtcIjoge1xuICAgIFwicHJlZml4XCI6IFwibXR1cmstcmVxdWVzdGVyXCIsXG4gICAgXCJuYW1lXCI6IFwiTVR1cmtcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcIm1vYmlsZWFuYWx5dGljc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiTW9iaWxlQW5hbHl0aWNzXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJvcHN3b3Jrc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiT3BzV29ya3NcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcIm9wc3dvcmtzY21cIjoge1xuICAgIFwibmFtZVwiOiBcIk9wc1dvcmtzQ01cIlxuICB9LFxuICBcIm9yZ2FuaXphdGlvbnNcIjoge1xuICAgIFwibmFtZVwiOiBcIk9yZ2FuaXphdGlvbnNcIlxuICB9LFxuICBcInBpbnBvaW50XCI6IHtcbiAgICBcIm5hbWVcIjogXCJQaW5wb2ludFwiXG4gIH0sXG4gIFwicG9sbHlcIjoge1xuICAgIFwibmFtZVwiOiBcIlBvbGx5XCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJyZHNcIjoge1xuICAgIFwibmFtZVwiOiBcIlJEU1wiLFxuICAgIFwidmVyc2lvbnNcIjogW1xuICAgICAgXCIyMDE0LTA5LTAxKlwiXG4gICAgXSxcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInJlZHNoaWZ0XCI6IHtcbiAgICBcIm5hbWVcIjogXCJSZWRzaGlmdFwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwicmVrb2duaXRpb25cIjoge1xuICAgIFwibmFtZVwiOiBcIlJla29nbml0aW9uXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJyZXNvdXJjZWdyb3Vwc3RhZ2dpbmdhcGlcIjoge1xuICAgIFwibmFtZVwiOiBcIlJlc291cmNlR3JvdXBzVGFnZ2luZ0FQSVwiXG4gIH0sXG4gIFwicm91dGU1M1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiUm91dGU1M1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwicm91dGU1M2RvbWFpbnNcIjoge1xuICAgIFwibmFtZVwiOiBcIlJvdXRlNTNEb21haW5zXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJzM1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiUzNcIixcbiAgICBcImR1YWxzdGFja0F2YWlsYWJsZVwiOiB0cnVlLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiczNjb250cm9sXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTM0NvbnRyb2xcIixcbiAgICBcImR1YWxzdGFja0F2YWlsYWJsZVwiOiB0cnVlXG4gIH0sXG4gIFwic2VydmljZWNhdGFsb2dcIjoge1xuICAgIFwibmFtZVwiOiBcIlNlcnZpY2VDYXRhbG9nXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJzZXNcIjoge1xuICAgIFwicHJlZml4XCI6IFwiZW1haWxcIixcbiAgICBcIm5hbWVcIjogXCJTRVNcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInNoaWVsZFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiU2hpZWxkXCJcbiAgfSxcbiAgXCJzaW1wbGVkYlwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJzZGJcIixcbiAgICBcIm5hbWVcIjogXCJTaW1wbGVEQlwiXG4gIH0sXG4gIFwic21zXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTTVNcIlxuICB9LFxuICBcInNub3diYWxsXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTbm93YmFsbFwiXG4gIH0sXG4gIFwic25zXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTTlNcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInNxc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiU1FTXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJzc21cIjoge1xuICAgIFwibmFtZVwiOiBcIlNTTVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwic3RvcmFnZWdhdGV3YXlcIjoge1xuICAgIFwibmFtZVwiOiBcIlN0b3JhZ2VHYXRld2F5XCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJzdGVwZnVuY3Rpb25zXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInN0YXRlc1wiLFxuICAgIFwibmFtZVwiOiBcIlN0ZXBGdW5jdGlvbnNcIlxuICB9LFxuICBcInN0c1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiU1RTXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJzdXBwb3J0XCI6IHtcbiAgICBcIm5hbWVcIjogXCJTdXBwb3J0XCJcbiAgfSxcbiAgXCJzd2ZcIjoge1xuICAgIFwibmFtZVwiOiBcIlNXRlwiXG4gIH0sXG4gIFwieHJheVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiWFJheVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwid2FmXCI6IHtcbiAgICBcIm5hbWVcIjogXCJXQUZcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcIndhZnJlZ2lvbmFsXCI6IHtcbiAgICBcInByZWZpeFwiOiBcIndhZi1yZWdpb25hbFwiLFxuICAgIFwibmFtZVwiOiBcIldBRlJlZ2lvbmFsXCJcbiAgfSxcbiAgXCJ3b3JrZG9jc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiV29ya0RvY3NcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcIndvcmtzcGFjZXNcIjoge1xuICAgIFwibmFtZVwiOiBcIldvcmtTcGFjZXNcIlxuICB9LFxuICBcImNvZGVzdGFyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJDb2RlU3RhclwiXG4gIH0sXG4gIFwibGV4bW9kZWxidWlsZGluZ3NlcnZpY2VcIjoge1xuICAgIFwicHJlZml4XCI6IFwibGV4LW1vZGVsc1wiLFxuICAgIFwibmFtZVwiOiBcIkxleE1vZGVsQnVpbGRpbmdTZXJ2aWNlXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJtYXJrZXRwbGFjZWVudGl0bGVtZW50c2VydmljZVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJlbnRpdGxlbWVudC5tYXJrZXRwbGFjZVwiLFxuICAgIFwibmFtZVwiOiBcIk1hcmtldHBsYWNlRW50aXRsZW1lbnRTZXJ2aWNlXCJcbiAgfSxcbiAgXCJhdGhlbmFcIjoge1xuICAgIFwibmFtZVwiOiBcIkF0aGVuYVwiXG4gIH0sXG4gIFwiZ3JlZW5ncmFzc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiR3JlZW5ncmFzc1wiXG4gIH0sXG4gIFwiZGF4XCI6IHtcbiAgICBcIm5hbWVcIjogXCJEQVhcIlxuICB9LFxuICBcIm1pZ3JhdGlvbmh1YlwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJBV1NNaWdyYXRpb25IdWJcIixcbiAgICBcIm5hbWVcIjogXCJNaWdyYXRpb25IdWJcIlxuICB9LFxuICBcImNsb3VkaHNtdjJcIjoge1xuICAgIFwibmFtZVwiOiBcIkNsb3VkSFNNVjJcIlxuICB9LFxuICBcImdsdWVcIjoge1xuICAgIFwibmFtZVwiOiBcIkdsdWVcIlxuICB9LFxuICBcIm1vYmlsZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTW9iaWxlXCJcbiAgfSxcbiAgXCJwcmljaW5nXCI6IHtcbiAgICBcIm5hbWVcIjogXCJQcmljaW5nXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJjb3N0ZXhwbG9yZXJcIjoge1xuICAgIFwicHJlZml4XCI6IFwiY2VcIixcbiAgICBcIm5hbWVcIjogXCJDb3N0RXhwbG9yZXJcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcIm1lZGlhY29udmVydFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTWVkaWFDb252ZXJ0XCJcbiAgfSxcbiAgXCJtZWRpYWxpdmVcIjoge1xuICAgIFwibmFtZVwiOiBcIk1lZGlhTGl2ZVwiXG4gIH0sXG4gIFwibWVkaWFwYWNrYWdlXCI6IHtcbiAgICBcIm5hbWVcIjogXCJNZWRpYVBhY2thZ2VcIlxuICB9LFxuICBcIm1lZGlhc3RvcmVcIjoge1xuICAgIFwibmFtZVwiOiBcIk1lZGlhU3RvcmVcIlxuICB9LFxuICBcIm1lZGlhc3RvcmVkYXRhXCI6IHtcbiAgICBcInByZWZpeFwiOiBcIm1lZGlhc3RvcmUtZGF0YVwiLFxuICAgIFwibmFtZVwiOiBcIk1lZGlhU3RvcmVEYXRhXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJhcHBzeW5jXCI6IHtcbiAgICBcIm5hbWVcIjogXCJBcHBTeW5jXCJcbiAgfSxcbiAgXCJndWFyZGR1dHlcIjoge1xuICAgIFwibmFtZVwiOiBcIkd1YXJkRHV0eVwiXG4gIH0sXG4gIFwibXFcIjoge1xuICAgIFwibmFtZVwiOiBcIk1RXCJcbiAgfSxcbiAgXCJjb21wcmVoZW5kXCI6IHtcbiAgICBcIm5hbWVcIjogXCJDb21wcmVoZW5kXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJpb3Rqb2JzZGF0YXBsYW5lXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImlvdC1qb2JzLWRhdGFcIixcbiAgICBcIm5hbWVcIjogXCJJb1RKb2JzRGF0YVBsYW5lXCJcbiAgfSxcbiAgXCJraW5lc2lzdmlkZW9hcmNoaXZlZG1lZGlhXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImtpbmVzaXMtdmlkZW8tYXJjaGl2ZWQtbWVkaWFcIixcbiAgICBcIm5hbWVcIjogXCJLaW5lc2lzVmlkZW9BcmNoaXZlZE1lZGlhXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJraW5lc2lzdmlkZW9tZWRpYVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJraW5lc2lzLXZpZGVvLW1lZGlhXCIsXG4gICAgXCJuYW1lXCI6IFwiS2luZXNpc1ZpZGVvTWVkaWFcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImtpbmVzaXN2aWRlb1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiS2luZXNpc1ZpZGVvXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJzYWdlbWFrZXJydW50aW1lXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInJ1bnRpbWUuc2FnZW1ha2VyXCIsXG4gICAgXCJuYW1lXCI6IFwiU2FnZU1ha2VyUnVudGltZVwiXG4gIH0sXG4gIFwic2FnZW1ha2VyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTYWdlTWFrZXJcIlxuICB9LFxuICBcInRyYW5zbGF0ZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiVHJhbnNsYXRlXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJyZXNvdXJjZWdyb3Vwc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJyZXNvdXJjZS1ncm91cHNcIixcbiAgICBcIm5hbWVcIjogXCJSZXNvdXJjZUdyb3Vwc1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiYWxleGFmb3JidXNpbmVzc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiQWxleGFGb3JCdXNpbmVzc1wiXG4gIH0sXG4gIFwiY2xvdWQ5XCI6IHtcbiAgICBcIm5hbWVcIjogXCJDbG91ZDlcIlxuICB9LFxuICBcInNlcnZlcmxlc3NhcHBsaWNhdGlvbnJlcG9zaXRvcnlcIjoge1xuICAgIFwicHJlZml4XCI6IFwic2VydmVybGVzc3JlcG9cIixcbiAgICBcIm5hbWVcIjogXCJTZXJ2ZXJsZXNzQXBwbGljYXRpb25SZXBvc2l0b3J5XCJcbiAgfSxcbiAgXCJzZXJ2aWNlZGlzY292ZXJ5XCI6IHtcbiAgICBcIm5hbWVcIjogXCJTZXJ2aWNlRGlzY292ZXJ5XCJcbiAgfSxcbiAgXCJ3b3JrbWFpbFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiV29ya01haWxcIlxuICB9LFxuICBcImF1dG9zY2FsaW5ncGxhbnNcIjoge1xuICAgIFwicHJlZml4XCI6IFwiYXV0b3NjYWxpbmctcGxhbnNcIixcbiAgICBcIm5hbWVcIjogXCJBdXRvU2NhbGluZ1BsYW5zXCJcbiAgfSxcbiAgXCJ0cmFuc2NyaWJlc2VydmljZVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJ0cmFuc2NyaWJlXCIsXG4gICAgXCJuYW1lXCI6IFwiVHJhbnNjcmliZVNlcnZpY2VcIlxuICB9LFxuICBcImNvbm5lY3RcIjoge1xuICAgIFwibmFtZVwiOiBcIkNvbm5lY3RcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImFjbXBjYVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJhY20tcGNhXCIsXG4gICAgXCJuYW1lXCI6IFwiQUNNUENBXCJcbiAgfSxcbiAgXCJmbXNcIjoge1xuICAgIFwibmFtZVwiOiBcIkZNU1wiXG4gIH0sXG4gIFwic2VjcmV0c21hbmFnZXJcIjoge1xuICAgIFwibmFtZVwiOiBcIlNlY3JldHNNYW5hZ2VyXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJpb3RhbmFseXRpY3NcIjoge1xuICAgIFwibmFtZVwiOiBcIklvVEFuYWx5dGljc1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiaW90MWNsaWNrZGV2aWNlc3NlcnZpY2VcIjoge1xuICAgIFwicHJlZml4XCI6IFwiaW90MWNsaWNrLWRldmljZXNcIixcbiAgICBcIm5hbWVcIjogXCJJb1QxQ2xpY2tEZXZpY2VzU2VydmljZVwiXG4gIH0sXG4gIFwiaW90MWNsaWNrcHJvamVjdHNcIjoge1xuICAgIFwicHJlZml4XCI6IFwiaW90MWNsaWNrLXByb2plY3RzXCIsXG4gICAgXCJuYW1lXCI6IFwiSW9UMUNsaWNrUHJvamVjdHNcIlxuICB9LFxuICBcInBpXCI6IHtcbiAgICBcIm5hbWVcIjogXCJQSVwiXG4gIH0sXG4gIFwibmVwdHVuZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTmVwdHVuZVwiXG4gIH0sXG4gIFwibWVkaWF0YWlsb3JcIjoge1xuICAgIFwibmFtZVwiOiBcIk1lZGlhVGFpbG9yXCJcbiAgfSxcbiAgXCJla3NcIjoge1xuICAgIFwibmFtZVwiOiBcIkVLU1wiXG4gIH0sXG4gIFwibWFjaWVcIjoge1xuICAgIFwibmFtZVwiOiBcIk1hY2llXCJcbiAgfSxcbiAgXCJkbG1cIjoge1xuICAgIFwibmFtZVwiOiBcIkRMTVwiXG4gIH0sXG4gIFwic2lnbmVyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTaWduZXJcIlxuICB9LFxuICBcImNoaW1lXCI6IHtcbiAgICBcIm5hbWVcIjogXCJDaGltZVwiXG4gIH0sXG4gIFwicGlucG9pbnRlbWFpbFwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJwaW5wb2ludC1lbWFpbFwiLFxuICAgIFwibmFtZVwiOiBcIlBpbnBvaW50RW1haWxcIlxuICB9LFxuICBcInJhbVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiUkFNXCJcbiAgfSxcbiAgXCJyb3V0ZTUzcmVzb2x2ZXJcIjoge1xuICAgIFwibmFtZVwiOiBcIlJvdXRlNTNSZXNvbHZlclwiXG4gIH0sXG4gIFwicGlucG9pbnRzbXN2b2ljZVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJzbXMtdm9pY2VcIixcbiAgICBcIm5hbWVcIjogXCJQaW5wb2ludFNNU1ZvaWNlXCJcbiAgfSxcbiAgXCJxdWlja3NpZ2h0XCI6IHtcbiAgICBcIm5hbWVcIjogXCJRdWlja1NpZ2h0XCJcbiAgfSxcbiAgXCJyZHNkYXRhc2VydmljZVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJyZHMtZGF0YVwiLFxuICAgIFwibmFtZVwiOiBcIlJEU0RhdGFTZXJ2aWNlXCJcbiAgfSxcbiAgXCJhbXBsaWZ5XCI6IHtcbiAgICBcIm5hbWVcIjogXCJBbXBsaWZ5XCJcbiAgfSxcbiAgXCJkYXRhc3luY1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiRGF0YVN5bmNcIlxuICB9LFxuICBcInJvYm9tYWtlclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiUm9ib01ha2VyXCJcbiAgfSxcbiAgXCJ0cmFuc2ZlclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiVHJhbnNmZXJcIlxuICB9LFxuICBcImdsb2JhbGFjY2VsZXJhdG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJHbG9iYWxBY2NlbGVyYXRvclwiXG4gIH0sXG4gIFwiY29tcHJlaGVuZG1lZGljYWxcIjoge1xuICAgIFwibmFtZVwiOiBcIkNvbXByZWhlbmRNZWRpY2FsXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJraW5lc2lzYW5hbHl0aWNzdjJcIjoge1xuICAgIFwibmFtZVwiOiBcIktpbmVzaXNBbmFseXRpY3NWMlwiXG4gIH0sXG4gIFwibWVkaWFjb25uZWN0XCI6IHtcbiAgICBcIm5hbWVcIjogXCJNZWRpYUNvbm5lY3RcIlxuICB9LFxuICBcImZzeFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRlN4XCJcbiAgfSxcbiAgXCJzZWN1cml0eWh1YlwiOiB7XG4gICAgXCJuYW1lXCI6IFwiU2VjdXJpdHlIdWJcIlxuICB9LFxuICBcImFwcG1lc2hcIjoge1xuICAgIFwibmFtZVwiOiBcIkFwcE1lc2hcIixcbiAgICBcInZlcnNpb25zXCI6IFtcbiAgICAgIFwiMjAxOC0xMC0wMSpcIlxuICAgIF1cbiAgfSxcbiAgXCJsaWNlbnNlbWFuYWdlclwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJsaWNlbnNlLW1hbmFnZXJcIixcbiAgICBcIm5hbWVcIjogXCJMaWNlbnNlTWFuYWdlclwiXG4gIH0sXG4gIFwia2Fma2FcIjoge1xuICAgIFwibmFtZVwiOiBcIkthZmthXCJcbiAgfSxcbiAgXCJhcGlnYXRld2F5bWFuYWdlbWVudGFwaVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQXBpR2F0ZXdheU1hbmFnZW1lbnRBcGlcIlxuICB9LFxuICBcImFwaWdhdGV3YXl2MlwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQXBpR2F0ZXdheVYyXCJcbiAgfSxcbiAgXCJkb2NkYlwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRG9jREJcIlxuICB9LFxuICBcImJhY2t1cFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQmFja3VwXCJcbiAgfSxcbiAgXCJ3b3JrbGlua1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiV29ya0xpbmtcIlxuICB9LFxuICBcInRleHRyYWN0XCI6IHtcbiAgICBcIm5hbWVcIjogXCJUZXh0cmFjdFwiXG4gIH0sXG4gIFwibWFuYWdlZGJsb2NrY2hhaW5cIjoge1xuICAgIFwibmFtZVwiOiBcIk1hbmFnZWRCbG9ja2NoYWluXCJcbiAgfSxcbiAgXCJtZWRpYXBhY2thZ2V2b2RcIjoge1xuICAgIFwicHJlZml4XCI6IFwibWVkaWFwYWNrYWdlLXZvZFwiLFxuICAgIFwibmFtZVwiOiBcIk1lZGlhUGFja2FnZVZvZFwiXG4gIH0sXG4gIFwiZ3JvdW5kc3RhdGlvblwiOiB7XG4gICAgXCJuYW1lXCI6IFwiR3JvdW5kU3RhdGlvblwiXG4gIH0sXG4gIFwiaW90dGhpbmdzZ3JhcGhcIjoge1xuICAgIFwibmFtZVwiOiBcIklvVFRoaW5nc0dyYXBoXCJcbiAgfSxcbiAgXCJpb3RldmVudHNcIjoge1xuICAgIFwibmFtZVwiOiBcIklvVEV2ZW50c1wiXG4gIH0sXG4gIFwiaW90ZXZlbnRzZGF0YVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJpb3RldmVudHMtZGF0YVwiLFxuICAgIFwibmFtZVwiOiBcIklvVEV2ZW50c0RhdGFcIlxuICB9LFxuICBcInBlcnNvbmFsaXplXCI6IHtcbiAgICBcIm5hbWVcIjogXCJQZXJzb25hbGl6ZVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwicGVyc29uYWxpemVldmVudHNcIjoge1xuICAgIFwicHJlZml4XCI6IFwicGVyc29uYWxpemUtZXZlbnRzXCIsXG4gICAgXCJuYW1lXCI6IFwiUGVyc29uYWxpemVFdmVudHNcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInBlcnNvbmFsaXplcnVudGltZVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJwZXJzb25hbGl6ZS1ydW50aW1lXCIsXG4gICAgXCJuYW1lXCI6IFwiUGVyc29uYWxpemVSdW50aW1lXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJhcHBsaWNhdGlvbmluc2lnaHRzXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImFwcGxpY2F0aW9uLWluc2lnaHRzXCIsXG4gICAgXCJuYW1lXCI6IFwiQXBwbGljYXRpb25JbnNpZ2h0c1wiXG4gIH0sXG4gIFwic2VydmljZXF1b3Rhc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJzZXJ2aWNlLXF1b3Rhc1wiLFxuICAgIFwibmFtZVwiOiBcIlNlcnZpY2VRdW90YXNcIlxuICB9LFxuICBcImVjMmluc3RhbmNlY29ubmVjdFwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJlYzItaW5zdGFuY2UtY29ubmVjdFwiLFxuICAgIFwibmFtZVwiOiBcIkVDMkluc3RhbmNlQ29ubmVjdFwiXG4gIH0sXG4gIFwiZXZlbnRicmlkZ2VcIjoge1xuICAgIFwibmFtZVwiOiBcIkV2ZW50QnJpZGdlXCJcbiAgfSxcbiAgXCJsYWtlZm9ybWF0aW9uXCI6IHtcbiAgICBcIm5hbWVcIjogXCJMYWtlRm9ybWF0aW9uXCJcbiAgfSxcbiAgXCJmb3JlY2FzdHNlcnZpY2VcIjoge1xuICAgIFwicHJlZml4XCI6IFwiZm9yZWNhc3RcIixcbiAgICBcIm5hbWVcIjogXCJGb3JlY2FzdFNlcnZpY2VcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImZvcmVjYXN0cXVlcnlzZXJ2aWNlXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImZvcmVjYXN0cXVlcnlcIixcbiAgICBcIm5hbWVcIjogXCJGb3JlY2FzdFF1ZXJ5U2VydmljZVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwicWxkYlwiOiB7XG4gICAgXCJuYW1lXCI6IFwiUUxEQlwiXG4gIH0sXG4gIFwicWxkYnNlc3Npb25cIjoge1xuICAgIFwicHJlZml4XCI6IFwicWxkYi1zZXNzaW9uXCIsXG4gICAgXCJuYW1lXCI6IFwiUUxEQlNlc3Npb25cIlxuICB9LFxuICBcIndvcmttYWlsbWVzc2FnZWZsb3dcIjoge1xuICAgIFwibmFtZVwiOiBcIldvcmtNYWlsTWVzc2FnZUZsb3dcIlxuICB9LFxuICBcImNvZGVzdGFybm90aWZpY2F0aW9uc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJjb2Rlc3Rhci1ub3RpZmljYXRpb25zXCIsXG4gICAgXCJuYW1lXCI6IFwiQ29kZVN0YXJOb3RpZmljYXRpb25zXCJcbiAgfSxcbiAgXCJzYXZpbmdzcGxhbnNcIjoge1xuICAgIFwibmFtZVwiOiBcIlNhdmluZ3NQbGFuc1wiXG4gIH0sXG4gIFwic3NvXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTU09cIlxuICB9LFxuICBcInNzb29pZGNcIjoge1xuICAgIFwicHJlZml4XCI6IFwic3NvLW9pZGNcIixcbiAgICBcIm5hbWVcIjogXCJTU09PSURDXCJcbiAgfSxcbiAgXCJtYXJrZXRwbGFjZWNhdGFsb2dcIjoge1xuICAgIFwicHJlZml4XCI6IFwibWFya2V0cGxhY2UtY2F0YWxvZ1wiLFxuICAgIFwibmFtZVwiOiBcIk1hcmtldHBsYWNlQ2F0YWxvZ1wiXG4gIH0sXG4gIFwiZGF0YWV4Y2hhbmdlXCI6IHtcbiAgICBcIm5hbWVcIjogXCJEYXRhRXhjaGFuZ2VcIlxuICB9LFxuICBcInNlc3YyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTRVNWMlwiXG4gIH0sXG4gIFwibWlncmF0aW9uaHViY29uZmlnXCI6IHtcbiAgICBcInByZWZpeFwiOiBcIm1pZ3JhdGlvbmh1Yi1jb25maWdcIixcbiAgICBcIm5hbWVcIjogXCJNaWdyYXRpb25IdWJDb25maWdcIlxuICB9LFxuICBcImNvbm5lY3RwYXJ0aWNpcGFudFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ29ubmVjdFBhcnRpY2lwYW50XCJcbiAgfSxcbiAgXCJhcHBjb25maWdcIjoge1xuICAgIFwibmFtZVwiOiBcIkFwcENvbmZpZ1wiXG4gIH0sXG4gIFwiaW90c2VjdXJldHVubmVsaW5nXCI6IHtcbiAgICBcIm5hbWVcIjogXCJJb1RTZWN1cmVUdW5uZWxpbmdcIlxuICB9LFxuICBcIndhZnYyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJXQUZWMlwiXG4gIH0sXG4gIFwiZWxhc3RpY2luZmVyZW5jZVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJlbGFzdGljLWluZmVyZW5jZVwiLFxuICAgIFwibmFtZVwiOiBcIkVsYXN0aWNJbmZlcmVuY2VcIlxuICB9LFxuICBcImltYWdlYnVpbGRlclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiSW1hZ2VidWlsZGVyXCJcbiAgfSxcbiAgXCJzY2hlbWFzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTY2hlbWFzXCJcbiAgfSxcbiAgXCJhY2Nlc3NhbmFseXplclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQWNjZXNzQW5hbHl6ZXJcIlxuICB9LFxuICBcImNvZGVndXJ1cmV2aWV3ZXJcIjoge1xuICAgIFwicHJlZml4XCI6IFwiY29kZWd1cnUtcmV2aWV3ZXJcIixcbiAgICBcIm5hbWVcIjogXCJDb2RlR3VydVJldmlld2VyXCJcbiAgfSxcbiAgXCJjb2RlZ3VydXByb2ZpbGVyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJDb2RlR3VydVByb2ZpbGVyXCJcbiAgfSxcbiAgXCJjb21wdXRlb3B0aW1pemVyXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImNvbXB1dGUtb3B0aW1pemVyXCIsXG4gICAgXCJuYW1lXCI6IFwiQ29tcHV0ZU9wdGltaXplclwiXG4gIH0sXG4gIFwiZnJhdWRkZXRlY3RvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRnJhdWREZXRlY3RvclwiXG4gIH0sXG4gIFwia2VuZHJhXCI6IHtcbiAgICBcIm5hbWVcIjogXCJLZW5kcmFcIlxuICB9LFxuICBcIm5ldHdvcmttYW5hZ2VyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJOZXR3b3JrTWFuYWdlclwiXG4gIH0sXG4gIFwib3V0cG9zdHNcIjoge1xuICAgIFwibmFtZVwiOiBcIk91dHBvc3RzXCJcbiAgfSxcbiAgXCJhdWdtZW50ZWRhaXJ1bnRpbWVcIjoge1xuICAgIFwicHJlZml4XCI6IFwic2FnZW1ha2VyLWEyaS1ydW50aW1lXCIsXG4gICAgXCJuYW1lXCI6IFwiQXVnbWVudGVkQUlSdW50aW1lXCJcbiAgfSxcbiAgXCJlYnNcIjoge1xuICAgIFwibmFtZVwiOiBcIkVCU1wiXG4gIH0sXG4gIFwia2luZXNpc3ZpZGVvc2lnbmFsaW5nY2hhbm5lbHNcIjoge1xuICAgIFwicHJlZml4XCI6IFwia2luZXNpcy12aWRlby1zaWduYWxpbmdcIixcbiAgICBcIm5hbWVcIjogXCJLaW5lc2lzVmlkZW9TaWduYWxpbmdDaGFubmVsc1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZGV0ZWN0aXZlXCI6IHtcbiAgICBcIm5hbWVcIjogXCJEZXRlY3RpdmVcIlxuICB9LFxuICBcImNvZGVzdGFyY29ubmVjdGlvbnNcIjoge1xuICAgIFwicHJlZml4XCI6IFwiY29kZXN0YXItY29ubmVjdGlvbnNcIixcbiAgICBcIm5hbWVcIjogXCJDb2RlU3RhcmNvbm5lY3Rpb25zXCJcbiAgfVxufSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJ2ZXJzaW9uXCI6IFwiMi4wXCIsXG4gIFwibWV0YWRhdGFcIjoge1xuICAgIFwiYXBpVmVyc2lvblwiOiBcIjIwMDYtMDMtMDFcIixcbiAgICBcImNoZWNrc3VtRm9ybWF0XCI6IFwibWQ1XCIsXG4gICAgXCJlbmRwb2ludFByZWZpeFwiOiBcInMzXCIsXG4gICAgXCJnbG9iYWxFbmRwb2ludFwiOiBcInMzLmFtYXpvbmF3cy5jb21cIixcbiAgICBcInByb3RvY29sXCI6IFwicmVzdC14bWxcIixcbiAgICBcInNlcnZpY2VBYmJyZXZpYXRpb25cIjogXCJBbWF6b24gUzNcIixcbiAgICBcInNlcnZpY2VGdWxsTmFtZVwiOiBcIkFtYXpvbiBTaW1wbGUgU3RvcmFnZSBTZXJ2aWNlXCIsXG4gICAgXCJzZXJ2aWNlSWRcIjogXCJTM1wiLFxuICAgIFwic2lnbmF0dXJlVmVyc2lvblwiOiBcInMzXCIsXG4gICAgXCJ1aWRcIjogXCJzMy0yMDA2LTAzLTAxXCJcbiAgfSxcbiAgXCJvcGVyYXRpb25zXCI6IHtcbiAgICBcIkFib3J0TXVsdGlwYXJ0VXBsb2FkXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K31cIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCIsXG4gICAgICAgICAgXCJVcGxvYWRJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJVcGxvYWRJZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidXBsb2FkSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUmVxdWVzdENoYXJnZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJDb21wbGV0ZU11bHRpcGFydFVwbG9hZFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9XCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIixcbiAgICAgICAgICBcIlVwbG9hZElkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk11bHRpcGFydFVwbG9hZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiUGFydHNcIjoge1xuICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiUGFydFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiRVRhZ1wiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgXCJQYXJ0TnVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlVwbG9hZElkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ1cGxvYWRJZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiTXVsdGlwYXJ0VXBsb2FkXCJcbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiTG9jYXRpb25cIjoge30sXG4gICAgICAgICAgXCJCdWNrZXRcIjoge30sXG4gICAgICAgICAgXCJLZXlcIjoge30sXG4gICAgICAgICAgXCJFeHBpcmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwaXJhdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkVUYWdcIjoge30sXG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei12ZXJzaW9uLWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TS2V5SWRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNqXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYXdzLWttcy1rZXktaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkNvcHlPYmplY3RcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiQ29weVNvdXJjZVwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkFDTFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWFjbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNhY2hlQ29udHJvbFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNhY2hlLUNvbnRyb2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50RGlzcG9zaXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LURpc3Bvc2l0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudEVuY29kaW5nXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1FbmNvZGluZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRMYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTGFuZ3VhZ2VcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50VHlwZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtVHlwZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VJZk1hdGNoXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2UtaWYtbWF0Y2hcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb3B5U291cmNlSWZNb2RpZmllZFNpbmNlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2UtaWYtbW9kaWZpZWQtc2luY2VcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VJZk5vbmVNYXRjaFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlLWlmLW5vbmUtbWF0Y2hcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb3B5U291cmNlSWZVbm1vZGlmaWVkU2luY2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZS1pZi11bm1vZGlmaWVkLXNpbmNlXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBpcmVzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRXhwaXJlc1wiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRGdWxsQ29udHJvbFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LWZ1bGwtY29udHJvbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50UmVhZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXJlYWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudFJlYWRBQ1BcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC1yZWFkLWFjcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50V3JpdGVBQ1BcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC13cml0ZS1hY3BcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzExXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyc1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1tZXRhLVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1ldGFkYXRhRGlyZWN0aXZlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotbWV0YWRhdGEtZGlyZWN0aXZlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVGFnZ2luZ0RpcmVjdGl2ZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXRhZ2dpbmctZGlyZWN0aXZlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU2VydmVyU2lkZUVuY3J5cHRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3RvcmFnZUNsYXNzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc3RvcmFnZS1jbGFzc1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIldlYnNpdGVSZWRpcmVjdExvY2F0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotd2Vic2l0ZS1yZWRpcmVjdC1sb2NhdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzE5XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VLTVNLZXlJZFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2pcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1hd3Mta21zLWtleS1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUtNU0VuY3J5cHRpb25Db250ZXh0XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jb250ZXh0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZVNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2Utc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb3B5U291cmNlU1NFQ3VzdG9tZXJLZXlcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxZFwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZS1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlLXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJUYWdnaW5nXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotdGFnZ2luZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk9iamVjdExvY2tNb2RlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stbW9kZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk9iamVjdExvY2tSZXRhaW5VbnRpbERhdGVcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxaFwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1vYmplY3QtbG9jay1yZXRhaW4tdW50aWwtZGF0ZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk9iamVjdExvY2tMZWdhbEhvbGRTdGF0dXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1vYmplY3QtbG9jay1sZWdhbC1ob2xkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQ29weU9iamVjdFJlc3VsdFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiRVRhZ1wiOiB7fSxcbiAgICAgICAgICAgICAgXCJMYXN0TW9kaWZpZWRcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwaXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGlyYXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb3B5U291cmNlVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2UtdmVyc2lvbi1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXZlcnNpb24taWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VLTVNLZXlJZFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2pcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1hd3Mta21zLWtleS1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUtNU0VuY3J5cHRpb25Db250ZXh0XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jb250ZXh0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdENoYXJnZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiQ29weU9iamVjdFJlc3VsdFwiXG4gICAgICB9LFxuICAgICAgXCJhbGlhc1wiOiBcIlB1dE9iamVjdENvcHlcIlxuICAgIH0sXG4gICAgXCJDcmVhdGVCdWNrZXRcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9XCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkFDTFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWFjbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNyZWF0ZUJ1Y2tldENvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDcmVhdGVCdWNrZXRDb25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiTG9jYXRpb25Db25zdHJhaW50XCI6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50RnVsbENvbnRyb2xcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC1mdWxsLWNvbnRyb2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudFJlYWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC1yZWFkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRSZWFkQUNQXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtcmVhZC1hY3BcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudFdyaXRlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtd3JpdGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudFdyaXRlQUNQXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtd3JpdGUtYWNwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT2JqZWN0TG9ja0VuYWJsZWRGb3JCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1idWNrZXQtb2JqZWN0LWxvY2stZW5hYmxlZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJDcmVhdGVCdWNrZXRDb25maWd1cmF0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiTG9jYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJMb2NhdGlvblwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJhbGlhc1wiOiBcIlB1dEJ1Y2tldFwiXG4gICAgfSxcbiAgICBcIkNyZWF0ZU11bHRpcGFydFVwbG9hZFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9P3VwbG9hZHNcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJBQ0xcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1hY2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDYWNoZUNvbnRyb2xcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDYWNoZS1Db250cm9sXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudERpc3Bvc2l0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1EaXNwb3NpdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRFbmNvZGluZ1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtRW5jb2RpbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LUxhbmd1YWdlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudFR5cGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LVR5cGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBpcmVzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRXhwaXJlc1wiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRGdWxsQ29udHJvbFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LWZ1bGwtY29udHJvbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50UmVhZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXJlYWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudFJlYWRBQ1BcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC1yZWFkLWFjcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50V3JpdGVBQ1BcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC13cml0ZS1hY3BcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzExXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyc1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1tZXRhLVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNlcnZlclNpZGVFbmNyeXB0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlN0b3JhZ2VDbGFzc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXN0b3JhZ2UtY2xhc3NcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJXZWJzaXRlUmVkaXJlY3RMb2NhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXdlYnNpdGUtcmVkaXJlY3QtbG9jYXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxOVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TS2V5SWRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNqXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYXdzLWttcy1rZXktaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VLTVNFbmNyeXB0aW9uQ29udGV4dFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFiXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY29udGV4dFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJUYWdnaW5nXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotdGFnZ2luZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk9iamVjdExvY2tNb2RlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stbW9kZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk9iamVjdExvY2tSZXRhaW5VbnRpbERhdGVcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxaFwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1vYmplY3QtbG9jay1yZXRhaW4tdW50aWwtZGF0ZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk9iamVjdExvY2tMZWdhbEhvbGRTdGF0dXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1vYmplY3QtbG9jay1sZWdhbC1ob2xkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQWJvcnREYXRlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotYWJvcnQtZGF0ZVwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQWJvcnRSdWxlSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1hYm9ydC1ydWxlLWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHt9LFxuICAgICAgICAgIFwiVXBsb2FkSWRcIjoge30sXG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VLTVNLZXlJZFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2pcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1hd3Mta21zLWtleS1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUtNU0VuY3J5cHRpb25Db250ZXh0XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jb250ZXh0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdENoYXJnZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiYWxpYXNcIjogXCJJbml0aWF0ZU11bHRpcGFydFVwbG9hZFwiXG4gICAgfSxcbiAgICBcIkRlbGV0ZUJ1Y2tldFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkRFTEVURVwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH1cIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWxldGVCdWNrZXRBbmFseXRpY3NDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9hbmFseXRpY3NcIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiSWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImlkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVsZXRlQnVja2V0Q29yc1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkRFTEVURVwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/Y29yc1wiLFxuICAgICAgICBcInJlc3BvbnNlQ29kZVwiOiAyMDRcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkRlbGV0ZUJ1Y2tldEVuY3J5cHRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJERUxFVEVcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2VuY3J5cHRpb25cIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWxldGVCdWNrZXRJbnZlbnRvcnlDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9pbnZlbnRvcnlcIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiSWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImlkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVsZXRlQnVja2V0TGlmZWN5Y2xlXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9saWZlY3ljbGVcIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWxldGVCdWNrZXRNZXRyaWNzQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkRFTEVURVwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/bWV0cmljc1wiLFxuICAgICAgICBcInJlc3BvbnNlQ29kZVwiOiAyMDRcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiaWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWxldGVCdWNrZXRQb2xpY3lcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJERUxFVEVcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3BvbGljeVwiLFxuICAgICAgICBcInJlc3BvbnNlQ29kZVwiOiAyMDRcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkRlbGV0ZUJ1Y2tldFJlcGxpY2F0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9yZXBsaWNhdGlvblwiLFxuICAgICAgICBcInJlc3BvbnNlQ29kZVwiOiAyMDRcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkRlbGV0ZUJ1Y2tldFRhZ2dpbmdcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJERUxFVEVcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3RhZ2dpbmdcIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWxldGVCdWNrZXRXZWJzaXRlXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT93ZWJzaXRlXCIsXG4gICAgICAgIFwicmVzcG9uc2VDb2RlXCI6IDIwNFxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVsZXRlT2JqZWN0XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K31cIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1GQVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW1mYVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidmVyc2lvbklkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ5cGFzc0dvdmVybmFuY2VSZXRlbnRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ieXBhc3MtZ292ZXJuYW5jZS1yZXRlbnRpb25cIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJEZWxldGVNYXJrZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1kZWxldGUtbWFya2VyXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotdmVyc2lvbi1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVsZXRlT2JqZWN0VGFnZ2luZ1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkRFTEVURVwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9P3RhZ2dpbmdcIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidmVyc2lvbklkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotdmVyc2lvbi1pZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkRlbGV0ZU9iamVjdHNcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2RlbGV0ZVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiRGVsZXRlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkRlbGV0ZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkRlbGV0ZVwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgXCJPYmplY3RzXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIk9iamVjdHNcIjoge1xuICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiT2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIktleVwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgXCJWZXJzaW9uSWRcIjoge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJRdWlldFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTUZBXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotbWZhXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ5cGFzc0dvdmVybmFuY2VSZXRlbnRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ieXBhc3MtZ292ZXJuYW5jZS1yZXRlbnRpb25cIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiRGVsZXRlXCJcbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiRGVsZXRlZFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiS2V5XCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiRGVsZXRlTWFya2VyXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJEZWxldGVNYXJrZXJWZXJzaW9uSWRcIjoge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdENoYXJnZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFcnJvcnNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJFcnJvclwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcIktleVwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIkNvZGVcIjoge30sXG4gICAgICAgICAgICAgICAgXCJNZXNzYWdlXCI6IHt9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJhbGlhc1wiOiBcIkRlbGV0ZU11bHRpcGxlT2JqZWN0c1wiXG4gICAgfSxcbiAgICBcIkRlbGV0ZVB1YmxpY0FjY2Vzc0Jsb2NrXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9wdWJsaWNBY2Nlc3NCbG9ja1wiLFxuICAgICAgICBcInJlc3BvbnNlQ29kZVwiOiAyMDRcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldEFjY2VsZXJhdGVDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9hY2NlbGVyYXRlXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlN0YXR1c1wiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldEFjbFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/YWNsXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIk93bmVyXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMzJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudHNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzNVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJBY2Nlc3NDb250cm9sTGlzdFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldEFuYWx5dGljc0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2FuYWx5dGljc1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiSWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImlkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQW5hbHl0aWNzQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzNlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkFuYWx5dGljc0NvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRCdWNrZXRDb3JzXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9jb3JzXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkNPUlNSdWxlc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzN1XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNPUlNSdWxlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0RW5jcnlwdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/ZW5jcnlwdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvbkNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM0N1wiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvbkNvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRCdWNrZXRJbnZlbnRvcnlDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9pbnZlbnRvcnlcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIklkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJpZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkludmVudG9yeUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM0ZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJJbnZlbnRvcnlDb25maWd1cmF0aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0TGlmZWN5Y2xlXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9saWZlY3ljbGVcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUnVsZXNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM0dFwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJSdWxlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImRlcHJlY2F0ZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJHZXRCdWNrZXRMaWZlY3ljbGVDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9saWZlY3ljbGVcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUnVsZXNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1OFwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJSdWxlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0TG9jYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2xvY2F0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkxvY2F0aW9uQ29uc3RyYWludFwiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldExvZ2dpbmdcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2xvZ2dpbmdcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiTG9nZ2luZ0VuYWJsZWRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1aVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldE1ldHJpY3NDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9tZXRyaWNzXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiaWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJNZXRyaWNzQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzVxXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIk1ldHJpY3NDb25maWd1cmF0aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0Tm90aWZpY2F0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9ub3RpZmljYXRpb25cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInNoYXBlXCI6IFwiUzV0XCJcbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwic2hhcGVcIjogXCJTNXVcIlxuICAgICAgfSxcbiAgICAgIFwiZGVwcmVjYXRlZFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldE5vdGlmaWNhdGlvbkNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P25vdGlmaWNhdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwic2hhcGVcIjogXCJTNXRcIlxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJzaGFwZVwiOiBcIlM2NVwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldFBvbGljeVwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/cG9saWN5XCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlBvbGljeVwiOiB7fVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJQb2xpY3lcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRCdWNrZXRQb2xpY3lTdGF0dXNcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3BvbGljeVN0YXR1c1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJQb2xpY3lTdGF0dXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIklzUHVibGljXCI6IHtcbiAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIklzUHVibGljXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIlBvbGljeVN0YXR1c1wiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldFJlcGxpY2F0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9yZXBsaWNhdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSZXBsaWNhdGlvbkNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM2c1wiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJSZXBsaWNhdGlvbkNvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRCdWNrZXRSZXF1ZXN0UGF5bWVudFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/cmVxdWVzdFBheW1lbnRcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUGF5ZXJcIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRCdWNrZXRUYWdnaW5nXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT90YWdnaW5nXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJUYWdTZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiVGFnU2V0XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM2tcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRCdWNrZXRWZXJzaW9uaW5nXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT92ZXJzaW9uaW5nXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlN0YXR1c1wiOiB7fSxcbiAgICAgICAgICBcIk1GQURlbGV0ZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIk1mYURlbGV0ZVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldFdlYnNpdGVcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3dlYnNpdGVcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUmVkaXJlY3RBbGxSZXF1ZXN0c1RvXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTN3RcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJbmRleERvY3VtZW50XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTN3dcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFcnJvckRvY3VtZW50XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTN3lcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSb3V0aW5nUnVsZXNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM3elwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldE9iamVjdFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9XCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSWZNYXRjaFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIklmLU1hdGNoXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSWZNb2RpZmllZFNpbmNlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiSWYtTW9kaWZpZWQtU2luY2VcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklmTm9uZU1hdGNoXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiSWYtTm9uZS1NYXRjaFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklmVW5tb2RpZmllZFNpbmNlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiSWYtVW5tb2RpZmllZC1TaW5jZVwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmFuZ2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJSYW5nZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlc3BvbnNlQ2FjaGVDb250cm9sXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJyZXNwb25zZS1jYWNoZS1jb250cm9sXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVzcG9uc2VDb250ZW50RGlzcG9zaXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInJlc3BvbnNlLWNvbnRlbnQtZGlzcG9zaXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXNwb25zZUNvbnRlbnRFbmNvZGluZ1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicmVzcG9uc2UtY29udGVudC1lbmNvZGluZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlc3BvbnNlQ29udGVudExhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJyZXNwb25zZS1jb250ZW50LWxhbmd1YWdlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVzcG9uc2VDb250ZW50VHlwZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicmVzcG9uc2UtY29udGVudC10eXBlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVzcG9uc2VFeHBpcmVzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJyZXNwb25zZS1leHBpcmVzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInZlcnNpb25JZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzE5XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUGFydE51bWJlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicGFydE51bWJlclwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJvZHlcIjoge1xuICAgICAgICAgICAgXCJzdHJlYW1pbmdcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJsb2JcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJEZWxldGVNYXJrZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1kZWxldGUtbWFya2VyXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQWNjZXB0UmFuZ2VzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiYWNjZXB0LXJhbmdlc1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGlyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBpcmF0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVzdG9yZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlc3RvcmVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJMYXN0TW9kaWZpZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJMYXN0LU1vZGlmaWVkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TGVuZ3RoXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1MZW5ndGhcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxvbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFVGFnXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRVRhZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1pc3NpbmdNZXRhXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotbWlzc2luZy1tZXRhXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotdmVyc2lvbi1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNhY2hlQ29udHJvbFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNhY2hlLUNvbnRyb2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50RGlzcG9zaXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LURpc3Bvc2l0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudEVuY29kaW5nXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1FbmNvZGluZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRMYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTGFuZ3VhZ2VcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50UmFuZ2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LVJhbmdlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudFR5cGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LVR5cGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBpcmVzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRXhwaXJlc1wiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiV2Vic2l0ZVJlZGlyZWN0TG9jYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei13ZWJzaXRlLXJlZGlyZWN0LWxvY2F0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU2VydmVyU2lkZUVuY3J5cHRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxMVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlcnNcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotbWV0YS1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VLTVNLZXlJZFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2pcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1hd3Mta21zLWtleS1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlN0b3JhZ2VDbGFzc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXN0b3JhZ2UtY2xhc3NcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcGxpY2F0aW9uU3RhdHVzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVwbGljYXRpb24tc3RhdHVzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUGFydHNDb3VudFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW1wLXBhcnRzLWNvdW50XCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVGFnQ291bnRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei10YWdnaW5nLWNvdW50XCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT2JqZWN0TG9ja01vZGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1vYmplY3QtbG9jay1tb2RlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT2JqZWN0TG9ja1JldGFpblVudGlsRGF0ZVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFoXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW9iamVjdC1sb2NrLXJldGFpbi11bnRpbC1kYXRlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT2JqZWN0TG9ja0xlZ2FsSG9sZFN0YXR1c1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW9iamVjdC1sb2NrLWxlZ2FsLWhvbGRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiQm9keVwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldE9iamVjdEFjbFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9P2FjbFwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidmVyc2lvbklkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIk93bmVyXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMzJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudHNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzNVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJBY2Nlc3NDb250cm9sTGlzdFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0T2JqZWN0TGVnYWxIb2xkXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K30/bGVnYWwtaG9sZFwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidmVyc2lvbklkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkxlZ2FsSG9sZFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzh5XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkxlZ2FsSG9sZFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldE9iamVjdExvY2tDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9vYmplY3QtbG9ja1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJPYmplY3RMb2NrQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzkxXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIk9iamVjdExvY2tDb25maWd1cmF0aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0T2JqZWN0UmV0ZW50aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K30/cmV0ZW50aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ2ZXJzaW9uSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUmV0ZW50aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTOTlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiUmV0ZW50aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0T2JqZWN0VGFnZ2luZ1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9P3RhZ2dpbmdcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInZlcnNpb25JZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJUYWdTZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotdmVyc2lvbi1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlRhZ1NldFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzNrXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0T2JqZWN0VG9ycmVudFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9P3RvcnJlbnRcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQm9keVwiOiB7XG4gICAgICAgICAgICBcInN0cmVhbWluZ1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYmxvYlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkJvZHlcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRQdWJsaWNBY2Nlc3NCbG9ja1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/cHVibGljQWNjZXNzQmxvY2tcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUHVibGljQWNjZXNzQmxvY2tDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTOWdcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiUHVibGljQWNjZXNzQmxvY2tDb25maWd1cmF0aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiSGVhZEJ1Y2tldFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkhFQURcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9XCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkhlYWRPYmplY3RcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJIRUFEXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K31cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZk1hdGNoXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiSWYtTWF0Y2hcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZk1vZGlmaWVkU2luY2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJJZi1Nb2RpZmllZC1TaW5jZVwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSWZOb25lTWF0Y2hcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJJZi1Ob25lLU1hdGNoXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSWZVbm1vZGlmaWVkU2luY2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJJZi1Vbm1vZGlmaWVkLVNpbmNlXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSYW5nZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlJhbmdlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ2ZXJzaW9uSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxOVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBhcnROdW1iZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInBhcnROdW1iZXJcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJEZWxldGVNYXJrZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1kZWxldGUtbWFya2VyXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQWNjZXB0UmFuZ2VzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiYWNjZXB0LXJhbmdlc1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGlyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBpcmF0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVzdG9yZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlc3RvcmVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJMYXN0TW9kaWZpZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJMYXN0LU1vZGlmaWVkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TGVuZ3RoXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1MZW5ndGhcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxvbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFVGFnXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRVRhZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1pc3NpbmdNZXRhXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotbWlzc2luZy1tZXRhXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotdmVyc2lvbi1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNhY2hlQ29udHJvbFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNhY2hlLUNvbnRyb2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50RGlzcG9zaXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LURpc3Bvc2l0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudEVuY29kaW5nXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1FbmNvZGluZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRMYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTGFuZ3VhZ2VcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50VHlwZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtVHlwZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGlyZXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJFeHBpcmVzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJXZWJzaXRlUmVkaXJlY3RMb2NhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXdlYnNpdGUtcmVkaXJlY3QtbG9jYXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzExXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyc1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1tZXRhLVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUtNU0tleUlkXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTalwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWF3cy1rbXMta2V5LWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3RvcmFnZUNsYXNzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc3RvcmFnZS1jbGFzc1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVwbGljYXRpb25TdGF0dXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXBsaWNhdGlvbi1zdGF0dXNcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQYXJ0c0NvdW50XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotbXAtcGFydHMtY291bnRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrTW9kZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW9iamVjdC1sb2NrLW1vZGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrUmV0YWluVW50aWxEYXRlXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWhcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stcmV0YWluLXVudGlsLWRhdGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrTGVnYWxIb2xkU3RhdHVzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stbGVnYWwtaG9sZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkxpc3RCdWNrZXRBbmFseXRpY3NDb25maWd1cmF0aW9uc1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/YW5hbHl0aWNzXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRpbnVhdGlvblRva2VuXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJjb250aW51YXRpb24tdG9rZW5cIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJc1RydW5jYXRlZFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGludWF0aW9uVG9rZW5cIjoge30sXG4gICAgICAgICAgXCJOZXh0Q29udGludWF0aW9uVG9rZW5cIjoge30sXG4gICAgICAgICAgXCJBbmFseXRpY3NDb25maWd1cmF0aW9uTGlzdFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkFuYWx5dGljc0NvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJMaXN0QnVja2V0SW52ZW50b3J5Q29uZmlndXJhdGlvbnNcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2ludmVudG9yeVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250aW51YXRpb25Ub2tlblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiY29udGludWF0aW9uLXRva2VuXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQ29udGludWF0aW9uVG9rZW5cIjoge30sXG4gICAgICAgICAgXCJJbnZlbnRvcnlDb25maWd1cmF0aW9uTGlzdFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkludmVudG9yeUNvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM0ZFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJc1RydW5jYXRlZFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTmV4dENvbnRpbnVhdGlvblRva2VuXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiTGlzdEJ1Y2tldE1ldHJpY3NDb25maWd1cmF0aW9uc1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/bWV0cmljc1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250aW51YXRpb25Ub2tlblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiY29udGludWF0aW9uLXRva2VuXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSXNUcnVuY2F0ZWRcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRpbnVhdGlvblRva2VuXCI6IHt9LFxuICAgICAgICAgIFwiTmV4dENvbnRpbnVhdGlvblRva2VuXCI6IHt9LFxuICAgICAgICAgIFwiTWV0cmljc0NvbmZpZ3VyYXRpb25MaXN0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiTWV0cmljc0NvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1cVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJMaXN0QnVja2V0c1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiXG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldHNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiLFxuICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcIk5hbWVcIjoge30sXG4gICAgICAgICAgICAgICAgXCJDcmVhdGlvbkRhdGVcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT3duZXJcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzMlwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJhbGlhc1wiOiBcIkdldFNlcnZpY2VcIlxuICAgIH0sXG4gICAgXCJMaXN0TXVsdGlwYXJ0VXBsb2Fkc1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/dXBsb2Fkc1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJEZWxpbWl0ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImRlbGltaXRlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkVuY29kaW5nVHlwZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiZW5jb2RpbmctdHlwZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleU1hcmtlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwia2V5LW1hcmtlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1heFVwbG9hZHNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIm1heC11cGxvYWRzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUHJlZml4XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJwcmVmaXhcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJVcGxvYWRJZE1hcmtlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidXBsb2FkLWlkLW1hcmtlclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7fSxcbiAgICAgICAgICBcIktleU1hcmtlclwiOiB7fSxcbiAgICAgICAgICBcIlVwbG9hZElkTWFya2VyXCI6IHt9LFxuICAgICAgICAgIFwiTmV4dEtleU1hcmtlclwiOiB7fSxcbiAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICBcIkRlbGltaXRlclwiOiB7fSxcbiAgICAgICAgICBcIk5leHRVcGxvYWRJZE1hcmtlclwiOiB7fSxcbiAgICAgICAgICBcIk1heFVwbG9hZHNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklzVHJ1bmNhdGVkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJVcGxvYWRzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiVXBsb2FkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiVXBsb2FkSWRcIjoge30sXG4gICAgICAgICAgICAgICAgXCJLZXlcIjoge30sXG4gICAgICAgICAgICAgICAgXCJJbml0aWF0ZWRcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiU3RvcmFnZUNsYXNzXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiT3duZXJcIjoge1xuICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzMlwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIkluaXRpYXRvclwiOiB7XG4gICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiU2FkXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbW1vblByZWZpeGVzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTYWVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFbmNvZGluZ1R5cGVcIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJMaXN0T2JqZWN0VmVyc2lvbnNcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3ZlcnNpb25zXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkRlbGltaXRlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiZGVsaW1pdGVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRW5jb2RpbmdUeXBlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJlbmNvZGluZy10eXBlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5TWFya2VyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJrZXktbWFya2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWF4S2V5c1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwibWF4LWtleXNcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQcmVmaXhcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInByZWZpeFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZE1hcmtlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidmVyc2lvbi1pZC1tYXJrZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJc1RydW5jYXRlZFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5TWFya2VyXCI6IHt9LFxuICAgICAgICAgIFwiVmVyc2lvbklkTWFya2VyXCI6IHt9LFxuICAgICAgICAgIFwiTmV4dEtleU1hcmtlclwiOiB7fSxcbiAgICAgICAgICBcIk5leHRWZXJzaW9uSWRNYXJrZXJcIjoge30sXG4gICAgICAgICAgXCJWZXJzaW9uc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlZlcnNpb25cIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJFVGFnXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiU2l6ZVwiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiU3RvcmFnZUNsYXNzXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiS2V5XCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiSXNMYXRlc3RcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIkxhc3RNb2RpZmllZFwiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJPd25lclwiOiB7XG4gICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzMyXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkRlbGV0ZU1hcmtlcnNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJEZWxldGVNYXJrZXJcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJPd25lclwiOiB7XG4gICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzMyXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiS2V5XCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiSXNMYXRlc3RcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIkxhc3RNb2RpZmllZFwiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTmFtZVwiOiB7fSxcbiAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICBcIkRlbGltaXRlclwiOiB7fSxcbiAgICAgICAgICBcIk1heEtleXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbW1vblByZWZpeGVzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTYWVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFbmNvZGluZ1R5cGVcIjoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiYWxpYXNcIjogXCJHZXRCdWNrZXRPYmplY3RWZXJzaW9uc1wiXG4gICAgfSxcbiAgICBcIkxpc3RPYmplY3RzXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJEZWxpbWl0ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImRlbGltaXRlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkVuY29kaW5nVHlwZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiZW5jb2RpbmctdHlwZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1hcmtlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwibWFya2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWF4S2V5c1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwibWF4LWtleXNcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQcmVmaXhcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInByZWZpeFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJc1RydW5jYXRlZFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWFya2VyXCI6IHt9LFxuICAgICAgICAgIFwiTmV4dE1hcmtlclwiOiB7fSxcbiAgICAgICAgICBcIkNvbnRlbnRzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTYXdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJOYW1lXCI6IHt9LFxuICAgICAgICAgIFwiUHJlZml4XCI6IHt9LFxuICAgICAgICAgIFwiRGVsaW1pdGVyXCI6IHt9LFxuICAgICAgICAgIFwiTWF4S2V5c1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29tbW9uUHJlZml4ZXNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNhZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkVuY29kaW5nVHlwZVwiOiB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJhbGlhc1wiOiBcIkdldEJ1Y2tldFwiXG4gICAgfSxcbiAgICBcIkxpc3RPYmplY3RzVjJcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2xpc3QtdHlwZT0yXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkRlbGltaXRlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiZGVsaW1pdGVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRW5jb2RpbmdUeXBlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJlbmNvZGluZy10eXBlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWF4S2V5c1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwibWF4LWtleXNcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQcmVmaXhcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInByZWZpeFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRpbnVhdGlvblRva2VuXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJjb250aW51YXRpb24tdG9rZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJGZXRjaE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJmZXRjaC1vd25lclwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlN0YXJ0QWZ0ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInN0YXJ0LWFmdGVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklzVHJ1bmNhdGVkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50c1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2F3XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTmFtZVwiOiB7fSxcbiAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICBcIkRlbGltaXRlclwiOiB7fSxcbiAgICAgICAgICBcIk1heEtleXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbW1vblByZWZpeGVzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTYWVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFbmNvZGluZ1R5cGVcIjoge30sXG4gICAgICAgICAgXCJLZXlDb3VudFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGludWF0aW9uVG9rZW5cIjoge30sXG4gICAgICAgICAgXCJOZXh0Q29udGludWF0aW9uVG9rZW5cIjoge30sXG4gICAgICAgICAgXCJTdGFydEFmdGVyXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiTGlzdFBhcnRzXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K31cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiLFxuICAgICAgICAgIFwiVXBsb2FkSWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWF4UGFydHNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIm1heC1wYXJ0c1wiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBhcnROdW1iZXJNYXJrZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInBhcnQtbnVtYmVyLW1hcmtlclwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlVwbG9hZElkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ1cGxvYWRJZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJBYm9ydERhdGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1hYm9ydC1kYXRlXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJBYm9ydFJ1bGVJZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWFib3J0LXJ1bGUtaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJCdWNrZXRcIjoge30sXG4gICAgICAgICAgXCJLZXlcIjoge30sXG4gICAgICAgICAgXCJVcGxvYWRJZFwiOiB7fSxcbiAgICAgICAgICBcIlBhcnROdW1iZXJNYXJrZXJcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk5leHRQYXJ0TnVtYmVyTWFya2VyXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNYXhQYXJ0c1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSXNUcnVuY2F0ZWRcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBhcnRzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiUGFydFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcIlBhcnROdW1iZXJcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIkxhc3RNb2RpZmllZFwiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJFVGFnXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiU2l6ZVwiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkluaXRpYXRvclwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2FkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT3duZXJcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzMlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlN0b3JhZ2VDbGFzc1wiOiB7fSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0QnVja2V0QWNjZWxlcmF0ZUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2FjY2VsZXJhdGVcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIkFjY2VsZXJhdGVDb25maWd1cmF0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkFjY2VsZXJhdGVDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQWNjZWxlcmF0ZUNvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJTdGF0dXNcIjoge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkFjY2VsZXJhdGVDb25maWd1cmF0aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0QnVja2V0QWNsXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9hY2xcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQUNMXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotYWNsXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQWNjZXNzQ29udHJvbFBvbGljeVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2JlXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkFjY2Vzc0NvbnRyb2xQb2xpY3lcIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudEZ1bGxDb250cm9sXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtZnVsbC1jb250cm9sXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRSZWFkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtcmVhZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50UmVhZEFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXJlYWQtYWNwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRXcml0ZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXdyaXRlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRXcml0ZUFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXdyaXRlLWFjcFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJBY2Nlc3NDb250cm9sUG9saWN5XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0QnVja2V0QW5hbHl0aWNzQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/YW5hbHl0aWNzXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJJZFwiLFxuICAgICAgICAgIFwiQW5hbHl0aWNzQ29uZmlndXJhdGlvblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJBbmFseXRpY3NDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM2VcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQW5hbHl0aWNzQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJBbmFseXRpY3NDb25maWd1cmF0aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0QnVja2V0Q29yc1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/Y29yc1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiQ09SU0NvbmZpZ3VyYXRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ09SU0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDT1JTQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgXCJDT1JTUnVsZXNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiQ09SU1J1bGVzXCI6IHtcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzN1XCIsXG4gICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDT1JTUnVsZVwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudE1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkNPUlNDb25maWd1cmF0aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0QnVja2V0RW5jcnlwdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/ZW5jcnlwdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiU2VydmVyU2lkZUVuY3J5cHRpb25Db25maWd1cmF0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNlcnZlclNpZGVFbmNyeXB0aW9uQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzQ3XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlNlcnZlclNpZGVFbmNyeXB0aW9uQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvbkNvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRJbnZlbnRvcnlDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9pbnZlbnRvcnlcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIklkXCIsXG4gICAgICAgICAgXCJJbnZlbnRvcnlDb25maWd1cmF0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJpZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkludmVudG9yeUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM0ZFwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJJbnZlbnRvcnlDb25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkludmVudG9yeUNvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRMaWZlY3ljbGVcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2xpZmVjeWNsZVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJMaWZlY3ljbGVDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiTGlmZWN5Y2xlQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgXCJSdWxlc1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJSdWxlc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM0dFwiLFxuICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiUnVsZVwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkxpZmVjeWNsZUNvbmZpZ3VyYXRpb25cIlxuICAgICAgfSxcbiAgICAgIFwiZGVwcmVjYXRlZFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIlB1dEJ1Y2tldExpZmVjeWNsZUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2xpZmVjeWNsZVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJMaWZlY3ljbGVDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiTGlmZWN5Y2xlQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgXCJSdWxlc1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJSdWxlc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1OFwiLFxuICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiUnVsZVwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkxpZmVjeWNsZUNvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRMb2dnaW5nXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9sb2dnaW5nXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJCdWNrZXRMb2dnaW5nU3RhdHVzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldExvZ2dpbmdTdGF0dXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRMb2dnaW5nU3RhdHVzXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiTG9nZ2luZ0VuYWJsZWRcIjoge1xuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNWlcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJCdWNrZXRMb2dnaW5nU3RhdHVzXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0QnVja2V0TWV0cmljc0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P21ldHJpY3NcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIklkXCIsXG4gICAgICAgICAgXCJNZXRyaWNzQ29uZmlndXJhdGlvblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNZXRyaWNzQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzVxXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIk1ldHJpY3NDb25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIk1ldHJpY3NDb25maWd1cmF0aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0QnVja2V0Tm90aWZpY2F0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9ub3RpZmljYXRpb25cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIk5vdGlmaWNhdGlvbkNvbmZpZ3VyYXRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudE1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTm90aWZpY2F0aW9uQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzV1XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIk5vdGlmaWNhdGlvbkNvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiTm90aWZpY2F0aW9uQ29uZmlndXJhdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJkZXByZWNhdGVkXCI6IHRydWVcbiAgICB9LFxuICAgIFwiUHV0QnVja2V0Tm90aWZpY2F0aW9uQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/bm90aWZpY2F0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJOb3RpZmljYXRpb25Db25maWd1cmF0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk5vdGlmaWNhdGlvbkNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM2NVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJOb3RpZmljYXRpb25Db25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIk5vdGlmaWNhdGlvbkNvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRQb2xpY3lcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3BvbGljeVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiUG9saWN5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbmZpcm1SZW1vdmVTZWxmQnVja2V0QWNjZXNzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29uZmlybS1yZW1vdmUtc2VsZi1idWNrZXQtYWNjZXNzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUG9saWN5XCI6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIlBvbGljeVwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dEJ1Y2tldFJlcGxpY2F0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9yZXBsaWNhdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiUmVwbGljYXRpb25Db25maWd1cmF0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcGxpY2F0aW9uQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzZzXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlJlcGxpY2F0aW9uQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlRva2VuXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotYnVja2V0LW9iamVjdC1sb2NrLXRva2VuXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIlJlcGxpY2F0aW9uQ29uZmlndXJhdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dEJ1Y2tldFJlcXVlc3RQYXltZW50XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9yZXF1ZXN0UGF5bWVudFwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiUmVxdWVzdFBheW1lbnRDb25maWd1cmF0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXltZW50Q29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlJlcXVlc3RQYXltZW50Q29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgXCJQYXllclwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJQYXllclwiOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiUmVxdWVzdFBheW1lbnRDb25maWd1cmF0aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0QnVja2V0VGFnZ2luZ1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/dGFnZ2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiVGFnZ2luZ1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJUYWdnaW5nXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTYzFcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiVGFnZ2luZ1wiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJUYWdnaW5nXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0QnVja2V0VmVyc2lvbmluZ1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/dmVyc2lvbmluZ1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiVmVyc2lvbmluZ0NvbmZpZ3VyYXRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudE1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTUZBXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotbWZhXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbmluZ0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJWZXJzaW9uaW5nQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIk1GQURlbGV0ZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJNZmFEZWxldGVcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIlN0YXR1c1wiOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiVmVyc2lvbmluZ0NvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRXZWJzaXRlXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT93ZWJzaXRlXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJXZWJzaXRlQ29uZmlndXJhdGlvblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJXZWJzaXRlQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIldlYnNpdGVDb25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiRXJyb3JEb2N1bWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM3eVwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiSW5kZXhEb2N1bWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM3d1wiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiUmVkaXJlY3RBbGxSZXF1ZXN0c1RvXCI6IHtcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzd0XCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJSb3V0aW5nUnVsZXNcIjoge1xuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTN3pcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJXZWJzaXRlQ29uZmlndXJhdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dE9iamVjdFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9XCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQUNMXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotYWNsXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQm9keVwiOiB7XG4gICAgICAgICAgICBcInN0cmVhbWluZ1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYmxvYlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNhY2hlQ29udHJvbFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNhY2hlLUNvbnRyb2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50RGlzcG9zaXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LURpc3Bvc2l0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudEVuY29kaW5nXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1FbmNvZGluZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRMYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTGFuZ3VhZ2VcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TGVuZ3RoXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1MZW5ndGhcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxvbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50VHlwZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtVHlwZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGlyZXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJFeHBpcmVzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudEZ1bGxDb250cm9sXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtZnVsbC1jb250cm9sXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRSZWFkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtcmVhZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50UmVhZEFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXJlYWQtYWNwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRXcml0ZUFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXdyaXRlLWFjcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMTFcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJzXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW1ldGEtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU2VydmVyU2lkZUVuY3J5cHRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3RvcmFnZUNsYXNzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc3RvcmFnZS1jbGFzc1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIldlYnNpdGVSZWRpcmVjdExvY2F0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotd2Vic2l0ZS1yZWRpcmVjdC1sb2NhdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzE5XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VLTVNLZXlJZFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2pcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1hd3Mta21zLWtleS1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUtNU0VuY3J5cHRpb25Db250ZXh0XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jb250ZXh0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlRhZ2dpbmdcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei10YWdnaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT2JqZWN0TG9ja01vZGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1vYmplY3QtbG9jay1tb2RlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT2JqZWN0TG9ja1JldGFpblVudGlsRGF0ZVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFoXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW9iamVjdC1sb2NrLXJldGFpbi11bnRpbC1kYXRlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT2JqZWN0TG9ja0xlZ2FsSG9sZFN0YXR1c1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW9iamVjdC1sb2NrLWxlZ2FsLWhvbGRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiQm9keVwiXG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkV4cGlyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBpcmF0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRVRhZ1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkVUYWdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei12ZXJzaW9uLWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TS2V5SWRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNqXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYXdzLWttcy1rZXktaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VLTVNFbmNyeXB0aW9uQ29udGV4dFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFiXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY29udGV4dFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0T2JqZWN0QWNsXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K30/YWNsXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQUNMXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotYWNsXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQWNjZXNzQ29udHJvbFBvbGljeVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2JlXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkFjY2Vzc0NvbnRyb2xQb2xpY3lcIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudEZ1bGxDb250cm9sXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtZnVsbC1jb250cm9sXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRSZWFkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtcmVhZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50UmVhZEFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXJlYWQtYWNwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRXcml0ZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXdyaXRlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRXcml0ZUFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXdyaXRlLWFjcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInZlcnNpb25JZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJBY2Nlc3NDb250cm9sUG9saWN5XCJcbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUmVxdWVzdENoYXJnZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRPYmplY3RMZWdhbEhvbGRcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfT9sZWdhbC1ob2xkXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTGVnYWxIb2xkXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTOHlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiTGVnYWxIb2xkXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidmVyc2lvbklkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudE1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkxlZ2FsSG9sZFwiXG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0T2JqZWN0TG9ja0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P29iamVjdC1sb2NrXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk9iamVjdExvY2tDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTOTFcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiT2JqZWN0TG9ja0NvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVG9rZW5cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1idWNrZXQtb2JqZWN0LWxvY2stdG9rZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiT2JqZWN0TG9ja0NvbmZpZ3VyYXRpb25cIlxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dE9iamVjdFJldGVudGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9P3JldGVudGlvblwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJldGVudGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzk5XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlJldGVudGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInZlcnNpb25JZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ5cGFzc0dvdmVybmFuY2VSZXRlbnRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ieXBhc3MtZ292ZXJuYW5jZS1yZXRlbnRpb25cIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiUmV0ZW50aW9uXCJcbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUmVxdWVzdENoYXJnZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRPYmplY3RUYWdnaW5nXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K30/dGFnZ2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCIsXG4gICAgICAgICAgXCJUYWdnaW5nXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidmVyc2lvbklkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudE1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVGFnZ2luZ1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2MxXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlRhZ2dpbmdcIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiVGFnZ2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXZlcnNpb24taWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRQdWJsaWNBY2Nlc3NCbG9ja1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/cHVibGljQWNjZXNzQmxvY2tcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIlB1YmxpY0FjY2Vzc0Jsb2NrQ29uZmlndXJhdGlvblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQdWJsaWNBY2Nlc3NCbG9ja0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM5Z1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJQdWJsaWNBY2Nlc3NCbG9ja0NvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiUHVibGljQWNjZXNzQmxvY2tDb25maWd1cmF0aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUmVzdG9yZU9iamVjdFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9P3Jlc3RvcmVcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInZlcnNpb25JZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlc3RvcmVSZXF1ZXN0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiUmVzdG9yZVJlcXVlc3RcIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJEYXlzXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJHbGFjaWVySm9iUGFyYW1ldGVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgICAgICBcIlRpZXJcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwiVGllclwiOiB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJUeXBlXCI6IHt9LFxuICAgICAgICAgICAgICBcIlRpZXJcIjoge30sXG4gICAgICAgICAgICAgIFwiRGVzY3JpcHRpb25cIjoge30sXG4gICAgICAgICAgICAgIFwiU2VsZWN0UGFyYW1ldGVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgICAgICBcIklucHV0U2VyaWFsaXphdGlvblwiLFxuICAgICAgICAgICAgICAgICAgXCJFeHByZXNzaW9uVHlwZVwiLFxuICAgICAgICAgICAgICAgICAgXCJFeHByZXNzaW9uXCIsXG4gICAgICAgICAgICAgICAgICBcIk91dHB1dFNlcmlhbGl6YXRpb25cIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwiSW5wdXRTZXJpYWxpemF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNjclwiXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJFeHByZXNzaW9uVHlwZVwiOiB7fSxcbiAgICAgICAgICAgICAgICAgIFwiRXhwcmVzc2lvblwiOiB7fSxcbiAgICAgICAgICAgICAgICAgIFwiT3V0cHV0U2VyaWFsaXphdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTZDZcIlxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJPdXRwdXRMb2NhdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwiUzNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJCdWNrZXROYW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJQcmVmaXhcIlxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiQnVja2V0TmFtZVwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICBcIkVuY3J5cHRpb25cIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJFbmNyeXB0aW9uVHlwZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJFbmNyeXB0aW9uVHlwZVwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJLTVNLZXlJZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNqXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJLTVNDb250ZXh0XCI6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcIkNhbm5lZEFDTFwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICBcIkFjY2Vzc0NvbnRyb2xMaXN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMzVcIlxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJUYWdnaW5nXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTYzFcIlxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJVc2VyTWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIk1ldGFkYXRhRW50cnlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJOYW1lXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVmFsdWVcIjoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJTdG9yYWdlQ2xhc3NcIjoge31cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIlJlc3RvcmVSZXF1ZXN0XCJcbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUmVxdWVzdENoYXJnZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXN0b3JlT3V0cHV0UGF0aFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlc3RvcmUtb3V0cHV0LXBhdGhcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiYWxpYXNcIjogXCJQb3N0T2JqZWN0UmVzdG9yZVwiXG4gICAgfSxcbiAgICBcIlNlbGVjdE9iamVjdENvbnRlbnRcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfT9zZWxlY3Qmc2VsZWN0LXR5cGU9MlwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiU2VsZWN0T2JqZWN0Q29udGVudFJlcXVlc3RcIixcbiAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIixcbiAgICAgICAgICBcIkV4cHJlc3Npb25cIixcbiAgICAgICAgICBcIkV4cHJlc3Npb25UeXBlXCIsXG4gICAgICAgICAgXCJJbnB1dFNlcmlhbGl6YXRpb25cIixcbiAgICAgICAgICBcIk91dHB1dFNlcmlhbGl6YXRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMTlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cHJlc3Npb25cIjoge30sXG4gICAgICAgICAgXCJFeHByZXNzaW9uVHlwZVwiOiB7fSxcbiAgICAgICAgICBcIlJlcXVlc3RQcm9ncmVzc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiRW5hYmxlZFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSW5wdXRTZXJpYWxpemF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTY3JcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPdXRwdXRTZXJpYWxpemF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTZDZcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTY2FuUmFuZ2VcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIlN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJsb25nXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJFbmRcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImxvbmdcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlBheWxvYWRcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIlJlY29yZHNcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICBcIlBheWxvYWRcIjoge1xuICAgICAgICAgICAgICAgICAgICBcImV2ZW50cGF5bG9hZFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJibG9iXCJcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZXZlbnRcIjogdHJ1ZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIlN0YXRzXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJEZXRhaWxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJldmVudHBheWxvYWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJCeXRlc1NjYW5uZWRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcIkJ5dGVzUHJvY2Vzc2VkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImxvbmdcIlxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJCeXRlc1JldHVybmVkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImxvbmdcIlxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJldmVudFwiOiB0cnVlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiUHJvZ3Jlc3NcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICBcIkRldGFpbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcImV2ZW50cGF5bG9hZFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcIkJ5dGVzU2Nhbm5lZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJsb25nXCJcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiQnl0ZXNQcm9jZXNzZWRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcIkJ5dGVzUmV0dXJuZWRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImV2ZW50XCI6IHRydWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJDb250XCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge30sXG4gICAgICAgICAgICAgICAgXCJldmVudFwiOiB0cnVlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiRW5kXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge30sXG4gICAgICAgICAgICAgICAgXCJldmVudFwiOiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImV2ZW50c3RyZWFtXCI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIlBheWxvYWRcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJVcGxvYWRQYXJ0XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K31cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiLFxuICAgICAgICAgIFwiUGFydE51bWJlclwiLFxuICAgICAgICAgIFwiVXBsb2FkSWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQm9keVwiOiB7XG4gICAgICAgICAgICBcInN0cmVhbWluZ1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYmxvYlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRMZW5ndGhcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LUxlbmd0aFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBhcnROdW1iZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInBhcnROdW1iZXJcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJVcGxvYWRJZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidXBsb2FkSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxOVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJCb2R5XCJcbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiU2VydmVyU2lkZUVuY3J5cHRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRVRhZ1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkVUYWdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VLTVNLZXlJZFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2pcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1hd3Mta21zLWtleS1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiVXBsb2FkUGFydENvcHlcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiQ29weVNvdXJjZVwiLFxuICAgICAgICAgIFwiS2V5XCIsXG4gICAgICAgICAgXCJQYXJ0TnVtYmVyXCIsXG4gICAgICAgICAgXCJVcGxvYWRJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb3B5U291cmNlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2VcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb3B5U291cmNlSWZNYXRjaFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlLWlmLW1hdGNoXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZUlmTW9kaWZpZWRTaW5jZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlLWlmLW1vZGlmaWVkLXNpbmNlXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb3B5U291cmNlSWZOb25lTWF0Y2hcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZS1pZi1ub25lLW1hdGNoXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZUlmVW5tb2RpZmllZFNpbmNlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2UtaWYtdW5tb2RpZmllZC1zaW5jZVwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZVJhbmdlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2UtcmFuZ2VcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQYXJ0TnVtYmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJwYXJ0TnVtYmVyXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVXBsb2FkSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInVwbG9hZElkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMTlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VTU0VDdXN0b21lckFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlLXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZVNTRUN1c3RvbWVyS2V5XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWRcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2Utc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb3B5U291cmNlU1NFQ3VzdG9tZXJLZXlNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZS1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQ29weVNvdXJjZVZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlLXZlcnNpb24taWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb3B5UGFydFJlc3VsdFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiRVRhZ1wiOiB7fSxcbiAgICAgICAgICAgICAgXCJMYXN0TW9kaWZpZWRcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU2VydmVyU2lkZUVuY3J5cHRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TS2V5SWRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNqXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYXdzLWttcy1rZXktaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJDb3B5UGFydFJlc3VsdFwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcInNoYXBlc1wiOiB7XG4gICAgXCJTalwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwic2Vuc2l0aXZlXCI6IHRydWVcbiAgICB9LFxuICAgIFwiUzExXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm1hcFwiLFxuICAgICAgXCJrZXlcIjoge30sXG4gICAgICBcInZhbHVlXCI6IHt9XG4gICAgfSxcbiAgICBcIlMxOVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJibG9iXCIsXG4gICAgICBcInNlbnNpdGl2ZVwiOiB0cnVlXG4gICAgfSxcbiAgICBcIlMxYlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwic2Vuc2l0aXZlXCI6IHRydWVcbiAgICB9LFxuICAgIFwiUzFkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJsb2JcIixcbiAgICAgIFwic2Vuc2l0aXZlXCI6IHRydWVcbiAgICB9LFxuICAgIFwiUzFoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiLFxuICAgICAgXCJ0aW1lc3RhbXBGb3JtYXRcIjogXCJpc284NjAxXCJcbiAgICB9LFxuICAgIFwiUzMyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJEaXNwbGF5TmFtZVwiOiB7fSxcbiAgICAgICAgXCJJRFwiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTMzVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkdyYW50XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiR3JhbnRlZVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzM3XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUGVybWlzc2lvblwiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlMzN1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICBcIlR5cGVcIlxuICAgICAgXSxcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiRGlzcGxheU5hbWVcIjoge30sXG4gICAgICAgIFwiRW1haWxBZGRyZXNzXCI6IHt9LFxuICAgICAgICBcIklEXCI6IHt9LFxuICAgICAgICBcIlR5cGVcIjoge1xuICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieHNpOnR5cGVcIixcbiAgICAgICAgICBcInhtbEF0dHJpYnV0ZVwiOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIFwiVVJJXCI6IHt9XG4gICAgICB9LFxuICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICBcInByZWZpeFwiOiBcInhzaVwiLFxuICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hLWluc3RhbmNlXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzNlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiSWRcIixcbiAgICAgICAgXCJTdG9yYWdlQ2xhc3NBbmFseXNpc1wiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJJZFwiOiB7fSxcbiAgICAgICAgXCJGaWx0ZXJcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICAgIFwiVGFnXCI6IHtcbiAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzaFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJBbmRcIjoge1xuICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIlRhZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMza1wiLFxuICAgICAgICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiVGFnXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiU3RvcmFnZUNsYXNzQW5hbHlzaXNcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICBcIkRhdGFFeHBvcnRcIjoge1xuICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgICAgXCJPdXRwdXRTY2hlbWFWZXJzaW9uXCIsXG4gICAgICAgICAgICAgICAgXCJEZXN0aW5hdGlvblwiXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJPdXRwdXRTY2hlbWFWZXJzaW9uXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiRGVzdGluYXRpb25cIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJTM0J1Y2tldERlc3RpbmF0aW9uXCJcbiAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIlMzQnVja2V0RGVzdGluYXRpb25cIjoge1xuICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJGb3JtYXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIkZvcm1hdFwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQnVja2V0QWNjb3VudElkXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJCdWNrZXRcIjoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlByZWZpeFwiOiB7fVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTM2hcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgXCJLZXlcIixcbiAgICAgICAgXCJWYWx1ZVwiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJLZXlcIjoge30sXG4gICAgICAgIFwiVmFsdWVcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzNrXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgXCJzaGFwZVwiOiBcIlMzaFwiLFxuICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlRhZ1wiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlMzdVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkFsbG93ZWRNZXRob2RzXCIsXG4gICAgICAgICAgXCJBbGxvd2VkT3JpZ2luc1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJBbGxvd2VkSGVhZGVyc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkFsbG93ZWRIZWFkZXJcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHt9LFxuICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJBbGxvd2VkTWV0aG9kc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkFsbG93ZWRNZXRob2RcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHt9LFxuICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJBbGxvd2VkT3JpZ2luc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkFsbG93ZWRPcmlnaW5cIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHt9LFxuICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBvc2VIZWFkZXJzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRXhwb3NlSGVhZGVyXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7fSxcbiAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWF4QWdlU2Vjb25kc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIlM0N1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICBcIlJ1bGVzXCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIlJ1bGVzXCI6IHtcbiAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlJ1bGVcIixcbiAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIkFwcGx5U2VydmVyU2lkZUVuY3J5cHRpb25CeURlZmF1bHRcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgICAgXCJTU0VBbGdvcml0aG1cIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwiU1NFQWxnb3JpdGhtXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgXCJLTVNNYXN0ZXJLZXlJRFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTalwiXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzRkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiRGVzdGluYXRpb25cIixcbiAgICAgICAgXCJJc0VuYWJsZWRcIixcbiAgICAgICAgXCJJZFwiLFxuICAgICAgICBcIkluY2x1ZGVkT2JqZWN0VmVyc2lvbnNcIixcbiAgICAgICAgXCJTY2hlZHVsZVwiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJEZXN0aW5hdGlvblwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICBcIlMzQnVja2V0RGVzdGluYXRpb25cIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgIFwiUzNCdWNrZXREZXN0aW5hdGlvblwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgICAgICAgIFwiRm9ybWF0XCJcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcIkFjY291bnRJZFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIkJ1Y2tldFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIkZvcm1hdFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIkVuY3J5cHRpb25cIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIlNTRVMzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlNTRS1TM1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcIlNTRUtNU1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJTU0UtS01TXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIktleUlkXCJcbiAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIktleUlkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNqXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiSXNFbmFibGVkXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJGaWx0ZXJcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgXCJQcmVmaXhcIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgIFwiUHJlZml4XCI6IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIklkXCI6IHt9LFxuICAgICAgICBcIkluY2x1ZGVkT2JqZWN0VmVyc2lvbnNcIjoge30sXG4gICAgICAgIFwiT3B0aW9uYWxGaWVsZHNcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkZpZWxkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiU2NoZWR1bGVcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgXCJGcmVxdWVuY3lcIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgIFwiRnJlcXVlbmN5XCI6IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlM0dFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIlByZWZpeFwiLFxuICAgICAgICAgIFwiU3RhdHVzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkV4cGlyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM0dlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklEXCI6IHt9LFxuICAgICAgICAgIFwiUHJlZml4XCI6IHt9LFxuICAgICAgICAgIFwiU3RhdHVzXCI6IHt9LFxuICAgICAgICAgIFwiVHJhbnNpdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzUwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTm9uY3VycmVudFZlcnNpb25UcmFuc2l0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNTJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJOb25jdXJyZW50VmVyc2lvbkV4cGlyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1M1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkFib3J0SW5jb21wbGV0ZU11bHRpcGFydFVwbG9hZFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzU0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIlM0dlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiRGF0ZVwiOiB7XG4gICAgICAgICAgXCJzaGFwZVwiOiBcIlM0d1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiRGF5c1wiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiRXhwaXJlZE9iamVjdERlbGV0ZU1hcmtlclwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzR3XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiLFxuICAgICAgXCJ0aW1lc3RhbXBGb3JtYXRcIjogXCJpc284NjAxXCJcbiAgICB9LFxuICAgIFwiUzUwXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJEYXRlXCI6IHtcbiAgICAgICAgICBcInNoYXBlXCI6IFwiUzR3XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJEYXlzXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJTdG9yYWdlQ2xhc3NcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzUyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJOb25jdXJyZW50RGF5c1wiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiU3RvcmFnZUNsYXNzXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlM1M1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiTm9uY3VycmVudERheXNcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlM1NFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiRGF5c0FmdGVySW5pdGlhdGlvblwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzU4XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiU3RhdHVzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkV4cGlyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM0dlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklEXCI6IHt9LFxuICAgICAgICAgIFwiUHJlZml4XCI6IHtcbiAgICAgICAgICAgIFwiZGVwcmVjYXRlZFwiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkZpbHRlclwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiUHJlZml4XCI6IHt9LFxuICAgICAgICAgICAgICBcIlRhZ1wiOiB7XG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzaFwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiQW5kXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJQcmVmaXhcIjoge30sXG4gICAgICAgICAgICAgICAgICBcIlRhZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzNrXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiVGFnXCJcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3RhdHVzXCI6IHt9LFxuICAgICAgICAgIFwiVHJhbnNpdGlvbnNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJUcmFuc2l0aW9uXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNTBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTm9uY3VycmVudFZlcnNpb25UcmFuc2l0aW9uc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIk5vbmN1cnJlbnRWZXJzaW9uVHJhbnNpdGlvblwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzUyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk5vbmN1cnJlbnRWZXJzaW9uRXhwaXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzUzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQWJvcnRJbmNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNTRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICB9LFxuICAgIFwiUzVpXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiVGFyZ2V0QnVja2V0XCIsXG4gICAgICAgIFwiVGFyZ2V0UHJlZml4XCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIlRhcmdldEJ1Y2tldFwiOiB7fSxcbiAgICAgICAgXCJUYXJnZXRHcmFudHNcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkdyYW50XCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiR3JhbnRlZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzN1wiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiUGVybWlzc2lvblwiOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJUYXJnZXRQcmVmaXhcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzVxXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiSWRcIlxuICAgICAgXSxcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiSWRcIjoge30sXG4gICAgICAgIFwiRmlsdGVyXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgXCJQcmVmaXhcIjoge30sXG4gICAgICAgICAgICBcIlRhZ1wiOiB7XG4gICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM2hcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiQW5kXCI6IHtcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJQcmVmaXhcIjoge30sXG4gICAgICAgICAgICAgICAgXCJUYWdzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM2tcIixcbiAgICAgICAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlRhZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlM1dFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzV1XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJUb3BpY0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICBcIklkXCI6IHt9LFxuICAgICAgICAgICAgXCJFdmVudHNcIjoge1xuICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzV4XCIsXG4gICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRXZlbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiRXZlbnRcIjoge1xuICAgICAgICAgICAgICBcImRlcHJlY2F0ZWRcIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiVG9waWNcIjoge31cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiUXVldWVDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgXCJJZFwiOiB7fSxcbiAgICAgICAgICAgIFwiRXZlbnRcIjoge1xuICAgICAgICAgICAgICBcImRlcHJlY2F0ZWRcIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiRXZlbnRzXCI6IHtcbiAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1eFwiLFxuICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkV2ZW50XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIlF1ZXVlXCI6IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIkNsb3VkRnVuY3Rpb25Db25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgXCJJZFwiOiB7fSxcbiAgICAgICAgICAgIFwiRXZlbnRcIjoge1xuICAgICAgICAgICAgICBcImRlcHJlY2F0ZWRcIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiRXZlbnRzXCI6IHtcbiAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1eFwiLFxuICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkV2ZW50XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIkNsb3VkRnVuY3Rpb25cIjoge30sXG4gICAgICAgICAgICBcIkludm9jYXRpb25Sb2xlXCI6IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlM1eFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICBcIm1lbWJlclwiOiB7fSxcbiAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICB9LFxuICAgIFwiUzY1XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJUb3BpY0NvbmZpZ3VyYXRpb25zXCI6IHtcbiAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlRvcGljQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICBcIlRvcGljQXJuXCIsXG4gICAgICAgICAgICAgIFwiRXZlbnRzXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIklkXCI6IHt9LFxuICAgICAgICAgICAgICBcIlRvcGljQXJuXCI6IHtcbiAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlRvcGljXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJFdmVudHNcIjoge1xuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNXhcIixcbiAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkV2ZW50XCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJGaWx0ZXJcIjoge1xuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNjhcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIFwiUXVldWVDb25maWd1cmF0aW9uc1wiOiB7XG4gICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJRdWV1ZUNvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgXCJRdWV1ZUFyblwiLFxuICAgICAgICAgICAgICBcIkV2ZW50c1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJJZFwiOiB7fSxcbiAgICAgICAgICAgICAgXCJRdWV1ZUFyblwiOiB7XG4gICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJRdWV1ZVwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiRXZlbnRzXCI6IHtcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzV4XCIsXG4gICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJFdmVudFwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiRmlsdGVyXCI6IHtcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzY4XCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBcIkxhbWJkYUZ1bmN0aW9uQ29uZmlndXJhdGlvbnNcIjoge1xuICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ2xvdWRGdW5jdGlvbkNvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgXCJMYW1iZGFGdW5jdGlvbkFyblwiLFxuICAgICAgICAgICAgICBcIkV2ZW50c1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJJZFwiOiB7fSxcbiAgICAgICAgICAgICAgXCJMYW1iZGFGdW5jdGlvbkFyblwiOiB7XG4gICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDbG91ZEZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJFdmVudHNcIjoge1xuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNXhcIixcbiAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkV2ZW50XCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJGaWx0ZXJcIjoge1xuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNjhcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzY4XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiUzNLZXlcIixcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgXCJGaWx0ZXJSdWxlc1wiOiB7XG4gICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRmlsdGVyUnVsZVwiLFxuICAgICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJOYW1lXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgXCJWYWx1ZVwiOiB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTNnNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgXCJSb2xlXCIsXG4gICAgICAgIFwiUnVsZXNcIlxuICAgICAgXSxcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiUm9sZVwiOiB7fSxcbiAgICAgICAgXCJSdWxlc1wiOiB7XG4gICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJSdWxlXCIsXG4gICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgIFwiU3RhdHVzXCIsXG4gICAgICAgICAgICAgIFwiRGVzdGluYXRpb25cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiSURcIjoge30sXG4gICAgICAgICAgICAgIFwiUHJpb3JpdHlcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIlByZWZpeFwiOiB7XG4gICAgICAgICAgICAgICAgXCJkZXByZWNhdGVkXCI6IHRydWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJGaWx0ZXJcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICAgICAgICAgIFwiVGFnXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzaFwiXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJBbmRcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICBcIlRhZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMza1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiVGFnXCJcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiU3RhdHVzXCI6IHt9LFxuICAgICAgICAgICAgICBcIlNvdXJjZVNlbGVjdGlvbkNyaXRlcmlhXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJTc2VLbXNFbmNyeXB0ZWRPYmplY3RzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiU3RhdHVzXCJcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcIlN0YXR1c1wiOiB7fVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIkV4aXN0aW5nT2JqZWN0UmVwbGljYXRpb25cIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgICAgXCJTdGF0dXNcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwiU3RhdHVzXCI6IHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIkRlc3RpbmF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICBcIkJ1Y2tldFwiOiB7fSxcbiAgICAgICAgICAgICAgICAgIFwiQWNjb3VudFwiOiB7fSxcbiAgICAgICAgICAgICAgICAgIFwiU3RvcmFnZUNsYXNzXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgXCJBY2Nlc3NDb250cm9sVHJhbnNsYXRpb25cIjoge1xuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJPd25lclwiXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJPd25lclwiOiB7fVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJFbmNyeXB0aW9uQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiUmVwbGljYUttc0tleUlEXCI6IHt9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcIlJlcGxpY2F0aW9uVGltZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIlN0YXR1c1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiVGltZVwiXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJTdGF0dXNcIjoge30sXG4gICAgICAgICAgICAgICAgICAgICAgXCJUaW1lXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTN2NcIlxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiTWV0cmljc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIlN0YXR1c1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXZlbnRUaHJlc2hvbGRcIlxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiU3RhdHVzXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiRXZlbnRUaHJlc2hvbGRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM3Y1wiXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIkRlbGV0ZU1hcmtlclJlcGxpY2F0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJTdGF0dXNcIjoge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTN2NcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIk1pbnV0ZXNcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlM3dFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICBcIkhvc3ROYW1lXCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIkhvc3ROYW1lXCI6IHt9LFxuICAgICAgICBcIlByb3RvY29sXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlM3d1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICBcIlN1ZmZpeFwiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJTdWZmaXhcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzd5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiS2V5XCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIktleVwiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTN3pcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlJvdXRpbmdSdWxlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIlJlZGlyZWN0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkNvbmRpdGlvblwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiSHR0cEVycm9yQ29kZVJldHVybmVkRXF1YWxzXCI6IHt9LFxuICAgICAgICAgICAgICBcIktleVByZWZpeEVxdWFsc1wiOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZWRpcmVjdFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiSG9zdE5hbWVcIjoge30sXG4gICAgICAgICAgICAgIFwiSHR0cFJlZGlyZWN0Q29kZVwiOiB7fSxcbiAgICAgICAgICAgICAgXCJQcm90b2NvbFwiOiB7fSxcbiAgICAgICAgICAgICAgXCJSZXBsYWNlS2V5UHJlZml4V2l0aFwiOiB7fSxcbiAgICAgICAgICAgICAgXCJSZXBsYWNlS2V5V2l0aFwiOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTOHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIlN0YXR1c1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTOTFcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIk9iamVjdExvY2tFbmFibGVkXCI6IHt9LFxuICAgICAgICBcIlJ1bGVcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICBcIkRlZmF1bHRSZXRlbnRpb25cIjoge1xuICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcIk1vZGVcIjoge30sXG4gICAgICAgICAgICAgICAgXCJEYXlzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJZZWFyc1wiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzk5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJNb2RlXCI6IHt9LFxuICAgICAgICBcIlJldGFpblVudGlsRGF0ZVwiOiB7XG4gICAgICAgICAgXCJzaGFwZVwiOiBcIlM0d1wiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzlnXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJCbG9ja1B1YmxpY0FjbHNcIjoge1xuICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQmxvY2tQdWJsaWNBY2xzXCIsXG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiSWdub3JlUHVibGljQWNsc1wiOiB7XG4gICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJJZ25vcmVQdWJsaWNBY2xzXCIsXG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiQmxvY2tQdWJsaWNQb2xpY3lcIjoge1xuICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQmxvY2tQdWJsaWNQb2xpY3lcIixcbiAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJSZXN0cmljdFB1YmxpY0J1Y2tldHNcIjoge1xuICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiUmVzdHJpY3RQdWJsaWNCdWNrZXRzXCIsXG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiU2FkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJJRFwiOiB7fSxcbiAgICAgICAgXCJEaXNwbGF5TmFtZVwiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTYWVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlByZWZpeFwiOiB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJTYXdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIktleVwiOiB7fSxcbiAgICAgICAgICBcIkxhc3RNb2RpZmllZFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFVGFnXCI6IHt9LFxuICAgICAgICAgIFwiU2l6ZVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3RvcmFnZUNsYXNzXCI6IHt9LFxuICAgICAgICAgIFwiT3duZXJcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzMlwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJTYmVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIkdyYW50c1wiOiB7XG4gICAgICAgICAgXCJzaGFwZVwiOiBcIlMzNVwiLFxuICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQWNjZXNzQ29udHJvbExpc3RcIlxuICAgICAgICB9LFxuICAgICAgICBcIk93bmVyXCI6IHtcbiAgICAgICAgICBcInNoYXBlXCI6IFwiUzMyXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTYzFcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgXCJUYWdTZXRcIlxuICAgICAgXSxcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiVGFnU2V0XCI6IHtcbiAgICAgICAgICBcInNoYXBlXCI6IFwiUzNrXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTY3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIkNTVlwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgIFwiRmlsZUhlYWRlckluZm9cIjoge30sXG4gICAgICAgICAgICBcIkNvbW1lbnRzXCI6IHt9LFxuICAgICAgICAgICAgXCJRdW90ZUVzY2FwZUNoYXJhY3RlclwiOiB7fSxcbiAgICAgICAgICAgIFwiUmVjb3JkRGVsaW1pdGVyXCI6IHt9LFxuICAgICAgICAgICAgXCJGaWVsZERlbGltaXRlclwiOiB7fSxcbiAgICAgICAgICAgIFwiUXVvdGVDaGFyYWN0ZXJcIjoge30sXG4gICAgICAgICAgICBcIkFsbG93UXVvdGVkUmVjb3JkRGVsaW1pdGVyXCI6IHtcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIkNvbXByZXNzaW9uVHlwZVwiOiB7fSxcbiAgICAgICAgXCJKU09OXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgXCJUeXBlXCI6IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIlBhcnF1ZXRcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwibWVtYmVyc1wiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlNkNlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiQ1NWXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgXCJRdW90ZUZpZWxkc1wiOiB7fSxcbiAgICAgICAgICAgIFwiUXVvdGVFc2NhcGVDaGFyYWN0ZXJcIjoge30sXG4gICAgICAgICAgICBcIlJlY29yZERlbGltaXRlclwiOiB7fSxcbiAgICAgICAgICAgIFwiRmllbGREZWxpbWl0ZXJcIjoge30sXG4gICAgICAgICAgICBcIlF1b3RlQ2hhcmFjdGVyXCI6IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIkpTT05cIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICBcIlJlY29yZERlbGltaXRlclwiOiB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJwYWdpbmF0aW9uXCI6IHtcbiAgICBcIkxpc3RCdWNrZXRzXCI6IHtcbiAgICAgIFwicmVzdWx0X2tleVwiOiBcIkJ1Y2tldHNcIlxuICAgIH0sXG4gICAgXCJMaXN0TXVsdGlwYXJ0VXBsb2Fkc1wiOiB7XG4gICAgICBcImlucHV0X3Rva2VuXCI6IFtcbiAgICAgICAgXCJLZXlNYXJrZXJcIixcbiAgICAgICAgXCJVcGxvYWRJZE1hcmtlclwiXG4gICAgICBdLFxuICAgICAgXCJsaW1pdF9rZXlcIjogXCJNYXhVcGxvYWRzXCIsXG4gICAgICBcIm1vcmVfcmVzdWx0c1wiOiBcIklzVHJ1bmNhdGVkXCIsXG4gICAgICBcIm91dHB1dF90b2tlblwiOiBbXG4gICAgICAgIFwiTmV4dEtleU1hcmtlclwiLFxuICAgICAgICBcIk5leHRVcGxvYWRJZE1hcmtlclwiXG4gICAgICBdLFxuICAgICAgXCJyZXN1bHRfa2V5XCI6IFtcbiAgICAgICAgXCJVcGxvYWRzXCIsXG4gICAgICAgIFwiQ29tbW9uUHJlZml4ZXNcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJMaXN0T2JqZWN0VmVyc2lvbnNcIjoge1xuICAgICAgXCJpbnB1dF90b2tlblwiOiBbXG4gICAgICAgIFwiS2V5TWFya2VyXCIsXG4gICAgICAgIFwiVmVyc2lvbklkTWFya2VyXCJcbiAgICAgIF0sXG4gICAgICBcImxpbWl0X2tleVwiOiBcIk1heEtleXNcIixcbiAgICAgIFwibW9yZV9yZXN1bHRzXCI6IFwiSXNUcnVuY2F0ZWRcIixcbiAgICAgIFwib3V0cHV0X3Rva2VuXCI6IFtcbiAgICAgICAgXCJOZXh0S2V5TWFya2VyXCIsXG4gICAgICAgIFwiTmV4dFZlcnNpb25JZE1hcmtlclwiXG4gICAgICBdLFxuICAgICAgXCJyZXN1bHRfa2V5XCI6IFtcbiAgICAgICAgXCJWZXJzaW9uc1wiLFxuICAgICAgICBcIkRlbGV0ZU1hcmtlcnNcIixcbiAgICAgICAgXCJDb21tb25QcmVmaXhlc1wiXG4gICAgICBdXG4gICAgfSxcbiAgICBcIkxpc3RPYmplY3RzXCI6IHtcbiAgICAgIFwiaW5wdXRfdG9rZW5cIjogXCJNYXJrZXJcIixcbiAgICAgIFwibGltaXRfa2V5XCI6IFwiTWF4S2V5c1wiLFxuICAgICAgXCJtb3JlX3Jlc3VsdHNcIjogXCJJc1RydW5jYXRlZFwiLFxuICAgICAgXCJvdXRwdXRfdG9rZW5cIjogXCJOZXh0TWFya2VyIHx8IENvbnRlbnRzWy0xXS5LZXlcIixcbiAgICAgIFwicmVzdWx0X2tleVwiOiBbXG4gICAgICAgIFwiQ29udGVudHNcIixcbiAgICAgICAgXCJDb21tb25QcmVmaXhlc1wiXG4gICAgICBdXG4gICAgfSxcbiAgICBcIkxpc3RPYmplY3RzVjJcIjoge1xuICAgICAgXCJpbnB1dF90b2tlblwiOiBcIkNvbnRpbnVhdGlvblRva2VuXCIsXG4gICAgICBcImxpbWl0X2tleVwiOiBcIk1heEtleXNcIixcbiAgICAgIFwib3V0cHV0X3Rva2VuXCI6IFwiTmV4dENvbnRpbnVhdGlvblRva2VuXCIsXG4gICAgICBcInJlc3VsdF9rZXlcIjogW1xuICAgICAgICBcIkNvbnRlbnRzXCIsXG4gICAgICAgIFwiQ29tbW9uUHJlZml4ZXNcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJMaXN0UGFydHNcIjoge1xuICAgICAgXCJpbnB1dF90b2tlblwiOiBcIlBhcnROdW1iZXJNYXJrZXJcIixcbiAgICAgIFwibGltaXRfa2V5XCI6IFwiTWF4UGFydHNcIixcbiAgICAgIFwibW9yZV9yZXN1bHRzXCI6IFwiSXNUcnVuY2F0ZWRcIixcbiAgICAgIFwib3V0cHV0X3Rva2VuXCI6IFwiTmV4dFBhcnROdW1iZXJNYXJrZXJcIixcbiAgICAgIFwicmVzdWx0X2tleVwiOiBcIlBhcnRzXCJcbiAgICB9XG4gIH1cbn0iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwidmVyc2lvblwiOiAyLFxuICBcIndhaXRlcnNcIjoge1xuICAgIFwiQnVja2V0RXhpc3RzXCI6IHtcbiAgICAgIFwiZGVsYXlcIjogNSxcbiAgICAgIFwib3BlcmF0aW9uXCI6IFwiSGVhZEJ1Y2tldFwiLFxuICAgICAgXCJtYXhBdHRlbXB0c1wiOiAyMCxcbiAgICAgIFwiYWNjZXB0b3JzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiZXhwZWN0ZWRcIjogMjAwLFxuICAgICAgICAgIFwibWF0Y2hlclwiOiBcInN0YXR1c1wiLFxuICAgICAgICAgIFwic3RhdGVcIjogXCJzdWNjZXNzXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwiZXhwZWN0ZWRcIjogMzAxLFxuICAgICAgICAgIFwibWF0Y2hlclwiOiBcInN0YXR1c1wiLFxuICAgICAgICAgIFwic3RhdGVcIjogXCJzdWNjZXNzXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwiZXhwZWN0ZWRcIjogNDAzLFxuICAgICAgICAgIFwibWF0Y2hlclwiOiBcInN0YXR1c1wiLFxuICAgICAgICAgIFwic3RhdGVcIjogXCJzdWNjZXNzXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwiZXhwZWN0ZWRcIjogNDA0LFxuICAgICAgICAgIFwibWF0Y2hlclwiOiBcInN0YXR1c1wiLFxuICAgICAgICAgIFwic3RhdGVcIjogXCJyZXRyeVwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiQnVja2V0Tm90RXhpc3RzXCI6IHtcbiAgICAgIFwiZGVsYXlcIjogNSxcbiAgICAgIFwib3BlcmF0aW9uXCI6IFwiSGVhZEJ1Y2tldFwiLFxuICAgICAgXCJtYXhBdHRlbXB0c1wiOiAyMCxcbiAgICAgIFwiYWNjZXB0b3JzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiZXhwZWN0ZWRcIjogNDA0LFxuICAgICAgICAgIFwibWF0Y2hlclwiOiBcInN0YXR1c1wiLFxuICAgICAgICAgIFwic3RhdGVcIjogXCJzdWNjZXNzXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJPYmplY3RFeGlzdHNcIjoge1xuICAgICAgXCJkZWxheVwiOiA1LFxuICAgICAgXCJvcGVyYXRpb25cIjogXCJIZWFkT2JqZWN0XCIsXG4gICAgICBcIm1heEF0dGVtcHRzXCI6IDIwLFxuICAgICAgXCJhY2NlcHRvcnNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJleHBlY3RlZFwiOiAyMDAsXG4gICAgICAgICAgXCJtYXRjaGVyXCI6IFwic3RhdHVzXCIsXG4gICAgICAgICAgXCJzdGF0ZVwiOiBcInN1Y2Nlc3NcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJleHBlY3RlZFwiOiA0MDQsXG4gICAgICAgICAgXCJtYXRjaGVyXCI6IFwic3RhdHVzXCIsXG4gICAgICAgICAgXCJzdGF0ZVwiOiBcInJldHJ5XCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJPYmplY3ROb3RFeGlzdHNcIjoge1xuICAgICAgXCJkZWxheVwiOiA1LFxuICAgICAgXCJvcGVyYXRpb25cIjogXCJIZWFkT2JqZWN0XCIsXG4gICAgICBcIm1heEF0dGVtcHRzXCI6IDIwLFxuICAgICAgXCJhY2NlcHRvcnNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJleHBlY3RlZFwiOiA0MDQsXG4gICAgICAgICAgXCJtYXRjaGVyXCI6IFwic3RhdHVzXCIsXG4gICAgICAgICAgXCJzdGF0ZVwiOiBcInN1Y2Nlc3NcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwidmVyc2lvblwiOiBcIjIuMFwiLFxuICBcIm1ldGFkYXRhXCI6IHtcbiAgICBcImFwaVZlcnNpb25cIjogXCIyMDExLTA2LTE1XCIsXG4gICAgXCJlbmRwb2ludFByZWZpeFwiOiBcInN0c1wiLFxuICAgIFwiZ2xvYmFsRW5kcG9pbnRcIjogXCJzdHMuYW1hem9uYXdzLmNvbVwiLFxuICAgIFwicHJvdG9jb2xcIjogXCJxdWVyeVwiLFxuICAgIFwic2VydmljZUFiYnJldmlhdGlvblwiOiBcIkFXUyBTVFNcIixcbiAgICBcInNlcnZpY2VGdWxsTmFtZVwiOiBcIkFXUyBTZWN1cml0eSBUb2tlbiBTZXJ2aWNlXCIsXG4gICAgXCJzZXJ2aWNlSWRcIjogXCJTVFNcIixcbiAgICBcInNpZ25hdHVyZVZlcnNpb25cIjogXCJ2NFwiLFxuICAgIFwidWlkXCI6IFwic3RzLTIwMTEtMDYtMTVcIixcbiAgICBcInhtbE5hbWVzcGFjZVwiOiBcImh0dHBzOi8vc3RzLmFtYXpvbmF3cy5jb20vZG9jLzIwMTEtMDYtMTUvXCJcbiAgfSxcbiAgXCJvcGVyYXRpb25zXCI6IHtcbiAgICBcIkFzc3VtZVJvbGVcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIlJvbGVBcm5cIixcbiAgICAgICAgICBcIlJvbGVTZXNzaW9uTmFtZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSb2xlQXJuXCI6IHt9LFxuICAgICAgICAgIFwiUm9sZVNlc3Npb25OYW1lXCI6IHt9LFxuICAgICAgICAgIFwiUG9saWN5QXJuc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQb2xpY3lcIjoge30sXG4gICAgICAgICAgXCJEdXJhdGlvblNlY29uZHNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlRhZ3NcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM4XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVHJhbnNpdGl2ZVRhZ0tleXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXh0ZXJuYWxJZFwiOiB7fSxcbiAgICAgICAgICBcIlNlcmlhbE51bWJlclwiOiB7fSxcbiAgICAgICAgICBcIlRva2VuQ29kZVwiOiB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInJlc3VsdFdyYXBwZXJcIjogXCJBc3N1bWVSb2xlUmVzdWx0XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQ3JlZGVudGlhbHNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNoXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQXNzdW1lZFJvbGVVc2VyXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTbVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBhY2tlZFBvbGljeVNpemVcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkFzc3VtZVJvbGVXaXRoU0FNTFwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiUm9sZUFyblwiLFxuICAgICAgICAgIFwiUHJpbmNpcGFsQXJuXCIsXG4gICAgICAgICAgXCJTQU1MQXNzZXJ0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlJvbGVBcm5cIjoge30sXG4gICAgICAgICAgXCJQcmluY2lwYWxBcm5cIjoge30sXG4gICAgICAgICAgXCJTQU1MQXNzZXJ0aW9uXCI6IHt9LFxuICAgICAgICAgIFwiUG9saWN5QXJuc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQb2xpY3lcIjoge30sXG4gICAgICAgICAgXCJEdXJhdGlvblNlY29uZHNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInJlc3VsdFdyYXBwZXJcIjogXCJBc3N1bWVSb2xlV2l0aFNBTUxSZXN1bHRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJDcmVkZW50aWFsc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2hcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJBc3N1bWVkUm9sZVVzZXJcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUGFja2VkUG9saWN5U2l6ZVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3ViamVjdFwiOiB7fSxcbiAgICAgICAgICBcIlN1YmplY3RUeXBlXCI6IHt9LFxuICAgICAgICAgIFwiSXNzdWVyXCI6IHt9LFxuICAgICAgICAgIFwiQXVkaWVuY2VcIjoge30sXG4gICAgICAgICAgXCJOYW1lUXVhbGlmaWVyXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiQXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eVwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiUm9sZUFyblwiLFxuICAgICAgICAgIFwiUm9sZVNlc3Npb25OYW1lXCIsXG4gICAgICAgICAgXCJXZWJJZGVudGl0eVRva2VuXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlJvbGVBcm5cIjoge30sXG4gICAgICAgICAgXCJSb2xlU2Vzc2lvbk5hbWVcIjoge30sXG4gICAgICAgICAgXCJXZWJJZGVudGl0eVRva2VuXCI6IHt9LFxuICAgICAgICAgIFwiUHJvdmlkZXJJZFwiOiB7fSxcbiAgICAgICAgICBcIlBvbGljeUFybnNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUG9saWN5XCI6IHt9LFxuICAgICAgICAgIFwiRHVyYXRpb25TZWNvbmRzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJyZXN1bHRXcmFwcGVyXCI6IFwiQXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eVJlc3VsdFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkNyZWRlbnRpYWxzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTaFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlN1YmplY3RGcm9tV2ViSWRlbnRpdHlUb2tlblwiOiB7fSxcbiAgICAgICAgICBcIkFzc3VtZWRSb2xlVXNlclwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU21cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQYWNrZWRQb2xpY3lTaXplXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQcm92aWRlclwiOiB7fSxcbiAgICAgICAgICBcIkF1ZGllbmNlXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVjb2RlQXV0aG9yaXphdGlvbk1lc3NhZ2VcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkVuY29kZWRNZXNzYWdlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkVuY29kZWRNZXNzYWdlXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwicmVzdWx0V3JhcHBlclwiOiBcIkRlY29kZUF1dGhvcml6YXRpb25NZXNzYWdlUmVzdWx0XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiRGVjb2RlZE1lc3NhZ2VcIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRBY2Nlc3NLZXlJbmZvXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJBY2Nlc3NLZXlJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJBY2Nlc3NLZXlJZFwiOiB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInJlc3VsdFdyYXBwZXJcIjogXCJHZXRBY2Nlc3NLZXlJbmZvUmVzdWx0XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQWNjb3VudFwiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldENhbGxlcklkZW50aXR5XCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHt9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInJlc3VsdFdyYXBwZXJcIjogXCJHZXRDYWxsZXJJZGVudGl0eVJlc3VsdFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlVzZXJJZFwiOiB7fSxcbiAgICAgICAgICBcIkFjY291bnRcIjoge30sXG4gICAgICAgICAgXCJBcm5cIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRGZWRlcmF0aW9uVG9rZW5cIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIk5hbWVcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiTmFtZVwiOiB7fSxcbiAgICAgICAgICBcIlBvbGljeVwiOiB7fSxcbiAgICAgICAgICBcIlBvbGljeUFybnNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRHVyYXRpb25TZWNvbmRzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJUYWdzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTOFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInJlc3VsdFdyYXBwZXJcIjogXCJHZXRGZWRlcmF0aW9uVG9rZW5SZXN1bHRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJDcmVkZW50aWFsc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2hcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJGZWRlcmF0ZWRVc2VyXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgIFwiRmVkZXJhdGVkVXNlcklkXCIsXG4gICAgICAgICAgICAgIFwiQXJuXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIkZlZGVyYXRlZFVzZXJJZFwiOiB7fSxcbiAgICAgICAgICAgICAgXCJBcm5cIjoge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUGFja2VkUG9saWN5U2l6ZVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0U2Vzc2lvblRva2VuXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkR1cmF0aW9uU2Vjb25kc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU2VyaWFsTnVtYmVyXCI6IHt9LFxuICAgICAgICAgIFwiVG9rZW5Db2RlXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwicmVzdWx0V3JhcHBlclwiOiBcIkdldFNlc3Npb25Ub2tlblJlc3VsdFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkNyZWRlbnRpYWxzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTaFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcInNoYXBlc1wiOiB7XG4gICAgXCJTNFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiYXJuXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJLZXlcIixcbiAgICAgICAgICBcIlZhbHVlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIktleVwiOiB7fSxcbiAgICAgICAgICBcIlZhbHVlXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiU2hcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgXCJBY2Nlc3NLZXlJZFwiLFxuICAgICAgICBcIlNlY3JldEFjY2Vzc0tleVwiLFxuICAgICAgICBcIlNlc3Npb25Ub2tlblwiLFxuICAgICAgICBcIkV4cGlyYXRpb25cIlxuICAgICAgXSxcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiQWNjZXNzS2V5SWRcIjoge30sXG4gICAgICAgIFwiU2VjcmV0QWNjZXNzS2V5XCI6IHt9LFxuICAgICAgICBcIlNlc3Npb25Ub2tlblwiOiB7fSxcbiAgICAgICAgXCJFeHBpcmF0aW9uXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlNtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiQXNzdW1lZFJvbGVJZFwiLFxuICAgICAgICBcIkFyblwiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJBc3N1bWVkUm9sZUlkXCI6IHt9LFxuICAgICAgICBcIkFyblwiOiB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsInJlcXVpcmUoJy4vbGliL2Jyb3dzZXJfbG9hZGVyJyk7XG5cbnZhciBBV1MgPSByZXF1aXJlKCcuL2xpYi9jb3JlJyk7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHdpbmRvdy5BV1MgPSBBV1M7XG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIG1vZHVsZS5leHBvcnRzID0gQVdTO1xuaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgc2VsZi5BV1MgPSBBV1M7IiwicmVxdWlyZSgnLi4vbGliL25vZGVfbG9hZGVyJyk7XG52YXIgQVdTID0gcmVxdWlyZSgnLi4vbGliL2NvcmUnKTtcbnZhciBTZXJ2aWNlID0gQVdTLlNlcnZpY2U7XG52YXIgYXBpTG9hZGVyID0gQVdTLmFwaUxvYWRlcjtcblxuYXBpTG9hZGVyLnNlcnZpY2VzWydjb2duaXRvaWRlbnRpdHknXSA9IHt9O1xuQVdTLkNvZ25pdG9JZGVudGl0eSA9IFNlcnZpY2UuZGVmaW5lU2VydmljZSgnY29nbml0b2lkZW50aXR5JywgWycyMDE0LTA2LTMwJ10pO1xucmVxdWlyZSgnLi4vbGliL3NlcnZpY2VzL2NvZ25pdG9pZGVudGl0eScpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwaUxvYWRlci5zZXJ2aWNlc1snY29nbml0b2lkZW50aXR5J10sICcyMDE0LTA2LTMwJywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgbW9kZWwgPSByZXF1aXJlKCcuLi9hcGlzL2NvZ25pdG8taWRlbnRpdHktMjAxNC0wNi0zMC5taW4uanNvbicpO1xuICAgIG1vZGVsLnBhZ2luYXRvcnMgPSByZXF1aXJlKCcuLi9hcGlzL2NvZ25pdG8taWRlbnRpdHktMjAxNC0wNi0zMC5wYWdpbmF0b3JzLmpzb24nKS5wYWdpbmF0aW9uO1xuICAgIHJldHVybiBtb2RlbDtcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBV1MuQ29nbml0b0lkZW50aXR5O1xuIiwicmVxdWlyZSgnLi4vbGliL25vZGVfbG9hZGVyJyk7XG52YXIgQVdTID0gcmVxdWlyZSgnLi4vbGliL2NvcmUnKTtcbnZhciBTZXJ2aWNlID0gQVdTLlNlcnZpY2U7XG52YXIgYXBpTG9hZGVyID0gQVdTLmFwaUxvYWRlcjtcblxuYXBpTG9hZGVyLnNlcnZpY2VzWydzMyddID0ge307XG5BV1MuUzMgPSBTZXJ2aWNlLmRlZmluZVNlcnZpY2UoJ3MzJywgWycyMDA2LTAzLTAxJ10pO1xucmVxdWlyZSgnLi4vbGliL3NlcnZpY2VzL3MzJyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoYXBpTG9hZGVyLnNlcnZpY2VzWydzMyddLCAnMjAwNi0wMy0wMScsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIG1vZGVsID0gcmVxdWlyZSgnLi4vYXBpcy9zMy0yMDA2LTAzLTAxLm1pbi5qc29uJyk7XG4gICAgbW9kZWwucGFnaW5hdG9ycyA9IHJlcXVpcmUoJy4uL2FwaXMvczMtMjAwNi0wMy0wMS5wYWdpbmF0b3JzLmpzb24nKS5wYWdpbmF0aW9uO1xuICAgIG1vZGVsLndhaXRlcnMgPSByZXF1aXJlKCcuLi9hcGlzL3MzLTIwMDYtMDMtMDEud2FpdGVyczIuanNvbicpLndhaXRlcnM7XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5TMztcbiIsInJlcXVpcmUoJy4uL2xpYi9ub2RlX2xvYWRlcicpO1xudmFyIEFXUyA9IHJlcXVpcmUoJy4uL2xpYi9jb3JlJyk7XG52YXIgU2VydmljZSA9IEFXUy5TZXJ2aWNlO1xudmFyIGFwaUxvYWRlciA9IEFXUy5hcGlMb2FkZXI7XG5cbmFwaUxvYWRlci5zZXJ2aWNlc1snc3RzJ10gPSB7fTtcbkFXUy5TVFMgPSBTZXJ2aWNlLmRlZmluZVNlcnZpY2UoJ3N0cycsIFsnMjAxMS0wNi0xNSddKTtcbnJlcXVpcmUoJy4uL2xpYi9zZXJ2aWNlcy9zdHMnKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcGlMb2FkZXIuc2VydmljZXNbJ3N0cyddLCAnMjAxMS0wNi0xNScsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIG1vZGVsID0gcmVxdWlyZSgnLi4vYXBpcy9zdHMtMjAxMS0wNi0xNS5taW4uanNvbicpO1xuICAgIG1vZGVsLnBhZ2luYXRvcnMgPSByZXF1aXJlKCcuLi9hcGlzL3N0cy0yMDExLTA2LTE1LnBhZ2luYXRvcnMuanNvbicpLnBhZ2luYXRpb247XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5TVFM7XG4iLCJmdW5jdGlvbiBhcGlMb2FkZXIoc3ZjLCB2ZXJzaW9uKSB7XG4gIGlmICghYXBpTG9hZGVyLnNlcnZpY2VzLmhhc093blByb3BlcnR5KHN2YykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTZXJ2aWNlOiBGYWlsZWQgdG8gbG9hZCBhcGkgZm9yICcgKyBzdmMpO1xuICB9XG4gIHJldHVybiBhcGlMb2FkZXIuc2VydmljZXNbc3ZjXVt2ZXJzaW9uXTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqXG4gKiBUaGlzIG1lbWJlciBvZiBBV1MuYXBpTG9hZGVyIGlzIHByaXZhdGUsIGJ1dCBjaGFuZ2luZyBpdCB3aWxsIG5lY2Vzc2l0YXRlIGFcbiAqIGNoYW5nZSB0byAuLi9zY3JpcHRzL3NlcnZpY2VzLXRhYmxlLWdlbmVyYXRvci50c1xuICovXG5hcGlMb2FkZXIuc2VydmljZXMgPSB7fTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBhcGlMb2FkZXI7XG4iLCJ2YXIgSG1hYyA9IHJlcXVpcmUoJy4vYnJvd3NlckhtYWMnKTtcbnZhciBNZDUgPSByZXF1aXJlKCcuL2Jyb3dzZXJNZDUnKTtcbnZhciBTaGExID0gcmVxdWlyZSgnLi9icm93c2VyU2hhMScpO1xudmFyIFNoYTI1NiA9IHJlcXVpcmUoJy4vYnJvd3NlclNoYTI1NicpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSB7XG4gICAgY3JlYXRlSGFzaDogZnVuY3Rpb24gY3JlYXRlSGFzaChhbGcpIHtcbiAgICAgIGFsZyA9IGFsZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGFsZyA9PT0gJ21kNScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZDUoKTtcbiAgICAgIH0gZWxzZSBpZiAoYWxnID09PSAnc2hhMjU2Jykge1xuICAgICAgICByZXR1cm4gbmV3IFNoYTI1NigpO1xuICAgICAgfSBlbHNlIGlmIChhbGcgPT09ICdzaGExJykge1xuICAgICAgICByZXR1cm4gbmV3IFNoYTEoKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGFsZ29yaXRobSAnICsgYWxnICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBicm93c2VyIFNESycpO1xuICAgIH0sXG4gICAgY3JlYXRlSG1hYzogZnVuY3Rpb24gY3JlYXRlSG1hYyhhbGcsIGtleSkge1xuICAgICAgYWxnID0gYWxnLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoYWxnID09PSAnbWQ1Jykge1xuICAgICAgICByZXR1cm4gbmV3IEhtYWMoTWQ1LCBrZXkpO1xuICAgICAgfSBlbHNlIGlmIChhbGcgPT09ICdzaGEyNTYnKSB7XG4gICAgICAgIHJldHVybiBuZXcgSG1hYyhTaGEyNTYsIGtleSk7XG4gICAgICB9IGVsc2UgaWYgKGFsZyA9PT0gJ3NoYTEnKSB7XG4gICAgICAgIHJldHVybiBuZXcgSG1hYyhTaGExLCBrZXkpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hNQUMgYWxnb3JpdGhtICcgKyBhbGcgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGJyb3dzZXIgU0RLJyk7XG4gICAgfSxcbiAgICBjcmVhdGVTaWduOiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlU2lnbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGJyb3dzZXInKTtcbiAgICB9XG4gIH07XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyLycpLkJ1ZmZlcjtcblxuLyoqXG4gKiBUaGlzIGlzIGEgcG9seWZpbGwgZm9yIHRoZSBzdGF0aWMgbWV0aG9kIGBpc1ZpZXdgIG9mIGBBcnJheUJ1ZmZlcmAsIHdoaWNoIGlzXG4gKiBlLmcuIG1pc3NpbmcgaW4gSUUgMTAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmlmIChcbiAgICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ3VuZGVmaW5lZCdcbikge1xuICAgIEFycmF5QnVmZmVyLmlzVmlldyA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdmlld1N0cmluZ3MuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSkgPiAtMTtcbiAgICB9O1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgdmlld1N0cmluZ3MgPSBbXG4gICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgJ1tvYmplY3QgRGF0YVZpZXddJyxcbl07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHlEYXRhKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuYnl0ZUxlbmd0aCA9PT0gMDtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29udmVydFRvQnVmZmVyKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsICd1dGY4Jyk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoIC8gVWludDhBcnJheS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEpO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSB7XG4gICAgaXNFbXB0eURhdGE6IGlzRW1wdHlEYXRhLFxuICAgIGNvbnZlcnRUb0J1ZmZlcjogY29udmVydFRvQnVmZmVyLFxufTtcbiIsInZhciBoYXNoVXRpbHMgPSByZXF1aXJlKCcuL2Jyb3dzZXJIYXNoVXRpbHMnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gSG1hYyhoYXNoQ3Rvciwgc2VjcmV0KSB7XG4gICAgdGhpcy5oYXNoID0gbmV3IGhhc2hDdG9yKCk7XG4gICAgdGhpcy5vdXRlciA9IG5ldyBoYXNoQ3RvcigpO1xuXG4gICAgdmFyIGlubmVyID0gYnVmZmVyRnJvbVNlY3JldChoYXNoQ3Rvciwgc2VjcmV0KTtcbiAgICB2YXIgb3V0ZXIgPSBuZXcgVWludDhBcnJheShoYXNoQ3Rvci5CTE9DS19TSVpFKTtcbiAgICBvdXRlci5zZXQoaW5uZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYXNoQ3Rvci5CTE9DS19TSVpFOyBpKyspIHtcbiAgICAgICAgaW5uZXJbaV0gXj0gMHgzNjtcbiAgICAgICAgb3V0ZXJbaV0gXj0gMHg1YztcbiAgICB9XG5cbiAgICB0aGlzLmhhc2gudXBkYXRlKGlubmVyKTtcbiAgICB0aGlzLm91dGVyLnVwZGF0ZShvdXRlcik7XG5cbiAgICAvLyBaZXJvIG91dCB0aGUgY29waWVkIGtleSBidWZmZXIuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbm5lci5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW5uZXJbaV0gPSAwO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSG1hYztcblxuSG1hYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHRvSGFzaCkge1xuICAgIGlmIChoYXNoVXRpbHMuaXNFbXB0eURhdGEodG9IYXNoKSB8fCB0aGlzLmVycm9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaGFzaC51cGRhdGUoaGFzaFV0aWxzLmNvbnZlcnRUb0J1ZmZlcih0b0hhc2gpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuSG1hYy5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gICAgaWYgKCF0aGlzLm91dGVyLmZpbmlzaGVkKSB7XG4gICAgICAgIHRoaXMub3V0ZXIudXBkYXRlKHRoaXMuaGFzaC5kaWdlc3QoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMub3V0ZXIuZGlnZXN0KGVuY29kaW5nKTtcbn07XG5cbmZ1bmN0aW9uIGJ1ZmZlckZyb21TZWNyZXQoaGFzaEN0b3IsIHNlY3JldCkge1xuICAgIHZhciBpbnB1dCA9IGhhc2hVdGlscy5jb252ZXJ0VG9CdWZmZXIoc2VjcmV0KTtcbiAgICBpZiAoaW5wdXQuYnl0ZUxlbmd0aCA+IGhhc2hDdG9yLkJMT0NLX1NJWkUpIHtcbiAgICAgICAgdmFyIGJ1ZmZlckhhc2ggPSBuZXcgaGFzaEN0b3I7XG4gICAgICAgIGJ1ZmZlckhhc2gudXBkYXRlKGlucHV0KTtcbiAgICAgICAgaW5wdXQgPSBidWZmZXJIYXNoLmRpZ2VzdCgpO1xuICAgIH1cbiAgICB2YXIgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoaGFzaEN0b3IuQkxPQ0tfU0laRSk7XG4gICAgYnVmZmVyLnNldChpbnB1dCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbiIsInZhciBoYXNoVXRpbHMgPSByZXF1aXJlKCcuL2Jyb3dzZXJIYXNoVXRpbHMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXIvJykuQnVmZmVyO1xuXG52YXIgQkxPQ0tfU0laRSA9IDY0O1xuXG52YXIgRElHRVNUX0xFTkdUSCA9IDE2O1xuXG52YXIgSU5JVCA9IFtcbiAgICAweDY3NDUyMzAxLFxuICAgIDB4ZWZjZGFiODksXG4gICAgMHg5OGJhZGNmZSxcbiAgICAweDEwMzI1NDc2LFxuXTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gTWQ1KCkge1xuICAgIHRoaXMuc3RhdGUgPSBbXG4gICAgICAgIDB4Njc0NTIzMDEsXG4gICAgICAgIDB4ZWZjZGFiODksXG4gICAgICAgIDB4OThiYWRjZmUsXG4gICAgICAgIDB4MTAzMjU0NzYsXG4gICAgXTtcbiAgICB0aGlzLmJ1ZmZlciA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoQkxPQ0tfU0laRSkpO1xuICAgIHRoaXMuYnVmZmVyTGVuZ3RoID0gMDtcbiAgICB0aGlzLmJ5dGVzSGFzaGVkID0gMDtcbiAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IE1kNTtcblxuTWQ1LkJMT0NLX1NJWkUgPSBCTE9DS19TSVpFO1xuXG5NZDUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChzb3VyY2VEYXRhKSB7XG4gICAgaWYgKGhhc2hVdGlscy5pc0VtcHR5RGF0YShzb3VyY2VEYXRhKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKHRoaXMuZmluaXNoZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gdXBkYXRlIGFuIGFscmVhZHkgZmluaXNoZWQgaGFzaC4nKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IGhhc2hVdGlscy5jb252ZXJ0VG9CdWZmZXIoc291cmNlRGF0YSk7XG4gICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICB0aGlzLmJ5dGVzSGFzaGVkICs9IGJ5dGVMZW5ndGg7XG4gICAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLnNldFVpbnQ4KHRoaXMuYnVmZmVyTGVuZ3RoKyssIGRhdGFbcG9zaXRpb24rK10pO1xuICAgICAgICBieXRlTGVuZ3RoLS07XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlckxlbmd0aCA9PT0gQkxPQ0tfU0laRSkge1xuICAgICAgICAgICAgdGhpcy5oYXNoQnVmZmVyKCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbk1kNS5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gICAgaWYgKCF0aGlzLmZpbmlzaGVkKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGJ1ZmZlciA9IF9hLmJ1ZmZlciwgdW5kZWNvcmF0ZWRMZW5ndGggPSBfYS5idWZmZXJMZW5ndGgsIGJ5dGVzSGFzaGVkID0gX2EuYnl0ZXNIYXNoZWQ7XG4gICAgICAgIHZhciBiaXRzSGFzaGVkID0gYnl0ZXNIYXNoZWQgKiA4O1xuICAgICAgICBidWZmZXIuc2V0VWludDgodGhpcy5idWZmZXJMZW5ndGgrKywgMTI4KTtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBmaW5hbCBibG9jayBoYXMgZW5vdWdoIHJvb20gZm9yIHRoZSBoYXNoZWQgbGVuZ3RoXG4gICAgICAgIGlmICh1bmRlY29yYXRlZExlbmd0aCAlIEJMT0NLX1NJWkUgPj0gQkxPQ0tfU0laRSAtIDgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmJ1ZmZlckxlbmd0aDsgaSA8IEJMT0NLX1NJWkU7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5zZXRVaW50OChpLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFzaEJ1ZmZlcigpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJMZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmJ1ZmZlckxlbmd0aDsgaSA8IEJMT0NLX1NJWkUgLSA4OyBpKyspIHtcbiAgICAgICAgICAgIGJ1ZmZlci5zZXRVaW50OChpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIuc2V0VWludDMyKEJMT0NLX1NJWkUgLSA4LCBiaXRzSGFzaGVkID4+PiAwLCB0cnVlKTtcbiAgICAgICAgYnVmZmVyLnNldFVpbnQzMihCTE9DS19TSVpFIC0gNCwgTWF0aC5mbG9vcihiaXRzSGFzaGVkIC8gMHgxMDAwMDAwMDApLCB0cnVlKTtcbiAgICAgICAgdGhpcy5oYXNoQnVmZmVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgb3V0ID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcihESUdFU1RfTEVOR1RIKSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgb3V0LnNldFVpbnQzMihpICogNCwgdGhpcy5zdGF0ZVtpXSwgdHJ1ZSk7XG4gICAgfVxuICAgIHZhciBidWZmID0gbmV3IEJ1ZmZlcihvdXQuYnVmZmVyLCBvdXQuYnl0ZU9mZnNldCwgb3V0LmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiBlbmNvZGluZyA/IGJ1ZmYudG9TdHJpbmcoZW5jb2RpbmcpIDogYnVmZjtcbn07XG5cbk1kNS5wcm90b3R5cGUuaGFzaEJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EgPSB0aGlzLCBidWZmZXIgPSBfYS5idWZmZXIsIHN0YXRlID0gX2Euc3RhdGU7XG4gICAgdmFyIGEgPSBzdGF0ZVswXSwgYiA9IHN0YXRlWzFdLCBjID0gc3RhdGVbMl0sIGQgPSBzdGF0ZVszXTtcbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyLmdldFVpbnQzMigwLCB0cnVlKSwgNywgMHhkNzZhYTQ3OCk7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlci5nZXRVaW50MzIoNCwgdHJ1ZSksIDEyLCAweGU4YzdiNzU2KTtcbiAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyLmdldFVpbnQzMig4LCB0cnVlKSwgMTcsIDB4MjQyMDcwZGIpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDEyLCB0cnVlKSwgMjIsIDB4YzFiZGNlZWUpO1xuICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDE2LCB0cnVlKSwgNywgMHhmNTdjMGZhZik7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlci5nZXRVaW50MzIoMjAsIHRydWUpLCAxMiwgMHg0Nzg3YzYyYSk7XG4gICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlci5nZXRVaW50MzIoMjQsIHRydWUpLCAxNywgMHhhODMwNDYxMyk7XG4gICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlci5nZXRVaW50MzIoMjgsIHRydWUpLCAyMiwgMHhmZDQ2OTUwMSk7XG4gICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlci5nZXRVaW50MzIoMzIsIHRydWUpLCA3LCAweDY5ODA5OGQ4KTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyLmdldFVpbnQzMigzNiwgdHJ1ZSksIDEyLCAweDhiNDRmN2FmKTtcbiAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyLmdldFVpbnQzMig0MCwgdHJ1ZSksIDE3LCAweGZmZmY1YmIxKTtcbiAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyLmdldFVpbnQzMig0NCwgdHJ1ZSksIDIyLCAweDg5NWNkN2JlKTtcbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyLmdldFVpbnQzMig0OCwgdHJ1ZSksIDcsIDB4NmI5MDExMjIpO1xuICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDUyLCB0cnVlKSwgMTIsIDB4ZmQ5ODcxOTMpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDU2LCB0cnVlKSwgMTcsIDB4YTY3OTQzOGUpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDYwLCB0cnVlKSwgMjIsIDB4NDliNDA4MjEpO1xuICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDQsIHRydWUpLCA1LCAweGY2MWUyNTYyKTtcbiAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyLmdldFVpbnQzMigyNCwgdHJ1ZSksIDksIDB4YzA0MGIzNDApO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDQ0LCB0cnVlKSwgMTQsIDB4MjY1ZTVhNTEpO1xuICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDAsIHRydWUpLCAyMCwgMHhlOWI2YzdhYSk7XG4gICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlci5nZXRVaW50MzIoMjAsIHRydWUpLCA1LCAweGQ2MmYxMDVkKTtcbiAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyLmdldFVpbnQzMig0MCwgdHJ1ZSksIDksIDB4MDI0NDE0NTMpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDYwLCB0cnVlKSwgMTQsIDB4ZDhhMWU2ODEpO1xuICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDE2LCB0cnVlKSwgMjAsIDB4ZTdkM2ZiYzgpO1xuICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDM2LCB0cnVlKSwgNSwgMHgyMWUxY2RlNik7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlci5nZXRVaW50MzIoNTYsIHRydWUpLCA5LCAweGMzMzcwN2Q2KTtcbiAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyLmdldFVpbnQzMigxMiwgdHJ1ZSksIDE0LCAweGY0ZDUwZDg3KTtcbiAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyLmdldFVpbnQzMigzMiwgdHJ1ZSksIDIwLCAweDQ1NWExNGVkKTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyLmdldFVpbnQzMig1MiwgdHJ1ZSksIDUsIDB4YTllM2U5MDUpO1xuICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDgsIHRydWUpLCA5LCAweGZjZWZhM2Y4KTtcbiAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyLmdldFVpbnQzMigyOCwgdHJ1ZSksIDE0LCAweDY3NmYwMmQ5KTtcbiAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyLmdldFVpbnQzMig0OCwgdHJ1ZSksIDIwLCAweDhkMmE0YzhhKTtcbiAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyLmdldFVpbnQzMigyMCwgdHJ1ZSksIDQsIDB4ZmZmYTM5NDIpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDMyLCB0cnVlKSwgMTEsIDB4ODc3MWY2ODEpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDQ0LCB0cnVlKSwgMTYsIDB4NmQ5ZDYxMjIpO1xuICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDU2LCB0cnVlKSwgMjMsIDB4ZmRlNTM4MGMpO1xuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDQsIHRydWUpLCA0LCAweGE0YmVlYTQ0KTtcbiAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyLmdldFVpbnQzMigxNiwgdHJ1ZSksIDExLCAweDRiZGVjZmE5KTtcbiAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyLmdldFVpbnQzMigyOCwgdHJ1ZSksIDE2LCAweGY2YmI0YjYwKTtcbiAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyLmdldFVpbnQzMig0MCwgdHJ1ZSksIDIzLCAweGJlYmZiYzcwKTtcbiAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyLmdldFVpbnQzMig1MiwgdHJ1ZSksIDQsIDB4Mjg5YjdlYzYpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDAsIHRydWUpLCAxMSwgMHhlYWExMjdmYSk7XG4gICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlci5nZXRVaW50MzIoMTIsIHRydWUpLCAxNiwgMHhkNGVmMzA4NSk7XG4gICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlci5nZXRVaW50MzIoMjQsIHRydWUpLCAyMywgMHgwNDg4MWQwNSk7XG4gICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlci5nZXRVaW50MzIoMzYsIHRydWUpLCA0LCAweGQ5ZDRkMDM5KTtcbiAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyLmdldFVpbnQzMig0OCwgdHJ1ZSksIDExLCAweGU2ZGI5OWU1KTtcbiAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyLmdldFVpbnQzMig2MCwgdHJ1ZSksIDE2LCAweDFmYTI3Y2Y4KTtcbiAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyLmdldFVpbnQzMig4LCB0cnVlKSwgMjMsIDB4YzRhYzU2NjUpO1xuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDAsIHRydWUpLCA2LCAweGY0MjkyMjQ0KTtcbiAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyLmdldFVpbnQzMigyOCwgdHJ1ZSksIDEwLCAweDQzMmFmZjk3KTtcbiAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyLmdldFVpbnQzMig1NiwgdHJ1ZSksIDE1LCAweGFiOTQyM2E3KTtcbiAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyLmdldFVpbnQzMigyMCwgdHJ1ZSksIDIxLCAweGZjOTNhMDM5KTtcbiAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyLmdldFVpbnQzMig0OCwgdHJ1ZSksIDYsIDB4NjU1YjU5YzMpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDEyLCB0cnVlKSwgMTAsIDB4OGYwY2NjOTIpO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDQwLCB0cnVlKSwgMTUsIDB4ZmZlZmY0N2QpO1xuICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDQsIHRydWUpLCAyMSwgMHg4NTg0NWRkMSk7XG4gICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlci5nZXRVaW50MzIoMzIsIHRydWUpLCA2LCAweDZmYTg3ZTRmKTtcbiAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyLmdldFVpbnQzMig2MCwgdHJ1ZSksIDEwLCAweGZlMmNlNmUwKTtcbiAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyLmdldFVpbnQzMigyNCwgdHJ1ZSksIDE1LCAweGEzMDE0MzE0KTtcbiAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyLmdldFVpbnQzMig1MiwgdHJ1ZSksIDIxLCAweDRlMDgxMWExKTtcbiAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyLmdldFVpbnQzMigxNiwgdHJ1ZSksIDYsIDB4Zjc1MzdlODIpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDQ0LCB0cnVlKSwgMTAsIDB4YmQzYWYyMzUpO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDgsIHRydWUpLCAxNSwgMHgyYWQ3ZDJiYik7XG4gICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlci5nZXRVaW50MzIoMzYsIHRydWUpLCAyMSwgMHhlYjg2ZDM5MSk7XG4gICAgc3RhdGVbMF0gPSAoYSArIHN0YXRlWzBdKSAmIDB4RkZGRkZGRkY7XG4gICAgc3RhdGVbMV0gPSAoYiArIHN0YXRlWzFdKSAmIDB4RkZGRkZGRkY7XG4gICAgc3RhdGVbMl0gPSAoYyArIHN0YXRlWzJdKSAmIDB4RkZGRkZGRkY7XG4gICAgc3RhdGVbM10gPSAoZCArIHN0YXRlWzNdKSAmIDB4RkZGRkZGRkY7XG59O1xuXG5mdW5jdGlvbiBjbW4ocSwgYSwgYiwgeCwgcywgdCkge1xuICAgIGEgPSAoKChhICsgcSkgJiAweEZGRkZGRkZGKSArICgoeCArIHQpICYgMHhGRkZGRkZGRikpICYgMHhGRkZGRkZGRjtcbiAgICByZXR1cm4gKCgoYSA8PCBzKSB8IChhID4+PiAoMzIgLSBzKSkpICsgYikgJiAweEZGRkZGRkZGO1xufVxuXG5mdW5jdGlvbiBmZihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgcmV0dXJuIGNtbigoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIGdnKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICByZXR1cm4gY21uKChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gaGgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgIHJldHVybiBjbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gaWkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgIHJldHVybiBjbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlci8nKS5CdWZmZXI7XG52YXIgaGFzaFV0aWxzID0gcmVxdWlyZSgnLi9icm93c2VySGFzaFV0aWxzJyk7XG5cbnZhciBCTE9DS19TSVpFID0gNjQ7XG5cbnZhciBESUdFU1RfTEVOR1RIID0gMjA7XG5cbnZhciBLRVkgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NWE4Mjc5OTksXG4gICAgMHg2ZWQ5ZWJhMSxcbiAgICAweDhmMWJiY2RjIHwgMCxcbiAgICAweGNhNjJjMWQ2IHwgMFxuXSk7XG5cbnZhciBJTklUID0gW1xuICAgIDB4NmEwOWU2NjcsXG4gICAgMHhiYjY3YWU4NSxcbiAgICAweDNjNmVmMzcyLFxuICAgIDB4YTU0ZmY1M2EsXG4gICAgMHg1MTBlNTI3ZixcbiAgICAweDliMDU2ODhjLFxuICAgIDB4MWY4M2Q5YWIsXG4gICAgMHg1YmUwY2QxOSxcbl07XG5cbnZhciBNQVhfSEFTSEFCTEVfTEVOR1RIID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gU2hhMSgpIHtcbiAgICB0aGlzLmgwID0gMHg2NzQ1MjMwMTtcbiAgICB0aGlzLmgxID0gMHhFRkNEQUI4OTtcbiAgICB0aGlzLmgyID0gMHg5OEJBRENGRTtcbiAgICB0aGlzLmgzID0gMHgxMDMyNTQ3NjtcbiAgICB0aGlzLmg0ID0gMHhDM0QyRTFGMDtcbiAgICAvLyBUaGUgZmlyc3QgNjQgYnl0ZXMgKDE2IHdvcmRzKSBpcyB0aGUgZGF0YSBjaHVua1xuICAgIHRoaXMuYmxvY2sgPSBuZXcgVWludDMyQXJyYXkoODApO1xuICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICB0aGlzLnNoaWZ0ID0gMjQ7XG4gICAgdGhpcy50b3RhbExlbmd0aCA9IDA7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNoYTE7XG5cblNoYTEuQkxPQ0tfU0laRSA9IEJMT0NLX1NJWkU7XG5cblNoYTEucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKHRoaXMuZmluaXNoZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gdXBkYXRlIGFuIGFscmVhZHkgZmluaXNoZWQgaGFzaC4nKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzaFV0aWxzLmlzRW1wdHlEYXRhKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGRhdGEgPSBoYXNoVXRpbHMuY29udmVydFRvQnVmZmVyKGRhdGEpO1xuXG4gICAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIHRoaXMudG90YWxMZW5ndGggKz0gbGVuZ3RoICogODtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud3JpdGUoZGF0YVtpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5TaGExLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlKGJ5dGUpIHtcbiAgICB0aGlzLmJsb2NrW3RoaXMub2Zmc2V0XSB8PSAoYnl0ZSAmIDB4ZmYpIDw8IHRoaXMuc2hpZnQ7XG4gICAgaWYgKHRoaXMuc2hpZnQpIHtcbiAgICAgICAgdGhpcy5zaGlmdCAtPSA4O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHRoaXMuc2hpZnQgPSAyNDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vZmZzZXQgPT09IDE2KSB0aGlzLnByb2Nlc3NCbG9jaygpO1xufTtcblxuU2hhMS5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gICAgLy8gUGFkXG4gICAgdGhpcy53cml0ZSgweDgwKTtcbiAgICBpZiAodGhpcy5vZmZzZXQgPiAxNCB8fCAodGhpcy5vZmZzZXQgPT09IDE0ICYmIHRoaXMuc2hpZnQgPCAyNCkpIHtcbiAgICAgIHRoaXMucHJvY2Vzc0Jsb2NrKCk7XG4gICAgfVxuICAgIHRoaXMub2Zmc2V0ID0gMTQ7XG4gICAgdGhpcy5zaGlmdCA9IDI0O1xuXG4gICAgLy8gNjQtYml0IGxlbmd0aCBiaWctZW5kaWFuXG4gICAgdGhpcy53cml0ZSgweDAwKTsgLy8gbnVtYmVycyB0aGlzIGJpZyBhcmVuJ3QgYWNjdXJhdGUgaW4gamF2YXNjcmlwdCBhbnl3YXlcbiAgICB0aGlzLndyaXRlKDB4MDApOyAvLyAuLlNvIGp1c3QgaGFyZC1jb2RlIHRvIHplcm8uXG4gICAgdGhpcy53cml0ZSh0aGlzLnRvdGFsTGVuZ3RoID4gMHhmZmZmZmZmZmZmID8gdGhpcy50b3RhbExlbmd0aCAvIDB4MTAwMDAwMDAwMDAgOiAweDAwKTtcbiAgICB0aGlzLndyaXRlKHRoaXMudG90YWxMZW5ndGggPiAweGZmZmZmZmZmID8gdGhpcy50b3RhbExlbmd0aCAvIDB4MTAwMDAwMDAwIDogMHgwMCk7XG4gICAgZm9yICh2YXIgcyA9IDI0OyBzID49IDA7IHMgLT0gOCkge1xuICAgICAgICB0aGlzLndyaXRlKHRoaXMudG90YWxMZW5ndGggPj4gcyk7XG4gICAgfVxuICAgIC8vIFRoZSB2YWx1ZSBpbiBzdGF0ZSBpcyBsaXR0bGUtZW5kaWFuIHJhdGhlciB0aGFuIGJpZy1lbmRpYW4sIHNvIGZsaXBcbiAgICAvLyBlYWNoIHdvcmQgaW50byBhIG5ldyBVaW50OEFycmF5XG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIoRElHRVNUX0xFTkdUSCk7XG4gICAgdmFyIG91dFZpZXcgPSBuZXcgRGF0YVZpZXcob3V0LmJ1ZmZlcik7XG4gICAgb3V0Vmlldy5zZXRVaW50MzIoMCwgdGhpcy5oMCwgZmFsc2UpO1xuICAgIG91dFZpZXcuc2V0VWludDMyKDQsIHRoaXMuaDEsIGZhbHNlKTtcbiAgICBvdXRWaWV3LnNldFVpbnQzMig4LCB0aGlzLmgyLCBmYWxzZSk7XG4gICAgb3V0Vmlldy5zZXRVaW50MzIoMTIsIHRoaXMuaDMsIGZhbHNlKTtcbiAgICBvdXRWaWV3LnNldFVpbnQzMigxNiwgdGhpcy5oNCwgZmFsc2UpO1xuXG4gICAgcmV0dXJuIGVuY29kaW5nID8gb3V0LnRvU3RyaW5nKGVuY29kaW5nKSA6IG91dDtcbn07XG5cblNoYTEucHJvdG90eXBlLnByb2Nlc3NCbG9jayA9IGZ1bmN0aW9uIHByb2Nlc3NCbG9jaygpIHtcbiAgICAvLyBFeHRlbmQgdGhlIHNpeHRlZW4gMzItYml0IHdvcmRzIGludG8gZWlnaHR5IDMyLWJpdCB3b3JkczpcbiAgICBmb3IgKHZhciBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IHRoaXMuYmxvY2tbaSAtIDNdIF4gdGhpcy5ibG9ja1tpIC0gOF0gXiB0aGlzLmJsb2NrW2kgLSAxNF0gXiB0aGlzLmJsb2NrW2kgLSAxNl07XG4gICAgICB0aGlzLmJsb2NrW2ldID0gKHcgPDwgMSkgfCAodyA+Pj4gMzEpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgaGFzaCB2YWx1ZSBmb3IgdGhpcyBjaHVuazpcbiAgICB2YXIgYSA9IHRoaXMuaDA7XG4gICAgdmFyIGIgPSB0aGlzLmgxO1xuICAgIHZhciBjID0gdGhpcy5oMjtcbiAgICB2YXIgZCA9IHRoaXMuaDM7XG4gICAgdmFyIGUgPSB0aGlzLmg0O1xuICAgIHZhciBmLCBrO1xuXG4gICAgLy8gTWFpbiBsb29wOlxuICAgIGZvciAoaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICBpZiAoaSA8IDIwKSB7XG4gICAgICAgIGYgPSBkIF4gKGIgJiAoYyBeIGQpKTtcbiAgICAgICAgayA9IDB4NUE4Mjc5OTk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpIDwgNDApIHtcbiAgICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgICAgayA9IDB4NkVEOUVCQTE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpIDwgNjApIHtcbiAgICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIHwgYykpO1xuICAgICAgICBrID0gMHg4RjFCQkNEQztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgICBrID0gMHhDQTYyQzFENjtcbiAgICAgIH1cbiAgICAgIHZhciB0ZW1wID0gKGEgPDwgNSB8IGEgPj4+IDI3KSArIGYgKyBlICsgayArICh0aGlzLmJsb2NrW2ldfDApO1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSAoYiA8PCAzMCB8IGIgPj4+IDIpO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdGVtcDtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhpcyBjaHVuaydzIGhhc2ggdG8gcmVzdWx0IHNvIGZhcjpcbiAgICB0aGlzLmgwID0gKHRoaXMuaDAgKyBhKSB8IDA7XG4gICAgdGhpcy5oMSA9ICh0aGlzLmgxICsgYikgfCAwO1xuICAgIHRoaXMuaDIgPSAodGhpcy5oMiArIGMpIHwgMDtcbiAgICB0aGlzLmgzID0gKHRoaXMuaDMgKyBkKSB8IDA7XG4gICAgdGhpcy5oNCA9ICh0aGlzLmg0ICsgZSkgfCAwO1xuXG4gICAgLy8gVGhlIGJsb2NrIGlzIG5vdyByZXVzYWJsZS5cbiAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgdGhpcy5ibG9ja1tpXSA9IDA7XG4gICAgfVxufTtcbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXIvJykuQnVmZmVyO1xudmFyIGhhc2hVdGlscyA9IHJlcXVpcmUoJy4vYnJvd3Nlckhhc2hVdGlscycpO1xuXG52YXIgQkxPQ0tfU0laRSA9IDY0O1xuXG52YXIgRElHRVNUX0xFTkdUSCA9IDMyO1xuXG52YXIgS0VZID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LFxuICAgIDB4NzEzNzQ0OTEsXG4gICAgMHhiNWMwZmJjZixcbiAgICAweGU5YjVkYmE1LFxuICAgIDB4Mzk1NmMyNWIsXG4gICAgMHg1OWYxMTFmMSxcbiAgICAweDkyM2Y4MmE0LFxuICAgIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCxcbiAgICAweDEyODM1YjAxLFxuICAgIDB4MjQzMTg1YmUsXG4gICAgMHg1NTBjN2RjMyxcbiAgICAweDcyYmU1ZDc0LFxuICAgIDB4ODBkZWIxZmUsXG4gICAgMHg5YmRjMDZhNyxcbiAgICAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsXG4gICAgMHhlZmJlNDc4NixcbiAgICAweDBmYzE5ZGM2LFxuICAgIDB4MjQwY2ExY2MsXG4gICAgMHgyZGU5MmM2ZixcbiAgICAweDRhNzQ4NGFhLFxuICAgIDB4NWNiMGE5ZGMsXG4gICAgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLFxuICAgIDB4YTgzMWM2NmQsXG4gICAgMHhiMDAzMjdjOCxcbiAgICAweGJmNTk3ZmM3LFxuICAgIDB4YzZlMDBiZjMsXG4gICAgMHhkNWE3OTE0NyxcbiAgICAweDA2Y2E2MzUxLFxuICAgIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSxcbiAgICAweDJlMWIyMTM4LFxuICAgIDB4NGQyYzZkZmMsXG4gICAgMHg1MzM4MGQxMyxcbiAgICAweDY1MGE3MzU0LFxuICAgIDB4NzY2YTBhYmIsXG4gICAgMHg4MWMyYzkyZSxcbiAgICAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsXG4gICAgMHhhODFhNjY0YixcbiAgICAweGMyNGI4YjcwLFxuICAgIDB4Yzc2YzUxYTMsXG4gICAgMHhkMTkyZTgxOSxcbiAgICAweGQ2OTkwNjI0LFxuICAgIDB4ZjQwZTM1ODUsXG4gICAgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LFxuICAgIDB4MWUzNzZjMDgsXG4gICAgMHgyNzQ4Nzc0YyxcbiAgICAweDM0YjBiY2I1LFxuICAgIDB4MzkxYzBjYjMsXG4gICAgMHg0ZWQ4YWE0YSxcbiAgICAweDViOWNjYTRmLFxuICAgIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSxcbiAgICAweDc4YTU2MzZmLFxuICAgIDB4ODRjODc4MTQsXG4gICAgMHg4Y2M3MDIwOCxcbiAgICAweDkwYmVmZmZhLFxuICAgIDB4YTQ1MDZjZWIsXG4gICAgMHhiZWY5YTNmNyxcbiAgICAweGM2NzE3OGYyXG5dKTtcblxudmFyIElOSVQgPSBbXG4gICAgMHg2YTA5ZTY2NyxcbiAgICAweGJiNjdhZTg1LFxuICAgIDB4M2M2ZWYzNzIsXG4gICAgMHhhNTRmZjUzYSxcbiAgICAweDUxMGU1MjdmLFxuICAgIDB4OWIwNTY4OGMsXG4gICAgMHgxZjgzZDlhYixcbiAgICAweDViZTBjZDE5LFxuXTtcblxudmFyIE1BWF9IQVNIQUJMRV9MRU5HVEggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFNoYTI1NigpIHtcbiAgICB0aGlzLnN0YXRlID0gW1xuICAgICAgICAweDZhMDllNjY3LFxuICAgICAgICAweGJiNjdhZTg1LFxuICAgICAgICAweDNjNmVmMzcyLFxuICAgICAgICAweGE1NGZmNTNhLFxuICAgICAgICAweDUxMGU1MjdmLFxuICAgICAgICAweDliMDU2ODhjLFxuICAgICAgICAweDFmODNkOWFiLFxuICAgICAgICAweDViZTBjZDE5LFxuICAgIF07XG4gICAgdGhpcy50ZW1wID0gbmV3IEludDMyQXJyYXkoNjQpO1xuICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgIHRoaXMuYnVmZmVyTGVuZ3RoID0gMDtcbiAgICB0aGlzLmJ5dGVzSGFzaGVkID0gMDtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU2hhMjU2O1xuXG5TaGEyNTYuQkxPQ0tfU0laRSA9IEJMT0NLX1NJWkU7XG5cblNoYTI1Ni5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAodGhpcy5maW5pc2hlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byB1cGRhdGUgYW4gYWxyZWFkeSBmaW5pc2hlZCBoYXNoLicpO1xuICAgIH1cblxuICAgIGlmIChoYXNoVXRpbHMuaXNFbXB0eURhdGEoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZGF0YSA9IGhhc2hVdGlscy5jb252ZXJ0VG9CdWZmZXIoZGF0YSk7XG5cbiAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgIHZhciBieXRlTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIHRoaXMuYnl0ZXNIYXNoZWQgKz0gYnl0ZUxlbmd0aDtcbiAgICBpZiAodGhpcy5ieXRlc0hhc2hlZCAqIDggPiBNQVhfSEFTSEFCTEVfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhc2ggbW9yZSB0aGFuIDJeNTMgLSAxIGJpdHMnKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5idWZmZXJMZW5ndGgrK10gPSBkYXRhW3Bvc2l0aW9uKytdO1xuICAgICAgICBieXRlTGVuZ3RoLS07XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlckxlbmd0aCA9PT0gQkxPQ0tfU0laRSkge1xuICAgICAgICAgICAgdGhpcy5oYXNoQnVmZmVyKCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblNoYTI1Ni5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gICAgaWYgKCF0aGlzLmZpbmlzaGVkKSB7XG4gICAgICAgIHZhciBiaXRzSGFzaGVkID0gdGhpcy5ieXRlc0hhc2hlZCAqIDg7XG4gICAgICAgIHZhciBidWZmZXJWaWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuYnVmZmVyLmJ1ZmZlciwgdGhpcy5idWZmZXIuYnl0ZU9mZnNldCwgdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHZhciB1bmRlY29yYXRlZExlbmd0aCA9IHRoaXMuYnVmZmVyTGVuZ3RoO1xuICAgICAgICBidWZmZXJWaWV3LnNldFVpbnQ4KHRoaXMuYnVmZmVyTGVuZ3RoKyssIDB4ODApO1xuICAgICAgICAvLyBFbnN1cmUgdGhlIGZpbmFsIGJsb2NrIGhhcyBlbm91Z2ggcm9vbSBmb3IgdGhlIGhhc2hlZCBsZW5ndGhcbiAgICAgICAgaWYgKHVuZGVjb3JhdGVkTGVuZ3RoICUgQkxPQ0tfU0laRSA+PSBCTE9DS19TSVpFIC0gOCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuYnVmZmVyTGVuZ3RoOyBpIDwgQkxPQ0tfU0laRTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyVmlldy5zZXRVaW50OChpLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFzaEJ1ZmZlcigpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJMZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmJ1ZmZlckxlbmd0aDsgaSA8IEJMT0NLX1NJWkUgLSA4OyBpKyspIHtcbiAgICAgICAgICAgIGJ1ZmZlclZpZXcuc2V0VWludDgoaSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyVmlldy5zZXRVaW50MzIoQkxPQ0tfU0laRSAtIDgsIE1hdGguZmxvb3IoYml0c0hhc2hlZCAvIDB4MTAwMDAwMDAwKSwgdHJ1ZSk7XG4gICAgICAgIGJ1ZmZlclZpZXcuc2V0VWludDMyKEJMT0NLX1NJWkUgLSA0LCBiaXRzSGFzaGVkKTtcbiAgICAgICAgdGhpcy5oYXNoQnVmZmVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBUaGUgdmFsdWUgaW4gc3RhdGUgaXMgbGl0dGxlLWVuZGlhbiByYXRoZXIgdGhhbiBiaWctZW5kaWFuLCBzbyBmbGlwXG4gICAgLy8gZWFjaCB3b3JkIGludG8gYSBuZXcgVWludDhBcnJheVxuICAgIHZhciBvdXQgPSBuZXcgQnVmZmVyKERJR0VTVF9MRU5HVEgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIG91dFtpICogNF0gPSAodGhpcy5zdGF0ZVtpXSA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgb3V0W2kgKiA0ICsgMV0gPSAodGhpcy5zdGF0ZVtpXSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgb3V0W2kgKiA0ICsgMl0gPSAodGhpcy5zdGF0ZVtpXSA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBvdXRbaSAqIDQgKyAzXSA9ICh0aGlzLnN0YXRlW2ldID4+PiAwKSAmIDB4ZmY7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGluZyA/IG91dC50b1N0cmluZyhlbmNvZGluZykgOiBvdXQ7XG59O1xuXG5TaGEyNTYucHJvdG90eXBlLmhhc2hCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hID0gdGhpcyxcbiAgICAgICAgYnVmZmVyID0gX2EuYnVmZmVyLFxuICAgICAgICBzdGF0ZSA9IF9hLnN0YXRlO1xuICAgIHZhciBzdGF0ZTAgPSBzdGF0ZVswXSxcbiAgICAgICAgc3RhdGUxID0gc3RhdGVbMV0sXG4gICAgICAgIHN0YXRlMiA9IHN0YXRlWzJdLFxuICAgICAgICBzdGF0ZTMgPSBzdGF0ZVszXSxcbiAgICAgICAgc3RhdGU0ID0gc3RhdGVbNF0sXG4gICAgICAgIHN0YXRlNSA9IHN0YXRlWzVdLFxuICAgICAgICBzdGF0ZTYgPSBzdGF0ZVs2XSxcbiAgICAgICAgc3RhdGU3ID0gc3RhdGVbN107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBCTE9DS19TSVpFOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPCAxNikge1xuICAgICAgICAgICAgdGhpcy50ZW1wW2ldID0gKCgoYnVmZmVyW2kgKiA0XSAmIDB4ZmYpIDw8IDI0KSB8XG4gICAgICAgICAgICAgICAgKChidWZmZXJbKGkgKiA0KSArIDFdICYgMHhmZikgPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoKGJ1ZmZlclsoaSAqIDQpICsgMl0gJiAweGZmKSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlclsoaSAqIDQpICsgM10gJiAweGZmKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdSA9IHRoaXMudGVtcFtpIC0gMl07XG4gICAgICAgICAgICB2YXIgdDFfMSA9ICh1ID4+PiAxNyB8IHUgPDwgMTUpIF5cbiAgICAgICAgICAgICAgICAodSA+Pj4gMTkgfCB1IDw8IDEzKSBeXG4gICAgICAgICAgICAgICAgKHUgPj4+IDEwKTtcbiAgICAgICAgICAgIHUgPSB0aGlzLnRlbXBbaSAtIDE1XTtcbiAgICAgICAgICAgIHZhciB0Ml8xID0gKHUgPj4+IDcgfCB1IDw8IDI1KSBeXG4gICAgICAgICAgICAgICAgKHUgPj4+IDE4IHwgdSA8PCAxNCkgXlxuICAgICAgICAgICAgICAgICh1ID4+PiAzKTtcbiAgICAgICAgICAgIHRoaXMudGVtcFtpXSA9ICh0MV8xICsgdGhpcy50ZW1wW2kgLSA3XSB8IDApICtcbiAgICAgICAgICAgICAgICAodDJfMSArIHRoaXMudGVtcFtpIC0gMTZdIHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQxID0gKCgoKChzdGF0ZTQgPj4+IDYgfCBzdGF0ZTQgPDwgMjYpIF5cbiAgICAgICAgICAgIChzdGF0ZTQgPj4+IDExIHwgc3RhdGU0IDw8IDIxKSBeXG4gICAgICAgICAgICAoc3RhdGU0ID4+PiAyNSB8IHN0YXRlNCA8PCA3KSlcbiAgICAgICAgICAgICsgKChzdGF0ZTQgJiBzdGF0ZTUpIF4gKH5zdGF0ZTQgJiBzdGF0ZTYpKSkgfCAwKVxuICAgICAgICAgICAgKyAoKHN0YXRlNyArICgoS0VZW2ldICsgdGhpcy50ZW1wW2ldKSB8IDApKSB8IDApKSB8IDA7XG4gICAgICAgIHZhciB0MiA9ICgoKHN0YXRlMCA+Pj4gMiB8IHN0YXRlMCA8PCAzMCkgXlxuICAgICAgICAgICAgKHN0YXRlMCA+Pj4gMTMgfCBzdGF0ZTAgPDwgMTkpIF5cbiAgICAgICAgICAgIChzdGF0ZTAgPj4+IDIyIHwgc3RhdGUwIDw8IDEwKSkgKyAoKHN0YXRlMCAmIHN0YXRlMSkgXiAoc3RhdGUwICYgc3RhdGUyKSBeIChzdGF0ZTEgJiBzdGF0ZTIpKSkgfCAwO1xuICAgICAgICBzdGF0ZTcgPSBzdGF0ZTY7XG4gICAgICAgIHN0YXRlNiA9IHN0YXRlNTtcbiAgICAgICAgc3RhdGU1ID0gc3RhdGU0O1xuICAgICAgICBzdGF0ZTQgPSAoc3RhdGUzICsgdDEpIHwgMDtcbiAgICAgICAgc3RhdGUzID0gc3RhdGUyO1xuICAgICAgICBzdGF0ZTIgPSBzdGF0ZTE7XG4gICAgICAgIHN0YXRlMSA9IHN0YXRlMDtcbiAgICAgICAgc3RhdGUwID0gKHQxICsgdDIpIHwgMDtcbiAgICB9XG4gICAgc3RhdGVbMF0gKz0gc3RhdGUwO1xuICAgIHN0YXRlWzFdICs9IHN0YXRlMTtcbiAgICBzdGF0ZVsyXSArPSBzdGF0ZTI7XG4gICAgc3RhdGVbM10gKz0gc3RhdGUzO1xuICAgIHN0YXRlWzRdICs9IHN0YXRlNDtcbiAgICBzdGF0ZVs1XSArPSBzdGF0ZTU7XG4gICAgc3RhdGVbNl0gKz0gc3RhdGU2O1xuICAgIHN0YXRlWzddICs9IHN0YXRlNztcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBicm93c2VyIHNwZWNpZmljIG1vZHVsZXNcbnV0aWwuY3J5cHRvLmxpYiA9IHJlcXVpcmUoJy4vYnJvd3NlckNyeXB0b0xpYicpO1xudXRpbC5CdWZmZXIgPSByZXF1aXJlKCdidWZmZXIvJykuQnVmZmVyO1xudXRpbC51cmwgPSByZXF1aXJlKCd1cmwvJyk7XG51dGlsLnF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcvJyk7XG51dGlsLnJlYWxDbG9jayA9IHJlcXVpcmUoJy4vcmVhbGNsb2NrL2Jyb3dzZXJDbG9jaycpO1xudXRpbC5lbnZpcm9ubWVudCA9ICdqcyc7XG51dGlsLmNyZWF0ZUV2ZW50U3RyZWFtID0gcmVxdWlyZSgnLi9ldmVudC1zdHJlYW0vYnVmZmVyZWQtY3JlYXRlLWV2ZW50LXN0cmVhbScpLmNyZWF0ZUV2ZW50U3RyZWFtO1xudXRpbC5pc0Jyb3dzZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH07XG51dGlsLmlzTm9kZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbnZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1M7XG5cbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvY3JlZGVudGlhbF9wcm92aWRlcl9jaGFpbicpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy90ZW1wb3JhcnlfY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvY2hhaW5hYmxlX3RlbXBvcmFyeV9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy93ZWJfaWRlbnRpdHlfY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvY29nbml0b19pZGVudGl0eV9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy9zYW1sX2NyZWRlbnRpYWxzJyk7XG5cbi8vIExvYWQgdGhlIERPTVBhcnNlciBYTUwgcGFyc2VyXG5BV1MuWE1MLlBhcnNlciA9IHJlcXVpcmUoJy4veG1sL2Jyb3dzZXJfcGFyc2VyJyk7XG5cbi8vIExvYWQgdGhlIFhIUiBIdHRwQ2xpZW50XG5yZXF1aXJlKCcuL2h0dHAveGhyJyk7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIHByb2Nlc3MgPSB7XG4gICAgYnJvd3NlcjogdHJ1ZVxuICB9O1xufVxuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy9jcmVkZW50aWFsX3Byb3ZpZGVyX2NoYWluJyk7XG52YXIgUHJvbWlzZXNEZXBlbmRlbmN5O1xuXG4vKipcbiAqIFRoZSBtYWluIGNvbmZpZ3VyYXRpb24gY2xhc3MgdXNlZCBieSBhbGwgc2VydmljZSBvYmplY3RzIHRvIHNldFxuICogdGhlIHJlZ2lvbiwgY3JlZGVudGlhbHMsIGFuZCBvdGhlciBvcHRpb25zIGZvciByZXF1ZXN0cy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBjcmVkZW50aWFscyBhbmQgcmVnaW9uIHNldHRpbmdzIGFyZSBsZWZ0IHVuY29uZmlndXJlZC5cbiAqIFRoaXMgc2hvdWxkIGJlIGNvbmZpZ3VyZWQgYnkgdGhlIGFwcGxpY2F0aW9uIGJlZm9yZSB1c2luZyBhbnlcbiAqIEFXUyBzZXJ2aWNlIEFQSXMuXG4gKlxuICogSW4gb3JkZXIgdG8gc2V0IGdsb2JhbCBjb25maWd1cmF0aW9uIG9wdGlvbnMsIHByb3BlcnRpZXMgc2hvdWxkXG4gKiBiZSBhc3NpZ25lZCB0byB0aGUgZ2xvYmFsIHtBV1MuY29uZmlnfSBvYmplY3QuXG4gKlxuICogQHNlZSBBV1MuY29uZmlnXG4gKlxuICogQCFncm91cCBHZW5lcmFsIENvbmZpZ3VyYXRpb24gT3B0aW9uc1xuICpcbiAqIEAhYXR0cmlidXRlIGNyZWRlbnRpYWxzXG4gKiAgIEByZXR1cm4gW0FXUy5DcmVkZW50aWFsc10gdGhlIEFXUyBjcmVkZW50aWFscyB0byBzaWduIHJlcXVlc3RzIHdpdGguXG4gKlxuICogQCFhdHRyaWJ1dGUgcmVnaW9uXG4gKiAgIEBleGFtcGxlIFNldCB0aGUgZ2xvYmFsIHJlZ2lvbiBzZXR0aW5nIHRvIHVzLXdlc3QtMlxuICogICAgIEFXUy5jb25maWcudXBkYXRlKHtyZWdpb246ICd1cy13ZXN0LTInfSk7XG4gKiAgIEByZXR1cm4gW0FXUy5DcmVkZW50aWFsc10gVGhlIHJlZ2lvbiB0byBzZW5kIHNlcnZpY2UgcmVxdWVzdHMgdG8uXG4gKiAgIEBzZWUgaHR0cDovL2RvY3MuYW1hem9ud2Vic2VydmljZXMuY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3JhbmRlLmh0bWxcbiAqICAgICBBIGxpc3Qgb2YgYXZhaWxhYmxlIGVuZHBvaW50cyBmb3IgZWFjaCBBV1Mgc2VydmljZVxuICpcbiAqIEAhYXR0cmlidXRlIG1heFJldHJpZXNcbiAqICAgQHJldHVybiBbSW50ZWdlcl0gdGhlIG1heGltdW0gYW1vdW50IG9mIHJldHJpZXMgdG8gcGVyZm9ybSBmb3IgYVxuICogICAgIHNlcnZpY2UgcmVxdWVzdC4gQnkgZGVmYXVsdCB0aGlzIHZhbHVlIGlzIGNhbGN1bGF0ZWQgYnkgdGhlIHNwZWNpZmljXG4gKiAgICAgc2VydmljZSBvYmplY3QgdGhhdCB0aGUgcmVxdWVzdCBpcyBiZWluZyBtYWRlIHRvLlxuICpcbiAqIEAhYXR0cmlidXRlIG1heFJlZGlyZWN0c1xuICogICBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgbWF4aW11bSBhbW91bnQgb2YgcmVkaXJlY3RzIHRvIGZvbGxvdyBmb3IgYVxuICogICAgIHNlcnZpY2UgcmVxdWVzdC4gRGVmYXVsdHMgdG8gMTAuXG4gKlxuICogQCFhdHRyaWJ1dGUgcGFyYW1WYWxpZGF0aW9uXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW58bWFwXSB3aGV0aGVyIGlucHV0IHBhcmFtZXRlcnMgc2hvdWxkIGJlIHZhbGlkYXRlZCBhZ2FpbnN0XG4gKiAgICAgdGhlIG9wZXJhdGlvbiBkZXNjcmlwdGlvbiBiZWZvcmUgc2VuZGluZyB0aGUgcmVxdWVzdC4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAqICAgICBQYXNzIGEgbWFwIHRvIGVuYWJsZSBhbnkgb2YgdGhlIGZvbGxvd2luZyBzcGVjaWZpYyB2YWxpZGF0aW9uIGZlYXR1cmVzOlxuICpcbiAqICAgICAqICoqbWluKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBtZWV0cyB0aGUgbWluXG4gKiAgICAgICBjb25zdHJhaW50LiBUaGlzIGlzIGVuYWJsZWQgYnkgZGVmYXVsdCB3aGVuIHBhcmFtVmFsaWRhdGlvbiBpcyBzZXRcbiAqICAgICAgIHRvIGB0cnVlYC5cbiAqICAgICAqICoqbWF4KiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBtZWV0cyB0aGUgbWF4XG4gKiAgICAgICBjb25zdHJhaW50LlxuICogICAgICogKipwYXR0ZXJuKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSBzdHJpbmcgdmFsdWUgbWF0Y2hlcyBhXG4gKiAgICAgICByZWd1bGFyIGV4cHJlc3Npb24uXG4gKiAgICAgKiAqKmVudW0qKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHN0cmluZyB2YWx1ZSBtYXRjaGVzIG9uZVxuICogICAgICAgb2YgdGhlIGFsbG93YWJsZSBlbnVtIHZhbHVlcy5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBjb21wdXRlQ2hlY2tzdW1zXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdG8gY29tcHV0ZSBjaGVja3N1bXMgZm9yIHBheWxvYWQgYm9kaWVzIHdoZW5cbiAqICAgICB0aGUgc2VydmljZSBhY2NlcHRzIGl0IChjdXJyZW50bHkgc3VwcG9ydGVkIGluIFMzIG9ubHkpLlxuICpcbiAqIEAhYXR0cmlidXRlIGNvbnZlcnRSZXNwb25zZVR5cGVzXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdHlwZXMgYXJlIGNvbnZlcnRlZCB3aGVuIHBhcnNpbmcgcmVzcG9uc2UgZGF0YS5cbiAqICAgICBDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgZm9yIEpTT04gYmFzZWQgc2VydmljZXMuIFR1cm5pbmcgdGhpcyBvZmYgbWF5XG4gKiAgICAgaW1wcm92ZSBwZXJmb3JtYW5jZSBvbiBsYXJnZSByZXNwb25zZSBwYXlsb2Fkcy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICpcbiAqIEAhYXR0cmlidXRlIGNvcnJlY3RDbG9ja1NrZXdcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0byBhcHBseSBhIGNsb2NrIHNrZXcgY29ycmVjdGlvbiBhbmQgcmV0cnlcbiAqICAgICByZXF1ZXN0cyB0aGF0IGZhaWwgYmVjYXVzZSBvZiBhbiBza2V3ZWQgY2xpZW50IGNsb2NrLiBEZWZhdWx0cyB0b1xuICogICAgIGBmYWxzZWAuXG4gKlxuICogQCFhdHRyaWJ1dGUgc3NsRW5hYmxlZFxuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIFNTTCBpcyBlbmFibGVkIGZvciByZXF1ZXN0c1xuICpcbiAqIEAhYXR0cmlidXRlIHMzRm9yY2VQYXRoU3R5bGVcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0byBmb3JjZSBwYXRoIHN0eWxlIFVSTHMgZm9yIFMzIG9iamVjdHNcbiAqXG4gKiBAIWF0dHJpYnV0ZSBzM0J1Y2tldEVuZHBvaW50XG4gKiAgIEBub3RlIFNldHRpbmcgdGhpcyBjb25maWd1cmF0aW9uIG9wdGlvbiByZXF1aXJlcyBhbiBgZW5kcG9pbnRgIHRvIGJlXG4gKiAgICAgcHJvdmlkZWQgZXhwbGljaXRseSB0byB0aGUgc2VydmljZSBjb25zdHJ1Y3Rvci5cbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0aGUgcHJvdmlkZWQgZW5kcG9pbnQgYWRkcmVzc2VzIGFuIGluZGl2aWR1YWxcbiAqICAgICBidWNrZXQgKGZhbHNlIGlmIGl0IGFkZHJlc3NlcyB0aGUgcm9vdCBBUEkgZW5kcG9pbnQpLlxuICpcbiAqIEAhYXR0cmlidXRlIHMzRGlzYWJsZUJvZHlTaWduaW5nXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdG8gZGlzYWJsZSBTMyBib2R5IHNpZ25pbmcgd2hlbiB1c2luZyBzaWduYXR1cmUgdmVyc2lvbiBgdjRgLlxuICogICAgIEJvZHkgc2lnbmluZyBjYW4gb25seSBiZSBkaXNhYmxlZCB3aGVuIHVzaW5nIGh0dHBzLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKlxuICogQCFhdHRyaWJ1dGUgczNVc0Vhc3QxUmVnaW9uYWxFbmRwb2ludFxuICogICBAcmV0dXJuIFsnbGVnYWN5J3wncmVnaW9uYWwnXSB3aGVuIHJlZ2lvbiBpcyBzZXQgdG8gJ3VzLWVhc3QtMScsIHdoZXRoZXIgdG8gc2VuZCBzM1xuICogICAgIHJlcXVlc3QgdG8gZ2xvYmFsIGVuZHBvaW50cyBvciAndXMtZWFzdC0xJyByZWdpb25hbCBlbmRwb2ludHMuIFRoaXMgY29uZmlnIGlzIG9ubHlcbiAqICAgICBhcHBsaWNhYmxlIHRvIFMzIGNsaWVudDtcbiAqICAgICBEZWZhdWx0cyB0byAnbGVnYWN5J1xuICogQCFhdHRyaWJ1dGUgczNVc2VBcm5SZWdpb25cbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0byBvdmVycmlkZSB0aGUgcmVxdWVzdCByZWdpb24gd2l0aCB0aGUgcmVnaW9uIGluZmVycmVkXG4gKiAgICAgZnJvbSByZXF1ZXN0ZWQgcmVzb3VyY2UncyBBUk4uIE9ubHkgYXZhaWxhYmxlIGZvciBTMyBidWNrZXRzXG4gKiAgICAgRGVmYXVsdHMgdG8gYHRydWVgXG4gKlxuICogQCFhdHRyaWJ1dGUgdXNlQWNjZWxlcmF0ZUVuZHBvaW50XG4gKiAgIEBub3RlIFRoaXMgY29uZmlndXJhdGlvbiBvcHRpb24gaXMgb25seSBjb21wYXRpYmxlIHdpdGggUzMgd2hpbGUgYWNjZXNzaW5nXG4gKiAgICAgZG5zLWNvbXBhdGlibGUgYnVja2V0cy5cbiAqICAgQHJldHVybiBbQm9vbGVhbl0gV2hldGhlciB0byB1c2UgdGhlIEFjY2VsZXJhdGUgZW5kcG9pbnQgd2l0aCB0aGUgUzMgc2VydmljZS5cbiAqICAgICBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICpcbiAqIEAhYXR0cmlidXRlIHJldHJ5RGVsYXlPcHRpb25zXG4gKiAgIEBleGFtcGxlIFNldCB0aGUgYmFzZSByZXRyeSBkZWxheSBmb3IgYWxsIHNlcnZpY2VzIHRvIDMwMCBtc1xuICogICAgIEFXUy5jb25maWcudXBkYXRlKHtyZXRyeURlbGF5T3B0aW9uczoge2Jhc2U6IDMwMH19KTtcbiAqICAgICAvLyBEZWxheXMgd2l0aCBtYXhSZXRyaWVzID0gMzogMzAwLCA2MDAsIDEyMDBcbiAqICAgQGV4YW1wbGUgU2V0IGEgY3VzdG9tIGJhY2tvZmYgZnVuY3Rpb24gdG8gcHJvdmlkZSBkZWxheSB2YWx1ZXMgb24gcmV0cmllc1xuICogICAgIEFXUy5jb25maWcudXBkYXRlKHtyZXRyeURlbGF5T3B0aW9uczoge2N1c3RvbUJhY2tvZmY6IGZ1bmN0aW9uKHJldHJ5Q291bnQsIGVycikge1xuICogICAgICAgLy8gcmV0dXJucyBkZWxheSBpbiBtc1xuICogICAgIH19fSk7XG4gKiAgIEByZXR1cm4gW21hcF0gQSBzZXQgb2Ygb3B0aW9ucyB0byBjb25maWd1cmUgdGhlIHJldHJ5IGRlbGF5IG9uIHJldHJ5YWJsZSBlcnJvcnMuXG4gKiAgICAgQ3VycmVudGx5IHN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAgICAgKiAqKmJhc2UqKiBbSW50ZWdlcl0gJm1kYXNoOyBUaGUgYmFzZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHVzZSBpbiB0aGVcbiAqICAgICAgIGV4cG9uZW50aWFsIGJhY2tvZmYgZm9yIG9wZXJhdGlvbiByZXRyaWVzLiBEZWZhdWx0cyB0byAxMDAgbXMgZm9yIGFsbCBzZXJ2aWNlcyBleGNlcHRcbiAqICAgICAgIER5bmFtb0RCLCB3aGVyZSBpdCBkZWZhdWx0cyB0byA1MG1zLlxuICpcbiAqICAgICAqICoqY3VzdG9tQmFja29mZiAqKiBbZnVuY3Rpb25dICZtZGFzaDsgQSBjdXN0b20gZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFcbiAqICAgICAgIHJldHJ5IGNvdW50IGFuZCBlcnJvciBhbmQgcmV0dXJucyB0aGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgaW5cbiAqICAgICAgIG1pbGxpc2Vjb25kcy4gSWYgdGhlIHJlc3VsdCBpcyBhIG5vbi16ZXJvIG5lZ2F0aXZlIHZhbHVlLCBubyBmdXJ0aGVyXG4gKiAgICAgICByZXRyeSBhdHRlbXB0cyB3aWxsIGJlIG1hZGUuIFRoZSBgYmFzZWAgb3B0aW9uIHdpbGwgYmUgaWdub3JlZCBpZiB0aGlzXG4gKiAgICAgICBvcHRpb24gaXMgc3VwcGxpZWQuXG4gKlxuICogQCFhdHRyaWJ1dGUgaHR0cE9wdGlvbnNcbiAqICAgQHJldHVybiBbbWFwXSBBIHNldCBvZiBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIGxvdy1sZXZlbCBIVFRQIHJlcXVlc3QuXG4gKiAgICAgQ3VycmVudGx5IHN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAgICAgKiAqKnByb3h5KiogW1N0cmluZ10gJm1kYXNoOyB0aGUgVVJMIHRvIHByb3h5IHJlcXVlc3RzIHRocm91Z2hcbiAqICAgICAqICoqYWdlbnQqKiBbaHR0cC5BZ2VudCwgaHR0cHMuQWdlbnRdICZtZGFzaDsgdGhlIEFnZW50IG9iamVjdCB0byBwZXJmb3JtXG4gKiAgICAgICBIVFRQIHJlcXVlc3RzIHdpdGguIFVzZWQgZm9yIGNvbm5lY3Rpb24gcG9vbGluZy4gTm90ZSB0aGF0IGZvclxuICogICAgICAgU1NMIGNvbm5lY3Rpb25zLCBhIHNwZWNpYWwgQWdlbnQgb2JqZWN0IGlzIHVzZWQgaW4gb3JkZXIgdG8gZW5hYmxlXG4gKiAgICAgICBwZWVyIGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvbi4gVGhpcyBmZWF0dXJlIGlzIG9ubHkgc3VwcG9ydGVkIGluIHRoZVxuICogICAgICAgTm9kZS5qcyBlbnZpcm9ubWVudC5cbiAqICAgICAqICoqY29ubmVjdFRpbWVvdXQqKiBbSW50ZWdlcl0gJm1kYXNoOyBTZXRzIHRoZSBzb2NrZXQgdG8gdGltZW91dCBhZnRlclxuICogICAgICAgZmFpbGluZyB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHdpdGggdGhlIHNlcnZlciBhZnRlclxuICogICAgICAgYGNvbm5lY3RUaW1lb3V0YCBtaWxsaXNlY29uZHMuIFRoaXMgdGltZW91dCBoYXMgbm8gZWZmZWN0IG9uY2UgYSBzb2NrZXRcbiAqICAgICAgIGNvbm5lY3Rpb24gaGFzIGJlZW4gZXN0YWJsaXNoZWQuXG4gKiAgICAgKiAqKnRpbWVvdXQqKiBbSW50ZWdlcl0gJm1kYXNoOyBTZXRzIHRoZSBzb2NrZXQgdG8gdGltZW91dCBhZnRlciB0aW1lb3V0XG4gKiAgICAgICBtaWxsaXNlY29uZHMgb2YgaW5hY3Rpdml0eSBvbiB0aGUgc29ja2V0LiBEZWZhdWx0cyB0byB0d28gbWludXRlc1xuICogICAgICAgKDEyMDAwMClcbiAqICAgICAqICoqeGhyQXN5bmMqKiBbQm9vbGVhbl0gJm1kYXNoOyBXaGV0aGVyIHRoZSBTREsgd2lsbCBzZW5kIGFzeW5jaHJvbm91c1xuICogICAgICAgSFRUUCByZXF1ZXN0cy4gVXNlZCBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudCBvbmx5LiBTZXQgdG8gZmFsc2UgdG9cbiAqICAgICAgIHNlbmQgcmVxdWVzdHMgc3luY2hyb25vdXNseS4gRGVmYXVsdHMgdG8gdHJ1ZSAoYXN5bmMgb24pLlxuICogICAgICogKip4aHJXaXRoQ3JlZGVudGlhbHMqKiBbQm9vbGVhbl0gJm1kYXNoOyBTZXRzIHRoZSBcIndpdGhDcmVkZW50aWFsc1wiXG4gKiAgICAgICBwcm9wZXJ0eSBvZiBhbiBYTUxIdHRwUmVxdWVzdCBvYmplY3QuIFVzZWQgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqICAgICAgIG9ubHkuIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQCFhdHRyaWJ1dGUgbG9nZ2VyXG4gKiAgIEByZXR1cm4gWyN3cml0ZSwjbG9nXSBhbiBvYmplY3QgdGhhdCByZXNwb25kcyB0byAud3JpdGUoKSAobGlrZSBhIHN0cmVhbSlcbiAqICAgICBvciAubG9nKCkgKGxpa2UgdGhlIGNvbnNvbGUgb2JqZWN0KSBpbiBvcmRlciB0byBsb2cgaW5mb3JtYXRpb24gYWJvdXRcbiAqICAgICByZXF1ZXN0c1xuICpcbiAqIEAhYXR0cmlidXRlIHN5c3RlbUNsb2NrT2Zmc2V0XG4gKiAgIEByZXR1cm4gW051bWJlcl0gYW4gb2Zmc2V0IHZhbHVlIGluIG1pbGxpc2Vjb25kcyB0byBhcHBseSB0byBhbGwgc2lnbmluZ1xuICogICAgIHRpbWVzLiBVc2UgdGhpcyB0byBjb21wZW5zYXRlIGZvciBjbG9jayBza2V3IHdoZW4geW91ciBzeXN0ZW0gbWF5IGJlXG4gKiAgICAgb3V0IG9mIHN5bmMgd2l0aCB0aGUgc2VydmljZSB0aW1lLiBOb3RlIHRoYXQgdGhpcyBjb25maWd1cmF0aW9uIG9wdGlvblxuICogICAgIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGdsb2JhbCBgQVdTLmNvbmZpZ2Agb2JqZWN0IGFuZCBjYW5ub3QgYmVcbiAqICAgICBvdmVycmlkZGVuIGluIHNlcnZpY2Utc3BlY2lmaWMgY29uZmlndXJhdGlvbi4gRGVmYXVsdHMgdG8gMCBtaWxsaXNlY29uZHMuXG4gKlxuICogQCFhdHRyaWJ1dGUgc2lnbmF0dXJlVmVyc2lvblxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBzaWduYXR1cmUgdmVyc2lvbiB0byBzaWduIHJlcXVlc3RzIHdpdGggKG92ZXJyaWRpbmdcbiAqICAgICB0aGUgQVBJIGNvbmZpZ3VyYXRpb24pLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOiAndjInLCAndjMnLCAndjQnLlxuICpcbiAqIEAhYXR0cmlidXRlIHNpZ25hdHVyZUNhY2hlXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIHNpZ25hdHVyZSB0byBzaWduIHJlcXVlc3RzIHdpdGggKG92ZXJyaWRpbmdcbiAqICAgICB0aGUgQVBJIGNvbmZpZ3VyYXRpb24pIGlzIGNhY2hlZC4gT25seSBhcHBsaWVzIHRvIHRoZSBzaWduYXR1cmUgdmVyc2lvbiAndjQnLlxuICogICAgIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBlbmRwb2ludERpc2NvdmVyeUVuYWJsZWRcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0byBlbmFibGUgZW5kcG9pbnQgZGlzY292ZXJ5IGZvciBvcGVyYXRpb25zIHRoYXRcbiAqICAgICBhbGxvdyBvcHRpb25hbGx5IHVzaW5nIGFuIGVuZHBvaW50IHJldHVybmVkIGJ5IHRoZSBzZXJ2aWNlLlxuICogICAgIERlZmF1bHRzIHRvICdmYWxzZSdcbiAqXG4gKiBAIWF0dHJpYnV0ZSBlbmRwb2ludENhY2hlU2l6ZVxuICogICBAcmV0dXJuIFtOdW1iZXJdIHRoZSBzaXplIG9mIHRoZSBnbG9iYWwgY2FjaGUgc3RvcmluZyBlbmRwb2ludHMgZnJvbSBlbmRwb2ludFxuICogICAgIGRpc2NvdmVyeSBvcGVyYXRpb25zLiBPbmNlIGVuZHBvaW50IGNhY2hlIGlzIGNyZWF0ZWQsIHVwZGF0aW5nIHRoaXMgc2V0dGluZ1xuICogICAgIGNhbm5vdCBjaGFuZ2UgZXhpc3RpbmcgY2FjaGUgc2l6ZS5cbiAqICAgICBEZWZhdWx0cyB0byAxMDAwXG4gKlxuICogQCFhdHRyaWJ1dGUgaG9zdFByZWZpeEVuYWJsZWRcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0byBtYXJzaGFsIHJlcXVlc3QgcGFyYW1ldGVycyB0byB0aGUgcHJlZml4IG9mXG4gKiAgICAgaG9zdG5hbWUuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBzdHNSZWdpb25hbEVuZHBvaW50c1xuICogICBAcmV0dXJuIFsnbGVnYWN5J3wncmVnaW9uYWwnXSB3aGV0aGVyIHRvIHNlbmQgc3RzIHJlcXVlc3QgdG8gZ2xvYmFsIGVuZHBvaW50cyBvclxuICogICAgIHJlZ2lvbmFsIGVuZHBvaW50cy5cbiAqICAgICBEZWZhdWx0cyB0byAnbGVnYWN5J1xuICovXG5BV1MuQ29uZmlnID0gQVdTLnV0aWwuaW5oZXJpdCh7XG4gIC8qKlxuICAgKiBAIWVuZGdyb3VwXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNvbmZpZ3VyYXRpb24gb2JqZWN0LiBUaGlzIGlzIHRoZSBvYmplY3QgdGhhdCBwYXNzZXNcbiAgICogb3B0aW9uIGRhdGEgYWxvbmcgdG8gc2VydmljZSByZXF1ZXN0cywgaW5jbHVkaW5nIGNyZWRlbnRpYWxzLCBzZWN1cml0eSxcbiAgICogcmVnaW9uIGluZm9ybWF0aW9uLCBhbmQgc29tZSBzZXJ2aWNlIHNwZWNpZmljIHNldHRpbmdzLlxuICAgKlxuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhIG5ldyBjb25maWd1cmF0aW9uIG9iamVjdCB3aXRoIGNyZWRlbnRpYWxzIGFuZCByZWdpb25cbiAgICogICB2YXIgY29uZmlnID0gbmV3IEFXUy5Db25maWcoe1xuICAgKiAgICAgYWNjZXNzS2V5SWQ6ICdBS0lEJywgc2VjcmV0QWNjZXNzS2V5OiAnU0VDUkVUJywgcmVnaW9uOiAndXMtd2VzdC0yJ1xuICAgKiAgIH0pO1xuICAgKiBAb3B0aW9uIG9wdGlvbnMgYWNjZXNzS2V5SWQgW1N0cmluZ10geW91ciBBV1MgYWNjZXNzIGtleSBJRC5cbiAgICogQG9wdGlvbiBvcHRpb25zIHNlY3JldEFjY2Vzc0tleSBbU3RyaW5nXSB5b3VyIEFXUyBzZWNyZXQgYWNjZXNzIGtleS5cbiAgICogQG9wdGlvbiBvcHRpb25zIHNlc3Npb25Ub2tlbiBbQVdTLkNyZWRlbnRpYWxzXSB0aGUgb3B0aW9uYWwgQVdTXG4gICAqICAgc2Vzc2lvbiB0b2tlbiB0byBzaWduIHJlcXVlc3RzIHdpdGguXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjcmVkZW50aWFscyBbQVdTLkNyZWRlbnRpYWxzXSB0aGUgQVdTIGNyZWRlbnRpYWxzXG4gICAqICAgdG8gc2lnbiByZXF1ZXN0cyB3aXRoLiBZb3UgY2FuIGVpdGhlciBzcGVjaWZ5IHRoaXMgb2JqZWN0LCBvclxuICAgKiAgIHNwZWNpZnkgdGhlIGFjY2Vzc0tleUlkIGFuZCBzZWNyZXRBY2Nlc3NLZXkgb3B0aW9ucyBkaXJlY3RseS5cbiAgICogQG9wdGlvbiBvcHRpb25zIGNyZWRlbnRpYWxQcm92aWRlciBbQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluXSB0aGVcbiAgICogICBwcm92aWRlciBjaGFpbiB1c2VkIHRvIHJlc29sdmUgY3JlZGVudGlhbHMgaWYgbm8gc3RhdGljIGBjcmVkZW50aWFsc2BcbiAgICogICBwcm9wZXJ0eSBpcyBzZXQuXG4gICAqIEBvcHRpb24gb3B0aW9ucyByZWdpb24gW1N0cmluZ10gdGhlIHJlZ2lvbiB0byBzZW5kIHNlcnZpY2UgcmVxdWVzdHMgdG8uXG4gICAqICAgU2VlIHtyZWdpb259IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgbWF4UmV0cmllcyBbSW50ZWdlcl0gdGhlIG1heGltdW0gYW1vdW50IG9mIHJldHJpZXMgdG9cbiAgICogICBhdHRlbXB0IHdpdGggYSByZXF1ZXN0LiBTZWUge21heFJldHJpZXN9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgbWF4UmVkaXJlY3RzIFtJbnRlZ2VyXSB0aGUgbWF4aW11bSBhbW91bnQgb2YgcmVkaXJlY3RzIHRvXG4gICAqICAgZm9sbG93IHdpdGggYSByZXF1ZXN0LiBTZWUge21heFJlZGlyZWN0c30gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzc2xFbmFibGVkIFtCb29sZWFuXSB3aGV0aGVyIHRvIGVuYWJsZSBTU0wgZm9yXG4gICAqICAgcmVxdWVzdHMuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBwYXJhbVZhbGlkYXRpb24gW0Jvb2xlYW58bWFwXSB3aGV0aGVyIGlucHV0IHBhcmFtZXRlcnNcbiAgICogICBzaG91bGQgYmUgdmFsaWRhdGVkIGFnYWluc3QgdGhlIG9wZXJhdGlvbiBkZXNjcmlwdGlvbiBiZWZvcmUgc2VuZGluZ1xuICAgKiAgIHRoZSByZXF1ZXN0LiBEZWZhdWx0cyB0byB0cnVlLiBQYXNzIGEgbWFwIHRvIGVuYWJsZSBhbnkgb2YgdGhlXG4gICAqICAgZm9sbG93aW5nIHNwZWNpZmljIHZhbGlkYXRpb24gZmVhdHVyZXM6XG4gICAqXG4gICAqICAgKiAqKm1pbioqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgdmFsdWUgbWVldHMgdGhlIG1pblxuICAgKiAgICAgY29uc3RyYWludC4gVGhpcyBpcyBlbmFibGVkIGJ5IGRlZmF1bHQgd2hlbiBwYXJhbVZhbGlkYXRpb24gaXMgc2V0XG4gICAqICAgICB0byBgdHJ1ZWAuXG4gICAqICAgKiAqKm1heCoqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgdmFsdWUgbWVldHMgdGhlIG1heFxuICAgKiAgICAgY29uc3RyYWludC5cbiAgICogICAqICoqcGF0dGVybioqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgc3RyaW5nIHZhbHVlIG1hdGNoZXMgYVxuICAgKiAgICAgcmVndWxhciBleHByZXNzaW9uLlxuICAgKiAgICogKiplbnVtKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSBzdHJpbmcgdmFsdWUgbWF0Y2hlcyBvbmVcbiAgICogICAgIG9mIHRoZSBhbGxvd2FibGUgZW51bSB2YWx1ZXMuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjb21wdXRlQ2hlY2tzdW1zIFtCb29sZWFuXSB3aGV0aGVyIHRvIGNvbXB1dGUgY2hlY2tzdW1zXG4gICAqICAgZm9yIHBheWxvYWQgYm9kaWVzIHdoZW4gdGhlIHNlcnZpY2UgYWNjZXB0cyBpdCAoY3VycmVudGx5IHN1cHBvcnRlZFxuICAgKiAgIGluIFMzIG9ubHkpXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjb252ZXJ0UmVzcG9uc2VUeXBlcyBbQm9vbGVhbl0gd2hldGhlciB0eXBlcyBhcmUgY29udmVydGVkXG4gICAqICAgICB3aGVuIHBhcnNpbmcgcmVzcG9uc2UgZGF0YS4gQ3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGZvciBKU09OIGJhc2VkXG4gICAqICAgICBzZXJ2aWNlcy4gVHVybmluZyB0aGlzIG9mZiBtYXkgaW1wcm92ZSBwZXJmb3JtYW5jZSBvbiBsYXJnZSByZXNwb25zZVxuICAgKiAgICAgcGF5bG9hZHMuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIGNvcnJlY3RDbG9ja1NrZXcgW0Jvb2xlYW5dIHdoZXRoZXIgdG8gYXBwbHkgYSBjbG9jayBza2V3XG4gICAqICAgICBjb3JyZWN0aW9uIGFuZCByZXRyeSByZXF1ZXN0cyB0aGF0IGZhaWwgYmVjYXVzZSBvZiBhbiBza2V3ZWQgY2xpZW50XG4gICAqICAgICBjbG9jay4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIHMzRm9yY2VQYXRoU3R5bGUgW0Jvb2xlYW5dIHdoZXRoZXIgdG8gZm9yY2UgcGF0aFxuICAgKiAgIHN0eWxlIFVSTHMgZm9yIFMzIG9iamVjdHMuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzM0J1Y2tldEVuZHBvaW50IFtCb29sZWFuXSB3aGV0aGVyIHRoZSBwcm92aWRlZCBlbmRwb2ludFxuICAgKiAgIGFkZHJlc3NlcyBhbiBpbmRpdmlkdWFsIGJ1Y2tldCAoZmFsc2UgaWYgaXQgYWRkcmVzc2VzIHRoZSByb290IEFQSVxuICAgKiAgIGVuZHBvaW50KS4gTm90ZSB0aGF0IHNldHRpbmcgdGhpcyBjb25maWd1cmF0aW9uIG9wdGlvbiByZXF1aXJlcyBhblxuICAgKiAgIGBlbmRwb2ludGAgdG8gYmUgcHJvdmlkZWQgZXhwbGljaXRseSB0byB0aGUgc2VydmljZSBjb25zdHJ1Y3Rvci5cbiAgICogQG9wdGlvbiBvcHRpb25zIHMzRGlzYWJsZUJvZHlTaWduaW5nIFtCb29sZWFuXSB3aGV0aGVyIFMzIGJvZHkgc2lnbmluZ1xuICAgKiAgIHNob3VsZCBiZSBkaXNhYmxlZCB3aGVuIHVzaW5nIHNpZ25hdHVyZSB2ZXJzaW9uIGB2NGAuIEJvZHkgc2lnbmluZ1xuICAgKiAgIGNhbiBvbmx5IGJlIGRpc2FibGVkIHdoZW4gdXNpbmcgaHR0cHMuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIHMzVXNFYXN0MVJlZ2lvbmFsRW5kcG9pbnQgWydsZWdhY3knfCdyZWdpb25hbCddIHdoZW4gcmVnaW9uXG4gICAqICAgaXMgc2V0IHRvICd1cy1lYXN0LTEnLCB3aGV0aGVyIHRvIHNlbmQgczMgcmVxdWVzdCB0byBnbG9iYWwgZW5kcG9pbnRzIG9yXG4gICAqICAgJ3VzLWVhc3QtMScgcmVnaW9uYWwgZW5kcG9pbnRzLiBUaGlzIGNvbmZpZyBpcyBvbmx5IGFwcGxpY2FibGUgdG8gUzMgY2xpZW50LlxuICAgKiAgIERlZmF1bHRzIHRvIGBsZWdhY3lgXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzM1VzZUFyblJlZ2lvbiBbQm9vbGVhbl0gd2hldGhlciB0byBvdmVycmlkZSB0aGUgcmVxdWVzdCByZWdpb25cbiAgICogICB3aXRoIHRoZSByZWdpb24gaW5mZXJyZWQgZnJvbSByZXF1ZXN0ZWQgcmVzb3VyY2UncyBBUk4uIE9ubHkgYXZhaWxhYmxlIGZvciBTMyBidWNrZXRzXG4gICAqICAgRGVmYXVsdHMgdG8gYHRydWVgXG4gICAqXG4gICAqIEBvcHRpb24gb3B0aW9ucyByZXRyeURlbGF5T3B0aW9ucyBbbWFwXSBBIHNldCBvZiBvcHRpb25zIHRvIGNvbmZpZ3VyZVxuICAgKiAgIHRoZSByZXRyeSBkZWxheSBvbiByZXRyeWFibGUgZXJyb3JzLiBDdXJyZW50bHkgc3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICAgKlxuICAgKiAgICogKipiYXNlKiogW0ludGVnZXJdICZtZGFzaDsgVGhlIGJhc2UgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB1c2UgaW4gdGhlXG4gICAqICAgICBleHBvbmVudGlhbCBiYWNrb2ZmIGZvciBvcGVyYXRpb24gcmV0cmllcy4gRGVmYXVsdHMgdG8gMTAwIG1zIGZvciBhbGxcbiAgICogICAgIHNlcnZpY2VzIGV4Y2VwdCBEeW5hbW9EQiwgd2hlcmUgaXQgZGVmYXVsdHMgdG8gNTBtcy5cbiAgICogICAqICoqY3VzdG9tQmFja29mZiAqKiBbZnVuY3Rpb25dICZtZGFzaDsgQSBjdXN0b20gZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFcbiAgICogICAgIHJldHJ5IGNvdW50IGFuZCBlcnJvciBhbmQgcmV0dXJucyB0aGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgaW5cbiAgICogICAgIG1pbGxpc2Vjb25kcy4gSWYgdGhlIHJlc3VsdCBpcyBhIG5vbi16ZXJvIG5lZ2F0aXZlIHZhbHVlLCBubyBmdXJ0aGVyXG4gICAqICAgICByZXRyeSBhdHRlbXB0cyB3aWxsIGJlIG1hZGUuIFRoZSBgYmFzZWAgb3B0aW9uIHdpbGwgYmUgaWdub3JlZCBpZiB0aGlzXG4gICAqICAgICBvcHRpb24gaXMgc3VwcGxpZWQuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBodHRwT3B0aW9ucyBbbWFwXSBBIHNldCBvZiBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIGxvdy1sZXZlbFxuICAgKiAgIEhUVFAgcmVxdWVzdC4gQ3VycmVudGx5IHN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAgICpcbiAgICogICAqICoqcHJveHkqKiBbU3RyaW5nXSAmbWRhc2g7IHRoZSBVUkwgdG8gcHJveHkgcmVxdWVzdHMgdGhyb3VnaFxuICAgKiAgICogKiphZ2VudCoqIFtodHRwLkFnZW50LCBodHRwcy5BZ2VudF0gJm1kYXNoOyB0aGUgQWdlbnQgb2JqZWN0IHRvIHBlcmZvcm1cbiAgICogICAgIEhUVFAgcmVxdWVzdHMgd2l0aC4gVXNlZCBmb3IgY29ubmVjdGlvbiBwb29saW5nLiBEZWZhdWx0cyB0byB0aGUgZ2xvYmFsXG4gICAqICAgICBhZ2VudCAoYGh0dHAuZ2xvYmFsQWdlbnRgKSBmb3Igbm9uLVNTTCBjb25uZWN0aW9ucy4gTm90ZSB0aGF0IGZvclxuICAgKiAgICAgU1NMIGNvbm5lY3Rpb25zLCBhIHNwZWNpYWwgQWdlbnQgb2JqZWN0IGlzIHVzZWQgaW4gb3JkZXIgdG8gZW5hYmxlXG4gICAqICAgICBwZWVyIGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvbi4gVGhpcyBmZWF0dXJlIGlzIG9ubHkgYXZhaWxhYmxlIGluIHRoZVxuICAgKiAgICAgTm9kZS5qcyBlbnZpcm9ubWVudC5cbiAgICogICAqICoqY29ubmVjdFRpbWVvdXQqKiBbSW50ZWdlcl0gJm1kYXNoOyBTZXRzIHRoZSBzb2NrZXQgdG8gdGltZW91dCBhZnRlclxuICAgKiAgICAgZmFpbGluZyB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHdpdGggdGhlIHNlcnZlciBhZnRlclxuICAgKiAgICAgYGNvbm5lY3RUaW1lb3V0YCBtaWxsaXNlY29uZHMuIFRoaXMgdGltZW91dCBoYXMgbm8gZWZmZWN0IG9uY2UgYSBzb2NrZXRcbiAgICogICAgIGNvbm5lY3Rpb24gaGFzIGJlZW4gZXN0YWJsaXNoZWQuXG4gICAqICAgKiAqKnRpbWVvdXQqKiBbSW50ZWdlcl0gJm1kYXNoOyBTZXRzIHRoZSBzb2NrZXQgdG8gdGltZW91dCBhZnRlciB0aW1lb3V0XG4gICAqICAgICBtaWxsaXNlY29uZHMgb2YgaW5hY3Rpdml0eSBvbiB0aGUgc29ja2V0LiBEZWZhdWx0cyB0byB0d28gbWludXRlc1xuICAgKiAgICAgKDEyMDAwMCkuXG4gICAqICAgKiAqKnhockFzeW5jKiogW0Jvb2xlYW5dICZtZGFzaDsgV2hldGhlciB0aGUgU0RLIHdpbGwgc2VuZCBhc3luY2hyb25vdXNcbiAgICogICAgIEhUVFAgcmVxdWVzdHMuIFVzZWQgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQgb25seS4gU2V0IHRvIGZhbHNlIHRvXG4gICAqICAgICBzZW5kIHJlcXVlc3RzIHN5bmNocm9ub3VzbHkuIERlZmF1bHRzIHRvIHRydWUgKGFzeW5jIG9uKS5cbiAgICogICAqICoqeGhyV2l0aENyZWRlbnRpYWxzKiogW0Jvb2xlYW5dICZtZGFzaDsgU2V0cyB0aGUgXCJ3aXRoQ3JlZGVudGlhbHNcIlxuICAgKiAgICAgcHJvcGVydHkgb2YgYW4gWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LiBVc2VkIGluIHRoZSBicm93c2VyIGVudmlyb25tZW50XG4gICAqICAgICBvbmx5LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICogQG9wdGlvbiBvcHRpb25zIGFwaVZlcnNpb24gW1N0cmluZywgRGF0ZV0gYSBTdHJpbmcgaW4gWVlZWS1NTS1ERCBmb3JtYXRcbiAgICogICAob3IgYSBkYXRlKSB0aGF0IHJlcHJlc2VudHMgdGhlIGxhdGVzdCBwb3NzaWJsZSBBUEkgdmVyc2lvbiB0aGF0IGNhbiBiZVxuICAgKiAgIHVzZWQgaW4gYWxsIHNlcnZpY2VzICh1bmxlc3Mgb3ZlcnJpZGRlbiBieSBgYXBpVmVyc2lvbnNgKS4gU3BlY2lmeVxuICAgKiAgICdsYXRlc3QnIHRvIHVzZSB0aGUgbGF0ZXN0IHBvc3NpYmxlIHZlcnNpb24uXG4gICAqIEBvcHRpb24gb3B0aW9ucyBhcGlWZXJzaW9ucyBbbWFwPFN0cmluZywgU3RyaW5nfERhdGU+XSBhIG1hcCBvZiBzZXJ2aWNlXG4gICAqICAgaWRlbnRpZmllcnMgKHRoZSBsb3dlcmNhc2Ugc2VydmljZSBjbGFzcyBuYW1lKSB3aXRoIHRoZSBBUEkgdmVyc2lvbiB0b1xuICAgKiAgIHVzZSB3aGVuIGluc3RhbnRpYXRpbmcgYSBzZXJ2aWNlLiBTcGVjaWZ5ICdsYXRlc3QnIGZvciBlYWNoIGluZGl2aWR1YWxcbiAgICogICB0aGF0IGNhbiB1c2UgdGhlIGxhdGVzdCBhdmFpbGFibGUgdmVyc2lvbi5cbiAgICogQG9wdGlvbiBvcHRpb25zIGxvZ2dlciBbI3dyaXRlLCNsb2ddIGFuIG9iamVjdCB0aGF0IHJlc3BvbmRzIHRvIC53cml0ZSgpXG4gICAqICAgKGxpa2UgYSBzdHJlYW0pIG9yIC5sb2coKSAobGlrZSB0aGUgY29uc29sZSBvYmplY3QpIGluIG9yZGVyIHRvIGxvZ1xuICAgKiAgIGluZm9ybWF0aW9uIGFib3V0IHJlcXVlc3RzXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzeXN0ZW1DbG9ja09mZnNldCBbTnVtYmVyXSBhbiBvZmZzZXQgdmFsdWUgaW4gbWlsbGlzZWNvbmRzXG4gICAqICAgdG8gYXBwbHkgdG8gYWxsIHNpZ25pbmcgdGltZXMuIFVzZSB0aGlzIHRvIGNvbXBlbnNhdGUgZm9yIGNsb2NrIHNrZXdcbiAgICogICB3aGVuIHlvdXIgc3lzdGVtIG1heSBiZSBvdXQgb2Ygc3luYyB3aXRoIHRoZSBzZXJ2aWNlIHRpbWUuIE5vdGUgdGhhdFxuICAgKiAgIHRoaXMgY29uZmlndXJhdGlvbiBvcHRpb24gY2FuIG9ubHkgYmUgYXBwbGllZCB0byB0aGUgZ2xvYmFsIGBBV1MuY29uZmlnYFxuICAgKiAgIG9iamVjdCBhbmQgY2Fubm90IGJlIG92ZXJyaWRkZW4gaW4gc2VydmljZS1zcGVjaWZpYyBjb25maWd1cmF0aW9uLlxuICAgKiAgIERlZmF1bHRzIHRvIDAgbWlsbGlzZWNvbmRzLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc2lnbmF0dXJlVmVyc2lvbiBbU3RyaW5nXSB0aGUgc2lnbmF0dXJlIHZlcnNpb24gdG8gc2lnblxuICAgKiAgIHJlcXVlc3RzIHdpdGggKG92ZXJyaWRpbmcgdGhlIEFQSSBjb25maWd1cmF0aW9uKS4gUG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICogICAndjInLCAndjMnLCAndjQnLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc2lnbmF0dXJlQ2FjaGUgW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIHNpZ25hdHVyZSB0byBzaWduXG4gICAqICAgcmVxdWVzdHMgd2l0aCAob3ZlcnJpZGluZyB0aGUgQVBJIGNvbmZpZ3VyYXRpb24pIGlzIGNhY2hlZC4gT25seSBhcHBsaWVzXG4gICAqICAgdG8gdGhlIHNpZ25hdHVyZSB2ZXJzaW9uICd2NCcuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIGR5bmFtb0RiQ3JjMzIgW0Jvb2xlYW5dIHdoZXRoZXIgdG8gdmFsaWRhdGUgdGhlIENSQzMyXG4gICAqICAgY2hlY2tzdW0gb2YgSFRUUCByZXNwb25zZSBib2RpZXMgcmV0dXJuZWQgYnkgRHluYW1vREIuIERlZmF1bHQ6IGB0cnVlYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIHVzZUFjY2VsZXJhdGVFbmRwb2ludCBbQm9vbGVhbl0gV2hldGhlciB0byB1c2UgdGhlXG4gICAqICAgUzMgVHJhbnNmZXIgQWNjZWxlcmF0aW9uIGVuZHBvaW50IHdpdGggdGhlIFMzIHNlcnZpY2UuIERlZmF1bHQ6IGBmYWxzZWAuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjbGllbnRTaWRlTW9uaXRvcmluZyBbQm9vbGVhbl0gd2hldGhlciB0byBjb2xsZWN0IGFuZFxuICAgKiAgIHB1Ymxpc2ggdGhpcyBjbGllbnQncyBwZXJmb3JtYW5jZSBtZXRyaWNzIG9mIGFsbCBpdHMgQVBJIHJlcXVlc3RzLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgZW5kcG9pbnREaXNjb3ZlcnlFbmFibGVkIFtCb29sZWFuXSB3aGV0aGVyIHRvIGVuYWJsZSBlbmRwb2ludFxuICAgKiAgIGRpc2NvdmVyeSBmb3Igb3BlcmF0aW9ucyB0aGF0IGFsbG93IG9wdGlvbmFsbHkgdXNpbmcgYW4gZW5kcG9pbnQgcmV0dXJuZWQgYnlcbiAgICogICB0aGUgc2VydmljZS5cbiAgICogICBEZWZhdWx0cyB0byAnZmFsc2UnXG4gICAqIEBvcHRpb24gb3B0aW9ucyBlbmRwb2ludENhY2hlU2l6ZSBbTnVtYmVyXSB0aGUgc2l6ZSBvZiB0aGUgZ2xvYmFsIGNhY2hlIHN0b3JpbmdcbiAgICogICBlbmRwb2ludHMgZnJvbSBlbmRwb2ludCBkaXNjb3Zlcnkgb3BlcmF0aW9ucy4gT25jZSBlbmRwb2ludCBjYWNoZSBpcyBjcmVhdGVkLFxuICAgKiAgIHVwZGF0aW5nIHRoaXMgc2V0dGluZyBjYW5ub3QgY2hhbmdlIGV4aXN0aW5nIGNhY2hlIHNpemUuXG4gICAqICAgRGVmYXVsdHMgdG8gMTAwMFxuICAgKiBAb3B0aW9uIG9wdGlvbnMgaG9zdFByZWZpeEVuYWJsZWQgW0Jvb2xlYW5dIHdoZXRoZXIgdG8gbWFyc2hhbCByZXF1ZXN0XG4gICAqICAgcGFyYW1ldGVycyB0byB0aGUgcHJlZml4IG9mIGhvc3RuYW1lLlxuICAgKiAgIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIHN0c1JlZ2lvbmFsRW5kcG9pbnRzIFsnbGVnYWN5J3wncmVnaW9uYWwnXSB3aGV0aGVyIHRvIHNlbmQgc3RzIHJlcXVlc3RcbiAgICogICB0byBnbG9iYWwgZW5kcG9pbnRzIG9yIHJlZ2lvbmFsIGVuZHBvaW50cy5cbiAgICogICBEZWZhdWx0cyB0byAnbGVnYWN5Jy5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBDb25maWcob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIG9wdGlvbnMgPSB7fTtcbiAgICBvcHRpb25zID0gdGhpcy5leHRyYWN0Q3JlZGVudGlhbHMob3B0aW9ucyk7XG5cbiAgICBBV1MudXRpbC5lYWNoLmNhbGwodGhpcywgdGhpcy5rZXlzLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5zZXQoa2V5LCBvcHRpb25zW2tleV0sIHZhbHVlKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQCFncm91cCBNYW5hZ2luZyBDcmVkZW50aWFsc1xuICAgKi9cblxuICAvKipcbiAgICogTG9hZHMgY3JlZGVudGlhbHMgZnJvbSB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QuIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5XG4gICAqIGJ5IHRoZSBTREsgdG8gZW5zdXJlIHRoYXQgcmVmcmVzaGFibGUge0NyZWRlbnRpYWxzfSBvYmplY3RzIGFyZSBwcm9wZXJseVxuICAgKiByZWZyZXNoZWQgYW5kIGxvYWRlZCB3aGVuIHNlbmRpbmcgYSByZXF1ZXN0LiBJZiB5b3Ugd2FudCB0byBlbnN1cmUgdGhhdFxuICAgKiB5b3VyIGNyZWRlbnRpYWxzIGFyZSBsb2FkZWQgcHJpb3IgdG8gYSByZXF1ZXN0LCB5b3UgY2FuIHVzZSB0aGlzIG1ldGhvZFxuICAgKiBkaXJlY3RseSB0byBwcm92aWRlIGFjY3VyYXRlIGNyZWRlbnRpYWwgZGF0YSBzdG9yZWQgaW4gdGhlIG9iamVjdC5cbiAgICpcbiAgICogQG5vdGUgSWYgeW91IGNvbmZpZ3VyZSB0aGUgU0RLIHdpdGggc3RhdGljIG9yIGVudmlyb25tZW50IGNyZWRlbnRpYWxzLFxuICAgKiAgIHRoZSBjcmVkZW50aWFsIGRhdGEgc2hvdWxkIGFscmVhZHkgYmUgcHJlc2VudCBpbiB7Y3JlZGVudGlhbHN9IGF0dHJpYnV0ZS5cbiAgICogICBUaGlzIG1ldGhvZCBpcyBwcmltYXJpbHkgbmVjZXNzYXJ5IHRvIGxvYWQgY3JlZGVudGlhbHMgZnJvbSBhc3luY2hyb25vdXNcbiAgICogICBzb3VyY2VzLCBvciBzb3VyY2VzIHRoYXQgY2FuIHJlZnJlc2ggY3JlZGVudGlhbHMgcGVyaW9kaWNhbGx5LlxuICAgKiBAZXhhbXBsZSBHZXR0aW5nIHlvdXIgYWNjZXNzIGtleVxuICAgKiAgIEFXUy5jb25maWcuZ2V0Q3JlZGVudGlhbHMoZnVuY3Rpb24oZXJyKSB7XG4gICAqICAgICBpZiAoZXJyKSBjb25zb2xlLmxvZyhlcnIuc3RhY2spOyAvLyBjcmVkZW50aWFscyBub3QgbG9hZGVkXG4gICAqICAgICBlbHNlIGNvbnNvbGUubG9nKFwiQWNjZXNzIEtleTpcIiwgQVdTLmNvbmZpZy5jcmVkZW50aWFscy5hY2Nlc3NLZXlJZCk7XG4gICAqICAgfSlcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgd2hlbiB0aGUge2NyZWRlbnRpYWxzfSBoYXZlIGJlZW4gcHJvcGVybHkgc2V0IG9uIHRoZSBjb25maWd1cmF0aW9uXG4gICAqICAgb2JqZWN0LlxuICAgKlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiB0aGlzIGlzIHNldCwgY3JlZGVudGlhbHMgd2VyZSBub3Qgc3VjY2Vzc2Z1bGx5XG4gICAqICAgICBsb2FkZWQgYW5kIHRoaXMgZXJyb3IgcHJvdmlkZXMgaW5mb3JtYXRpb24gd2h5LlxuICAgKiBAc2VlIGNyZWRlbnRpYWxzXG4gICAqIEBzZWUgQ3JlZGVudGlhbHNcbiAgICovXG4gIGdldENyZWRlbnRpYWxzOiBmdW5jdGlvbiBnZXRDcmVkZW50aWFscyhjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGZpbmlzaChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVyciwgZXJyID8gbnVsbCA6IHNlbGYuY3JlZGVudGlhbHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWRFcnJvcihtc2csIGVycikge1xuICAgICAgcmV0dXJuIG5ldyBBV1MudXRpbC5lcnJvcihlcnIgfHwgbmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0NyZWRlbnRpYWxzRXJyb3InLFxuICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgIG5hbWU6ICdDcmVkZW50aWFsc0Vycm9yJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QXN5bmNDcmVkZW50aWFscygpIHtcbiAgICAgIHNlbGYuY3JlZGVudGlhbHMuZ2V0KGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgdmFyIG1zZyA9ICdDb3VsZCBub3QgbG9hZCBjcmVkZW50aWFscyBmcm9tICcgK1xuICAgICAgICAgICAgc2VsZi5jcmVkZW50aWFscy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICAgIGVyciA9IGNyZWRFcnJvcihtc2csIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZmluaXNoKGVycik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdGF0aWNDcmVkZW50aWFscygpIHtcbiAgICAgIHZhciBlcnIgPSBudWxsO1xuICAgICAgaWYgKCFzZWxmLmNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkIHx8ICFzZWxmLmNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSkge1xuICAgICAgICBlcnIgPSBjcmVkRXJyb3IoJ01pc3NpbmcgY3JlZGVudGlhbHMnKTtcbiAgICAgIH1cbiAgICAgIGZpbmlzaChlcnIpO1xuICAgIH1cblxuICAgIGlmIChzZWxmLmNyZWRlbnRpYWxzKSB7XG4gICAgICBpZiAodHlwZW9mIHNlbGYuY3JlZGVudGlhbHMuZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGdldEFzeW5jQ3JlZGVudGlhbHMoKTtcbiAgICAgIH0gZWxzZSB7IC8vIHN0YXRpYyBjcmVkZW50aWFsc1xuICAgICAgICBnZXRTdGF0aWNDcmVkZW50aWFscygpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2VsZi5jcmVkZW50aWFsUHJvdmlkZXIpIHtcbiAgICAgIHNlbGYuY3JlZGVudGlhbFByb3ZpZGVyLnJlc29sdmUoZnVuY3Rpb24oZXJyLCBjcmVkcykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZXJyID0gY3JlZEVycm9yKCdDb3VsZCBub3QgbG9hZCBjcmVkZW50aWFscyBmcm9tIGFueSBwcm92aWRlcnMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuY3JlZGVudGlhbHMgPSBjcmVkcztcbiAgICAgICAgZmluaXNoKGVycik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluaXNoKGNyZWRFcnJvcignTm8gY3JlZGVudGlhbHMgdG8gbG9hZCcpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEAhZ3JvdXAgTG9hZGluZyBhbmQgU2V0dGluZyBDb25maWd1cmF0aW9uIE9wdGlvbnNcbiAgICovXG5cbiAgLyoqXG4gICAqIEBvdmVybG9hZCB1cGRhdGUob3B0aW9ucywgYWxsb3dVbmtub3duS2V5cyA9IGZhbHNlKVxuICAgKiAgIFVwZGF0ZXMgdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCBuZXcgb3B0aW9ucy5cbiAgICpcbiAgICogICBAZXhhbXBsZSBVcGRhdGUgbWF4UmV0cmllcyBwcm9wZXJ0eSBvZiBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqICAgICBjb25maWcudXBkYXRlKHttYXhSZXRyaWVzOiAxMH0pO1xuICAgKiAgIEBwYXJhbSBbT2JqZWN0XSBvcHRpb25zIGEgbWFwIG9mIG9wdGlvbiBrZXlzIGFuZCB2YWx1ZXMuXG4gICAqICAgQHBhcmFtIFtCb29sZWFuXSBhbGxvd1Vua25vd25LZXlzIHdoZXRoZXIgdW5rbm93biBrZXlzIGNhbiBiZSBzZXQgb25cbiAgICogICAgIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICogICBAc2VlIGNvbnN0cnVjdG9yXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvcHRpb25zLCBhbGxvd1Vua25vd25LZXlzKSB7XG4gICAgYWxsb3dVbmtub3duS2V5cyA9IGFsbG93VW5rbm93bktleXMgfHwgZmFsc2U7XG4gICAgb3B0aW9ucyA9IHRoaXMuZXh0cmFjdENyZWRlbnRpYWxzKG9wdGlvbnMpO1xuICAgIEFXUy51dGlsLmVhY2guY2FsbCh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGFsbG93VW5rbm93bktleXMgfHwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMua2V5cywga2V5KSB8fFxuICAgICAgICAgIEFXUy5TZXJ2aWNlLmhhc1NlcnZpY2Uoa2V5KSkge1xuICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogTG9hZHMgY29uZmlndXJhdGlvbiBkYXRhIGZyb20gYSBKU09OIGZpbGUgaW50byB0aGlzIGNvbmZpZyBvYmplY3QuXG4gICAqIEBub3RlIExvYWRpbmcgY29uZmlndXJhdGlvbiB3aWxsIHJlc2V0IGFsbCBleGlzdGluZyBjb25maWd1cmF0aW9uXG4gICAqICAgb24gdGhlIG9iamVjdC5cbiAgICogQCFtYWNybyBub2Jyb3dzZXJcbiAgICogQHBhcmFtIHBhdGggW1N0cmluZ10gdGhlIHBhdGggcmVsYXRpdmUgdG8geW91ciBwcm9jZXNzJ3MgY3VycmVudFxuICAgKiAgICB3b3JraW5nIGRpcmVjdG9yeSB0byBsb2FkIGNvbmZpZ3VyYXRpb24gZnJvbS5cbiAgICogQHJldHVybiBbQVdTLkNvbmZpZ10gdGhlIHNhbWUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIGxvYWRGcm9tUGF0aDogZnVuY3Rpb24gbG9hZEZyb21QYXRoKHBhdGgpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IEpTT04ucGFyc2UoQVdTLnV0aWwucmVhZEZpbGVTeW5jKHBhdGgpKTtcbiAgICB2YXIgZmlsZVN5c3RlbUNyZWRzID0gbmV3IEFXUy5GaWxlU3lzdGVtQ3JlZGVudGlhbHMocGF0aCk7XG4gICAgdmFyIGNoYWluID0gbmV3IEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbigpO1xuICAgIGNoYWluLnByb3ZpZGVycy51bnNoaWZ0KGZpbGVTeXN0ZW1DcmVkcyk7XG4gICAgY2hhaW4ucmVzb2x2ZShmdW5jdGlvbiAoZXJyLCBjcmVkcykge1xuICAgICAgaWYgKGVycikgdGhyb3cgZXJyO1xuICAgICAgZWxzZSBvcHRpb25zLmNyZWRlbnRpYWxzID0gY3JlZHM7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnN0cnVjdG9yKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFycyBjb25maWd1cmF0aW9uIGRhdGEgb24gdGhpcyBvYmplY3RcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgLypqc2hpbnQgZm9yaW46ZmFsc2UgKi9cbiAgICBBV1MudXRpbC5lYWNoLmNhbGwodGhpcywgdGhpcy5rZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgIH0pO1xuXG4gICAgLy8gcmVzZXQgY3JlZGVudGlhbCBwcm92aWRlclxuICAgIHRoaXMuc2V0KCdjcmVkZW50aWFscycsIHVuZGVmaW5lZCk7XG4gICAgdGhpcy5zZXQoJ2NyZWRlbnRpYWxQcm92aWRlcicsIHVuZGVmaW5lZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBwcm9wZXJ0eSBvbiB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QsIGFsbG93aW5nIGZvciBhXG4gICAqIGRlZmF1bHQgdmFsdWVcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzZXQ6IGZ1bmN0aW9uIHNldChwcm9wZXJ0eSwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gdGhpcy5rZXlzW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gZGVmYXVsdFZhbHVlLmNhbGwodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSAnaHR0cE9wdGlvbnMnICYmIHRoaXNbcHJvcGVydHldKSB7XG4gICAgICAvLyBkZWVwIG1lcmdlIGh0dHBPcHRpb25zXG4gICAgICB0aGlzW3Byb3BlcnR5XSA9IEFXUy51dGlsLm1lcmdlKHRoaXNbcHJvcGVydHldLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBbGwgb2YgdGhlIGtleXMgd2l0aCB0aGVpciBkZWZhdWx0IHZhbHVlcy5cbiAgICpcbiAgICogQGNvbnN0YW50XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAga2V5czoge1xuICAgIGNyZWRlbnRpYWxzOiBudWxsLFxuICAgIGNyZWRlbnRpYWxQcm92aWRlcjogbnVsbCxcbiAgICByZWdpb246IG51bGwsXG4gICAgbG9nZ2VyOiBudWxsLFxuICAgIGFwaVZlcnNpb25zOiB7fSxcbiAgICBhcGlWZXJzaW9uOiBudWxsLFxuICAgIGVuZHBvaW50OiB1bmRlZmluZWQsXG4gICAgaHR0cE9wdGlvbnM6IHtcbiAgICAgIHRpbWVvdXQ6IDEyMDAwMFxuICAgIH0sXG4gICAgbWF4UmV0cmllczogdW5kZWZpbmVkLFxuICAgIG1heFJlZGlyZWN0czogMTAsXG4gICAgcGFyYW1WYWxpZGF0aW9uOiB0cnVlLFxuICAgIHNzbEVuYWJsZWQ6IHRydWUsXG4gICAgczNGb3JjZVBhdGhTdHlsZTogZmFsc2UsXG4gICAgczNCdWNrZXRFbmRwb2ludDogZmFsc2UsXG4gICAgczNEaXNhYmxlQm9keVNpZ25pbmc6IHRydWUsXG4gICAgczNVc0Vhc3QxUmVnaW9uYWxFbmRwb2ludDogJ2xlZ2FjeScsXG4gICAgczNVc2VBcm5SZWdpb246IHVuZGVmaW5lZCxcbiAgICBjb21wdXRlQ2hlY2tzdW1zOiB0cnVlLFxuICAgIGNvbnZlcnRSZXNwb25zZVR5cGVzOiB0cnVlLFxuICAgIGNvcnJlY3RDbG9ja1NrZXc6IGZhbHNlLFxuICAgIGN1c3RvbVVzZXJBZ2VudDogbnVsbCxcbiAgICBkeW5hbW9EYkNyYzMyOiB0cnVlLFxuICAgIHN5c3RlbUNsb2NrT2Zmc2V0OiAwLFxuICAgIHNpZ25hdHVyZVZlcnNpb246IG51bGwsXG4gICAgc2lnbmF0dXJlQ2FjaGU6IHRydWUsXG4gICAgcmV0cnlEZWxheU9wdGlvbnM6IHt9LFxuICAgIHVzZUFjY2VsZXJhdGVFbmRwb2ludDogZmFsc2UsXG4gICAgY2xpZW50U2lkZU1vbml0b3Jpbmc6IGZhbHNlLFxuICAgIGVuZHBvaW50RGlzY292ZXJ5RW5hYmxlZDogZmFsc2UsXG4gICAgZW5kcG9pbnRDYWNoZVNpemU6IDEwMDAsXG4gICAgaG9zdFByZWZpeEVuYWJsZWQ6IHRydWUsXG4gICAgc3RzUmVnaW9uYWxFbmRwb2ludHM6ICdsZWdhY3knXG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGFjY2Vzc0tleUlkLCBzZWNyZXRBY2Nlc3NLZXkgYW5kIHNlc3Npb25Ub2tlblxuICAgKiBmcm9tIGEgY29uZmlndXJhdGlvbiBoYXNoLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGV4dHJhY3RDcmVkZW50aWFsczogZnVuY3Rpb24gZXh0cmFjdENyZWRlbnRpYWxzKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5hY2Nlc3NLZXlJZCAmJiBvcHRpb25zLnNlY3JldEFjY2Vzc0tleSkge1xuICAgICAgb3B0aW9ucyA9IEFXUy51dGlsLmNvcHkob3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5DcmVkZW50aWFscyhvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByb21pc2UgZGVwZW5kZW5jeSB0aGUgU0RLIHdpbGwgdXNlIHdoZXJldmVyIFByb21pc2VzIGFyZSByZXR1cm5lZC5cbiAgICogUGFzc2luZyBgbnVsbGAgd2lsbCBmb3JjZSB0aGUgU0RLIHRvIHVzZSBuYXRpdmUgUHJvbWlzZXMgaWYgdGhleSBhcmUgYXZhaWxhYmxlLlxuICAgKiBJZiBuYXRpdmUgUHJvbWlzZXMgYXJlIG5vdCBhdmFpbGFibGUsIHBhc3NpbmcgYG51bGxgIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gICAqIEBwYXJhbSBbQ29uc3RydWN0b3JdIGRlcCBBIHJlZmVyZW5jZSB0byBhIFByb21pc2UgY29uc3RydWN0b3JcbiAgICovXG4gIHNldFByb21pc2VzRGVwZW5kZW5jeTogZnVuY3Rpb24gc2V0UHJvbWlzZXNEZXBlbmRlbmN5KGRlcCkge1xuICAgIFByb21pc2VzRGVwZW5kZW5jeSA9IGRlcDtcbiAgICAvLyBpZiBudWxsIHdhcyBwYXNzZWQgaW4sIHdlIHNob3VsZCB0cnkgdG8gdXNlIG5hdGl2ZSBwcm9taXNlc1xuICAgIGlmIChkZXAgPT09IG51bGwgJiYgdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIFByb21pc2VzRGVwZW5kZW5jeSA9IFByb21pc2U7XG4gICAgfVxuICAgIHZhciBjb25zdHJ1Y3RvcnMgPSBbQVdTLlJlcXVlc3QsIEFXUy5DcmVkZW50aWFscywgQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluXTtcbiAgICBpZiAoQVdTLlMzKSB7XG4gICAgICBjb25zdHJ1Y3RvcnMucHVzaChBV1MuUzMpO1xuICAgICAgaWYgKEFXUy5TMy5NYW5hZ2VkVXBsb2FkKSB7XG4gICAgICAgIGNvbnN0cnVjdG9ycy5wdXNoKEFXUy5TMy5NYW5hZ2VkVXBsb2FkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgQVdTLnV0aWwuYWRkUHJvbWlzZXMoY29uc3RydWN0b3JzLCBQcm9taXNlc0RlcGVuZGVuY3kpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwcm9taXNlIGRlcGVuZGVuY3kgc2V0IGJ5IGBBV1MuY29uZmlnLnNldFByb21pc2VzRGVwZW5kZW5jeWAuXG4gICAqL1xuICBnZXRQcm9taXNlc0RlcGVuZGVuY3k6IGZ1bmN0aW9uIGdldFByb21pc2VzRGVwZW5kZW5jeSgpIHtcbiAgICByZXR1cm4gUHJvbWlzZXNEZXBlbmRlbmN5O1xuICB9XG59KTtcblxuLyoqXG4gKiBAcmV0dXJuIFtBV1MuQ29uZmlnXSBUaGUgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHNpbmdsZXRvbiBpbnN0YW5jZVxuICogQHJlYWRvbmx5XG4gKiBAc2VlIEFXUy5Db25maWdcbiAqL1xuQVdTLmNvbmZpZyA9IG5ldyBBV1MuQ29uZmlnKCk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJlZ2lvbmFsRW5kcG9pbnRzRmxhZ1ZhbHVlKGNvbmZpZ1ZhbHVlLCBlcnJvck9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBjb25maWdWYWx1ZSAhPT0gJ3N0cmluZycpIHJldHVybiB1bmRlZmluZWQ7XG4gIGVsc2UgaWYgKFsnbGVnYWN5JywgJ3JlZ2lvbmFsJ10uaW5kZXhPZihjb25maWdWYWx1ZS50b0xvd2VyQ2FzZSgpKSA+PSAwKSB7XG4gICAgcmV0dXJuIGNvbmZpZ1ZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIGVycm9yT3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNvbHZlIHRoZSBjb25maWd1cmF0aW9uIHZhbHVlIGZvciByZWdpb25hbCBlbmRwb2ludCBmcm9tIGRpZmZlcmVuY2Ugc291cmNlczogY2xpZW50XG4gKiBjb25maWcsIGVudmlyb25tZW50YWwgdmFyaWFibGUsIHNoYXJlZCBjb25maWcgZmlsZS4gVmFsdWUgY2FuIGJlIGNhc2UtaW5zZW5zaXRpdmVcbiAqICdsZWdhY3knIG9yICdyZWdpbmFsJy5cbiAqIEBwYXJhbSBvcmlnaW5hbENvbmZpZyB1c2VyLXN1cHBsaWVkIGNvbmZpZyBvYmplY3QgdG8gcmVzb2x2ZVxuICogQHBhcmFtIG9wdGlvbnMgYSBtYXAgb2YgY29uZmlnIHByb3BlcnR5IG5hbWVzIGZyb20gaW5kaXZpZHVhbCBjb25maWd1cmF0aW9uIHNvdXJjZVxuICogIC0gZW52OiBuYW1lIG9mIGVudmlyb25tZW50YWwgdmFyaWFibGUgdGhhdCByZWZlcnMgdG8gdGhlIGNvbmZpZ1xuICogIC0gc2hhcmVkQ29uZmlnOiBuYW1lIG9mIHNoYXJlZCBjb25maWd1cmF0aW9uIGZpbGUgcHJvcGVydHkgdGhhdCByZWZlcnMgdG8gdGhlIGNvbmZpZ1xuICogIC0gY2xpZW50Q29uZmlnOiBuYW1lIG9mIGNsaWVudCBjb25maWd1cmF0aW9uIHByb3BlcnR5IHRoYXQgcmVmZXJzIHRvIHRoZSBjb25maWdcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVJlZ2lvbmFsRW5kcG9pbnRzRmxhZyhvcmlnaW5hbENvbmZpZywgb3B0aW9ucykge1xuICBvcmlnaW5hbENvbmZpZyA9IG9yaWdpbmFsQ29uZmlnIHx8IHt9O1xuICAvL3ZhbGlkYXRlIGNvbmZpZyB2YWx1ZVxuICB2YXIgcmVzb2x2ZWQ7XG4gIGlmIChvcmlnaW5hbENvbmZpZ1tvcHRpb25zLmNsaWVudENvbmZpZ10pIHtcbiAgICByZXNvbHZlZCA9IHZhbGlkYXRlUmVnaW9uYWxFbmRwb2ludHNGbGFnVmFsdWUob3JpZ2luYWxDb25maWdbb3B0aW9ucy5jbGllbnRDb25maWddLCB7XG4gICAgICBjb2RlOiAnSW52YWxpZENvbmZpZ3VyYXRpb24nLFxuICAgICAgbWVzc2FnZTogJ2ludmFsaWQgXCInICsgb3B0aW9ucy5jbGllbnRDb25maWcgKyAnXCIgY29uZmlndXJhdGlvbi4gRXhwZWN0IFwibGVnYWN5XCIgJyArXG4gICAgICAnIG9yIFwicmVnaW9uYWxcIi4gR290IFwiJyArIG9yaWdpbmFsQ29uZmlnW29wdGlvbnMuY2xpZW50Q29uZmlnXSArICdcIi4nXG4gICAgfSk7XG4gICAgaWYgKHJlc29sdmVkKSByZXR1cm4gcmVzb2x2ZWQ7XG4gIH1cbiAgaWYgKCFBV1MudXRpbC5pc05vZGUoKSkgcmV0dXJuIHJlc29sdmVkO1xuICAvL3ZhbGlkYXRlIGVudmlyb25tZW50YWwgdmFyaWFibGVcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9jZXNzLmVudiwgb3B0aW9ucy5lbnYpKSB7XG4gICAgdmFyIGVudkZsYWcgPSBwcm9jZXNzLmVudltvcHRpb25zLmVudl07XG4gICAgcmVzb2x2ZWQgPSB2YWxpZGF0ZVJlZ2lvbmFsRW5kcG9pbnRzRmxhZ1ZhbHVlKGVudkZsYWcsIHtcbiAgICAgIGNvZGU6ICdJbnZhbGlkRW52aXJvbm1lbnRhbFZhcmlhYmxlJyxcbiAgICAgIG1lc3NhZ2U6ICdpbnZhbGlkICcgKyBvcHRpb25zLmVudiArICcgZW52aXJvbm1lbnRhbCB2YXJpYWJsZS4gRXhwZWN0IFwibGVnYWN5XCIgJyArXG4gICAgICAnIG9yIFwicmVnaW9uYWxcIi4gR290IFwiJyArIHByb2Nlc3MuZW52W29wdGlvbnMuZW52XSArICdcIi4nXG4gICAgfSk7XG4gICAgaWYgKHJlc29sdmVkKSByZXR1cm4gcmVzb2x2ZWQ7XG4gIH1cbiAgLy92YWxpZGF0ZSBzaGFyZWQgY29uZmlnIGZpbGVcbiAgdmFyIHByb2ZpbGUgPSB7fTtcbiAgdHJ5IHtcbiAgICB2YXIgcHJvZmlsZXMgPSBBV1MudXRpbC5nZXRQcm9maWxlc0Zyb21TaGFyZWRDb25maWcoQVdTLnV0aWwuaW5pTG9hZGVyKTtcbiAgICBwcm9maWxlID0gcHJvZmlsZXNbcHJvY2Vzcy5lbnYuQVdTX1BST0ZJTEUgfHwgQVdTLnV0aWwuZGVmYXVsdFByb2ZpbGVdO1xuICB9IGNhdGNoIChlKSB7fTtcbiAgaWYgKHByb2ZpbGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb2ZpbGUsIG9wdGlvbnMuc2hhcmVkQ29uZmlnKSkge1xuICAgIHZhciBmaWxlRmxhZyA9IHByb2ZpbGVbb3B0aW9ucy5zaGFyZWRDb25maWddO1xuICAgIHJlc29sdmVkID0gdmFsaWRhdGVSZWdpb25hbEVuZHBvaW50c0ZsYWdWYWx1ZShmaWxlRmxhZywge1xuICAgICAgY29kZTogJ0ludmFsaWRDb25maWd1cmF0aW9uJyxcbiAgICAgIG1lc3NhZ2U6ICdpbnZhbGlkICcgKyBvcHRpb25zLnNoYXJlZENvbmZpZyArICcgcHJvZmlsZSBjb25maWcuIEV4cGVjdCBcImxlZ2FjeVwiICcgK1xuICAgICAgJyBvciBcInJlZ2lvbmFsXCIuIEdvdCBcIicgKyBwcm9maWxlW29wdGlvbnMuc2hhcmVkQ29uZmlnXSArICdcIi4nXG4gICAgfSk7XG4gICAgaWYgKHJlc29sdmVkKSByZXR1cm4gcmVzb2x2ZWQ7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmVSZWdpb25hbEVuZHBvaW50c0ZsYWc7XG4iLCIvKipcbiAqIFRoZSBtYWluIEFXUyBuYW1lc3BhY2VcbiAqL1xudmFyIEFXUyA9IHsgdXRpbDogcmVxdWlyZSgnLi91dGlsJykgfTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEAhbWFjcm8gW25ld10gbm9icm93c2VyXG4gKiAgIEBub3RlIFRoaXMgZmVhdHVyZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBicm93c2VyIGVudmlyb25tZW50IG9mIHRoZSBTREsuXG4gKi9cbnZhciBfaGlkZGVuID0ge307IF9oaWRkZW4udG9TdHJpbmcoKTsgLy8gaGFjayB0byBwYXJzZSBtYWNyb1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUztcblxuQVdTLnV0aWwudXBkYXRlKEFXUywge1xuXG4gIC8qKlxuICAgKiBAY29uc3RhbnRcbiAgICovXG4gIFZFUlNJT046ICcyLjU5Ni4wJyxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBTaWduZXJzOiB7fSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBQcm90b2NvbDoge1xuICAgIEpzb246IHJlcXVpcmUoJy4vcHJvdG9jb2wvanNvbicpLFxuICAgIFF1ZXJ5OiByZXF1aXJlKCcuL3Byb3RvY29sL3F1ZXJ5JyksXG4gICAgUmVzdDogcmVxdWlyZSgnLi9wcm90b2NvbC9yZXN0JyksXG4gICAgUmVzdEpzb246IHJlcXVpcmUoJy4vcHJvdG9jb2wvcmVzdF9qc29uJyksXG4gICAgUmVzdFhtbDogcmVxdWlyZSgnLi9wcm90b2NvbC9yZXN0X3htbCcpXG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgWE1MOiB7XG4gICAgQnVpbGRlcjogcmVxdWlyZSgnLi94bWwvYnVpbGRlcicpLFxuICAgIFBhcnNlcjogbnVsbCAvLyBjb25kaXRpb25hbGx5IHNldCBiYXNlZCBvbiBlbnZpcm9ubWVudFxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIEpTT046IHtcbiAgICBCdWlsZGVyOiByZXF1aXJlKCcuL2pzb24vYnVpbGRlcicpLFxuICAgIFBhcnNlcjogcmVxdWlyZSgnLi9qc29uL3BhcnNlcicpXG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgTW9kZWw6IHtcbiAgICBBcGk6IHJlcXVpcmUoJy4vbW9kZWwvYXBpJyksXG4gICAgT3BlcmF0aW9uOiByZXF1aXJlKCcuL21vZGVsL29wZXJhdGlvbicpLFxuICAgIFNoYXBlOiByZXF1aXJlKCcuL21vZGVsL3NoYXBlJyksXG4gICAgUGFnaW5hdG9yOiByZXF1aXJlKCcuL21vZGVsL3BhZ2luYXRvcicpLFxuICAgIFJlc291cmNlV2FpdGVyOiByZXF1aXJlKCcuL21vZGVsL3Jlc291cmNlX3dhaXRlcicpXG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYXBpTG9hZGVyOiByZXF1aXJlKCcuL2FwaV9sb2FkZXInKSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBFbmRwb2ludENhY2hlOiByZXF1aXJlKCcuLi92ZW5kb3IvZW5kcG9pbnQtY2FjaGUnKS5FbmRwb2ludENhY2hlXG59KTtcbnJlcXVpcmUoJy4vc2VxdWVudGlhbF9leGVjdXRvcicpO1xucmVxdWlyZSgnLi9zZXJ2aWNlJyk7XG5yZXF1aXJlKCcuL2NvbmZpZycpO1xucmVxdWlyZSgnLi9odHRwJyk7XG5yZXF1aXJlKCcuL2V2ZW50X2xpc3RlbmVycycpO1xucmVxdWlyZSgnLi9yZXF1ZXN0Jyk7XG5yZXF1aXJlKCcuL3Jlc3BvbnNlJyk7XG5yZXF1aXJlKCcuL3Jlc291cmNlX3dhaXRlcicpO1xucmVxdWlyZSgnLi9zaWduZXJzL3JlcXVlc3Rfc2lnbmVyJyk7XG5yZXF1aXJlKCcuL3BhcmFtX3ZhbGlkYXRvcicpO1xuXG4vKipcbiAqIEByZWFkb25seVxuICogQHJldHVybiBbQVdTLlNlcXVlbnRpYWxFeGVjdXRvcl0gYSBjb2xsZWN0aW9uIG9mIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMgdGhhdFxuICogICBhcmUgYXR0YWNoZWQgdG8gZXZlcnkgc2VudCByZXF1ZXN0LlxuICogQHNlZSBBV1MuUmVxdWVzdCBBV1MuUmVxdWVzdCBmb3IgYSBsaXN0IG9mIGV2ZW50cyB0byBsaXN0ZW4gZm9yXG4gKiBAZXhhbXBsZSBMb2dnaW5nIHRoZSB0aW1lIHRha2VuIHRvIHNlbmQgYSByZXF1ZXN0XG4gKiAgIEFXUy5ldmVudHMub24oJ3NlbmQnLCBmdW5jdGlvbiBzdGFydFNlbmQocmVzcCkge1xuICogICAgIHJlc3Auc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gKiAgIH0pLm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uIGNhbGN1bGF0ZVRpbWUocmVzcCkge1xuICogICAgIHZhciB0aW1lID0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gcmVzcC5zdGFydFRpbWUpIC8gMTAwMDtcbiAqICAgICBjb25zb2xlLmxvZygnUmVxdWVzdCB0b29rICcgKyB0aW1lICsgJyBzZWNvbmRzJyk7XG4gKiAgIH0pO1xuICpcbiAqICAgbmV3IEFXUy5TMygpLmxpc3RCdWNrZXRzKCk7IC8vIHByaW50cyAnUmVxdWVzdCB0b29rIDAuMjg1IHNlY29uZHMnXG4gKi9cbkFXUy5ldmVudHMgPSBuZXcgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcigpO1xuXG4vL2NyZWF0ZSBlbmRwb2ludCBjYWNoZSBsYXppbHlcbkFXUy51dGlsLm1lbW9pemVkUHJvcGVydHkoQVdTLCAnZW5kcG9pbnRDYWNoZScsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IEFXUy5FbmRwb2ludENhY2hlKEFXUy5jb25maWcuZW5kcG9pbnRDYWNoZVNpemUpO1xufSwgdHJ1ZSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB5b3VyIEFXUyBzZWN1cml0eSBjcmVkZW50aWFscywgc3BlY2lmaWNhbGx5IHRoZVxuICoge2FjY2Vzc0tleUlkfSwge3NlY3JldEFjY2Vzc0tleX0sIGFuZCBvcHRpb25hbCB7c2Vzc2lvblRva2VufS5cbiAqIENyZWF0aW5nIGEgYENyZWRlbnRpYWxzYCBvYmplY3QgYWxsb3dzIHlvdSB0byBwYXNzIGFyb3VuZCB5b3VyXG4gKiBzZWN1cml0eSBpbmZvcm1hdGlvbiB0byBjb25maWd1cmF0aW9uIGFuZCBzZXJ2aWNlIG9iamVjdHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgY2xhc3MgdHlwaWNhbGx5IGRvZXMgbm90IG5lZWQgdG8gYmUgY29uc3RydWN0ZWQgbWFudWFsbHksXG4gKiBhcyB0aGUge0FXUy5Db25maWd9IGFuZCB7QVdTLlNlcnZpY2V9IGNsYXNzZXMgYm90aCBhY2NlcHQgc2ltcGxlXG4gKiBvcHRpb25zIGhhc2hlcyB3aXRoIHRoZSB0aHJlZSBrZXlzLiBUaGVzZSBzdHJ1Y3R1cmVzIHdpbGwgYmUgY29udmVydGVkXG4gKiBpbnRvIENyZWRlbnRpYWxzIG9iamVjdHMgYXV0b21hdGljYWxseS5cbiAqXG4gKiAjIyBFeHBpcmluZyBhbmQgUmVmcmVzaGluZyBDcmVkZW50aWFsc1xuICpcbiAqIE9jY2FzaW9uYWxseSBjcmVkZW50aWFscyBjYW4gZXhwaXJlIGluIHRoZSBtaWRkbGUgb2YgYSBsb25nLXJ1bm5pbmdcbiAqIGFwcGxpY2F0aW9uLiBJbiB0aGlzIGNhc2UsIHRoZSBTREsgd2lsbCBhdXRvbWF0aWNhbGx5IGF0dGVtcHQgdG9cbiAqIHJlZnJlc2ggdGhlIGNyZWRlbnRpYWxzIGZyb20gdGhlIHN0b3JhZ2UgbG9jYXRpb24gaWYgdGhlIENyZWRlbnRpYWxzXG4gKiBjbGFzcyBpbXBsZW1lbnRzIHRoZSB7cmVmcmVzaH0gbWV0aG9kLlxuICpcbiAqIElmIHlvdSBhcmUgaW1wbGVtZW50aW5nIGEgY3JlZGVudGlhbCBzdG9yYWdlIGxvY2F0aW9uLCB5b3VcbiAqIHdpbGwgd2FudCB0byBjcmVhdGUgYSBzdWJjbGFzcyBvZiB0aGUgYENyZWRlbnRpYWxzYCBjbGFzcyBhbmRcbiAqIG92ZXJyaWRlIHRoZSB7cmVmcmVzaH0gbWV0aG9kLiBUaGlzIG1ldGhvZCBhbGxvd3MgY3JlZGVudGlhbHMgdG8gYmVcbiAqIHJldHJpZXZlZCBmcm9tIHRoZSBiYWNraW5nIHN0b3JlLCBiZSBpdCBhIGZpbGUgc3lzdGVtLCBkYXRhYmFzZSwgb3JcbiAqIHNvbWUgbmV0d29yayBzdG9yYWdlLiBUaGUgbWV0aG9kIHNob3VsZCByZXNldCB0aGUgY3JlZGVudGlhbCBhdHRyaWJ1dGVzXG4gKiBvbiB0aGUgb2JqZWN0LlxuICpcbiAqIEAhYXR0cmlidXRlIGV4cGlyZWRcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0aGUgY3JlZGVudGlhbHMgaGF2ZSBiZWVuIGV4cGlyZWQgYW5kXG4gKiAgICAgcmVxdWlyZSBhIHJlZnJlc2guIFVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB7ZXhwaXJlVGltZX0uXG4gKiBAIWF0dHJpYnV0ZSBleHBpcmVUaW1lXG4gKiAgIEByZXR1cm4gW0RhdGVdIGEgdGltZSB3aGVuIGNyZWRlbnRpYWxzIHNob3VsZCBiZSBjb25zaWRlcmVkIGV4cGlyZWQuIFVzZWRcbiAqICAgICBpbiBjb25qdW5jdGlvbiB3aXRoIHtleHBpcmVkfS5cbiAqIEAhYXR0cmlidXRlIGFjY2Vzc0tleUlkXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIEFXUyBhY2Nlc3Mga2V5IElEXG4gKiBAIWF0dHJpYnV0ZSBzZWNyZXRBY2Nlc3NLZXlcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgQVdTIHNlY3JldCBhY2Nlc3Mga2V5XG4gKiBAIWF0dHJpYnV0ZSBzZXNzaW9uVG9rZW5cbiAqICAgQHJldHVybiBbU3RyaW5nXSBhbiBvcHRpb25hbCBBV1Mgc2Vzc2lvbiB0b2tlblxuICovXG5BV1MuQ3JlZGVudGlhbHMgPSBBV1MudXRpbC5pbmhlcml0KHtcbiAgLyoqXG4gICAqIEEgY3JlZGVudGlhbHMgb2JqZWN0IGNhbiBiZSBjcmVhdGVkIHVzaW5nIHBvc2l0aW9uYWwgYXJndW1lbnRzIG9yIGFuIG9wdGlvbnNcbiAgICogaGFzaC5cbiAgICpcbiAgICogQG92ZXJsb2FkIEFXUy5DcmVkZW50aWFscyhhY2Nlc3NLZXlJZCwgc2VjcmV0QWNjZXNzS2V5LCBzZXNzaW9uVG9rZW49bnVsbClcbiAgICogICBDcmVhdGVzIGEgQ3JlZGVudGlhbHMgb2JqZWN0IHdpdGggYSBnaXZlbiBzZXQgb2YgY3JlZGVudGlhbCBpbmZvcm1hdGlvblxuICAgKiAgIGFzIHBvc2l0aW9uYWwgYXJndW1lbnRzLlxuICAgKiAgIEBwYXJhbSBhY2Nlc3NLZXlJZCBbU3RyaW5nXSB0aGUgQVdTIGFjY2VzcyBrZXkgSURcbiAgICogICBAcGFyYW0gc2VjcmV0QWNjZXNzS2V5IFtTdHJpbmddIHRoZSBBV1Mgc2VjcmV0IGFjY2VzcyBrZXlcbiAgICogICBAcGFyYW0gc2Vzc2lvblRva2VuIFtTdHJpbmddIHRoZSBvcHRpb25hbCBBV1Mgc2Vzc2lvbiB0b2tlblxuICAgKiAgIEBleGFtcGxlIENyZWF0ZSBhIGNyZWRlbnRpYWxzIG9iamVjdCB3aXRoIEFXUyBjcmVkZW50aWFsc1xuICAgKiAgICAgdmFyIGNyZWRzID0gbmV3IEFXUy5DcmVkZW50aWFscygnYWtpZCcsICdzZWNyZXQnLCAnc2Vzc2lvbicpO1xuICAgKiBAb3ZlcmxvYWQgQVdTLkNyZWRlbnRpYWxzKG9wdGlvbnMpXG4gICAqICAgQ3JlYXRlcyBhIENyZWRlbnRpYWxzIG9iamVjdCB3aXRoIGEgZ2l2ZW4gc2V0IG9mIGNyZWRlbnRpYWwgaW5mb3JtYXRpb25cbiAgICogICBhcyBhbiBvcHRpb25zIGhhc2guXG4gICAqICAgQG9wdGlvbiBvcHRpb25zIGFjY2Vzc0tleUlkIFtTdHJpbmddIHRoZSBBV1MgYWNjZXNzIGtleSBJRFxuICAgKiAgIEBvcHRpb24gb3B0aW9ucyBzZWNyZXRBY2Nlc3NLZXkgW1N0cmluZ10gdGhlIEFXUyBzZWNyZXQgYWNjZXNzIGtleVxuICAgKiAgIEBvcHRpb24gb3B0aW9ucyBzZXNzaW9uVG9rZW4gW1N0cmluZ10gdGhlIG9wdGlvbmFsIEFXUyBzZXNzaW9uIHRva2VuXG4gICAqICAgQGV4YW1wbGUgQ3JlYXRlIGEgY3JlZGVudGlhbHMgb2JqZWN0IHdpdGggQVdTIGNyZWRlbnRpYWxzXG4gICAqICAgICB2YXIgY3JlZHMgPSBuZXcgQVdTLkNyZWRlbnRpYWxzKHtcbiAgICogICAgICAgYWNjZXNzS2V5SWQ6ICdha2lkJywgc2VjcmV0QWNjZXNzS2V5OiAnc2VjcmV0Jywgc2Vzc2lvblRva2VuOiAnc2Vzc2lvbidcbiAgICogICAgIH0pO1xuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIENyZWRlbnRpYWxzKCkge1xuICAgIC8vIGhpZGUgc2VjcmV0QWNjZXNzS2V5IGZyb20gYmVpbmcgZGlzcGxheWVkIHdpdGggdXRpbC5pbnNwZWN0XG4gICAgQVdTLnV0aWwuaGlkZVByb3BlcnRpZXModGhpcywgWydzZWNyZXRBY2Nlc3NLZXknXSk7XG5cbiAgICB0aGlzLmV4cGlyZWQgPSBmYWxzZTtcbiAgICB0aGlzLmV4cGlyZVRpbWUgPSBudWxsO1xuICAgIHRoaXMucmVmcmVzaENhbGxiYWNrcyA9IFtdO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgY3JlZHMgPSBhcmd1bWVudHNbMF0uY3JlZGVudGlhbHMgfHwgYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5hY2Nlc3NLZXlJZCA9IGNyZWRzLmFjY2Vzc0tleUlkO1xuICAgICAgdGhpcy5zZWNyZXRBY2Nlc3NLZXkgPSBjcmVkcy5zZWNyZXRBY2Nlc3NLZXk7XG4gICAgICB0aGlzLnNlc3Npb25Ub2tlbiA9IGNyZWRzLnNlc3Npb25Ub2tlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hY2Nlc3NLZXlJZCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuc2VjcmV0QWNjZXNzS2V5ID0gYXJndW1lbnRzWzFdO1xuICAgICAgdGhpcy5zZXNzaW9uVG9rZW4gPSBhcmd1bWVudHNbMl07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgbnVtYmVyIG9mIHNlY29uZHMgYmVmb3JlIHtleHBpcmVUaW1lfSBkdXJpbmcgd2hpY2hcbiAgICogICB0aGUgY3JlZGVudGlhbHMgd2lsbCBiZSBjb25zaWRlcmVkIGV4cGlyZWQuXG4gICAqL1xuICBleHBpcnlXaW5kb3c6IDE1LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRoZSBjcmVkZW50aWFscyBvYmplY3Qgc2hvdWxkIGNhbGwge3JlZnJlc2h9XG4gICAqIEBub3RlIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHByb3ZpZGUgY3VzdG9tIHJlZnJlc2hcbiAgICogICBsb2dpYy5cbiAgICovXG4gIG5lZWRzUmVmcmVzaDogZnVuY3Rpb24gbmVlZHNSZWZyZXNoKCkge1xuICAgIHZhciBjdXJyZW50VGltZSA9IEFXUy51dGlsLmRhdGUuZ2V0RGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgYWRqdXN0ZWRUaW1lID0gbmV3IERhdGUoY3VycmVudFRpbWUgKyB0aGlzLmV4cGlyeVdpbmRvdyAqIDEwMDApO1xuXG4gICAgaWYgKHRoaXMuZXhwaXJlVGltZSAmJiBhZGp1c3RlZFRpbWUgPiB0aGlzLmV4cGlyZVRpbWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5leHBpcmVkIHx8ICF0aGlzLmFjY2Vzc0tleUlkIHx8ICF0aGlzLnNlY3JldEFjY2Vzc0tleTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGV4aXN0aW5nIGNyZWRlbnRpYWxzLCByZWZyZXNoaW5nIHRoZW0gaWYgdGhleSBhcmUgbm90IHlldCBsb2FkZWRcbiAgICogb3IgaGF2ZSBleHBpcmVkLiBVc2VycyBzaG91bGQgY2FsbCB0aGlzIG1ldGhvZCBiZWZvcmUgdXNpbmcge3JlZnJlc2h9LFxuICAgKiBhcyB0aGlzIHdpbGwgbm90IGF0dGVtcHQgdG8gcmVsb2FkIGNyZWRlbnRpYWxzIHdoZW4gdGhleSBhcmUgYWxyZWFkeVxuICAgKiBsb2FkZWQgaW50byB0aGUgb2JqZWN0LlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIFdoZW4gdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgaXQgbWVhbnMgZWl0aGVyIGNyZWRlbnRpYWxzXG4gICAqICAgZG8gbm90IG5lZWQgdG8gYmUgcmVmcmVzaGVkIG9yIHJlZnJlc2hlZCBjcmVkZW50aWFscyBpbmZvcm1hdGlvbiBoYXNcbiAgICogICBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLCBgc2VjcmV0QWNjZXNzS2V5YCxcbiAgICogICBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqL1xuICBnZXQ6IGZ1bmN0aW9uIGdldChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goKSkge1xuICAgICAgdGhpcy5yZWZyZXNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoIWVycikgc2VsZi5leHBpcmVkID0gZmFsc2U7IC8vIHJlc2V0IGV4cGlyZWQgZmxhZ1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycik7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQCFtZXRob2QgIGdldFByb21pc2UoKVxuICAgKiAgIFJldHVybnMgYSAndGhlbmFibGUnIHByb21pc2UuXG4gICAqICAgR2V0cyB0aGUgZXhpc3RpbmcgY3JlZGVudGlhbHMsIHJlZnJlc2hpbmcgdGhlbSBpZiB0aGV5IGFyZSBub3QgeWV0IGxvYWRlZFxuICAgKiAgIG9yIGhhdmUgZXhwaXJlZC4gVXNlcnMgc2hvdWxkIGNhbGwgdGhpcyBtZXRob2QgYmVmb3JlIHVzaW5nIHtyZWZyZXNofSxcbiAgICogICBhcyB0aGlzIHdpbGwgbm90IGF0dGVtcHQgdG8gcmVsb2FkIGNyZWRlbnRpYWxzIHdoZW4gdGhleSBhcmUgYWxyZWFkeVxuICAgKiAgIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QuXG4gICAqXG4gICAqICAgVHdvIGNhbGxiYWNrcyBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIGB0aGVuYCBtZXRob2Qgb24gdGhlIHJldHVybmVkIHByb21pc2UuXG4gICAqICAgVGhlIGZpcnN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgYW5kIHRoZSBzZWNvbmRcbiAgICogICBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICBAY2FsbGJhY2sgZnVsZmlsbGVkQ2FsbGJhY2sgZnVuY3Rpb24oKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZC4gV2hlbiB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCwgaXRcbiAgICogICAgIG1lYW5zIGVpdGhlciBjcmVkZW50aWFscyBkbyBub3QgbmVlZCB0byBiZSByZWZyZXNoZWQgb3IgcmVmcmVzaGVkXG4gICAqICAgICBjcmVkZW50aWFscyBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGVcbiAgICogICAgIGBhY2Nlc3NLZXlJZGAsIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQGNhbGxiYWNrIHJlamVjdGVkQ2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqICAgQHJldHVybiBbUHJvbWlzZV0gQSBwcm9taXNlIHRoYXQgcmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIGBnZXRgIGNhbGwuXG4gICAqICAgQGV4YW1wbGUgQ2FsbGluZyB0aGUgYGdldFByb21pc2VgIG1ldGhvZC5cbiAgICogICAgIHZhciBwcm9taXNlID0gY3JlZFByb3ZpZGVyLmdldFByb21pc2UoKTtcbiAgICogICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHsgLi4uIH0sIGZ1bmN0aW9uKGVycikgeyAuLi4gfSk7XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAIW1ldGhvZCAgcmVmcmVzaFByb21pc2UoKVxuICAgKiAgIFJldHVybnMgYSAndGhlbmFibGUnIHByb21pc2UuXG4gICAqICAgUmVmcmVzaGVzIHRoZSBjcmVkZW50aWFscy4gVXNlcnMgc2hvdWxkIGNhbGwge2dldH0gYmVmb3JlIGF0dGVtcHRpbmdcbiAgICogICB0byBmb3JjaWJseSByZWZyZXNoIGNyZWRlbnRpYWxzLlxuICAgKlxuICAgKiAgIFR3byBjYWxsYmFja3MgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSBgdGhlbmAgbWV0aG9kIG9uIHRoZSByZXR1cm5lZCBwcm9taXNlLlxuICAgKiAgIFRoZSBmaXJzdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQsIGFuZCB0aGUgc2Vjb25kXG4gICAqICAgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgQGNhbGxiYWNrIGZ1bGZpbGxlZENhbGxiYWNrIGZ1bmN0aW9uKClcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQuIFdoZW4gdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQsIGl0XG4gICAqICAgICBtZWFucyByZWZyZXNoZWQgY3JlZGVudGlhbHMgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdFxuICAgKiAgICAgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLCBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBjYWxsYmFjayByZWplY3RlZENhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiAgIEByZXR1cm4gW1Byb21pc2VdIEEgcHJvbWlzZSB0aGF0IHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSBgcmVmcmVzaGAgY2FsbC5cbiAgICogICBAZXhhbXBsZSBDYWxsaW5nIHRoZSBgcmVmcmVzaFByb21pc2VgIG1ldGhvZC5cbiAgICogICAgIHZhciBwcm9taXNlID0gY3JlZFByb3ZpZGVyLnJlZnJlc2hQcm9taXNlKCk7XG4gICAqICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7IC4uLiB9LCBmdW5jdGlvbihlcnIpIHsgLi4uIH0pO1xuICAgKi9cblxuICAvKipcbiAgICogUmVmcmVzaGVzIHRoZSBjcmVkZW50aWFscy4gVXNlcnMgc2hvdWxkIGNhbGwge2dldH0gYmVmb3JlIGF0dGVtcHRpbmdcbiAgICogdG8gZm9yY2libHkgcmVmcmVzaCBjcmVkZW50aWFscy5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBXaGVuIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHJlZnJlc2hlZFxuICAgKiAgIGNyZWRlbnRpYWxzIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZVxuICAgKiAgIGBhY2Nlc3NLZXlJZGAsIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqIEBub3RlIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgY2xhc3MgdG8gcmVzZXQgdGhlXG4gICAqICAge2FjY2Vzc0tleUlkfSwge3NlY3JldEFjY2Vzc0tleX0gYW5kIG9wdGlvbmFsIHtzZXNzaW9uVG9rZW59XG4gICAqICAgb24gdGhlIGNyZWRlbnRpYWxzIG9iamVjdCBhbmQgdGhlbiBjYWxsIHRoZSBjYWxsYmFjayB3aXRoXG4gICAqICAgYW55IGVycm9yIGluZm9ybWF0aW9uLlxuICAgKiBAc2VlIGdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChjYWxsYmFjaykge1xuICAgIHRoaXMuZXhwaXJlZCA9IGZhbHNlO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGNvYWxlc2NlUmVmcmVzaDogZnVuY3Rpb24gY29hbGVzY2VSZWZyZXNoKGNhbGxiYWNrLCBzeW5jKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLnJlZnJlc2hDYWxsYmFja3MucHVzaChjYWxsYmFjaykgPT09IDEpIHtcbiAgICAgIHNlbGYubG9hZChmdW5jdGlvbiBvbkxvYWQoZXJyKSB7XG4gICAgICAgIEFXUy51dGlsLmFycmF5RWFjaChzZWxmLnJlZnJlc2hDYWxsYmFja3MsIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIGNvdWxkIHRocm93LCBzbyBkZWZlciB0byBlbnN1cmUgYWxsIGNhbGxiYWNrcyBhcmUgbm90aWZpZWRcbiAgICAgICAgICAgIEFXUy51dGlsLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYucmVmcmVzaENhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBsb2FkOiBmdW5jdGlvbiBsb2FkKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5DcmVkZW50aWFscy5hZGRQcm9taXNlc1RvQ2xhc3MgPSBmdW5jdGlvbiBhZGRQcm9taXNlc1RvQ2xhc3MoUHJvbWlzZURlcGVuZGVuY3kpIHtcbiAgdGhpcy5wcm90b3R5cGUuZ2V0UHJvbWlzZSA9IEFXUy51dGlsLnByb21pc2lmeU1ldGhvZCgnZ2V0JywgUHJvbWlzZURlcGVuZGVuY3kpO1xuICB0aGlzLnByb3RvdHlwZS5yZWZyZXNoUHJvbWlzZSA9IEFXUy51dGlsLnByb21pc2lmeU1ldGhvZCgncmVmcmVzaCcsIFByb21pc2VEZXBlbmRlbmN5KTtcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5DcmVkZW50aWFscy5kZWxldGVQcm9taXNlc0Zyb21DbGFzcyA9IGZ1bmN0aW9uIGRlbGV0ZVByb21pc2VzRnJvbUNsYXNzKCkge1xuICBkZWxldGUgdGhpcy5wcm90b3R5cGUuZ2V0UHJvbWlzZTtcbiAgZGVsZXRlIHRoaXMucHJvdG90eXBlLnJlZnJlc2hQcm9taXNlO1xufTtcblxuQVdTLnV0aWwuYWRkUHJvbWlzZXMoQVdTLkNyZWRlbnRpYWxzKTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgU1RTID0gcmVxdWlyZSgnLi4vLi4vY2xpZW50cy9zdHMnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRlbXBvcmFyeSBjcmVkZW50aWFscyByZXRyaWV2ZWQgZnJvbSB7QVdTLlNUU30uIFdpdGhvdXQgYW55XG4gKiBleHRyYSBwYXJhbWV0ZXJzLCBjcmVkZW50aWFscyB3aWxsIGJlIGZldGNoZWQgZnJvbSB0aGVcbiAqIHtBV1MuU1RTLmdldFNlc3Npb25Ub2tlbn0gb3BlcmF0aW9uLiBJZiBhbiBJQU0gcm9sZSBpcyBwcm92aWRlZCwgdGhlXG4gKiB7QVdTLlNUUy5hc3N1bWVSb2xlfSBvcGVyYXRpb24gd2lsbCBiZSB1c2VkIHRvIGZldGNoIGNyZWRlbnRpYWxzIGZvciB0aGVcbiAqIHJvbGUgaW5zdGVhZC5cbiAqXG4gKiBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMgZGlmZmVycyBmcm9tIEFXUy5UZW1wb3JhcnlDcmVkZW50aWFscyBpblxuICogdGhlIHdheSBtYXN0ZXJDcmVkZW50aWFscyBhbmQgcmVmcmVzaGVzIGFyZSBoYW5kbGVkLlxuICogQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzIHJlZnJlc2hlcyBleHBpcmVkIGNyZWRlbnRpYWxzIHVzaW5nIHRoZVxuICogbWFzdGVyQ3JlZGVudGlhbHMgcGFzc2VkIGJ5IHRoZSB1c2VyIHRvIHN1cHBvcnQgY2hhaW5pbmcgb2YgU1RTIGNyZWRlbnRpYWxzLlxuICogSG93ZXZlciwgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzIHJlY3Vyc2l2ZWx5IGNvbGxhcHNlcyB0aGUgbWFzdGVyQ3JlZGVudGlhbHNcbiAqIGR1cmluZyBpbnN0YW50aWF0aW9uLCBwcmVjbHVkaW5nIHRoZSBhYmlsaXR5IHRvIHJlZnJlc2ggY3JlZGVudGlhbHMgd2hpY2hcbiAqIHJlcXVpcmUgaW50ZXJtZWRpYXRlLCB0ZW1wb3JhcnkgY3JlZGVudGlhbHMuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHRoZSBhcHBsaWNhdGlvbiBzaG91bGQgdXNlIFJvbGVBLCB3aGljaCBtdXN0IGJlIGFzc3VtZWQgZnJvbVxuICogUm9sZUIsIGFuZCB0aGUgZW52aXJvbm1lbnQgcHJvdmlkZXMgY3JlZGVudGlhbHMgd2hpY2ggY2FuIGFzc3VtZSBSb2xlQiwgdGhlblxuICogQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzIG11c3QgYmUgdXNlZCB0byBzdXBwb3J0IHJlZnJlc2hpbmcgdGhlXG4gKiB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgZm9yIFJvbGVBOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciByb2xlQUNyZWRzID0gbmV3IEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyh7XG4gKiAgIHBhcmFtczoge1JvbGVBcm46ICdSb2xlQSd9LFxuICogICBtYXN0ZXJDcmVkZW50aWFsczogbmV3IEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyh7XG4gKiAgICAgcGFyYW1zOiB7Um9sZUFybjogJ1JvbGVCJ30sXG4gKiAgICAgbWFzdGVyQ3JlZGVudGlhbHM6IG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQVdTJylcbiAqICAgfSlcbiAqIH0pO1xuICogYGBgXG4gKlxuICogSWYgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzIGhhZCBiZWVuIHVzZWQgaW4gdGhlIHByZXZpb3VzIGV4YW1wbGUsXG4gKiBgcm9sZUFDcmVkc2Agd291bGQgZmFpbCB0byByZWZyZXNoIGJlY2F1c2UgYHJvbGVBQ3JlZHNgIHdvdWxkXG4gKiB1c2UgdGhlIGVudmlyb25tZW50IGNyZWRlbnRpYWxzIGZvciB0aGUgQXNzdW1lUm9sZSByZXF1ZXN0LlxuICpcbiAqIEFub3RoZXIgZGlmZmVyZW5jZSBpcyB0aGF0IEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyBjcmVhdGVzIHRoZSBTVFNcbiAqIHNlcnZpY2UgaW5zdGFuY2UgZHVyaW5nIGluc3RhbnRpYXRpb24gd2hpbGUgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzIGNyZWF0ZXNcbiAqIHRoZSBTVFMgc2VydmljZSBpbnN0YW5jZSBkdXJpbmcgdGhlIGZpcnN0IHJlZnJlc2guIENyZWF0aW5nIHRoZSBzZXJ2aWNlXG4gKiBpbnN0YW5jZSBkdXJpbmcgaW5zdGFudGlhdGlvbiBlZmZlY3RpdmVseSBjYXB0dXJlcyB0aGUgbWFzdGVyIGNyZWRlbnRpYWxzXG4gKiBmcm9tIHRoZSBnbG9iYWwgY29uZmlnLCBzbyB0aGF0IHN1YnNlcXVlbnQgY2hhbmdlcyB0byB0aGUgZ2xvYmFsIGNvbmZpZyBkb1xuICogbm90IGFmZmVjdCB0aGUgbWFzdGVyIGNyZWRlbnRpYWxzIHVzZWQgdG8gcmVmcmVzaCB0aGUgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzLlxuICpcbiAqIFRoaXMgYWxsb3dzIGFuIGluc3RhbmNlIG9mIEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyB0byBiZSBhc3NpZ25lZFxuICogdG8gQVdTLmNvbmZpZy5jcmVkZW50aWFsczpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgZW52Q3JlZHMgPSBuZXcgQVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHMoJ0FXUycpO1xuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IGVudkNyZWRzO1xuICogLy8gbWFzdGVyQ3JlZGVudGlhbHMgd2lsbCBiZSBlbnZDcmVkc1xuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMoe1xuICogICBwYXJhbXM6IHtSb2xlQXJuOiAnLi4uJ31cbiAqIH0pO1xuICogYGBgXG4gKlxuICogU2ltaWxhcmx5LCB0byB1c2UgdGhlIENyZWRlbnRpYWxQcm92aWRlckNoYWluJ3MgZGVmYXVsdCBwcm92aWRlcnMgYXMgdGhlXG4gKiBtYXN0ZXIgY3JlZGVudGlhbHMsIHNpbXBseSBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2ZcbiAqIEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFsczpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IENoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzKHtcbiAqICAgcGFyYW1zOiB7Um9sZUFybjogJy4uLid9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEAhYXR0cmlidXRlIHNlcnZpY2VcbiAqICAgQHJldHVybiBbQVdTLlNUU10gdGhlIFNUUyBzZXJ2aWNlIGluc3RhbmNlIHVzZWQgdG9cbiAqICAgICBnZXQgYW5kIHJlZnJlc2ggdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIGZyb20gQVdTIFNUUy5cbiAqIEBub3RlIChzZWUgY29uc3RydWN0b3IpXG4gKi9cbkFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyA9IEFXUy51dGlsLmluaGVyaXQoQVdTLkNyZWRlbnRpYWxzLCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHRlbXBvcmFyeSBjcmVkZW50aWFscyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIFttYXBdIGEgc2V0IG9mIG9wdGlvbnNcbiAgICogQG9wdGlvbiBvcHRpb25zIHBhcmFtcyBbbWFwXSAoe30pIGEgbWFwIG9mIG9wdGlvbnMgdGhhdCBhcmUgcGFzc2VkIHRvIHRoZVxuICAgKiAgIHtBV1MuU1RTLmFzc3VtZVJvbGV9IG9yIHtBV1MuU1RTLmdldFNlc3Npb25Ub2tlbn0gb3BlcmF0aW9ucy5cbiAgICogICBJZiBhIGBSb2xlQXJuYCBwYXJhbWV0ZXIgaXMgcGFzc2VkIGluLCBjcmVkZW50aWFscyB3aWxsIGJlIGJhc2VkIG9uIHRoZVxuICAgKiAgIElBTSByb2xlLiBJZiBhIGBTZXJpYWxOdW1iZXJgIHBhcmFtZXRlciBpcyBwYXNzZWQgaW4sIHt0b2tlbkNvZGVGbn0gbXVzdFxuICAgKiAgIGFsc28gYmUgcGFzc2VkIGluIG9yIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgbWFzdGVyQ3JlZGVudGlhbHMgW0FXUy5DcmVkZW50aWFsc10gdGhlIG1hc3RlciBjcmVkZW50aWFsc1xuICAgKiAgIHVzZWQgdG8gZ2V0IGFuZCByZWZyZXNoIHRlbXBvcmFyeSBjcmVkZW50aWFscyBmcm9tIEFXUyBTVFMuIEJ5IGRlZmF1bHQsXG4gICAqICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyBvciBBV1MuY29uZmlnLmNyZWRlbnRpYWxQcm92aWRlciB3aWxsIGJlIHVzZWQuXG4gICAqIEBvcHRpb24gb3B0aW9ucyB0b2tlbkNvZGVGbiBbRnVuY3Rpb25dIChudWxsKSBGdW5jdGlvbiB0byBwcm92aWRlXG4gICAqICAgYFRva2VuQ29kZWAsIGlmIGBTZXJpYWxOdW1iZXJgIGlzIHByb3ZpZGVkIGZvciBwcm9maWxlIGluIHtwYXJhbXN9LiBGdW5jdGlvblxuICAgKiAgIGlzIGNhbGxlZCB3aXRoIHZhbHVlIG9mIGBTZXJpYWxOdW1iZXJgIGFuZCBgY2FsbGJhY2tgLCBhbmQgc2hvdWxkIHByb3ZpZGVcbiAgICogICB0aGUgYFRva2VuQ29kZWAgb3IgYW4gZXJyb3IgdG8gdGhlIGNhbGxiYWNrIGluIHRoZSBmb3JtYXRcbiAgICogICBgY2FsbGJhY2soZXJyLCB0b2tlbilgLlxuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhIG5ldyBjcmVkZW50aWFscyBvYmplY3QgZm9yIGdlbmVyaWMgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzXG4gICAqICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMoKTtcbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0IGZvciBhbiBJQU0gcm9sZVxuICAgKiAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzKHtcbiAgICogICAgIHBhcmFtczoge1xuICAgKiAgICAgICBSb2xlQXJuOiAnYXJuOmF3czppYW06OjEyMzQ1Njc4OTA6cm9sZS9UZW1wb3JhcnlDcmVkZW50aWFscydcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICogQHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVcbiAgICogQHNlZSBBV1MuU1RTLmdldFNlc3Npb25Ub2tlblxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIENoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzKG9wdGlvbnMpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLmVycm9yQ29kZSA9ICdDaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZSc7XG4gICAgdGhpcy5leHBpcmVkID0gdHJ1ZTtcbiAgICB0aGlzLnRva2VuQ29kZUZuID0gbnVsbDtcblxuICAgIHZhciBwYXJhbXMgPSBBV1MudXRpbC5jb3B5KG9wdGlvbnMucGFyYW1zKSB8fCB7fTtcbiAgICBpZiAocGFyYW1zLlJvbGVBcm4pIHtcbiAgICAgIHBhcmFtcy5Sb2xlU2Vzc2lvbk5hbWUgPSBwYXJhbXMuUm9sZVNlc3Npb25OYW1lIHx8ICd0ZW1wb3JhcnktY3JlZGVudGlhbHMnO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLlNlcmlhbE51bWJlcikge1xuICAgICAgaWYgKCFvcHRpb25zLnRva2VuQ29kZUZuIHx8ICh0eXBlb2Ygb3B0aW9ucy50b2tlbkNvZGVGbiAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgIG5ldyBFcnJvcigndG9rZW5Db2RlRm4gbXVzdCBiZSBhIGZ1bmN0aW9uIHdoZW4gcGFyYW1zLlNlcmlhbE51bWJlciBpcyBnaXZlbicpLFxuICAgICAgICAgIHtjb2RlOiB0aGlzLmVycm9yQ29kZX1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudG9rZW5Db2RlRm4gPSBvcHRpb25zLnRva2VuQ29kZUZuO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY29uZmlnID0gQVdTLnV0aWwubWVyZ2UoXG4gICAgICB7XG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICBjcmVkZW50aWFsczogb3B0aW9ucy5tYXN0ZXJDcmVkZW50aWFscyB8fCBBV1MuY29uZmlnLmNyZWRlbnRpYWxzXG4gICAgICB9LFxuICAgICAgb3B0aW9ucy5zdHNDb25maWcgfHwge31cbiAgICApO1xuICAgIHRoaXMuc2VydmljZSA9IG5ldyBTVFMoY29uZmlnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaGVzIGNyZWRlbnRpYWxzIHVzaW5nIHtBV1MuU1RTLmFzc3VtZVJvbGV9IG9yXG4gICAqIHtBV1MuU1RTLmdldFNlc3Npb25Ub2tlbn0sIGRlcGVuZGluZyBvbiB3aGV0aGVyIGFuIElBTSByb2xlIEFSTiB3YXMgcGFzc2VkXG4gICAqIHRvIHRoZSBjcmVkZW50aWFscyB7Y29uc3RydWN0b3J9LlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCB3aGVuIHRoZSBTVFMgc2VydmljZSByZXNwb25kcyAob3IgZmFpbHMpLiBXaGVuXG4gICAqICAgdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgaXQgbWVhbnMgdGhhdCB0aGUgY3JlZGVudGlhbHNcbiAgICogICBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGUgYGFjY2Vzc0tleUlkYCxcbiAgICogICBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiBAc2VlIEFXUy5DcmVkZW50aWFscy5nZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmNvYWxlc2NlUmVmcmVzaChjYWxsYmFjayB8fCBBV1MudXRpbC5mbi5jYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG9wZXJhdGlvbiA9IHNlbGYuc2VydmljZS5jb25maWcucGFyYW1zLlJvbGVBcm4gPyAnYXNzdW1lUm9sZScgOiAnZ2V0U2Vzc2lvblRva2VuJztcbiAgICB0aGlzLmdldFRva2VuQ29kZShmdW5jdGlvbiAoZXJyLCB0b2tlbkNvZGUpIHtcbiAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuQ29kZSkge1xuICAgICAgICBwYXJhbXMuVG9rZW5Db2RlID0gdG9rZW5Db2RlO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXJ2aWNlW29wZXJhdGlvbl0ocGFyYW1zLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgc2VsZi5zZXJ2aWNlLmNyZWRlbnRpYWxzRnJvbShkYXRhLCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0VG9rZW5Db2RlOiBmdW5jdGlvbiBnZXRUb2tlbkNvZGUoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMudG9rZW5Db2RlRm4pIHtcbiAgICAgIHRoaXMudG9rZW5Db2RlRm4odGhpcy5zZXJ2aWNlLmNvbmZpZy5wYXJhbXMuU2VyaWFsTnVtYmVyLCBmdW5jdGlvbiAoZXJyLCB0b2tlbikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBlcnI7XG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcignRXJyb3IgZmV0Y2hpbmcgTUZBIHRva2VuOiAnICsgbWVzc2FnZSksXG4gICAgICAgICAgICAgIHsgY29kZTogc2VsZi5lcnJvckNvZGV9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdG9rZW4pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgfVxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIENvZ25pdG9JZGVudGl0eSA9IHJlcXVpcmUoJy4uLy4uL2NsaWVudHMvY29nbml0b2lkZW50aXR5Jyk7XG52YXIgU1RTID0gcmVxdWlyZSgnLi4vLi4vY2xpZW50cy9zdHMnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGNyZWRlbnRpYWxzIHJldHJpZXZlZCBmcm9tIFNUUyBXZWIgSWRlbnRpdHkgRmVkZXJhdGlvbiB1c2luZ1xuICogdGhlIEFtYXpvbiBDb2duaXRvIElkZW50aXR5IHNlcnZpY2UuXG4gKlxuICogQnkgZGVmYXVsdCB0aGlzIHByb3ZpZGVyIGdldHMgY3JlZGVudGlhbHMgdXNpbmcgdGhlXG4gKiB7QVdTLkNvZ25pdG9JZGVudGl0eS5nZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5fSBzZXJ2aWNlIG9wZXJhdGlvbiwgd2hpY2hcbiAqIHJlcXVpcmVzIGVpdGhlciBhbiBgSWRlbnRpdHlJZGAgb3IgYW4gYElkZW50aXR5UG9vbElkYCAoQW1hem9uIENvZ25pdG9cbiAqIElkZW50aXR5IFBvb2wgSUQpLCB3aGljaCBpcyB1c2VkIHRvIGNhbGwge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0SWR9IHRvXG4gKiBvYnRhaW4gYW4gYElkZW50aXR5SWRgLiBJZiB0aGUgaWRlbnRpdHkgb3IgaWRlbnRpdHkgcG9vbCBpcyBub3QgY29uZmlndXJlZCBpblxuICogdGhlIEFtYXpvbiBDb2duaXRvIENvbnNvbGUgdG8gdXNlIElBTSByb2xlcyB3aXRoIHRoZSBhcHByb3ByaWF0ZSBwZXJtaXNzaW9ucyxcbiAqIHRoZW4gYWRkaXRpb25hbGx5IGEgYFJvbGVBcm5gIGlzIHJlcXVpcmVkIGNvbnRhaW5pbmcgdGhlIEFSTiBvZiB0aGUgSUFNIHRydXN0XG4gKiBwb2xpY3kgZm9yIHRoZSBBbWF6b24gQ29nbml0byByb2xlIHRoYXQgdGhlIHVzZXIgd2lsbCBsb2cgaW50by4gSWYgYSBgUm9sZUFybmBcbiAqIGlzIHByb3ZpZGVkLCB0aGVuIHRoaXMgcHJvdmlkZXIgZ2V0cyBjcmVkZW50aWFscyB1c2luZyB0aGVcbiAqIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9IHNlcnZpY2Ugb3BlcmF0aW9uLCBhZnRlciBmaXJzdCBnZXR0aW5nIGFuXG4gKiBPcGVuIElEIHRva2VuIGZyb20ge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0T3BlbklkVG9rZW59LlxuICpcbiAqIEluIGFkZGl0aW9uLCBpZiB0aGlzIGNyZWRlbnRpYWwgcHJvdmlkZXIgaXMgdXNlZCB0byBwcm92aWRlIGF1dGhlbnRpY2F0ZWRcbiAqIGxvZ2luLCB0aGUgYExvZ2luc2AgbWFwIG1heSBiZSBzZXQgdG8gdGhlIHRva2VucyBwcm92aWRlZCBieSB0aGUgcmVzcGVjdGl2ZVxuICogaWRlbnRpdHkgcHJvdmlkZXJzLiBTZWUge2NvbnN0cnVjdG9yfSBmb3IgYW4gZXhhbXBsZSBvbiBjcmVhdGluZyBhIGNyZWRlbnRpYWxzXG4gKiBvYmplY3Qgd2l0aCBwcm9wZXIgcHJvcGVydHkgdmFsdWVzLlxuICpcbiAqICMjIFJlZnJlc2hpbmcgQ3JlZGVudGlhbHMgZnJvbSBJZGVudGl0eSBTZXJ2aWNlXG4gKlxuICogSW4gYWRkaXRpb24gdG8gQVdTIGNyZWRlbnRpYWxzIGV4cGlyaW5nIGFmdGVyIGEgZ2l2ZW4gYW1vdW50IG9mIHRpbWUsIHRoZVxuICogbG9naW4gdG9rZW4gZnJvbSB0aGUgaWRlbnRpdHkgcHJvdmlkZXIgd2lsbCBhbHNvIGV4cGlyZS4gT25jZSB0aGlzIHRva2VuXG4gKiBleHBpcmVzLCBpdCB3aWxsIG5vdCBiZSB1c2FibGUgdG8gcmVmcmVzaCBBV1MgY3JlZGVudGlhbHMsIGFuZCBhbm90aGVyXG4gKiB0b2tlbiB3aWxsIGJlIG5lZWRlZC4gVGhlIFNESyBkb2VzIG5vdCBtYW5hZ2UgcmVmcmVzaGluZyBvZiB0aGUgdG9rZW4gdmFsdWUsXG4gKiBidXQgdGhpcyBjYW4gYmUgZG9uZSB0aHJvdWdoIGEgXCJyZWZyZXNoIHRva2VuXCIgc3VwcG9ydGVkIGJ5IG1vc3QgaWRlbnRpdHlcbiAqIHByb3ZpZGVycy4gQ29uc3VsdCB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGlkZW50aXR5IHByb3ZpZGVyIGZvciByZWZyZXNoaW5nXG4gKiB0b2tlbnMuIE9uY2UgdGhlIHJlZnJlc2hlZCB0b2tlbiBpcyBhY3F1aXJlZCwgeW91IHNob3VsZCBtYWtlIHN1cmUgdG8gdXBkYXRlXG4gKiB0aGlzIG5ldyB0b2tlbiBpbiB0aGUgY3JlZGVudGlhbHMgb2JqZWN0J3Mge3BhcmFtc30gcHJvcGVydHkuIFRoZSBmb2xsb3dpbmdcbiAqIGNvZGUgd2lsbCB1cGRhdGUgdGhlIFdlYklkZW50aXR5VG9rZW4sIGFzc3VtaW5nIHlvdSBoYXZlIHJldHJpZXZlZCBhbiB1cGRhdGVkXG4gKiB0b2tlbiBmcm9tIHRoZSBpZGVudGl0eSBwcm92aWRlcjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzLnBhcmFtcy5Mb2dpbnNbJ2dyYXBoLmZhY2Vib29rLmNvbSddID0gdXBkYXRlZFRva2VuO1xuICogYGBgXG4gKlxuICogRnV0dXJlIGNhbGxzIHRvIGBjcmVkZW50aWFscy5yZWZyZXNoKClgIHdpbGwgbm93IHVzZSB0aGUgbmV3IHRva2VuLlxuICpcbiAqIEAhYXR0cmlidXRlIHBhcmFtc1xuICogICBAcmV0dXJuIFttYXBdIHRoZSBtYXAgb2YgcGFyYW1zIHBhc3NlZCB0b1xuICogICAgIHtBV1MuQ29nbml0b0lkZW50aXR5LmdldElkfSxcbiAqICAgICB7QVdTLkNvZ25pdG9JZGVudGl0eS5nZXRPcGVuSWRUb2tlbn0sIGFuZFxuICogICAgIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9LiBUbyB1cGRhdGUgdGhlIHRva2VuLCBzZXQgdGhlXG4gKiAgICAgYHBhcmFtcy5XZWJJZGVudGl0eVRva2VuYCBwcm9wZXJ0eS5cbiAqIEAhYXR0cmlidXRlIGRhdGFcbiAqICAgQHJldHVybiBbbWFwXSB0aGUgcmF3IGRhdGEgcmVzcG9uc2UgZnJvbSB0aGUgY2FsbCB0b1xuICogICAgIHtBV1MuQ29nbml0b0lkZW50aXR5LmdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHl9LCBvclxuICogICAgIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9LiBVc2UgdGhpcyBpZiB5b3Ugd2FudCB0byBnZXRcbiAqICAgICBhY2Nlc3MgdG8gb3RoZXIgcHJvcGVydGllcyBmcm9tIHRoZSByZXNwb25zZS5cbiAqIEAhYXR0cmlidXRlIGlkZW50aXR5SWRcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgQ29nbml0byBJRCByZXR1cm5lZCBieSB0aGUgbGFzdCBjYWxsIHRvXG4gKiAgICAge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0T3BlbklkVG9rZW59LiBUaGlzIElEIHJlcHJlc2VudHMgdGhlIGFjdHVhbFxuICogICAgIGZpbmFsIHJlc29sdmVkIGlkZW50aXR5IElEIGZyb20gQW1hem9uIENvZ25pdG8uXG4gKi9cbkFXUy5Db2duaXRvSWRlbnRpdHlDcmVkZW50aWFscyA9IEFXUy51dGlsLmluaGVyaXQoQVdTLkNyZWRlbnRpYWxzLCB7XG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxvY2FsU3RvcmFnZUtleToge1xuICAgIGlkOiAnYXdzLmNvZ25pdG8uaWRlbnRpdHktaWQuJyxcbiAgICBwcm92aWRlcnM6ICdhd3MuY29nbml0by5pZGVudGl0eS1wcm92aWRlcnMuJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdC5cbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0XG4gICAqICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuQ29nbml0b0lkZW50aXR5Q3JlZGVudGlhbHMoe1xuICAgKlxuICAgKiAgICAgLy8gZWl0aGVyIElkZW50aXR5UG9vbElkIG9yIElkZW50aXR5SWQgaXMgcmVxdWlyZWRcbiAgICogICAgIC8vIFNlZSB0aGUgSWRlbnRpdHlQb29sSWQgcGFyYW0gZm9yIEFXUy5Db2duaXRvSWRlbnRpdHkuZ2V0SUQgKGxpbmtlZCBiZWxvdylcbiAgICogICAgIC8vIFNlZSB0aGUgSWRlbnRpdHlJZCBwYXJhbSBmb3IgQVdTLkNvZ25pdG9JZGVudGl0eS5nZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5XG4gICAqICAgICAvLyBvciBBV1MuQ29nbml0b0lkZW50aXR5LmdldE9wZW5JZFRva2VuIChsaW5rZWQgYmVsb3cpXG4gICAqICAgICBJZGVudGl0eVBvb2xJZDogJ3VzLWVhc3QtMToxNjk5ZWJjMC03OTAwLTQwOTktYjkxMC0yZGY5NGY1MmEwMzAnLFxuICAgKiAgICAgSWRlbnRpdHlJZDogJ3VzLWVhc3QtMToxMjhkMGE3NC1jODJmLTQ1NTMtOTE2ZC05MDA1M2U0YThiMGYnXG4gICAqXG4gICAqICAgICAvLyBvcHRpb25hbCwgb25seSBuZWNlc3Nhcnkgd2hlbiB0aGUgaWRlbnRpdHkgcG9vbCBpcyBub3QgY29uZmlndXJlZFxuICAgKiAgICAgLy8gdG8gdXNlIElBTSByb2xlcyBpbiB0aGUgQW1hem9uIENvZ25pdG8gQ29uc29sZVxuICAgKiAgICAgLy8gU2VlIHRoZSBSb2xlQXJuIHBhcmFtIGZvciBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHkgKGxpbmtlZCBiZWxvdylcbiAgICogICAgIFJvbGVBcm46ICdhcm46YXdzOmlhbTo6MTIzNDU2Nzg5MDpyb2xlL01ZQVBQLUNvZ25pdG9JZGVudGl0eScsXG4gICAqXG4gICAqICAgICAvLyBvcHRpb25hbCB0b2tlbnMsIHVzZWQgZm9yIGF1dGhlbnRpY2F0ZWQgbG9naW5cbiAgICogICAgIC8vIFNlZSB0aGUgTG9naW5zIHBhcmFtIGZvciBBV1MuQ29nbml0b0lkZW50aXR5LmdldElEIChsaW5rZWQgYmVsb3cpXG4gICAqICAgICBMb2dpbnM6IHtcbiAgICogICAgICAgJ2dyYXBoLmZhY2Vib29rLmNvbSc6ICdGQlRPS0VOJyxcbiAgICogICAgICAgJ3d3dy5hbWF6b24uY29tJzogJ0FNQVpPTlRPS0VOJyxcbiAgICogICAgICAgJ2FjY291bnRzLmdvb2dsZS5jb20nOiAnR09PR0xFVE9LRU4nLFxuICAgKiAgICAgICAnYXBpLnR3aXR0ZXIuY29tJzogJ1RXSVRURVJUT0tFTicsXG4gICAqICAgICAgICd3d3cuZGlnaXRzLmNvbSc6ICdESUdJVFNUT0tFTidcbiAgICogICAgIH0sXG4gICAqXG4gICAqICAgICAvLyBvcHRpb25hbCBuYW1lLCBkZWZhdWx0cyB0byB3ZWItaWRlbnRpdHlcbiAgICogICAgIC8vIFNlZSB0aGUgUm9sZVNlc3Npb25OYW1lIHBhcmFtIGZvciBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHkgKGxpbmtlZCBiZWxvdylcbiAgICogICAgIFJvbGVTZXNzaW9uTmFtZTogJ3dlYicsXG4gICAqXG4gICAqICAgICAvLyBvcHRpb25hbCwgb25seSBuZWNlc3Nhcnkgd2hlbiBhcHBsaWNhdGlvbiBydW5zIGluIGEgYnJvd3NlclxuICAgKiAgICAgLy8gYW5kIG11bHRpcGxlIHVzZXJzIGFyZSBzaWduZWQgaW4gYXQgb25jZSwgdXNlZCBmb3IgY2FjaGluZ1xuICAgKiAgICAgTG9naW5JZDogJ2V4YW1wbGVAZ21haWwuY29tJ1xuICAgKlxuICAgKiAgIH0sIHtcbiAgICogICAgICAvLyBvcHRpb25hbGx5IHByb3ZpZGUgY29uZmlndXJhdGlvbiB0byBhcHBseSB0byB0aGUgdW5kZXJseWluZyBzZXJ2aWNlIGNsaWVudHNcbiAgICogICAgICAvLyBpZiBjb25maWd1cmF0aW9uIGlzIG5vdCBwcm92aWRlZCwgdGhlbiBjb25maWd1cmF0aW9uIHdpbGwgYmUgcHVsbGVkIGZyb20gQVdTLmNvbmZpZ1xuICAgKlxuICAgKiAgICAgIC8vIHJlZ2lvbiBzaG91bGQgbWF0Y2ggdGhlIHJlZ2lvbiB5b3VyIGlkZW50aXR5IHBvb2wgaXMgbG9jYXRlZCBpblxuICAgKiAgICAgIHJlZ2lvbjogJ3VzLWVhc3QtMScsXG4gICAqXG4gICAqICAgICAgLy8gc3BlY2lmeSB0aW1lb3V0IG9wdGlvbnNcbiAgICogICAgICBodHRwT3B0aW9uczoge1xuICAgKiAgICAgICAgdGltZW91dDogMTAwXG4gICAqICAgICAgfVxuICAgKiAgIH0pO1xuICAgKiBAc2VlIEFXUy5Db2duaXRvSWRlbnRpdHkuZ2V0SWRcbiAgICogQHNlZSBBV1MuQ29nbml0b0lkZW50aXR5LmdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHlcbiAgICogQHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHlcbiAgICogQHNlZSBBV1MuQ29nbml0b0lkZW50aXR5LmdldE9wZW5JZFRva2VuXG4gICAqIEBzZWUgQVdTLkNvbmZpZ1xuICAgKiBAbm90ZSBJZiBhIHJlZ2lvbiBpcyBub3QgcHJvdmlkZWQgaW4gdGhlIGdsb2JhbCBBV1MuY29uZmlnLCBvclxuICAgKiAgIHNwZWNpZmllZCBpbiB0aGUgYGNsaWVudENvbmZpZ2AgdG8gdGhlIENvZ25pdG9JZGVudGl0eUNyZWRlbnRpYWxzXG4gICAqICAgY29uc3RydWN0b3IsIHlvdSBtYXkgZW5jb3VudGVyIGEgJ01pc3NpbmcgY3JlZGVudGlhbHMgaW4gY29uZmlnJyBlcnJvclxuICAgKiAgIHdoZW4gY2FsbGluZyBtYWtpbmcgYSBzZXJ2aWNlIGNhbGwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gQ29nbml0b0lkZW50aXR5Q3JlZGVudGlhbHMocGFyYW1zLCBjbGllbnRDb25maWcpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmV4cGlyZWQgPSB0cnVlO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy5faWRlbnRpdHlJZCA9IG51bGw7XG4gICAgdGhpcy5fY2xpZW50Q29uZmlnID0gQVdTLnV0aWwuY29weShjbGllbnRDb25maWcgfHwge30pO1xuICAgIHRoaXMubG9hZENhY2hlZElkKCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaWRlbnRpdHlJZCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYubG9hZENhY2hlZElkKCk7XG4gICAgICAgIHJldHVybiBzZWxmLl9pZGVudGl0eUlkIHx8IHNlbGYucGFyYW1zLklkZW50aXR5SWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihpZGVudGl0eUlkKSB7XG4gICAgICAgIHNlbGYuX2lkZW50aXR5SWQgPSBpZGVudGl0eUlkO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgY3JlZGVudGlhbHMgdXNpbmcge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eX0sXG4gICAqIG9yIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9LlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCB3aGVuIHRoZSBTVFMgc2VydmljZSByZXNwb25kcyAob3IgZmFpbHMpLiBXaGVuXG4gICAqICAgdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgaXQgbWVhbnMgdGhhdCB0aGUgY3JlZGVudGlhbHNcbiAgICogICBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGUgYGFjY2Vzc0tleUlkYCxcbiAgICogICBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiBAc2VlIEFXUy5DcmVkZW50aWFscy5nZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmNvYWxlc2NlUmVmcmVzaChjYWxsYmFjayB8fCBBV1MudXRpbC5mbi5jYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jcmVhdGVDbGllbnRzKCk7XG4gICAgc2VsZi5kYXRhID0gbnVsbDtcbiAgICBzZWxmLl9pZGVudGl0eUlkID0gbnVsbDtcbiAgICBzZWxmLmdldElkKGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgaWYgKCFzZWxmLnBhcmFtcy5Sb2xlQXJuKSB7XG4gICAgICAgICAgc2VsZi5nZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5KGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLmdldENyZWRlbnRpYWxzRnJvbVNUUyhjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuY2xlYXJJZE9uTm90QXV0aG9yaXplZChlcnIpO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGNhY2hlZCBDb2duaXRvIElEIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudGx5IGNvbmZpZ3VyZWRcbiAgICogaWRlbnRpdHkgcG9vbCBJRC4gVXNlIHRoaXMgdG8gbWFudWFsbHkgaW52YWxpZGF0ZSB5b3VyIGNhY2hlIGlmXG4gICAqIHRoZSBpZGVudGl0eSBwb29sIElEIHdhcyBkZWxldGVkLlxuICAgKi9cbiAgY2xlYXJDYWNoZWRJZDogZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLl9pZGVudGl0eUlkID0gbnVsbDtcbiAgICBkZWxldGUgdGhpcy5wYXJhbXMuSWRlbnRpdHlJZDtcblxuICAgIHZhciBwb29sSWQgPSB0aGlzLnBhcmFtcy5JZGVudGl0eVBvb2xJZDtcbiAgICB2YXIgbG9naW5JZCA9IHRoaXMucGFyYW1zLkxvZ2luSWQgfHwgJyc7XG4gICAgZGVsZXRlIHRoaXMuc3RvcmFnZVt0aGlzLmxvY2FsU3RvcmFnZUtleS5pZCArIHBvb2xJZCArIGxvZ2luSWRdO1xuICAgIGRlbGV0ZSB0aGlzLnN0b3JhZ2VbdGhpcy5sb2NhbFN0b3JhZ2VLZXkucHJvdmlkZXJzICsgcG9vbElkICsgbG9naW5JZF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2xlYXJJZE9uTm90QXV0aG9yaXplZDogZnVuY3Rpb24gY2xlYXJJZE9uTm90QXV0aG9yaXplZChlcnIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKGVyci5jb2RlID09ICdOb3RBdXRob3JpemVkRXhjZXB0aW9uJykge1xuICAgICAgc2VsZi5jbGVhckNhY2hlZElkKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBDb2duaXRvIElELCBsb2FkaW5nIGZyb20gY2FjaGUgaWYgaXQgd2FzIGFscmVhZHkgcmV0cmlldmVkXG4gICAqIG9uIHRoaXMgZGV2aWNlLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBpZGVudGl0eUlkKVxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yLCBudWxsXSBhbiBlcnJvciBvYmplY3QgaWYgdGhlIGNhbGwgZmFpbGVkIG9yIG51bGwgaWZcbiAgICogICAgIGl0IHN1Y2NlZWRlZC5cbiAgICogICBAcGFyYW0gaWRlbnRpdHlJZCBbU3RyaW5nLCBudWxsXSBpZiBzdWNjZXNzZnVsLCB0aGUgY2FsbGJhY2sgd2lsbCByZXR1cm5cbiAgICogICAgIHRoZSBDb2duaXRvIElELlxuICAgKiBAbm90ZSBJZiBub3QgbG9hZGVkIGV4cGxpY2l0bHksIHRoZSBDb2duaXRvIElEIGlzIGxvYWRlZCBhbmQgc3RvcmVkIGluXG4gICAqICAgbG9jYWxTdG9yYWdlIGluIHRoZSBicm93c2VyIGVudmlyb25tZW50IG9mIGEgZGV2aWNlLlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldElkOiBmdW5jdGlvbiBnZXRJZChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYucGFyYW1zLklkZW50aXR5SWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgc2VsZi5wYXJhbXMuSWRlbnRpdHlJZCk7XG4gICAgfVxuXG4gICAgc2VsZi5jb2duaXRvLmdldElkKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKCFlcnIgJiYgZGF0YS5JZGVudGl0eUlkKSB7XG4gICAgICAgIHNlbGYucGFyYW1zLklkZW50aXR5SWQgPSBkYXRhLklkZW50aXR5SWQ7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEuSWRlbnRpdHlJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZENyZWRlbnRpYWxzOiBmdW5jdGlvbiBsb2FkQ3JlZGVudGlhbHMoZGF0YSwgY3JlZGVudGlhbHMpIHtcbiAgICBpZiAoIWRhdGEgfHwgIWNyZWRlbnRpYWxzKSByZXR1cm47XG4gICAgY3JlZGVudGlhbHMuZXhwaXJlZCA9IGZhbHNlO1xuICAgIGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkID0gZGF0YS5DcmVkZW50aWFscy5BY2Nlc3NLZXlJZDtcbiAgICBjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXkgPSBkYXRhLkNyZWRlbnRpYWxzLlNlY3JldEtleTtcbiAgICBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4gPSBkYXRhLkNyZWRlbnRpYWxzLlNlc3Npb25Ub2tlbjtcbiAgICBjcmVkZW50aWFscy5leHBpcmVUaW1lID0gZGF0YS5DcmVkZW50aWFscy5FeHBpcmF0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHk6IGZ1bmN0aW9uIGdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHkoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jb2duaXRvLmdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHkoZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoIWVycikge1xuICAgICAgICBzZWxmLmNhY2hlSWQoZGF0YSk7XG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgIHNlbGYubG9hZENyZWRlbnRpYWxzKHNlbGYuZGF0YSwgc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmNsZWFySWRPbk5vdEF1dGhvcml6ZWQoZXJyKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q3JlZGVudGlhbHNGcm9tU1RTOiBmdW5jdGlvbiBnZXRDcmVkZW50aWFsc0Zyb21TVFMoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jb2duaXRvLmdldE9wZW5JZFRva2VuKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgc2VsZi5jYWNoZUlkKGRhdGEpO1xuICAgICAgICBzZWxmLnBhcmFtcy5XZWJJZGVudGl0eVRva2VuID0gZGF0YS5Ub2tlbjtcbiAgICAgICAgc2VsZi53ZWJJZGVudGl0eUNyZWRlbnRpYWxzLnJlZnJlc2goZnVuY3Rpb24od2ViRXJyKSB7XG4gICAgICAgICAgaWYgKCF3ZWJFcnIpIHtcbiAgICAgICAgICAgIHNlbGYuZGF0YSA9IHNlbGYud2ViSWRlbnRpdHlDcmVkZW50aWFscy5kYXRhO1xuICAgICAgICAgICAgc2VsZi5zdHMuY3JlZGVudGlhbHNGcm9tKHNlbGYuZGF0YSwgc2VsZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKHdlYkVycik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5jbGVhcklkT25Ob3RBdXRob3JpemVkKGVycik7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZENhY2hlZElkOiBmdW5jdGlvbiBsb2FkQ2FjaGVkSWQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gaW4gdGhlIGJyb3dzZXIgd2Ugc291cmNlIGRlZmF1bHQgSWRlbnRpdHlJZCBmcm9tIGxvY2FsU3RvcmFnZVxuICAgIGlmIChBV1MudXRpbC5pc0Jyb3dzZXIoKSAmJiAhc2VsZi5wYXJhbXMuSWRlbnRpdHlJZCkge1xuICAgICAgdmFyIGlkID0gc2VsZi5nZXRTdG9yYWdlKCdpZCcpO1xuICAgICAgaWYgKGlkICYmIHNlbGYucGFyYW1zLkxvZ2lucykge1xuICAgICAgICB2YXIgYWN0dWFsUHJvdmlkZXJzID0gT2JqZWN0LmtleXMoc2VsZi5wYXJhbXMuTG9naW5zKTtcbiAgICAgICAgdmFyIGNhY2hlZFByb3ZpZGVycyA9XG4gICAgICAgICAgKHNlbGYuZ2V0U3RvcmFnZSgncHJvdmlkZXJzJykgfHwgJycpLnNwbGl0KCcsJyk7XG5cbiAgICAgICAgLy8gb25seSBsb2FkIElEIGlmIGF0IGxlYXN0IG9uZSBwcm92aWRlciB1c2VkIHRoaXMgSUQgYmVmb3JlXG4gICAgICAgIHZhciBpbnRlcnNlY3QgPSBjYWNoZWRQcm92aWRlcnMuZmlsdGVyKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gYWN0dWFsUHJvdmlkZXJzLmluZGV4T2YobikgIT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGludGVyc2VjdC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBzZWxmLnBhcmFtcy5JZGVudGl0eUlkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaWQpIHtcbiAgICAgICAgc2VsZi5wYXJhbXMuSWRlbnRpdHlJZCA9IGlkO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVDbGllbnRzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2xpZW50Q29uZmlnID0gdGhpcy5fY2xpZW50Q29uZmlnO1xuICAgIHRoaXMud2ViSWRlbnRpdHlDcmVkZW50aWFscyA9IHRoaXMud2ViSWRlbnRpdHlDcmVkZW50aWFscyB8fFxuICAgICAgbmV3IEFXUy5XZWJJZGVudGl0eUNyZWRlbnRpYWxzKHRoaXMucGFyYW1zLCBjbGllbnRDb25maWcpO1xuICAgIGlmICghdGhpcy5jb2duaXRvKSB7XG4gICAgICB2YXIgY29nbml0b0NvbmZpZyA9IEFXUy51dGlsLm1lcmdlKHt9LCBjbGllbnRDb25maWcpO1xuICAgICAgY29nbml0b0NvbmZpZy5wYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgICAgIHRoaXMuY29nbml0byA9IG5ldyBDb2duaXRvSWRlbnRpdHkoY29nbml0b0NvbmZpZyk7XG4gICAgfVxuICAgIHRoaXMuc3RzID0gdGhpcy5zdHMgfHwgbmV3IFNUUyhjbGllbnRDb25maWcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNhY2hlSWQ6IGZ1bmN0aW9uIGNhY2hlSWQoZGF0YSkge1xuICAgIHRoaXMuX2lkZW50aXR5SWQgPSBkYXRhLklkZW50aXR5SWQ7XG4gICAgdGhpcy5wYXJhbXMuSWRlbnRpdHlJZCA9IHRoaXMuX2lkZW50aXR5SWQ7XG5cbiAgICAvLyBjYWNoZSB0aGlzIElkZW50aXR5SWQgaW4gYnJvd3NlciBsb2NhbFN0b3JhZ2UgaWYgcG9zc2libGVcbiAgICBpZiAoQVdTLnV0aWwuaXNCcm93c2VyKCkpIHtcbiAgICAgIHRoaXMuc2V0U3RvcmFnZSgnaWQnLCBkYXRhLklkZW50aXR5SWQpO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbXMuTG9naW5zKSB7XG4gICAgICAgIHRoaXMuc2V0U3RvcmFnZSgncHJvdmlkZXJzJywgT2JqZWN0LmtleXModGhpcy5wYXJhbXMuTG9naW5zKS5qb2luKCcsJykpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRTdG9yYWdlOiBmdW5jdGlvbiBnZXRTdG9yYWdlKGtleSkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VbdGhpcy5sb2NhbFN0b3JhZ2VLZXlba2V5XSArIHRoaXMucGFyYW1zLklkZW50aXR5UG9vbElkICsgKHRoaXMucGFyYW1zLkxvZ2luSWQgfHwgJycpXTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzZXRTdG9yYWdlOiBmdW5jdGlvbiBzZXRTdG9yYWdlKGtleSwgdmFsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc3RvcmFnZVt0aGlzLmxvY2FsU3RvcmFnZUtleVtrZXldICsgdGhpcy5wYXJhbXMuSWRlbnRpdHlQb29sSWQgKyAodGhpcy5wYXJhbXMuTG9naW5JZCB8fCAnJyldID0gdmFsO1xuICAgIH0gY2F0Y2ggKF8pIHt9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc3RvcmFnZTogKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgc3RvcmFnZSA9IEFXUy51dGlsLmlzQnJvd3NlcigpICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UgIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvdy5sb2NhbFN0b3JhZ2UgPT09ICdvYmplY3QnID9cbiAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlIDoge307XG5cbiAgICAgIC8vIFRlc3Qgc2V0L3JlbW92ZSB3aGljaCB3b3VsZCB0aHJvdyBhbiBlcnJvciBpbiBTYWZhcmkncyBwcml2YXRlIGJyb3dzaW5nXG4gICAgICBzdG9yYWdlWydhd3MudGVzdC1zdG9yYWdlJ10gPSAnZm9vYmFyJztcbiAgICAgIGRlbGV0ZSBzdG9yYWdlWydhd3MudGVzdC1zdG9yYWdlJ107XG5cbiAgICAgIHJldHVybiBzdG9yYWdlO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH0pKClcbn0pO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY3JlZGVudGlhbCBwcm92aWRlciBjaGFpbiB0aGF0IHNlYXJjaGVzIGZvciBBV1MgY3JlZGVudGlhbHNcbiAqIGluIGEgbGlzdCBvZiBjcmVkZW50aWFsIHByb3ZpZGVycyBzcGVjaWZpZWQgYnkgdGhlIHtwcm92aWRlcnN9IHByb3BlcnR5LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoZSBjaGFpbiB3aWxsIHVzZSB0aGUge2RlZmF1bHRQcm92aWRlcnN9IHRvIHJlc29sdmUgY3JlZGVudGlhbHMuXG4gKiBUaGVzZSBwcm92aWRlcnMgd2lsbCBsb29rIGluIHRoZSBlbnZpcm9ubWVudCB1c2luZyB0aGVcbiAqIHtBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFsc30gY2xhc3Mgd2l0aCB0aGUgJ0FXUycgYW5kICdBTUFaT04nIHByZWZpeGVzLlxuICpcbiAqICMjIFNldHRpbmcgUHJvdmlkZXJzXG4gKlxuICogRWFjaCBwcm92aWRlciBpbiB0aGUge3Byb3ZpZGVyc30gbGlzdCBzaG91bGQgYmUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAqIGEge0FXUy5DcmVkZW50aWFsc30gb2JqZWN0LCBvciBhIGhhcmRjb2RlZCBjcmVkZW50aWFscyBvYmplY3QuIFRoZSBmdW5jdGlvblxuICogZm9ybSBhbGxvd3MgZm9yIGRlbGF5ZWQgZXhlY3V0aW9uIG9mIHRoZSBjcmVkZW50aWFsIGNvbnN0cnVjdGlvbi5cbiAqXG4gKiAjIyBSZXNvbHZpbmcgQ3JlZGVudGlhbHMgZnJvbSBhIENoYWluXG4gKlxuICogQ2FsbCB7cmVzb2x2ZX0gdG8gcmV0dXJuIHRoZSBmaXJzdCB2YWxpZCBjcmVkZW50aWFsIG9iamVjdCB0aGF0IGNhbiBiZVxuICogbG9hZGVkIGJ5IHRoZSBwcm92aWRlciBjaGFpbi5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgdG8gcmVzb2x2ZSBhIGNoYWluIHdpdGggYSBjdXN0b20gcHJvdmlkZXIgdGhhdCBjaGVja3MgYSBmaWxlXG4gKiBvbiBkaXNrIGFmdGVyIHRoZSBzZXQgb2Yge2RlZmF1bHRQcm92aWRlcnN9OlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBkaXNrUHJvdmlkZXIgPSBuZXcgQVdTLkZpbGVTeXN0ZW1DcmVkZW50aWFscygnLi9jcmVkcy5qc29uJyk7XG4gKiB2YXIgY2hhaW4gPSBuZXcgQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluKCk7XG4gKiBjaGFpbi5wcm92aWRlcnMucHVzaChkaXNrUHJvdmlkZXIpO1xuICogY2hhaW4ucmVzb2x2ZSgpO1xuICogYGBgXG4gKlxuICogVGhlIGFib3ZlIGNvZGUgd2lsbCByZXR1cm4gdGhlIGBkaXNrUHJvdmlkZXJgIG9iamVjdCBpZiB0aGVcbiAqIGZpbGUgY29udGFpbnMgY3JlZGVudGlhbHMgYW5kIHRoZSBgZGVmYXVsdFByb3ZpZGVyc2AgZG8gbm90IGNvbnRhaW5cbiAqIGFueSBjcmVkZW50aWFsIHNldHRpbmdzLlxuICpcbiAqIEAhYXR0cmlidXRlIHByb3ZpZGVyc1xuICogICBAcmV0dXJuIFtBcnJheTxBV1MuQ3JlZGVudGlhbHMsIEZ1bmN0aW9uPl1cbiAqICAgICBhIGxpc3Qgb2YgY3JlZGVudGlhbHMgb2JqZWN0cyBvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gY3JlZGVudGlhbHNcbiAqICAgICBvYmplY3RzLiBJZiB0aGUgcHJvdmlkZXIgaXMgYSBmdW5jdGlvbiwgdGhlIGZ1bmN0aW9uIHdpbGwgYmVcbiAqICAgICBleGVjdXRlZCBsYXppbHkgd2hlbiB0aGUgcHJvdmlkZXIgbmVlZHMgdG8gYmUgY2hlY2tlZCBmb3IgdmFsaWRcbiAqICAgICBjcmVkZW50aWFscy4gQnkgZGVmYXVsdCwgdGhpcyBvYmplY3Qgd2lsbCBiZSBzZXQgdG8gdGhlXG4gKiAgICAge2RlZmF1bHRQcm92aWRlcnN9LlxuICogICBAc2VlIGRlZmF1bHRQcm92aWRlcnNcbiAqL1xuQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBDcmVkZW50aWFsUHJvdmlkZXJDaGFpbiB3aXRoIGEgZGVmYXVsdCBzZXQgb2YgcHJvdmlkZXJzXG4gICAqIHNwZWNpZmllZCBieSB7ZGVmYXVsdFByb3ZpZGVyc30uXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4ocHJvdmlkZXJzKSB7XG4gICAgaWYgKHByb3ZpZGVycykge1xuICAgICAgdGhpcy5wcm92aWRlcnMgPSBwcm92aWRlcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJvdmlkZXJzID0gQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluLmRlZmF1bHRQcm92aWRlcnMuc2xpY2UoMCk7XG4gICAgfVxuICAgIHRoaXMucmVzb2x2ZUNhbGxiYWNrcyA9IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAIW1ldGhvZCAgcmVzb2x2ZVByb21pc2UoKVxuICAgKiAgIFJldHVybnMgYSAndGhlbmFibGUnIHByb21pc2UuXG4gICAqICAgUmVzb2x2ZXMgdGhlIHByb3ZpZGVyIGNoYWluIGJ5IHNlYXJjaGluZyBmb3IgdGhlIGZpcnN0IHNldCBvZlxuICAgKiAgIGNyZWRlbnRpYWxzIGluIHtwcm92aWRlcnN9LlxuICAgKlxuICAgKiAgIFR3byBjYWxsYmFja3MgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSBgdGhlbmAgbWV0aG9kIG9uIHRoZSByZXR1cm5lZCBwcm9taXNlLlxuICAgKiAgIFRoZSBmaXJzdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQsIGFuZCB0aGUgc2Vjb25kXG4gICAqICAgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgQGNhbGxiYWNrIGZ1bGZpbGxlZENhbGxiYWNrIGZ1bmN0aW9uKGNyZWRlbnRpYWxzKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCBhbmQgdGhlIHByb3ZpZGVyIHJlc29sdmVzIHRoZSBjaGFpblxuICAgKiAgICAgdG8gYSBjcmVkZW50aWFscyBvYmplY3RcbiAgICogICAgIEBwYXJhbSBjcmVkZW50aWFscyBbQVdTLkNyZWRlbnRpYWxzXSB0aGUgY3JlZGVudGlhbHMgb2JqZWN0IHJlc29sdmVkXG4gICAqICAgICAgIGJ5IHRoZSBwcm92aWRlciBjaGFpbi5cbiAgICogICBAY2FsbGJhY2sgcmVqZWN0ZWRDYWxsYmFjayBmdW5jdGlvbihlcnJvcilcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICAgIEBwYXJhbSBlcnIgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHJldHVybmVkIGlmIG5vIGNyZWRlbnRpYWxzIGFyZSBmb3VuZC5cbiAgICogICBAcmV0dXJuIFtQcm9taXNlXSBBIHByb21pc2UgdGhhdCByZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgYHJlc29sdmVgIG1ldGhvZCBjYWxsLlxuICAgKiAgIEBleGFtcGxlIENhbGxpbmcgdGhlIGByZXNvbHZlUHJvbWlzZWAgbWV0aG9kLlxuICAgKiAgICAgdmFyIHByb21pc2UgPSBjaGFpbi5yZXNvbHZlUHJvbWlzZSgpO1xuICAgKiAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGNyZWRlbnRpYWxzKSB7IC4uLiB9LCBmdW5jdGlvbihlcnIpIHsgLi4uIH0pO1xuICAgKi9cblxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIHByb3ZpZGVyIGNoYWluIGJ5IHNlYXJjaGluZyBmb3IgdGhlIGZpcnN0IHNldCBvZlxuICAgKiBjcmVkZW50aWFscyBpbiB7cHJvdmlkZXJzfS5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgY3JlZGVudGlhbHMpXG4gICAqICAgQ2FsbGVkIHdoZW4gdGhlIHByb3ZpZGVyIHJlc29sdmVzIHRoZSBjaGFpbiB0byBhIGNyZWRlbnRpYWxzIG9iamVjdFxuICAgKiAgIG9yIG51bGwgaWYgbm8gY3JlZGVudGlhbHMgY2FuIGJlIGZvdW5kLlxuICAgKlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHJldHVybmVkIGlmIG5vIGNyZWRlbnRpYWxzIGFyZVxuICAgKiAgICAgZm91bmQuXG4gICAqICAgQHBhcmFtIGNyZWRlbnRpYWxzIFtBV1MuQ3JlZGVudGlhbHNdIHRoZSBjcmVkZW50aWFscyBvYmplY3QgcmVzb2x2ZWRcbiAgICogICAgIGJ5IHRoZSBwcm92aWRlciBjaGFpbi5cbiAgICogQHJldHVybiBbQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluXSB0aGUgcHJvdmlkZXIsIGZvciBjaGFpbmluZy5cbiAgICovXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHNlbGYucHJvdmlkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdObyBwcm92aWRlcnMnKSk7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5yZXNvbHZlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spID09PSAxKSB7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHByb3ZpZGVycyA9IHNlbGYucHJvdmlkZXJzLnNsaWNlKDApO1xuXG4gICAgICBmdW5jdGlvbiByZXNvbHZlTmV4dChlcnIsIGNyZWRzKSB7XG4gICAgICAgIGlmICgoIWVyciAmJiBjcmVkcykgfHwgaW5kZXggPT09IHByb3ZpZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBBV1MudXRpbC5hcnJheUVhY2goc2VsZi5yZXNvbHZlQ2FsbGJhY2tzLCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgY3JlZHMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYucmVzb2x2ZUNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm92aWRlciA9IHByb3ZpZGVyc1tpbmRleCsrXTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNyZWRzID0gcHJvdmlkZXIuY2FsbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNyZWRzID0gcHJvdmlkZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3JlZHMuZ2V0KSB7XG4gICAgICAgICAgY3JlZHMuZ2V0KGZ1bmN0aW9uIChnZXRFcnIpIHtcbiAgICAgICAgICAgIHJlc29sdmVOZXh0KGdldEVyciwgZ2V0RXJyID8gbnVsbCA6IGNyZWRzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlTmV4dChudWxsLCBjcmVkcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZU5leHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxufSk7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgc2V0IG9mIHByb3ZpZGVycyB1c2VkIGJ5IGEgdmFuaWxsYSBDcmVkZW50aWFsUHJvdmlkZXJDaGFpbi5cbiAqXG4gKiBJbiB0aGUgYnJvd3NlcjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4uZGVmYXVsdFByb3ZpZGVycyA9IFtdXG4gKiBgYGBcbiAqXG4gKiBJbiBOb2RlLmpzOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbi5kZWZhdWx0UHJvdmlkZXJzID0gW1xuICogICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHMoJ0FXUycpOyB9LFxuICogICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHMoJ0FNQVpPTicpOyB9LFxuICogICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQVdTLlNoYXJlZEluaUZpbGVDcmVkZW50aWFscygpOyB9LFxuICogICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQVdTLkVDU0NyZWRlbnRpYWxzKCk7IH0sXG4gKiAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuUHJvY2Vzc0NyZWRlbnRpYWxzKCk7IH0sXG4gKiAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuVG9rZW5GaWxlV2ViSWRlbnRpdHlDcmVkZW50aWFscygpOyB9LFxuICogICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQVdTLkVDMk1ldGFkYXRhQ3JlZGVudGlhbHMoKSB9XG4gKiBdXG4gKiBgYGBcbiAqL1xuQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluLmRlZmF1bHRQcm92aWRlcnMgPSBbXTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluLmFkZFByb21pc2VzVG9DbGFzcyA9IGZ1bmN0aW9uIGFkZFByb21pc2VzVG9DbGFzcyhQcm9taXNlRGVwZW5kZW5jeSkge1xuICB0aGlzLnByb3RvdHlwZS5yZXNvbHZlUHJvbWlzZSA9IEFXUy51dGlsLnByb21pc2lmeU1ldGhvZCgncmVzb2x2ZScsIFByb21pc2VEZXBlbmRlbmN5KTtcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbi5kZWxldGVQcm9taXNlc0Zyb21DbGFzcyA9IGZ1bmN0aW9uIGRlbGV0ZVByb21pc2VzRnJvbUNsYXNzKCkge1xuICBkZWxldGUgdGhpcy5wcm90b3R5cGUucmVzb2x2ZVByb21pc2U7XG59O1xuXG5BV1MudXRpbC5hZGRQcm9taXNlcyhBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4pO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBTVFMgPSByZXF1aXJlKCcuLi8uLi9jbGllbnRzL3N0cycpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgY3JlZGVudGlhbHMgcmV0cmlldmVkIGZyb20gU1RTIFNBTUwgc3VwcG9ydC5cbiAqXG4gKiBCeSBkZWZhdWx0IHRoaXMgcHJvdmlkZXIgZ2V0cyBjcmVkZW50aWFscyB1c2luZyB0aGVcbiAqIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoU0FNTH0gc2VydmljZSBvcGVyYXRpb24uIFRoaXMgb3BlcmF0aW9uXG4gKiByZXF1aXJlcyBhIGBSb2xlQXJuYCBjb250YWluaW5nIHRoZSBBUk4gb2YgdGhlIElBTSB0cnVzdCBwb2xpY3kgZm9yIHRoZVxuICogYXBwbGljYXRpb24gZm9yIHdoaWNoIGNyZWRlbnRpYWxzIHdpbGwgYmUgZ2l2ZW4sIGFzIHdlbGwgYXMgYSBgUHJpbmNpcGFsQXJuYFxuICogcmVwcmVzZW50aW5nIHRoZSBBUk4gZm9yIHRoZSBTQU1MIGlkZW50aXR5IHByb3ZpZGVyLiBJbiBhZGRpdGlvbiwgdGhlXG4gKiBgU0FNTEFzc2VydGlvbmAgbXVzdCBiZSBzZXQgdG8gdGhlIHRva2VuIHByb3ZpZGVkIGJ5IHRoZSBpZGVudGl0eVxuICogcHJvdmlkZXIuIFNlZSB7Y29uc3RydWN0b3J9IGZvciBhbiBleGFtcGxlIG9uIGNyZWF0aW5nIGEgY3JlZGVudGlhbHNcbiAqIG9iamVjdCB3aXRoIHByb3BlciBgUm9sZUFybmAsIGBQcmluY2lwYWxBcm5gLCBhbmQgYFNBTUxBc3NlcnRpb25gIHZhbHVlcy5cbiAqXG4gKiAjIyBSZWZyZXNoaW5nIENyZWRlbnRpYWxzIGZyb20gSWRlbnRpdHkgU2VydmljZVxuICpcbiAqIEluIGFkZGl0aW9uIHRvIEFXUyBjcmVkZW50aWFscyBleHBpcmluZyBhZnRlciBhIGdpdmVuIGFtb3VudCBvZiB0aW1lLCB0aGVcbiAqIGxvZ2luIHRva2VuIGZyb20gdGhlIGlkZW50aXR5IHByb3ZpZGVyIHdpbGwgYWxzbyBleHBpcmUuIE9uY2UgdGhpcyB0b2tlblxuICogZXhwaXJlcywgaXQgd2lsbCBub3QgYmUgdXNhYmxlIHRvIHJlZnJlc2ggQVdTIGNyZWRlbnRpYWxzLCBhbmQgYW5vdGhlclxuICogdG9rZW4gd2lsbCBiZSBuZWVkZWQuIFRoZSBTREsgZG9lcyBub3QgbWFuYWdlIHJlZnJlc2hpbmcgb2YgdGhlIHRva2VuIHZhbHVlLFxuICogYnV0IHRoaXMgY2FuIGJlIGRvbmUgdGhyb3VnaCBhIFwicmVmcmVzaCB0b2tlblwiIHN1cHBvcnRlZCBieSBtb3N0IGlkZW50aXR5XG4gKiBwcm92aWRlcnMuIENvbnN1bHQgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBpZGVudGl0eSBwcm92aWRlciBmb3IgcmVmcmVzaGluZ1xuICogdG9rZW5zLiBPbmNlIHRoZSByZWZyZXNoZWQgdG9rZW4gaXMgYWNxdWlyZWQsIHlvdSBzaG91bGQgbWFrZSBzdXJlIHRvIHVwZGF0ZVxuICogdGhpcyBuZXcgdG9rZW4gaW4gdGhlIGNyZWRlbnRpYWxzIG9iamVjdCdzIHtwYXJhbXN9IHByb3BlcnR5LiBUaGUgZm9sbG93aW5nXG4gKiBjb2RlIHdpbGwgdXBkYXRlIHRoZSBTQU1MQXNzZXJ0aW9uLCBhc3N1bWluZyB5b3UgaGF2ZSByZXRyaWV2ZWQgYW4gdXBkYXRlZFxuICogdG9rZW4gZnJvbSB0aGUgaWRlbnRpdHkgcHJvdmlkZXI6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscy5wYXJhbXMuU0FNTEFzc2VydGlvbiA9IHVwZGF0ZWRUb2tlbjtcbiAqIGBgYFxuICpcbiAqIEZ1dHVyZSBjYWxscyB0byBgY3JlZGVudGlhbHMucmVmcmVzaCgpYCB3aWxsIG5vdyB1c2UgdGhlIG5ldyB0b2tlbi5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBwYXJhbXNcbiAqICAgQHJldHVybiBbbWFwXSB0aGUgbWFwIG9mIHBhcmFtcyBwYXNzZWQgdG9cbiAqICAgICB7QVdTLlNUUy5hc3N1bWVSb2xlV2l0aFNBTUx9LiBUbyB1cGRhdGUgdGhlIHRva2VuLCBzZXQgdGhlXG4gKiAgICAgYHBhcmFtcy5TQU1MQXNzZXJ0aW9uYCBwcm9wZXJ0eS5cbiAqL1xuQVdTLlNBTUxDcmVkZW50aWFscyA9IEFXUy51dGlsLmluaGVyaXQoQVdTLkNyZWRlbnRpYWxzLCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdC5cbiAgICogQHBhcmFtIChzZWUgQVdTLlNUUy5hc3N1bWVSb2xlV2l0aFNBTUwpXG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdFxuICAgKiAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLlNBTUxDcmVkZW50aWFscyh7XG4gICAqICAgICBSb2xlQXJuOiAnYXJuOmF3czppYW06OjEyMzQ1Njc4OTA6cm9sZS9TQU1MUm9sZScsXG4gICAqICAgICBQcmluY2lwYWxBcm46ICdhcm46YXdzOmlhbTo6MTIzNDU2Nzg5MDpyb2xlL1NBTUxQcmluY2lwYWwnLFxuICAgKiAgICAgU0FNTEFzc2VydGlvbjogJ2Jhc2U2NC10b2tlbicsIC8vIGJhc2U2NC1lbmNvZGVkIHRva2VuIGZyb20gSWRQXG4gICAqICAgfSk7XG4gICAqIEBzZWUgQVdTLlNUUy5hc3N1bWVSb2xlV2l0aFNBTUxcbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBTQU1MQ3JlZGVudGlhbHMocGFyYW1zKSB7XG4gICAgQVdTLkNyZWRlbnRpYWxzLmNhbGwodGhpcyk7XG4gICAgdGhpcy5leHBpcmVkID0gdHJ1ZTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaGVzIGNyZWRlbnRpYWxzIHVzaW5nIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoU0FNTH1cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgd2hlbiB0aGUgU1RTIHNlcnZpY2UgcmVzcG9uZHMgKG9yIGZhaWxzKS4gV2hlblxuICAgKiAgIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHRoYXQgdGhlIGNyZWRlbnRpYWxzXG4gICAqICAgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsXG4gICAqICAgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogQHNlZSBnZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmNvYWxlc2NlUmVmcmVzaChjYWxsYmFjayB8fCBBV1MudXRpbC5mbi5jYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZDogZnVuY3Rpb24gbG9hZChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmNyZWF0ZUNsaWVudHMoKTtcbiAgICBzZWxmLnNlcnZpY2UuYXNzdW1lUm9sZVdpdGhTQU1MKGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHNlbGYuc2VydmljZS5jcmVkZW50aWFsc0Zyb20oZGF0YSwgc2VsZik7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZUNsaWVudHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2VydmljZSA9IHRoaXMuc2VydmljZSB8fCBuZXcgU1RTKHtwYXJhbXM6IHRoaXMucGFyYW1zfSk7XG4gIH1cblxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIFNUUyA9IHJlcXVpcmUoJy4uLy4uL2NsaWVudHMvc3RzJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgcmV0cmlldmVkIGZyb20ge0FXUy5TVFN9LiBXaXRob3V0IGFueVxuICogZXh0cmEgcGFyYW1ldGVycywgY3JlZGVudGlhbHMgd2lsbCBiZSBmZXRjaGVkIGZyb20gdGhlXG4gKiB7QVdTLlNUUy5nZXRTZXNzaW9uVG9rZW59IG9wZXJhdGlvbi4gSWYgYW4gSUFNIHJvbGUgaXMgcHJvdmlkZWQsIHRoZVxuICoge0FXUy5TVFMuYXNzdW1lUm9sZX0gb3BlcmF0aW9uIHdpbGwgYmUgdXNlZCB0byBmZXRjaCBjcmVkZW50aWFscyBmb3IgdGhlXG4gKiByb2xlIGluc3RlYWQuXG4gKlxuICogQG5vdGUgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzIGlzIGRlcHJlY2F0ZWQsIGJ1dCByZW1haW5zIGF2YWlsYWJsZSBmb3JcbiAqICAgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIHtBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHN9IGlzIHRoZVxuICogICBwcmVmZXJyZWQgY2xhc3MgZm9yIHRlbXBvcmFyeSBjcmVkZW50aWFscy5cbiAqXG4gKiBUbyBzZXR1cCB0ZW1wb3JhcnkgY3JlZGVudGlhbHMsIGNvbmZpZ3VyZSBhIHNldCBvZiBtYXN0ZXIgY3JlZGVudGlhbHNcbiAqIHVzaW5nIHRoZSBzdGFuZGFyZCBjcmVkZW50aWFscyBwcm92aWRlcnMgKGVudmlyb25tZW50LCBFQzIgaW5zdGFuY2UgbWV0YWRhdGEsXG4gKiBvciBmcm9tIHRoZSBmaWxlc3lzdGVtKSwgdGhlbiBzZXQgdGhlIGdsb2JhbCBjcmVkZW50aWFscyB0byBhIG5ld1xuICogdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIG9iamVjdDpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBOb3RlIHRoYXQgZW52aXJvbm1lbnQgY3JlZGVudGlhbHMgYXJlIGxvYWRlZCBieSBkZWZhdWx0LFxuICogLy8gdGhlIGZvbGxvd2luZyBsaW5lIGlzIHNob3duIGZvciBjbGFyaXR5OlxuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQVdTJyk7XG4gKlxuICogLy8gTm93IHNldCB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgc2VlZGVkIGZyb20gdGhlIG1hc3RlciBjcmVkZW50aWFsc1xuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMoKTtcbiAqXG4gKiAvLyBzdWJzZXF1ZW50IHJlcXVlc3RzIHdpbGwgbm93IHVzZSB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgZnJvbSBBV1MgU1RTLlxuICogbmV3IEFXUy5TMygpLmxpc3RCdWNrZXQoZnVuY3Rpb24oZXJyLCBkYXRhKSB7IC4uLiB9KTtcbiAqIGBgYFxuICpcbiAqIEAhYXR0cmlidXRlIG1hc3RlckNyZWRlbnRpYWxzXG4gKiAgIEByZXR1cm4gW0FXUy5DcmVkZW50aWFsc10gdGhlIG1hc3RlciAobm9uLXRlbXBvcmFyeSkgY3JlZGVudGlhbHMgdXNlZCB0b1xuICogICAgIGdldCBhbmQgcmVmcmVzaCB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgZnJvbSBBV1MgU1RTLlxuICogQG5vdGUgKHNlZSBjb25zdHJ1Y3RvcilcbiAqL1xuQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIG9iamVjdC5cbiAgICpcbiAgICogQG5vdGUgSW4gb3JkZXIgdG8gY3JlYXRlIHRlbXBvcmFyeSBjcmVkZW50aWFscywgeW91IGZpcnN0IG5lZWQgdG8gaGF2ZVxuICAgKiAgIFwibWFzdGVyXCIgY3JlZGVudGlhbHMgY29uZmlndXJlZCBpbiB7QVdTLkNvbmZpZy5jcmVkZW50aWFsc30uIFRoZXNlXG4gICAqICAgbWFzdGVyIGNyZWRlbnRpYWxzIGFyZSBuZWNlc3NhcnkgdG8gcmV0cmlldmUgdGhlIHRlbXBvcmFyeSBjcmVkZW50aWFscyxcbiAgICogICBhcyB3ZWxsIGFzIHJlZnJlc2ggdGhlIGNyZWRlbnRpYWxzIHdoZW4gdGhleSBleHBpcmUuXG4gICAqIEBwYXJhbSBwYXJhbXMgW21hcF0gYSBtYXAgb2Ygb3B0aW9ucyB0aGF0IGFyZSBwYXNzZWQgdG8gdGhlXG4gICAqICAge0FXUy5TVFMuYXNzdW1lUm9sZX0gb3Ige0FXUy5TVFMuZ2V0U2Vzc2lvblRva2VufSBvcGVyYXRpb25zLlxuICAgKiAgIElmIGEgYFJvbGVBcm5gIHBhcmFtZXRlciBpcyBwYXNzZWQgaW4sIGNyZWRlbnRpYWxzIHdpbGwgYmUgYmFzZWQgb24gdGhlXG4gICAqICAgSUFNIHJvbGUuXG4gICAqIEBwYXJhbSBtYXN0ZXJDcmVkZW50aWFscyBbQVdTLkNyZWRlbnRpYWxzXSB0aGUgbWFzdGVyIChub24tdGVtcG9yYXJ5KSBjcmVkZW50aWFsc1xuICAgKiAgdXNlZCB0byBnZXQgYW5kIHJlZnJlc2ggdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIGZyb20gQVdTIFNUUy5cbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0IGZvciBnZW5lcmljIHRlbXBvcmFyeSBjcmVkZW50aWFsc1xuICAgKiAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzKCk7XG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdCBmb3IgYW4gSUFNIHJvbGVcbiAgICogICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5UZW1wb3JhcnlDcmVkZW50aWFscyh7XG4gICAqICAgICBSb2xlQXJuOiAnYXJuOmF3czppYW06OjEyMzQ1Njc4OTA6cm9sZS9UZW1wb3JhcnlDcmVkZW50aWFscycsXG4gICAqICAgfSk7XG4gICAqIEBzZWUgQVdTLlNUUy5hc3N1bWVSb2xlXG4gICAqIEBzZWUgQVdTLlNUUy5nZXRTZXNzaW9uVG9rZW5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBUZW1wb3JhcnlDcmVkZW50aWFscyhwYXJhbXMsIG1hc3RlckNyZWRlbnRpYWxzKSB7XG4gICAgQVdTLkNyZWRlbnRpYWxzLmNhbGwodGhpcyk7XG4gICAgdGhpcy5sb2FkTWFzdGVyQ3JlZGVudGlhbHMobWFzdGVyQ3JlZGVudGlhbHMpO1xuICAgIHRoaXMuZXhwaXJlZCA9IHRydWU7XG5cbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBpZiAodGhpcy5wYXJhbXMuUm9sZUFybikge1xuICAgICAgdGhpcy5wYXJhbXMuUm9sZVNlc3Npb25OYW1lID1cbiAgICAgICAgdGhpcy5wYXJhbXMuUm9sZVNlc3Npb25OYW1lIHx8ICd0ZW1wb3JhcnktY3JlZGVudGlhbHMnO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaGVzIGNyZWRlbnRpYWxzIHVzaW5nIHtBV1MuU1RTLmFzc3VtZVJvbGV9IG9yXG4gICAqIHtBV1MuU1RTLmdldFNlc3Npb25Ub2tlbn0sIGRlcGVuZGluZyBvbiB3aGV0aGVyIGFuIElBTSByb2xlIEFSTiB3YXMgcGFzc2VkXG4gICAqIHRvIHRoZSBjcmVkZW50aWFscyB7Y29uc3RydWN0b3J9LlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCB3aGVuIHRoZSBTVFMgc2VydmljZSByZXNwb25kcyAob3IgZmFpbHMpLiBXaGVuXG4gICAqICAgdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgaXQgbWVhbnMgdGhhdCB0aGUgY3JlZGVudGlhbHNcbiAgICogICBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGUgYGFjY2Vzc0tleUlkYCxcbiAgICogICBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiBAc2VlIGdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaCAoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNvYWxlc2NlUmVmcmVzaChjYWxsYmFjayB8fCBBV1MudXRpbC5mbi5jYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZDogZnVuY3Rpb24gbG9hZCAoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jcmVhdGVDbGllbnRzKCk7XG4gICAgc2VsZi5tYXN0ZXJDcmVkZW50aWFscy5nZXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5zZXJ2aWNlLmNvbmZpZy5jcmVkZW50aWFscyA9IHNlbGYubWFzdGVyQ3JlZGVudGlhbHM7XG4gICAgICB2YXIgb3BlcmF0aW9uID0gc2VsZi5wYXJhbXMuUm9sZUFybiA/XG4gICAgICAgIHNlbGYuc2VydmljZS5hc3N1bWVSb2xlIDogc2VsZi5zZXJ2aWNlLmdldFNlc3Npb25Ub2tlbjtcbiAgICAgIG9wZXJhdGlvbi5jYWxsKHNlbGYuc2VydmljZSwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHNlbGYuc2VydmljZS5jcmVkZW50aWFsc0Zyb20oZGF0YSwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxvYWRNYXN0ZXJDcmVkZW50aWFsczogZnVuY3Rpb24gbG9hZE1hc3RlckNyZWRlbnRpYWxzIChtYXN0ZXJDcmVkZW50aWFscykge1xuICAgIHRoaXMubWFzdGVyQ3JlZGVudGlhbHMgPSBtYXN0ZXJDcmVkZW50aWFscyB8fCBBV1MuY29uZmlnLmNyZWRlbnRpYWxzO1xuICAgIHdoaWxlICh0aGlzLm1hc3RlckNyZWRlbnRpYWxzLm1hc3RlckNyZWRlbnRpYWxzKSB7XG4gICAgICB0aGlzLm1hc3RlckNyZWRlbnRpYWxzID0gdGhpcy5tYXN0ZXJDcmVkZW50aWFscy5tYXN0ZXJDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMubWFzdGVyQ3JlZGVudGlhbHMuZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLm1hc3RlckNyZWRlbnRpYWxzID0gbmV3IEFXUy5DcmVkZW50aWFscyh0aGlzLm1hc3RlckNyZWRlbnRpYWxzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlQ2xpZW50czogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VydmljZSA9IHRoaXMuc2VydmljZSB8fCBuZXcgU1RTKHtwYXJhbXM6IHRoaXMucGFyYW1zfSk7XG4gIH1cblxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIFNUUyA9IHJlcXVpcmUoJy4uLy4uL2NsaWVudHMvc3RzJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBjcmVkZW50aWFscyByZXRyaWV2ZWQgZnJvbSBTVFMgV2ViIElkZW50aXR5IEZlZGVyYXRpb24gc3VwcG9ydC5cbiAqXG4gKiBCeSBkZWZhdWx0IHRoaXMgcHJvdmlkZXIgZ2V0cyBjcmVkZW50aWFscyB1c2luZyB0aGVcbiAqIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9IHNlcnZpY2Ugb3BlcmF0aW9uLiBUaGlzIG9wZXJhdGlvblxuICogcmVxdWlyZXMgYSBgUm9sZUFybmAgY29udGFpbmluZyB0aGUgQVJOIG9mIHRoZSBJQU0gdHJ1c3QgcG9saWN5IGZvciB0aGVcbiAqIGFwcGxpY2F0aW9uIGZvciB3aGljaCBjcmVkZW50aWFscyB3aWxsIGJlIGdpdmVuLiBJbiBhZGRpdGlvbiwgdGhlXG4gKiBgV2ViSWRlbnRpdHlUb2tlbmAgbXVzdCBiZSBzZXQgdG8gdGhlIHRva2VuIHByb3ZpZGVkIGJ5IHRoZSBpZGVudGl0eVxuICogcHJvdmlkZXIuIFNlZSB7Y29uc3RydWN0b3J9IGZvciBhbiBleGFtcGxlIG9uIGNyZWF0aW5nIGEgY3JlZGVudGlhbHNcbiAqIG9iamVjdCB3aXRoIHByb3BlciBgUm9sZUFybmAgYW5kIGBXZWJJZGVudGl0eVRva2VuYCB2YWx1ZXMuXG4gKlxuICogIyMgUmVmcmVzaGluZyBDcmVkZW50aWFscyBmcm9tIElkZW50aXR5IFNlcnZpY2VcbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBBV1MgY3JlZGVudGlhbHMgZXhwaXJpbmcgYWZ0ZXIgYSBnaXZlbiBhbW91bnQgb2YgdGltZSwgdGhlXG4gKiBsb2dpbiB0b2tlbiBmcm9tIHRoZSBpZGVudGl0eSBwcm92aWRlciB3aWxsIGFsc28gZXhwaXJlLiBPbmNlIHRoaXMgdG9rZW5cbiAqIGV4cGlyZXMsIGl0IHdpbGwgbm90IGJlIHVzYWJsZSB0byByZWZyZXNoIEFXUyBjcmVkZW50aWFscywgYW5kIGFub3RoZXJcbiAqIHRva2VuIHdpbGwgYmUgbmVlZGVkLiBUaGUgU0RLIGRvZXMgbm90IG1hbmFnZSByZWZyZXNoaW5nIG9mIHRoZSB0b2tlbiB2YWx1ZSxcbiAqIGJ1dCB0aGlzIGNhbiBiZSBkb25lIHRocm91Z2ggYSBcInJlZnJlc2ggdG9rZW5cIiBzdXBwb3J0ZWQgYnkgbW9zdCBpZGVudGl0eVxuICogcHJvdmlkZXJzLiBDb25zdWx0IHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgaWRlbnRpdHkgcHJvdmlkZXIgZm9yIHJlZnJlc2hpbmdcbiAqIHRva2Vucy4gT25jZSB0aGUgcmVmcmVzaGVkIHRva2VuIGlzIGFjcXVpcmVkLCB5b3Ugc2hvdWxkIG1ha2Ugc3VyZSB0byB1cGRhdGVcbiAqIHRoaXMgbmV3IHRva2VuIGluIHRoZSBjcmVkZW50aWFscyBvYmplY3QncyB7cGFyYW1zfSBwcm9wZXJ0eS4gVGhlIGZvbGxvd2luZ1xuICogY29kZSB3aWxsIHVwZGF0ZSB0aGUgV2ViSWRlbnRpdHlUb2tlbiwgYXNzdW1pbmcgeW91IGhhdmUgcmV0cmlldmVkIGFuIHVwZGF0ZWRcbiAqIHRva2VuIGZyb20gdGhlIGlkZW50aXR5IHByb3ZpZGVyOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMucGFyYW1zLldlYklkZW50aXR5VG9rZW4gPSB1cGRhdGVkVG9rZW47XG4gKiBgYGBcbiAqXG4gKiBGdXR1cmUgY2FsbHMgdG8gYGNyZWRlbnRpYWxzLnJlZnJlc2goKWAgd2lsbCBub3cgdXNlIHRoZSBuZXcgdG9rZW4uXG4gKlxuICogQCFhdHRyaWJ1dGUgcGFyYW1zXG4gKiAgIEByZXR1cm4gW21hcF0gdGhlIG1hcCBvZiBwYXJhbXMgcGFzc2VkIHRvXG4gKiAgICAge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0uIFRvIHVwZGF0ZSB0aGUgdG9rZW4sIHNldCB0aGVcbiAqICAgICBgcGFyYW1zLldlYklkZW50aXR5VG9rZW5gIHByb3BlcnR5LlxuICogQCFhdHRyaWJ1dGUgZGF0YVxuICogICBAcmV0dXJuIFttYXBdIHRoZSByYXcgZGF0YSByZXNwb25zZSBmcm9tIHRoZSBjYWxsIHRvXG4gKiAgICAge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0uIFVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIGdldFxuICogICAgIGFjY2VzcyB0byBvdGhlciBwcm9wZXJ0aWVzIGZyb20gdGhlIHJlc3BvbnNlLlxuICovXG5BV1MuV2ViSWRlbnRpdHlDcmVkZW50aWFscyA9IEFXUy51dGlsLmluaGVyaXQoQVdTLkNyZWRlbnRpYWxzLCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdC5cbiAgICogQHBhcmFtIChzZWUgQVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5KVxuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhIG5ldyBjcmVkZW50aWFscyBvYmplY3RcbiAgICogICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5XZWJJZGVudGl0eUNyZWRlbnRpYWxzKHtcbiAgICogICAgIFJvbGVBcm46ICdhcm46YXdzOmlhbTo6MTIzNDU2Nzg5MDpyb2xlL1dlYklkZW50aXR5JyxcbiAgICogICAgIFdlYklkZW50aXR5VG9rZW46ICdBQkNERUZHSElKS0xNTk9QJywgLy8gdG9rZW4gZnJvbSBpZGVudGl0eSBzZXJ2aWNlXG4gICAqICAgICBSb2xlU2Vzc2lvbk5hbWU6ICd3ZWInIC8vIG9wdGlvbmFsIG5hbWUsIGRlZmF1bHRzIHRvIHdlYi1pZGVudGl0eVxuICAgKiAgIH0sIHtcbiAgICogICAgIC8vIG9wdGlvbmFsbHkgcHJvdmlkZSBjb25maWd1cmF0aW9uIHRvIGFwcGx5IHRvIHRoZSB1bmRlcmx5aW5nIEFXUy5TVFMgc2VydmljZSBjbGllbnRcbiAgICogICAgIC8vIGlmIGNvbmZpZ3VyYXRpb24gaXMgbm90IHByb3ZpZGVkLCB0aGVuIGNvbmZpZ3VyYXRpb24gd2lsbCBiZSBwdWxsZWQgZnJvbSBBV1MuY29uZmlnXG4gICAqXG4gICAqICAgICAvLyBzcGVjaWZ5IHRpbWVvdXQgb3B0aW9uc1xuICAgKiAgICAgaHR0cE9wdGlvbnM6IHtcbiAgICogICAgICAgdGltZW91dDogMTAwXG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqIEBzZWUgQVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5XG4gICAqIEBzZWUgQVdTLkNvbmZpZ1xuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFdlYklkZW50aXR5Q3JlZGVudGlhbHMocGFyYW1zLCBjbGllbnRDb25maWcpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmV4cGlyZWQgPSB0cnVlO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMucGFyYW1zLlJvbGVTZXNzaW9uTmFtZSA9IHRoaXMucGFyYW1zLlJvbGVTZXNzaW9uTmFtZSB8fCAnd2ViLWlkZW50aXR5JztcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMuX2NsaWVudENvbmZpZyA9IEFXUy51dGlsLmNvcHkoY2xpZW50Q29uZmlnIHx8IHt9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaGVzIGNyZWRlbnRpYWxzIHVzaW5nIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9XG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgQ2FsbGVkIHdoZW4gdGhlIFNUUyBzZXJ2aWNlIHJlc3BvbmRzIChvciBmYWlscykuIFdoZW5cbiAgICogICB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyB0aGF0IHRoZSBjcmVkZW50aWFsc1xuICAgKiAgIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLFxuICAgKiAgIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqIEBzZWUgZ2V0XG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jb2FsZXNjZVJlZnJlc2goY2FsbGJhY2sgfHwgQVdTLnV0aWwuZm4uY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jcmVhdGVDbGllbnRzKCk7XG4gICAgc2VsZi5zZXJ2aWNlLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHkoZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgc2VsZi5kYXRhID0gbnVsbDtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgIHNlbGYuc2VydmljZS5jcmVkZW50aWFsc0Zyb20oZGF0YSwgc2VsZik7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZUNsaWVudHM6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5zZXJ2aWNlKSB7XG4gICAgICB2YXIgc3RzQ29uZmlnID0gQVdTLnV0aWwubWVyZ2Uoe30sIHRoaXMuX2NsaWVudENvbmZpZyk7XG4gICAgICBzdHNDb25maWcucGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgICB0aGlzLnNlcnZpY2UgPSBuZXcgU1RTKHN0c0NvbmZpZyk7XG4gICAgfVxuICB9XG5cbn0pO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBlbmRwb2ludERpc2NvdmVyeUVuYWJsZWRFbnZzID0gWydBV1NfRU5BQkxFX0VORFBPSU5UX0RJU0NPVkVSWScsICdBV1NfRU5EUE9JTlRfRElTQ09WRVJZX0VOQUJMRUQnXTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBrZXkgKGV4Y2VwdCByZXNvdXJjZXMgYW5kIG9wZXJhdGlvbiBwYXJ0KSB0byBpbmRleCB0aGUgZW5kcG9pbnRzIGluIHRoZSBjYWNoZVxuICogSWYgaW5wdXQgc2hhcGUgaGFzIGVuZHBvaW50ZGlzY292ZXJ5aWQgdHJhaXQgdGhlbiB1c2VcbiAqICAgYWNjZXNzS2V5ICsgb3BlcmF0aW9uICsgcmVzb3VyY2VzICsgcmVnaW9uICsgc2VydmljZSBhcyBjYWNoZSBrZXlcbiAqIElmIGlucHV0IHNoYXBlIGRvZXNuJ3QgaGF2ZSBlbmRwb2ludGRpc2NvdmVyeWlkIHRyYWl0IHRoZW4gdXNlXG4gKiAgIGFjY2Vzc0tleSArIHJlZ2lvbiArIHNlcnZpY2UgYXMgY2FjaGUga2V5XG4gKiBAcmV0dXJuIFttYXA8U3RyaW5nLFN0cmluZz5dIG9iamVjdCB3aXRoIGtleXMgdG8gaW5kZXggZW5kcG9pbnRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldENhY2hlS2V5KHJlcXVlc3QpIHtcbiAgdmFyIHNlcnZpY2UgPSByZXF1ZXN0LnNlcnZpY2U7XG4gIHZhciBhcGkgPSBzZXJ2aWNlLmFwaSB8fCB7fTtcbiAgdmFyIG9wZXJhdGlvbnMgPSBhcGkub3BlcmF0aW9ucztcbiAgdmFyIGlkZW50aWZpZXJzID0ge307XG4gIGlmIChzZXJ2aWNlLmNvbmZpZy5yZWdpb24pIHtcbiAgICBpZGVudGlmaWVycy5yZWdpb24gPSBzZXJ2aWNlLmNvbmZpZy5yZWdpb247XG4gIH1cbiAgaWYgKGFwaS5zZXJ2aWNlSWQpIHtcbiAgICBpZGVudGlmaWVycy5zZXJ2aWNlSWQgPSBhcGkuc2VydmljZUlkO1xuICB9XG4gIGlmIChzZXJ2aWNlLmNvbmZpZy5jcmVkZW50aWFscy5hY2Nlc3NLZXlJZCkge1xuICAgIGlkZW50aWZpZXJzLmFjY2Vzc0tleUlkID0gc2VydmljZS5jb25maWcuY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQ7XG4gIH1cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnMoKS5cbiAqIExvb2tzIGZvciByZXF1aXJlZCBzdHJpbmcgaW5wdXQgbWVtYmVycyB0aGF0IGhhdmUgJ2VuZHBvaW50ZGlzY292ZXJ5aWQnIHRyYWl0LlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnNIZWxwZXIocmVzdWx0LCBwYXJhbXMsIHNoYXBlKSB7XG4gIGlmICghc2hhcGUgfHwgcGFyYW1zID09PSB1bmRlZmluZWQgfHwgcGFyYW1zID09PSBudWxsKSByZXR1cm47XG4gIGlmIChzaGFwZS50eXBlID09PSAnc3RydWN0dXJlJyAmJiBzaGFwZS5yZXF1aXJlZCAmJiBzaGFwZS5yZXF1aXJlZC5sZW5ndGggPiAwKSB7XG4gICAgdXRpbC5hcnJheUVhY2goc2hhcGUucmVxdWlyZWQsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBtZW1iZXJTaGFwZSA9IHNoYXBlLm1lbWJlcnNbbmFtZV07XG4gICAgICBpZiAobWVtYmVyU2hhcGUuZW5kcG9pbnREaXNjb3ZlcnlJZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbG9jYXRpb25OYW1lID0gbWVtYmVyU2hhcGUuaXNMb2NhdGlvbk5hbWUgPyBtZW1iZXJTaGFwZS5uYW1lIDogbmFtZTtcbiAgICAgICAgcmVzdWx0W2xvY2F0aW9uTmFtZV0gPSBTdHJpbmcocGFyYW1zW25hbWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnNIZWxwZXIocmVzdWx0LCBwYXJhbXNbbmFtZV0sIG1lbWJlclNoYXBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBjdXN0b20gaWRlbnRpZmllcnMgZm9yIGNhY2hlIGtleS5cbiAqIElkZW50aWZpZXMgY3VzdG9tIGlkZW50aWZpZXJzIGJ5IGNoZWNraW5nIGVhY2ggc2hhcGUncyBgZW5kcG9pbnREaXNjb3ZlcnlJZGAgdHJhaXQuXG4gKiBAcGFyYW0gW29iamVjdF0gcmVxdWVzdCBvYmplY3RcbiAqIEBwYXJhbSBbb2JqZWN0XSBpbnB1dCBzaGFwZSBvZiB0aGUgZ2l2ZW4gb3BlcmF0aW9uJ3MgYXBpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFyc2hhbGxDdXN0b21JZGVudGlmaWVycyhyZXF1ZXN0LCBzaGFwZSkge1xuICB2YXIgaWRlbnRpZmllcnMgPSB7fTtcbiAgbWFyc2hhbGxDdXN0b21JZGVudGlmaWVyc0hlbHBlcihpZGVudGlmaWVycywgcmVxdWVzdC5wYXJhbXMsIHNoYXBlKTtcbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG4vKipcbiAqIENhbGwgZW5kcG9pbnQgZGlzY292ZXJ5IG9wZXJhdGlvbiB3aGVuIGl0J3Mgb3B0aW9uYWwuXG4gKiBXaGVuIGVuZHBvaW50IGlzIGF2YWlsYWJsZSBpbiBjYWNoZSB0aGVuIHVzZSB0aGUgY2FjaGVkIGVuZHBvaW50cy4gSWYgZW5kcG9pbnRzXG4gKiBhcmUgdW5hdmFpbGFibGUgdGhlbiB1c2UgcmVnaW9uYWwgZW5kcG9pbnRzIGFuZCBjYWxsIGVuZHBvaW50IGRpc2NvdmVyeSBvcGVyYXRpb25cbiAqIGFzeW5jaHJvbm91c2x5LiBUaGlzIGlzIHR1cm5lZCBvZmYgYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSBbb2JqZWN0XSByZXF1ZXN0IG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsRGlzY292ZXJFbmRwb2ludChyZXF1ZXN0KSB7XG4gIHZhciBzZXJ2aWNlID0gcmVxdWVzdC5zZXJ2aWNlO1xuICB2YXIgYXBpID0gc2VydmljZS5hcGk7XG4gIHZhciBvcGVyYXRpb25Nb2RlbCA9IGFwaS5vcGVyYXRpb25zID8gYXBpLm9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dIDogdW5kZWZpbmVkO1xuICB2YXIgaW5wdXRTaGFwZSA9IG9wZXJhdGlvbk1vZGVsID8gb3BlcmF0aW9uTW9kZWwuaW5wdXQgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlkZW50aWZpZXJzID0gbWFyc2hhbGxDdXN0b21JZGVudGlmaWVycyhyZXF1ZXN0LCBpbnB1dFNoYXBlKTtcbiAgdmFyIGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkocmVxdWVzdCk7XG4gIGlmIChPYmplY3Qua2V5cyhpZGVudGlmaWVycykubGVuZ3RoID4gMCkge1xuICAgIGNhY2hlS2V5ID0gdXRpbC51cGRhdGUoY2FjaGVLZXksIGlkZW50aWZpZXJzKTtcbiAgICBpZiAob3BlcmF0aW9uTW9kZWwpIGNhY2hlS2V5Lm9wZXJhdGlvbiA9IG9wZXJhdGlvbk1vZGVsLm5hbWU7XG4gIH1cbiAgdmFyIGVuZHBvaW50cyA9IEFXUy5lbmRwb2ludENhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmIChlbmRwb2ludHMgJiYgZW5kcG9pbnRzLmxlbmd0aCA9PT0gMSAmJiBlbmRwb2ludHNbMF0uQWRkcmVzcyA9PT0gJycpIHtcbiAgICAvL2VuZHBvaW50IG9wZXJhdGlvbiBpcyBiZWluZyBtYWRlIGJ1dCByZXNwb25zZSBub3QgeWV0IHJlY2VpdmVkXG4gICAgLy9vciBlbmRwb2ludCBvcGVyYXRpb24ganVzdCBmYWlsZWQgaW4gMSBtaW51dGVcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoZW5kcG9pbnRzICYmIGVuZHBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgLy9mb3VuZCBlbmRwb2ludCByZWNvcmQgZnJvbSBjYWNoZVxuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QudXBkYXRlRW5kcG9pbnQoZW5kcG9pbnRzWzBdLkFkZHJlc3MpO1xuICB9IGVsc2Uge1xuICAgIC8vZW5kcG9pbnQgcmVjb3JkIG5vdCBpbiBjYWNoZSBvciBvdXRkYXRlZC4gbWFrZSBkaXNjb3Zlcnkgb3BlcmF0aW9uXG4gICAgdmFyIGVuZHBvaW50UmVxdWVzdCA9IHNlcnZpY2UubWFrZVJlcXVlc3QoYXBpLmVuZHBvaW50T3BlcmF0aW9uLCB7XG4gICAgICBPcGVyYXRpb246IG9wZXJhdGlvbk1vZGVsLm5hbWUsXG4gICAgICBJZGVudGlmaWVyczogaWRlbnRpZmllcnMsXG4gICAgfSk7XG4gICAgYWRkQXBpVmVyc2lvbkhlYWRlcihlbmRwb2ludFJlcXVlc3QpO1xuICAgIGVuZHBvaW50UmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9QQVJBTUVURVJTKTtcbiAgICBlbmRwb2ludFJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3JldHJ5JywgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuUkVUUllfQ0hFQ0spO1xuICAgIC8vcHV0IGluIGEgcGxhY2Vob2xkZXIgZm9yIGVuZHBvaW50cyBhbHJlYWR5IHJlcXVlc3RlZCwgcHJldmVudFxuICAgIC8vdG9vIG11Y2ggaW4tZmxpZ2h0IGNhbGxzXG4gICAgQVdTLmVuZHBvaW50Q2FjaGUucHV0KGNhY2hlS2V5LCBbe1xuICAgICAgQWRkcmVzczogJycsXG4gICAgICBDYWNoZVBlcmlvZEluTWludXRlczogMVxuICAgIH1dKTtcbiAgICBlbmRwb2ludFJlcXVlc3Quc2VuZChmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChkYXRhICYmIGRhdGEuRW5kcG9pbnRzKSB7XG4gICAgICAgIEFXUy5lbmRwb2ludENhY2hlLnB1dChjYWNoZUtleSwgZGF0YS5FbmRwb2ludHMpO1xuICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgQVdTLmVuZHBvaW50Q2FjaGUucHV0KGNhY2hlS2V5LCBbe1xuICAgICAgICAgIEFkZHJlc3M6ICcnLFxuICAgICAgICAgIENhY2hlUGVyaW9kSW5NaW51dGVzOiAxIC8vbm90IHRvIG1ha2UgbW9yZSBlbmRwb2ludCBvcGVyYXRpb24gaW4gbmV4dCAxIG1pbnV0ZVxuICAgICAgICB9XSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIHJlcXVlc3RRdWV1ZSA9IHt9O1xuXG4vKipcbiAqIENhbGwgZW5kcG9pbnQgZGlzY292ZXJ5IG9wZXJhdGlvbiB3aGVuIGl0J3MgcmVxdWlyZWQuXG4gKiBXaGVuIGVuZHBvaW50IGlzIGF2YWlsYWJsZSBpbiBjYWNoZSB0aGVuIHVzZSBjYWNoZWQgb25lcy4gSWYgZW5kcG9pbnRzIGFyZVxuICogdW5hdmFpbGFibGUgdGhlbiBTREsgc2hvdWxkIGNhbGwgZW5kcG9pbnQgb3BlcmF0aW9uIHRoZW4gdXNlIHJldHVybmVkIG5ld1xuICogZW5kcG9pbnQgZm9yIHRoZSBhcGkgY2FsbC4gU0RLIHdpbGwgYXV0b21hdGljYWxseSBhdHRlbXB0IHRvIGRvIGVuZHBvaW50XG4gKiBkaXNjb3ZlcnkuIFRoaXMgaXMgdHVybmVkIG9mZiBieSBkZWZhdWx0XG4gKiBAcGFyYW0gW29iamVjdF0gcmVxdWVzdCBvYmplY3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXF1aXJlZERpc2NvdmVyRW5kcG9pbnQocmVxdWVzdCwgZG9uZSkge1xuICB2YXIgc2VydmljZSA9IHJlcXVlc3Quc2VydmljZTtcbiAgdmFyIGFwaSA9IHNlcnZpY2UuYXBpO1xuICB2YXIgb3BlcmF0aW9uTW9kZWwgPSBhcGkub3BlcmF0aW9ucyA/IGFwaS5vcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGlucHV0U2hhcGUgPSBvcGVyYXRpb25Nb2RlbCA/IG9wZXJhdGlvbk1vZGVsLmlucHV0IDogdW5kZWZpbmVkO1xuXG4gIHZhciBpZGVudGlmaWVycyA9IG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnMocmVxdWVzdCwgaW5wdXRTaGFwZSk7XG4gIHZhciBjYWNoZUtleSA9IGdldENhY2hlS2V5KHJlcXVlc3QpO1xuICBpZiAoT2JqZWN0LmtleXMoaWRlbnRpZmllcnMpLmxlbmd0aCA+IDApIHtcbiAgICBjYWNoZUtleSA9IHV0aWwudXBkYXRlKGNhY2hlS2V5LCBpZGVudGlmaWVycyk7XG4gICAgaWYgKG9wZXJhdGlvbk1vZGVsKSBjYWNoZUtleS5vcGVyYXRpb24gPSBvcGVyYXRpb25Nb2RlbC5uYW1lO1xuICB9XG4gIHZhciBjYWNoZUtleVN0ciA9IEFXUy5FbmRwb2ludENhY2hlLmdldEtleVN0cmluZyhjYWNoZUtleSk7XG4gIHZhciBlbmRwb2ludHMgPSBBV1MuZW5kcG9pbnRDYWNoZS5nZXQoY2FjaGVLZXlTdHIpOyAvL2VuZHBvaW50IGNhY2hlIGFsc28gYWNjZXB0cyBzdHJpbmcga2V5c1xuICBpZiAoZW5kcG9pbnRzICYmIGVuZHBvaW50cy5sZW5ndGggPT09IDEgJiYgZW5kcG9pbnRzWzBdLkFkZHJlc3MgPT09ICcnKSB7XG4gICAgLy9lbmRwb2ludCBvcGVyYXRpb24gaXMgYmVpbmcgbWFkZSBidXQgcmVzcG9uc2Ugbm90IHlldCByZWNlaXZlZFxuICAgIC8vcHVzaCByZXF1ZXN0IG9iamVjdCB0byBhIHBlbmRpbmcgcXVldWVcbiAgICBpZiAoIXJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl0pIHJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl0gPSBbXTtcbiAgICByZXF1ZXN0UXVldWVbY2FjaGVLZXlTdHJdLnB1c2goe3JlcXVlc3Q6IHJlcXVlc3QsIGNhbGxiYWNrOiBkb25lfSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGVuZHBvaW50cyAmJiBlbmRwb2ludHMubGVuZ3RoID4gMCkge1xuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QudXBkYXRlRW5kcG9pbnQoZW5kcG9pbnRzWzBdLkFkZHJlc3MpO1xuICAgIGRvbmUoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZW5kcG9pbnRSZXF1ZXN0ID0gc2VydmljZS5tYWtlUmVxdWVzdChhcGkuZW5kcG9pbnRPcGVyYXRpb24sIHtcbiAgICAgIE9wZXJhdGlvbjogb3BlcmF0aW9uTW9kZWwubmFtZSxcbiAgICAgIElkZW50aWZpZXJzOiBpZGVudGlmaWVycyxcbiAgICB9KTtcbiAgICBlbmRwb2ludFJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJywgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfUEFSQU1FVEVSUyk7XG4gICAgYWRkQXBpVmVyc2lvbkhlYWRlcihlbmRwb2ludFJlcXVlc3QpO1xuXG4gICAgLy9wdXQgaW4gYSBwbGFjZWhvbGRlciBmb3IgZW5kcG9pbnRzIGFscmVhZHkgcmVxdWVzdGVkLCBwcmV2ZW50XG4gICAgLy90b28gbXVjaCBpbi1mbGlnaHQgY2FsbHNcbiAgICBBV1MuZW5kcG9pbnRDYWNoZS5wdXQoY2FjaGVLZXlTdHIsIFt7XG4gICAgICBBZGRyZXNzOiAnJyxcbiAgICAgIENhY2hlUGVyaW9kSW5NaW51dGVzOiA2MCAvL2xvbmctbGl2ZSBjYWNoZVxuICAgIH1dKTtcbiAgICBlbmRwb2ludFJlcXVlc3Quc2VuZChmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdmFyIGVycm9yUGFyYW1zID0ge1xuICAgICAgICAgIGNvZGU6ICdFbmRwb2ludERpc2NvdmVyeUV4Y2VwdGlvbicsXG4gICAgICAgICAgbWVzc2FnZTogJ1JlcXVlc3QgY2Fubm90IGJlIGZ1bGZpbGxlZCB3aXRob3V0IHNwZWNpZnlpbmcgYW4gZW5kcG9pbnQnLFxuICAgICAgICAgIHJldHJ5YWJsZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZS5lcnJvciA9IHV0aWwuZXJyb3IoZXJyLCBlcnJvclBhcmFtcyk7XG4gICAgICAgIEFXUy5lbmRwb2ludENhY2hlLnJlbW92ZShjYWNoZUtleSk7XG5cbiAgICAgICAgLy9mYWlsIGFsbCB0aGUgcGVuZGluZyByZXF1ZXN0cyBpbiBiYXRjaFxuICAgICAgICBpZiAocmVxdWVzdFF1ZXVlW2NhY2hlS2V5U3RyXSkge1xuICAgICAgICAgIHZhciBwZW5kaW5nUmVxdWVzdHMgPSByZXF1ZXN0UXVldWVbY2FjaGVLZXlTdHJdO1xuICAgICAgICAgIHV0aWwuYXJyYXlFYWNoKHBlbmRpbmdSZXF1ZXN0cywgZnVuY3Rpb24ocmVxdWVzdENvbnRleHQpIHtcbiAgICAgICAgICAgIHJlcXVlc3RDb250ZXh0LnJlcXVlc3QucmVzcG9uc2UuZXJyb3IgPSB1dGlsLmVycm9yKGVyciwgZXJyb3JQYXJhbXMpO1xuICAgICAgICAgICAgcmVxdWVzdENvbnRleHQuY2FsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdFF1ZXVlW2NhY2hlS2V5U3RyXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhKSB7XG4gICAgICAgIEFXUy5lbmRwb2ludENhY2hlLnB1dChjYWNoZUtleVN0ciwgZGF0YS5FbmRwb2ludHMpO1xuICAgICAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnVwZGF0ZUVuZHBvaW50KGRhdGEuRW5kcG9pbnRzWzBdLkFkZHJlc3MpO1xuXG4gICAgICAgIC8vdXBkYXRlIHRoZSBlbmRwb2ludCBmb3IgYWxsIHRoZSBwZW5kaW5nIHJlcXVlc3RzIGluIGJhdGNoXG4gICAgICAgIGlmIChyZXF1ZXN0UXVldWVbY2FjaGVLZXlTdHJdKSB7XG4gICAgICAgICAgdmFyIHBlbmRpbmdSZXF1ZXN0cyA9IHJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl07XG4gICAgICAgICAgdXRpbC5hcnJheUVhY2gocGVuZGluZ1JlcXVlc3RzLCBmdW5jdGlvbihyZXF1ZXN0Q29udGV4dCkge1xuICAgICAgICAgICAgcmVxdWVzdENvbnRleHQucmVxdWVzdC5odHRwUmVxdWVzdC51cGRhdGVFbmRwb2ludChkYXRhLkVuZHBvaW50c1swXS5BZGRyZXNzKTtcbiAgICAgICAgICAgIHJlcXVlc3RDb250ZXh0LmNhbGxiYWNrKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIGFkZCBhcGkgdmVyc2lvbiBoZWFkZXIgdG8gZW5kcG9pbnQgb3BlcmF0aW9uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkQXBpVmVyc2lvbkhlYWRlcihlbmRwb2ludFJlcXVlc3QpIHtcbiAgdmFyIGFwaSA9IGVuZHBvaW50UmVxdWVzdC5zZXJ2aWNlLmFwaTtcbiAgdmFyIGFwaVZlcnNpb24gPSBhcGkuYXBpVmVyc2lvbjtcbiAgaWYgKGFwaVZlcnNpb24gJiYgIWVuZHBvaW50UmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzWyd4LWFtei1hcGktdmVyc2lvbiddKSB7XG4gICAgZW5kcG9pbnRSZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LWFwaS12ZXJzaW9uJ10gPSBhcGlWZXJzaW9uO1xuICB9XG59XG5cbi8qKlxuICogSWYgYXBpIGNhbGwgZ2V0cyBpbnZhbGlkIGVuZHBvaW50IGV4Y2VwdGlvbiwgU0RLIHNob3VsZCBhdHRlbXB0IHRvIHJlbW92ZSB0aGUgaW52YWxpZFxuICogZW5kcG9pbnQgZnJvbSBjYWNoZS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbnZhbGlkYXRlQ2FjaGVkRW5kcG9pbnRzKHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuICB2YXIgaHR0cFJlc3BvbnNlID0gcmVzcG9uc2UuaHR0cFJlc3BvbnNlO1xuICBpZiAoZXJyb3IgJiZcbiAgICAoZXJyb3IuY29kZSA9PT0gJ0ludmFsaWRFbmRwb2ludEV4Y2VwdGlvbicgfHwgaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQyMSlcbiAgKSB7XG4gICAgdmFyIHJlcXVlc3QgPSByZXNwb25zZS5yZXF1ZXN0O1xuICAgIHZhciBvcGVyYXRpb25zID0gcmVxdWVzdC5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zIHx8IHt9O1xuICAgIHZhciBpbnB1dFNoYXBlID0gb3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl0gPyBvcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXS5pbnB1dCA6IHVuZGVmaW5lZDtcbiAgICB2YXIgaWRlbnRpZmllcnMgPSBtYXJzaGFsbEN1c3RvbUlkZW50aWZpZXJzKHJlcXVlc3QsIGlucHV0U2hhcGUpO1xuICAgIHZhciBjYWNoZUtleSA9IGdldENhY2hlS2V5KHJlcXVlc3QpO1xuICAgIGlmIChPYmplY3Qua2V5cyhpZGVudGlmaWVycykubGVuZ3RoID4gMCkge1xuICAgICAgY2FjaGVLZXkgPSB1dGlsLnVwZGF0ZShjYWNoZUtleSwgaWRlbnRpZmllcnMpO1xuICAgICAgaWYgKG9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dKSBjYWNoZUtleS5vcGVyYXRpb24gPSBvcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXS5uYW1lO1xuICAgIH1cbiAgICBBV1MuZW5kcG9pbnRDYWNoZS5yZW1vdmUoY2FjaGVLZXkpO1xuICB9XG59XG5cbi8qKlxuICogSWYgZW5kcG9pbnQgaXMgZXhwbGljaXRseSBjb25maWd1cmVkLCBTREsgc2hvdWxkIG5vdCBkbyBlbmRwb2ludCBkaXNjb3ZlcnkgaW4gYW55dGltZS5cbiAqIEBwYXJhbSBbb2JqZWN0XSBjbGllbnQgU2VydmljZSBjbGllbnQgb2JqZWN0LlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhc0N1c3RvbUVuZHBvaW50KGNsaWVudCkge1xuICAvL2lmIHNldCBlbmRwb2ludCBpcyBzZXQgZm9yIHNwZWNpZmljIGNsaWVudCwgZW5hYmxlIGVuZHBvaW50IGRpc2NvdmVyeSB3aWxsIHJhaXNlIGFuIGVycm9yLlxuICBpZiAoY2xpZW50Ll9vcmlnaW5hbENvbmZpZyAmJiBjbGllbnQuX29yaWdpbmFsQ29uZmlnLmVuZHBvaW50ICYmIGNsaWVudC5fb3JpZ2luYWxDb25maWcuZW5kcG9pbnREaXNjb3ZlcnlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgY29kZTogJ0NvbmZpZ3VyYXRpb25FeGNlcHRpb24nLFxuICAgICAgbWVzc2FnZTogJ0N1c3RvbSBlbmRwb2ludCBpcyBzdXBwbGllZDsgZW5kcG9pbnREaXNjb3ZlcnlFbmFibGVkIG11c3Qgbm90IGJlIHRydWUuJ1xuICAgIH0pO1xuICB9O1xuICB2YXIgc3ZjQ29uZmlnID0gQVdTLmNvbmZpZ1tjbGllbnQuc2VydmljZUlkZW50aWZpZXJdIHx8IHt9O1xuICByZXR1cm4gQm9vbGVhbihBV1MuY29uZmlnLmVuZHBvaW50IHx8IHN2Y0NvbmZpZy5lbmRwb2ludCB8fCAoY2xpZW50Ll9vcmlnaW5hbENvbmZpZyAmJiBjbGllbnQuX29yaWdpbmFsQ29uZmlnLmVuZHBvaW50KSk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzRmFsc3kodmFsdWUpIHtcbiAgcmV0dXJuIFsnZmFsc2UnLCAnMCddLmluZGV4T2YodmFsdWUpID49IDA7XG59XG5cbi8qKlxuICogSWYgZW5kcG9pbnQgZGlzY292ZXJ5IHNob3VsZCBwZXJmb3JtIGZvciB0aGlzIHJlcXVlc3Qgd2hlbiBlbmRwb2ludCBkaXNjb3ZlcnkgaXMgb3B0aW9uYWwuXG4gKiBTREsgcGVyZm9ybXMgY29uZmlnIHJlc29sdXRpb24gaW4gb3JkZXIgbGlrZSBiZWxvdzpcbiAqIDEuIElmIHR1cm5lZCBvbiBjbGllbnQgY29uZmlndXJhdGlvbihkZWZhdWx0IHRvIG9mZikgdGhlbiB0dXJuIG9uIGVuZHBvaW50IGRpc2NvdmVyeS5cbiAqIDIuIElmIHR1cm5lZCBvbiBpbiBlbnYgQVdTX0VOQUJMRV9FTkRQT0lOVF9ESVNDT1ZFUlkgdGhlbiB0dXJuIG9uIGVuZHBvaW50IGRpc2NvdmVyeS5cbiAqIDMuIElmIHR1cm5lZCBvbiBpbiBzaGFyZWQgaW5pIGNvbmZpZyBmaWxlIHdpdGgga2V5ICdlbmRwb2ludF9kaXNjb3ZlcnlfZW5hYmxlZCcsIHRoZW5cbiAqICAgdHVybiBvbiBlbmRwb2ludCBkaXNjb3ZlcnkuXG4gKiBAcGFyYW0gW29iamVjdF0gcmVxdWVzdCByZXF1ZXN0IG9iamVjdC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0VuZHBvaW50RGlzY292ZXJ5QXBwbGljYWJsZShyZXF1ZXN0KSB7XG4gIHZhciBzZXJ2aWNlID0gcmVxdWVzdC5zZXJ2aWNlIHx8IHt9O1xuICBpZiAoc2VydmljZS5jb25maWcuZW5kcG9pbnREaXNjb3ZlcnlFbmFibGVkID09PSB0cnVlKSByZXR1cm4gdHJ1ZTtcblxuICAvL3NoYXJlZCBpbmkgZmlsZSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBOb2RlXG4gIC8vbm90IHRvIGNoZWNrIGVudiBpbiBicm93c2VyXG4gIGlmICh1dGlsLmlzQnJvd3NlcigpKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmRwb2ludERpc2NvdmVyeUVuYWJsZWRFbnZzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVudiA9IGVuZHBvaW50RGlzY292ZXJ5RW5hYmxlZEVudnNbaV07XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9jZXNzLmVudiwgZW52KSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52W2Vudl0gPT09ICcnIHx8IHByb2Nlc3MuZW52W2Vudl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgICAgY29kZTogJ0NvbmZpZ3VyYXRpb25FeGNlcHRpb24nLFxuICAgICAgICAgIG1lc3NhZ2U6ICdlbnZpcm9ubWVudGFsIHZhcmlhYmxlICcgKyBlbnYgKyAnIGNhbm5vdCBiZSBzZXQgdG8gbm90aGluZydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzRmFsc3kocHJvY2Vzcy5lbnZbZW52XSkpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb25maWdGaWxlID0ge307XG4gIHRyeSB7XG4gICAgY29uZmlnRmlsZSA9IEFXUy51dGlsLmluaUxvYWRlciA/IEFXUy51dGlsLmluaUxvYWRlci5sb2FkRnJvbSh7XG4gICAgICBpc0NvbmZpZzogdHJ1ZSxcbiAgICAgIGZpbGVuYW1lOiBwcm9jZXNzLmVudltBV1MudXRpbC5zaGFyZWRDb25maWdGaWxlRW52XVxuICAgIH0pIDoge307XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHZhciBzaGFyZWRGaWxlQ29uZmlnID0gY29uZmlnRmlsZVtcbiAgICBwcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBBV1MudXRpbC5kZWZhdWx0UHJvZmlsZVxuICBdIHx8IHt9O1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNoYXJlZEZpbGVDb25maWcsICdlbmRwb2ludF9kaXNjb3ZlcnlfZW5hYmxlZCcpKSB7XG4gICAgaWYgKHNoYXJlZEZpbGVDb25maWcuZW5kcG9pbnRfZGlzY292ZXJ5X2VuYWJsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnQ29uZmlndXJhdGlvbkV4Y2VwdGlvbicsXG4gICAgICAgIG1lc3NhZ2U6ICdjb25maWcgZmlsZSBlbnRyeSBcXCdlbmRwb2ludF9kaXNjb3ZlcnlfZW5hYmxlZFxcJyBjYW5ub3QgYmUgc2V0IHRvIG5vdGhpbmcnXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0ZhbHN5KHNoYXJlZEZpbGVDb25maWcuZW5kcG9pbnRfZGlzY292ZXJ5X2VuYWJsZWQpKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogYXR0YWNoIGVuZHBvaW50IGRpc2NvdmVyeSBsb2dpYyB0byByZXF1ZXN0IG9iamVjdFxuICogQHBhcmFtIFtvYmplY3RdIHJlcXVlc3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkaXNjb3ZlckVuZHBvaW50KHJlcXVlc3QsIGRvbmUpIHtcbiAgdmFyIHNlcnZpY2UgPSByZXF1ZXN0LnNlcnZpY2UgfHwge307XG4gIGlmIChoYXNDdXN0b21FbmRwb2ludChzZXJ2aWNlKSB8fCByZXF1ZXN0LmlzUHJlc2lnbmVkKCkpIHJldHVybiBkb25lKCk7XG5cbiAgaWYgKCFpc0VuZHBvaW50RGlzY292ZXJ5QXBwbGljYWJsZShyZXF1ZXN0KSkgcmV0dXJuIGRvbmUoKTtcblxuICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmFwcGVuZFRvVXNlckFnZW50KCdlbmRwb2ludC1kaXNjb3ZlcnknKTtcblxuICB2YXIgb3BlcmF0aW9ucyA9IHNlcnZpY2UuYXBpLm9wZXJhdGlvbnMgfHwge307XG4gIHZhciBvcGVyYXRpb25Nb2RlbCA9IG9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dO1xuICB2YXIgaXNFbmRwb2ludERpc2NvdmVyeVJlcXVpcmVkID0gb3BlcmF0aW9uTW9kZWwgPyBvcGVyYXRpb25Nb2RlbC5lbmRwb2ludERpc2NvdmVyeVJlcXVpcmVkIDogJ05VTEwnO1xuICBzd2l0Y2ggKGlzRW5kcG9pbnREaXNjb3ZlcnlSZXF1aXJlZCkge1xuICAgIGNhc2UgJ09QVElPTkFMJzpcbiAgICAgIG9wdGlvbmFsRGlzY292ZXJFbmRwb2ludChyZXF1ZXN0KTtcbiAgICAgIHJlcXVlc3QuYWRkTmFtZWRMaXN0ZW5lcignSU5WQUxJREFURV9DQUNIRURfRU5EUE9JTlRTJywgJ2V4dHJhY3RFcnJvcicsIGludmFsaWRhdGVDYWNoZWRFbmRwb2ludHMpO1xuICAgICAgZG9uZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkVRVUlSRUQnOlxuICAgICAgcmVxdWVzdC5hZGROYW1lZExpc3RlbmVyKCdJTlZBTElEQVRFX0NBQ0hFRF9FTkRQT0lOVFMnLCAnZXh0cmFjdEVycm9yJywgaW52YWxpZGF0ZUNhY2hlZEVuZHBvaW50cyk7XG4gICAgICByZXF1aXJlZERpc2NvdmVyRW5kcG9pbnQocmVxdWVzdCwgZG9uZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdOVUxMJzpcbiAgICBkZWZhdWx0OlxuICAgICAgZG9uZSgpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRpc2NvdmVyRW5kcG9pbnQ6IGRpc2NvdmVyRW5kcG9pbnQsXG4gIHJlcXVpcmVkRGlzY292ZXJFbmRwb2ludDogcmVxdWlyZWREaXNjb3ZlckVuZHBvaW50LFxuICBvcHRpb25hbERpc2NvdmVyRW5kcG9pbnQ6IG9wdGlvbmFsRGlzY292ZXJFbmRwb2ludCxcbiAgbWFyc2hhbGxDdXN0b21JZGVudGlmaWVyczogbWFyc2hhbGxDdXN0b21JZGVudGlmaWVycyxcbiAgZ2V0Q2FjaGVLZXk6IGdldENhY2hlS2V5LFxuICBpbnZhbGlkYXRlQ2FjaGVkRW5kcG9pbnQ6IGludmFsaWRhdGVDYWNoZWRFbmRwb2ludHMsXG59O1xuIiwidmFyIGV2ZW50TWVzc2FnZUNodW5rZXIgPSByZXF1aXJlKCcuLi9ldmVudC1zdHJlYW0vZXZlbnQtbWVzc2FnZS1jaHVua2VyJykuZXZlbnRNZXNzYWdlQ2h1bmtlcjtcbnZhciBwYXJzZUV2ZW50ID0gcmVxdWlyZSgnLi9wYXJzZS1ldmVudCcpLnBhcnNlRXZlbnQ7XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50U3RyZWFtKGJvZHksIHBhcnNlciwgbW9kZWwpIHtcbiAgICB2YXIgZXZlbnRNZXNzYWdlcyA9IGV2ZW50TWVzc2FnZUNodW5rZXIoYm9keSk7XG5cbiAgICB2YXIgZXZlbnRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50TWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXZlbnRzLnB1c2gocGFyc2VFdmVudChwYXJzZXIsIGV2ZW50TWVzc2FnZXNbaV0sIG1vZGVsKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50cztcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY3JlYXRlRXZlbnRTdHJlYW06IGNyZWF0ZUV2ZW50U3RyZWFtXG59O1xuIiwiLyoqXG4gKiBUYWtlcyBpbiBhIGJ1ZmZlciBvZiBldmVudCBtZXNzYWdlcyBhbmQgc3BsaXRzIHRoZW0gaW50byBpbmRpdmlkdWFsIG1lc3NhZ2VzLlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlclxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV2ZW50TWVzc2FnZUNodW5rZXIoYnVmZmVyKSB7XG4gICAgLyoqIEB0eXBlIEJ1ZmZlcltdICovXG4gICAgdmFyIG1lc3NhZ2VzID0gW107XG4gICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICB2YXIgdG90YWxMZW5ndGggPSBidWZmZXIucmVhZEludDMyQkUob2Zmc2V0KTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IGJ1ZmZlciBmb3IgaW5kaXZpZHVhbCBtZXNzYWdlIChzaGFyZXMgbWVtb3J5IHdpdGggb3JpZ2luYWwpXG4gICAgICAgIHZhciBtZXNzYWdlID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgdG90YWxMZW5ndGggKyBvZmZzZXQpO1xuICAgICAgICAvLyBpbmNyZW1lbnQgb2Zmc2V0IHRvIGl0IHN0YXJ0cyBhdCB0aGUgbmV4dCBtZXNzYWdlXG4gICAgICAgIG9mZnNldCArPSB0b3RhbExlbmd0aDtcblxuICAgICAgICBtZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlcztcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZXZlbnRNZXNzYWdlQ2h1bmtlcjogZXZlbnRNZXNzYWdlQ2h1bmtlclxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZScpLnV0aWw7XG52YXIgdG9CdWZmZXIgPSB1dGlsLmJ1ZmZlci50b0J1ZmZlcjtcblxuLyoqXG4gKiBBIGxvc3NsZXNzIHJlcHJlc2VudGF0aW9uIG9mIGEgc2lnbmVkLCA2NC1iaXQgaW50ZWdlci4gSW5zdGFuY2VzIG9mIHRoaXNcbiAqIGNsYXNzIG1heSBiZSB1c2VkIGluIGFyaXRobWV0aWMgZXhwcmVzc2lvbnMgYXMgaWYgdGhleSB3ZXJlIG51bWVyaWNcbiAqIHByaW1pdGl2ZXMsIGJ1dCB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uIHdpbGwgYmUgcHJlc2VydmVkIHVuY2hhbmdlZCBhcyB0aGVcbiAqIGBieXRlc2AgcHJvcGVydHkgb2YgdGhlIG9iamVjdC4gVGhlIGJ5dGVzIHNob3VsZCBiZSBlbmNvZGVkIGFzIGJpZy1lbmRpYW4sXG4gKiB0d28ncyBjb21wbGVtZW50IGludGVnZXJzLlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ5dGVzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEludDY0KGJ5dGVzKSB7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gOCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludDY0IGJ1ZmZlcnMgbXVzdCBiZSBleGFjdGx5IDggYnl0ZXMnKTtcbiAgICB9XG4gICAgaWYgKCF1dGlsLkJ1ZmZlci5pc0J1ZmZlcihieXRlcykpIGJ5dGVzID0gdG9CdWZmZXIoYnl0ZXMpO1xuXG4gICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAqIEByZXR1cm5zIHtJbnQ2NH1cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuSW50NjQuZnJvbU51bWJlciA9IGZ1bmN0aW9uKG51bWJlcikge1xuICAgIGlmIChudW1iZXIgPiA5MjIzMzcyMDM2ODU0Nzc1ODA3IHx8IG51bWJlciA8IC05MjIzMzcyMDM2ODU0Nzc1ODA4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIG51bWJlciArICcgaXMgdG9vIGxhcmdlIChvciwgaWYgbmVnYXRpdmUsIHRvbyBzbWFsbCkgdG8gcmVwcmVzZW50IGFzIGFuIEludDY0J1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgIGZvciAoXG4gICAgICAgIHZhciBpID0gNywgcmVtYWluaW5nID0gTWF0aC5hYnMoTWF0aC5yb3VuZChudW1iZXIpKTtcbiAgICAgICAgaSA+IC0xICYmIHJlbWFpbmluZyA+IDA7XG4gICAgICAgIGktLSwgcmVtYWluaW5nIC89IDI1NlxuICAgICkge1xuICAgICAgICBieXRlc1tpXSA9IHJlbWFpbmluZztcbiAgICB9XG5cbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICBuZWdhdGUoYnl0ZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSW50NjQoYnl0ZXMpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5JbnQ2NC5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBieXRlcyA9IHRoaXMuYnl0ZXMuc2xpY2UoMCk7XG4gICAgdmFyIG5lZ2F0aXZlID0gYnl0ZXNbMF0gJiAxMjg7XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIG5lZ2F0ZShieXRlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlSW50KGJ5dGVzLnRvU3RyaW5nKCdoZXgnKSwgMTYpICogKG5lZ2F0aXZlID8gLTEgOiAxKTtcbn07XG5cbkludDY0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy52YWx1ZU9mKCkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnl0ZXNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbmVnYXRlKGJ5dGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gXj0gMHhGRjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDc7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgIGJ5dGVzW2ldKys7XG4gICAgICAgIGlmIChieXRlc1tpXSAhPT0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEludDY0OiBJbnQ2NFxufTtcbiIsInZhciBwYXJzZU1lc3NhZ2UgPSByZXF1aXJlKCcuL3BhcnNlLW1lc3NhZ2UnKS5wYXJzZU1lc3NhZ2U7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7Kn0gcGFyc2VyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICogQHBhcmFtIHsqfSBzaGFwZVxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRXZlbnQocGFyc2VyLCBtZXNzYWdlLCBzaGFwZSkge1xuICAgIHZhciBwYXJzZWRNZXNzYWdlID0gcGFyc2VNZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgLy8gY2hlY2sgaWYgbWVzc2FnZSBpcyBhbiBldmVudCBvciBlcnJvclxuICAgIHZhciBtZXNzYWdlVHlwZSA9IHBhcnNlZE1lc3NhZ2UuaGVhZGVyc1snOm1lc3NhZ2UtdHlwZSddO1xuICAgIGlmIChtZXNzYWdlVHlwZSkge1xuICAgICAgICBpZiAobWVzc2FnZVR5cGUudmFsdWUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IHBhcnNlRXJyb3IocGFyc2VkTWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZVR5cGUudmFsdWUgIT09ICdldmVudCcpIHtcbiAgICAgICAgICAgIC8vIG5vdCBzdXJlIGhvdyB0byBwYXJzZSBub24tZXZlbnRzL25vbi1lcnJvcnMsIGlnbm9yZSBmb3Igbm93XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkZXRlcm1pbmUgZXZlbnQgdHlwZVxuICAgIHZhciBldmVudFR5cGUgPSBwYXJzZWRNZXNzYWdlLmhlYWRlcnNbJzpldmVudC10eXBlJ107XG4gICAgLy8gY2hlY2sgdGhhdCB0aGUgZXZlbnQgdHlwZSBpcyBtb2RlbGVkXG4gICAgdmFyIGV2ZW50TW9kZWwgPSBzaGFwZS5tZW1iZXJzW2V2ZW50VHlwZS52YWx1ZV07XG4gICAgaWYgKCFldmVudE1vZGVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgLy8gY2hlY2sgaWYgYW4gZXZlbnQgcGF5bG9hZCBleGlzdHNcbiAgICB2YXIgZXZlbnRQYXlsb2FkTWVtYmVyTmFtZSA9IGV2ZW50TW9kZWwuZXZlbnRQYXlsb2FkTWVtYmVyTmFtZTtcbiAgICBpZiAoZXZlbnRQYXlsb2FkTWVtYmVyTmFtZSkge1xuICAgICAgICB2YXIgcGF5bG9hZFNoYXBlID0gZXZlbnRNb2RlbC5tZW1iZXJzW2V2ZW50UGF5bG9hZE1lbWJlck5hbWVdO1xuICAgICAgICAvLyBpZiB0aGUgc2hhcGUgaXMgYmluYXJ5LCByZXR1cm4gdGhlIGJ5dGUgYXJyYXlcbiAgICAgICAgaWYgKHBheWxvYWRTaGFwZS50eXBlID09PSAnYmluYXJ5Jykge1xuICAgICAgICAgICAgcmVzdWx0W2V2ZW50UGF5bG9hZE1lbWJlck5hbWVdID0gcGFyc2VkTWVzc2FnZS5ib2R5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W2V2ZW50UGF5bG9hZE1lbWJlck5hbWVdID0gcGFyc2VyLnBhcnNlKHBhcnNlZE1lc3NhZ2UuYm9keS50b1N0cmluZygpLCBwYXlsb2FkU2hhcGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVhZCBldmVudCBoZWFkZXJzXG4gICAgdmFyIGV2ZW50SGVhZGVyTmFtZXMgPSBldmVudE1vZGVsLmV2ZW50SGVhZGVyTWVtYmVyTmFtZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudEhlYWRlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gZXZlbnRIZWFkZXJOYW1lc1tpXTtcbiAgICAgICAgaWYgKHBhcnNlZE1lc3NhZ2UuaGVhZGVyc1tuYW1lXSkge1xuICAgICAgICAgICAgLy8gcGFyc2UgdGhlIGhlYWRlciFcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IGV2ZW50TW9kZWwubWVtYmVyc1tuYW1lXS50b1R5cGUocGFyc2VkTWVzc2FnZS5oZWFkZXJzW25hbWVdLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvdXRwdXQgPSB7fTtcbiAgICBvdXRwdXRbZXZlbnRUeXBlLnZhbHVlXSA9IHJlc3VsdDtcbiAgICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB2YXIgZXJyb3JDb2RlID0gbWVzc2FnZS5oZWFkZXJzWyc6ZXJyb3ItY29kZSddO1xuICAgIHZhciBlcnJvck1lc3NhZ2UgPSBtZXNzYWdlLmhlYWRlcnNbJzplcnJvci1tZXNzYWdlJ107XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKGVycm9yTWVzc2FnZS52YWx1ZSB8fCBlcnJvck1lc3NhZ2UpO1xuICAgIGVycm9yLmNvZGUgPSBlcnJvci5uYW1lID0gZXJyb3JDb2RlLnZhbHVlIHx8IGVycm9yQ29kZTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHBhcnNlRXZlbnQ6IHBhcnNlRXZlbnRcbn07XG4iLCJ2YXIgSW50NjQgPSByZXF1aXJlKCcuL2ludDY0JykuSW50NjQ7XG5cbnZhciBzcGxpdE1lc3NhZ2UgPSByZXF1aXJlKCcuL3NwbGl0LW1lc3NhZ2UnKS5zcGxpdE1lc3NhZ2U7XG5cbnZhciBCT09MRUFOX1RBRyA9ICdib29sZWFuJztcbnZhciBCWVRFX1RBRyA9ICdieXRlJztcbnZhciBTSE9SVF9UQUcgPSAnc2hvcnQnO1xudmFyIElOVF9UQUcgPSAnaW50ZWdlcic7XG52YXIgTE9OR19UQUcgPSAnbG9uZyc7XG52YXIgQklOQVJZX1RBRyA9ICdiaW5hcnknO1xudmFyIFNUUklOR19UQUcgPSAnc3RyaW5nJztcbnZhciBUSU1FU1RBTVBfVEFHID0gJ3RpbWVzdGFtcCc7XG52YXIgVVVJRF9UQUcgPSAndXVpZCc7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGhlYWRlcnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB2YXIgb3V0ID0ge307XG4gICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICB3aGlsZSAocG9zaXRpb24gPCBoZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmFtZUxlbmd0aCA9IGhlYWRlcnMucmVhZFVJbnQ4KHBvc2l0aW9uKyspO1xuICAgICAgICB2YXIgbmFtZSA9IGhlYWRlcnMuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgbmFtZUxlbmd0aCkudG9TdHJpbmcoKTtcbiAgICAgICAgcG9zaXRpb24gKz0gbmFtZUxlbmd0aDtcbiAgICAgICAgc3dpdGNoIChoZWFkZXJzLnJlYWRVSW50OChwb3NpdGlvbisrKSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIGJvb2xUcnVlICovOlxuICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogQk9PTEVBTl9UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMSAvKiBib29sRmFsc2UgKi86XG4gICAgICAgICAgICAgICAgb3V0W25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBCT09MRUFOX1RBRyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMiAvKiBieXRlICovOlxuICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogQllURV9UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBoZWFkZXJzLnJlYWRJbnQ4KHBvc2l0aW9uKyspXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMyAvKiBzaG9ydCAqLzpcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNIT1JUX1RBRyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGhlYWRlcnMucmVhZEludDE2QkUocG9zaXRpb24pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0IC8qIGludGVnZXIgKi86XG4gICAgICAgICAgICAgICAgb3V0W25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJTlRfVEFHLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaGVhZGVycy5yZWFkSW50MzJCRShwb3NpdGlvbilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDUgLyogbG9uZyAqLzpcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IExPTkdfVEFHLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IEludDY0KGhlYWRlcnMuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgOCkpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2IC8qIGJ5dGVBcnJheSAqLzpcbiAgICAgICAgICAgICAgICB2YXIgYmluYXJ5TGVuZ3RoID0gaGVhZGVycy5yZWFkVUludDE2QkUocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgICAgICAgICAgICAgb3V0W25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBCSU5BUllfVEFHLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaGVhZGVycy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBiaW5hcnlMZW5ndGgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSBiaW5hcnlMZW5ndGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDcgLyogc3RyaW5nICovOlxuICAgICAgICAgICAgICAgIHZhciBzdHJpbmdMZW5ndGggPSBoZWFkZXJzLnJlYWRVSW50MTZCRShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNUUklOR19UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBoZWFkZXJzLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArIHN0cmluZ0xlbmd0aFxuICAgICAgICAgICAgICAgICAgICApLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHN0cmluZ0xlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOCAvKiB0aW1lc3RhbXAgKi86XG4gICAgICAgICAgICAgICAgb3V0W25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUSU1FU1RBTVBfVEFHLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IERhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgSW50NjQoaGVhZGVycy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyA4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFsdWVPZigpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDkgLyogdXVpZCAqLzpcbiAgICAgICAgICAgICAgICB2YXIgdXVpZENoYXJzID0gaGVhZGVycy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyAxNilcbiAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAxNjtcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFVVSURfVEFHLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdXVpZENoYXJzLnN1YnN0cigwLCA4KSArICctJyArXG4gICAgICAgICAgICAgICAgICAgICAgICB1dWlkQ2hhcnMuc3Vic3RyKDgsIDQpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV1aWRDaGFycy5zdWJzdHIoMTIsIDQpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV1aWRDaGFycy5zdWJzdHIoMTYsIDQpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV1aWRDaGFycy5zdWJzdHIoMjApXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgaGVhZGVyIHR5cGUgdGFnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gcGFyc2VNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICB2YXIgcGFyc2VkID0gc3BsaXRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIHJldHVybiB7IGhlYWRlcnM6IHBhcnNlSGVhZGVycyhwYXJzZWQuaGVhZGVycyksIGJvZHk6IHBhcnNlZC5ib2R5IH07XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHBhcnNlTWVzc2FnZTogcGFyc2VNZXNzYWdlXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlJykudXRpbDtcbnZhciB0b0J1ZmZlciA9IHV0aWwuYnVmZmVyLnRvQnVmZmVyO1xuXG4vLyBBbGwgcHJlbHVkZSBjb21wb25lbnRzIGFyZSB1bnNpZ25lZCwgMzItYml0IGludGVnZXJzXG52YXIgUFJFTFVERV9NRU1CRVJfTEVOR1RIID0gNDtcbi8vIFRoZSBwcmVsdWRlIGNvbnNpc3RzIG9mIHR3byBjb21wb25lbnRzXG52YXIgUFJFTFVERV9MRU5HVEggPSBQUkVMVURFX01FTUJFUl9MRU5HVEggKiAyO1xuLy8gQ2hlY2tzdW1zIGFyZSBhbHdheXMgQ1JDMzIgaGFzaGVzLlxudmFyIENIRUNLU1VNX0xFTkdUSCA9IDQ7XG4vLyBNZXNzYWdlcyBtdXN0IGluY2x1ZGUgYSBmdWxsIHByZWx1ZGUsIGEgcHJlbHVkZSBjaGVja3N1bSwgYW5kIGEgbWVzc2FnZSBjaGVja3N1bVxudmFyIE1JTklNVU1fTUVTU0FHRV9MRU5HVEggPSBQUkVMVURFX0xFTkdUSCArIENIRUNLU1VNX0xFTkdUSCAqIDI7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gc3BsaXRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAoIXV0aWwuQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSBtZXNzYWdlID0gdG9CdWZmZXIobWVzc2FnZSk7XG5cbiAgICBpZiAobWVzc2FnZS5sZW5ndGggPCBNSU5JTVVNX01FU1NBR0VfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgbWVzc2FnZSB0b28gc2hvcnQgdG8gYWNjb21tb2RhdGUgZXZlbnQgc3RyZWFtIG1lc3NhZ2Ugb3ZlcmhlYWQnKTtcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZS5sZW5ndGggIT09IG1lc3NhZ2UucmVhZFVJbnQzMkJFKDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVwb3J0ZWQgbWVzc2FnZSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggcmVjZWl2ZWQgbWVzc2FnZSBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICB2YXIgZXhwZWN0ZWRQcmVsdWRlQ2hlY2tzdW0gPSBtZXNzYWdlLnJlYWRVSW50MzJCRShQUkVMVURFX0xFTkdUSCk7XG5cbiAgICBpZiAoXG4gICAgICAgIGV4cGVjdGVkUHJlbHVkZUNoZWNrc3VtICE9PSB1dGlsLmNyeXB0by5jcmMzMihcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2xpY2UoMCwgUFJFTFVERV9MRU5HVEgpXG4gICAgICAgIClcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBwcmVsdWRlIGNoZWNrc3VtIHNwZWNpZmllZCBpbiB0aGUgbWVzc2FnZSAoJyArXG4gICAgICAgICAgICBleHBlY3RlZFByZWx1ZGVDaGVja3N1bSArXG4gICAgICAgICAgICAnKSBkb2VzIG5vdCBtYXRjaCB0aGUgY2FsY3VsYXRlZCBDUkMzMiBjaGVja3N1bS4nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGV4cGVjdGVkTWVzc2FnZUNoZWNrc3VtID0gbWVzc2FnZS5yZWFkVUludDMyQkUobWVzc2FnZS5sZW5ndGggLSBDSEVDS1NVTV9MRU5HVEgpO1xuXG4gICAgaWYgKFxuICAgICAgICBleHBlY3RlZE1lc3NhZ2VDaGVja3N1bSAhPT0gdXRpbC5jcnlwdG8uY3JjMzIoXG4gICAgICAgICAgICBtZXNzYWdlLnNsaWNlKDAsIG1lc3NhZ2UubGVuZ3RoIC0gQ0hFQ0tTVU1fTEVOR1RIKVxuICAgICAgICApXG4gICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgbWVzc2FnZSBjaGVja3N1bSBkaWQgbm90IG1hdGNoIHRoZSBleHBlY3RlZCB2YWx1ZSBvZiAnICtcbiAgICAgICAgICAgICAgICBleHBlY3RlZE1lc3NhZ2VDaGVja3N1bVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBoZWFkZXJzU3RhcnQgPSBQUkVMVURFX0xFTkdUSCArIENIRUNLU1VNX0xFTkdUSDtcbiAgICB2YXIgaGVhZGVyc0VuZCA9IGhlYWRlcnNTdGFydCArIG1lc3NhZ2UucmVhZFVJbnQzMkJFKFBSRUxVREVfTUVNQkVSX0xFTkdUSCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBoZWFkZXJzOiBtZXNzYWdlLnNsaWNlKGhlYWRlcnNTdGFydCwgaGVhZGVyc0VuZCksXG4gICAgICAgIGJvZHk6IG1lc3NhZ2Uuc2xpY2UoaGVhZGVyc0VuZCwgbWVzc2FnZS5sZW5ndGggLSBDSEVDS1NVTV9MRU5HVEgpLFxuICAgIH07XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHNwbGl0TWVzc2FnZTogc3BsaXRNZXNzYWdlXG59O1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIFNlcXVlbnRpYWxFeGVjdXRvciA9IHJlcXVpcmUoJy4vc2VxdWVudGlhbF9leGVjdXRvcicpO1xudmFyIERJU0NPVkVSX0VORFBPSU5UID0gcmVxdWlyZSgnLi9kaXNjb3Zlcl9lbmRwb2ludCcpLmRpc2NvdmVyRW5kcG9pbnQ7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgdXNlZCB0byByZWdpc3RlciBnbG9iYWwgZXZlbnQgbGlzdGVuZXJzIGZvciByZXF1ZXN0IGJ1aWxkaW5nXG4gKiBhbmQgc2VuZGluZy5cbiAqL1xuQVdTLkV2ZW50TGlzdGVuZXJzID0ge1xuICAvKipcbiAgICogQCFhdHRyaWJ1dGUgVkFMSURBVEVfQ1JFREVOVElBTFNcbiAgICogICBBIHJlcXVlc3QgbGlzdGVuZXIgdGhhdCB2YWxpZGF0ZXMgd2hldGhlciB0aGUgcmVxdWVzdCBpcyBiZWluZ1xuICAgKiAgIHNlbnQgd2l0aCBjcmVkZW50aWFscy5cbiAgICogICBIYW5kbGVzIHRoZSB7QVdTLlJlcXVlc3R+dmFsaWRhdGUgJ3ZhbGlkYXRlJyBSZXF1ZXN0IGV2ZW50fVxuICAgKiAgIEBleGFtcGxlIFNlbmRpbmcgYSByZXF1ZXN0IHdpdGhvdXQgdmFsaWRhdGluZyBjcmVkZW50aWFsc1xuICAgKiAgICAgdmFyIGxpc3RlbmVyID0gQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfQ1JFREVOVElBTFM7XG4gICAqICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCd2YWxpZGF0ZScsIGxpc3RlbmVyKTtcbiAgICogICBAcmVhZG9ubHlcbiAgICogICBAcmV0dXJuIFtGdW5jdGlvbl1cbiAgICogQCFhdHRyaWJ1dGUgVkFMSURBVEVfUkVHSU9OXG4gICAqICAgQSByZXF1ZXN0IGxpc3RlbmVyIHRoYXQgdmFsaWRhdGVzIHdoZXRoZXIgdGhlIHJlZ2lvbiBpcyBzZXRcbiAgICogICBmb3IgYSByZXF1ZXN0LlxuICAgKiAgIEhhbmRsZXMgdGhlIHtBV1MuUmVxdWVzdH52YWxpZGF0ZSAndmFsaWRhdGUnIFJlcXVlc3QgZXZlbnR9XG4gICAqICAgQGV4YW1wbGUgU2VuZGluZyBhIHJlcXVlc3Qgd2l0aG91dCB2YWxpZGF0aW5nIHJlZ2lvbiBjb25maWd1cmF0aW9uXG4gICAqICAgICB2YXIgbGlzdGVuZXIgPSBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9SRUdJT047XG4gICAqICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCd2YWxpZGF0ZScsIGxpc3RlbmVyKTtcbiAgICogICBAcmVhZG9ubHlcbiAgICogICBAcmV0dXJuIFtGdW5jdGlvbl1cbiAgICogQCFhdHRyaWJ1dGUgVkFMSURBVEVfUEFSQU1FVEVSU1xuICAgKiAgIEEgcmVxdWVzdCBsaXN0ZW5lciB0aGF0IHZhbGlkYXRlcyBpbnB1dCBwYXJhbWV0ZXJzIGluIGEgcmVxdWVzdC5cbiAgICogICBIYW5kbGVzIHRoZSB7QVdTLlJlcXVlc3R+dmFsaWRhdGUgJ3ZhbGlkYXRlJyBSZXF1ZXN0IGV2ZW50fVxuICAgKiAgIEBleGFtcGxlIFNlbmRpbmcgYSByZXF1ZXN0IHdpdGhvdXQgdmFsaWRhdGluZyBwYXJhbWV0ZXJzXG4gICAqICAgICB2YXIgbGlzdGVuZXIgPSBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9QQVJBTUVURVJTO1xuICAgKiAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLCBsaXN0ZW5lcik7XG4gICAqICAgQGV4YW1wbGUgRGlzYWJsZSBwYXJhbWV0ZXIgdmFsaWRhdGlvbiBnbG9iYWxseVxuICAgKiAgICAgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJyxcbiAgICogICAgICAgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfUkVHSU9OKTtcbiAgICogICBAcmVhZG9ubHlcbiAgICogICBAcmV0dXJuIFtGdW5jdGlvbl1cbiAgICogQCFhdHRyaWJ1dGUgU0VORFxuICAgKiAgIEEgcmVxdWVzdCBsaXN0ZW5lciB0aGF0IGluaXRpYXRlcyB0aGUgSFRUUCBjb25uZWN0aW9uIGZvciBhXG4gICAqICAgcmVxdWVzdCBiZWluZyBzZW50LiBIYW5kbGVzIHRoZSB7QVdTLlJlcXVlc3R+c2VuZCAnc2VuZCcgUmVxdWVzdCBldmVudH1cbiAgICogICBAZXhhbXBsZSBSZXBsYWNpbmcgdGhlIEhUVFAgaGFuZGxlclxuICAgKiAgICAgdmFyIGxpc3RlbmVyID0gQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuU0VORDtcbiAgICogICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3NlbmQnLCBsaXN0ZW5lcik7XG4gICAqICAgICByZXF1ZXN0Lm9uKCdzZW5kJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICogICAgICAgY3VzdG9tSGFuZGxlci5zZW5kKHJlc3BvbnNlKTtcbiAgICogICAgIH0pO1xuICAgKiAgIEByZXR1cm4gW0Z1bmN0aW9uXVxuICAgKiAgIEByZWFkb25seVxuICAgKiBAIWF0dHJpYnV0ZSBIVFRQX0RBVEFcbiAgICogICBBIHJlcXVlc3QgbGlzdGVuZXIgdGhhdCByZWFkcyBkYXRhIGZyb20gdGhlIEhUVFAgY29ubmVjdGlvbiBpbiBvcmRlclxuICAgKiAgIHRvIGJ1aWxkIHRoZSByZXNwb25zZSBkYXRhLlxuICAgKiAgIEhhbmRsZXMgdGhlIHtBV1MuUmVxdWVzdH5odHRwRGF0YSAnaHR0cERhdGEnIFJlcXVlc3QgZXZlbnR9LlxuICAgKiAgIFJlbW92ZSB0aGlzIGhhbmRsZXIgaWYgeW91IGFyZSBvdmVycmlkaW5nIHRoZSAnaHR0cERhdGEnIGV2ZW50IGFuZFxuICAgKiAgIGRvIG5vdCB3YW50IGV4dHJhIGRhdGEgcHJvY2Vzc2luZyBhbmQgYnVmZmVyaW5nIG92ZXJoZWFkLlxuICAgKiAgIEBleGFtcGxlIERpc2FibGluZyBkZWZhdWx0IGRhdGEgcHJvY2Vzc2luZ1xuICAgKiAgICAgdmFyIGxpc3RlbmVyID0gQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuSFRUUF9EQVRBO1xuICAgKiAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignaHR0cERhdGEnLCBsaXN0ZW5lcik7XG4gICAqICAgQHJldHVybiBbRnVuY3Rpb25dXG4gICAqICAgQHJlYWRvbmx5XG4gICAqL1xuICBDb3JlOiB7fSAvKiBkb2MgaGFjayAqL1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0T3BlcmF0aW9uQXV0aHR5cGUocmVxKSB7XG4gIGlmICghcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnMpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICByZXR1cm4gb3BlcmF0aW9uID8gb3BlcmF0aW9uLmF1dGh0eXBlIDogJyc7XG59XG5cbkFXUy5FdmVudExpc3RlbmVycyA9IHtcbiAgQ29yZTogbmV3IFNlcXVlbnRpYWxFeGVjdXRvcigpLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCwgYWRkQXN5bmMpIHtcbiAgICBhZGRBc3luYygnVkFMSURBVEVfQ1JFREVOVElBTFMnLCAndmFsaWRhdGUnLFxuICAgICAgICBmdW5jdGlvbiBWQUxJREFURV9DUkVERU5USUFMUyhyZXEsIGRvbmUpIHtcbiAgICAgIGlmICghcmVxLnNlcnZpY2UuYXBpLnNpZ25hdHVyZVZlcnNpb24gJiYgIXJlcS5zZXJ2aWNlLmNvbmZpZy5zaWduYXR1cmVWZXJzaW9uKSByZXR1cm4gZG9uZSgpOyAvLyBub25lXG4gICAgICByZXEuc2VydmljZS5jb25maWcuZ2V0Q3JlZGVudGlhbHMoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXEucmVzcG9uc2UuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihlcnIsXG4gICAgICAgICAgICB7Y29kZTogJ0NyZWRlbnRpYWxzRXJyb3InLCBtZXNzYWdlOiAnTWlzc2luZyBjcmVkZW50aWFscyBpbiBjb25maWcnfSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBhZGQoJ1ZBTElEQVRFX1JFR0lPTicsICd2YWxpZGF0ZScsIGZ1bmN0aW9uIFZBTElEQVRFX1JFR0lPTihyZXEpIHtcbiAgICAgIGlmICghcmVxLnNlcnZpY2UuY29uZmlnLnJlZ2lvbiAmJiAhcmVxLnNlcnZpY2UuaXNHbG9iYWxFbmRwb2ludCkge1xuICAgICAgICByZXEucmVzcG9uc2UuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgICB7Y29kZTogJ0NvbmZpZ0Vycm9yJywgbWVzc2FnZTogJ01pc3NpbmcgcmVnaW9uIGluIGNvbmZpZyd9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnQlVJTERfSURFTVBPVEVOQ1lfVE9LRU5TJywgJ3ZhbGlkYXRlJywgZnVuY3Rpb24gQlVJTERfSURFTVBPVEVOQ1lfVE9LRU5TKHJlcSkge1xuICAgICAgaWYgKCFyZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gICAgICBpZiAoIW9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaWRlbXBvdGVudE1lbWJlcnMgPSBvcGVyYXRpb24uaWRlbXBvdGVudE1lbWJlcnM7XG4gICAgICBpZiAoIWlkZW1wb3RlbnRNZW1iZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBjcmVhdGVzIGEgY29weSBvZiBwYXJhbXMgc28gdXNlcidzIHBhcmFtIG9iamVjdCBpc24ndCBtdXRhdGVkXG4gICAgICB2YXIgcGFyYW1zID0gQVdTLnV0aWwuY29weShyZXEucGFyYW1zKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gaWRlbXBvdGVudE1lbWJlcnMubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghcGFyYW1zW2lkZW1wb3RlbnRNZW1iZXJzW2ldXSkge1xuICAgICAgICAgIC8vIGFkZCB0aGUgbWVtYmVyXG4gICAgICAgICAgcGFyYW1zW2lkZW1wb3RlbnRNZW1iZXJzW2ldXSA9IEFXUy51dGlsLnV1aWQudjQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVxLnBhcmFtcyA9IHBhcmFtcztcbiAgICB9KTtcblxuICAgIGFkZCgnVkFMSURBVEVfUEFSQU1FVEVSUycsICd2YWxpZGF0ZScsIGZ1bmN0aW9uIFZBTElEQVRFX1BBUkFNRVRFUlMocmVxKSB7XG4gICAgICBpZiAoIXJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBydWxlcyA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLmlucHV0O1xuICAgICAgdmFyIHZhbGlkYXRpb24gPSByZXEuc2VydmljZS5jb25maWcucGFyYW1WYWxpZGF0aW9uO1xuICAgICAgbmV3IEFXUy5QYXJhbVZhbGlkYXRvcih2YWxpZGF0aW9uKS52YWxpZGF0ZShydWxlcywgcmVxLnBhcmFtcyk7XG4gICAgfSk7XG5cbiAgICBhZGRBc3luYygnQ09NUFVURV9TSEEyNTYnLCAnYWZ0ZXJCdWlsZCcsIGZ1bmN0aW9uIENPTVBVVEVfU0hBMjU2KHJlcSwgZG9uZSkge1xuICAgICAgcmVxLmhhbHRIYW5kbGVyc09uRXJyb3IoKTtcbiAgICAgIGlmICghcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICAgICAgdmFyIGF1dGh0eXBlID0gb3BlcmF0aW9uID8gb3BlcmF0aW9uLmF1dGh0eXBlIDogJyc7XG4gICAgICBpZiAoIXJlcS5zZXJ2aWNlLmFwaS5zaWduYXR1cmVWZXJzaW9uICYmICFhdXRodHlwZSAmJiAhcmVxLnNlcnZpY2UuY29uZmlnLnNpZ25hdHVyZVZlcnNpb24pIHJldHVybiBkb25lKCk7IC8vIG5vbmVcbiAgICAgIGlmIChyZXEuc2VydmljZS5nZXRTaWduZXJDbGFzcyhyZXEpID09PSBBV1MuU2lnbmVycy5WNCkge1xuICAgICAgICB2YXIgYm9keSA9IHJlcS5odHRwUmVxdWVzdC5ib2R5IHx8ICcnO1xuICAgICAgICBpZiAoYXV0aHR5cGUuaW5kZXhPZigndW5zaWduZWQtYm9keScpID49IDApIHtcbiAgICAgICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snWC1BbXotQ29udGVudC1TaGEyNTYnXSA9ICdVTlNJR05FRC1QQVlMT0FEJztcbiAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIEFXUy51dGlsLmNvbXB1dGVTaGEyNTYoYm9keSwgZnVuY3Rpb24oZXJyLCBzaGEpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LUNvbnRlbnQtU2hhMjU2J10gPSBzaGE7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnU0VUX0NPTlRFTlRfTEVOR1RIJywgJ2FmdGVyQnVpbGQnLCBmdW5jdGlvbiBTRVRfQ09OVEVOVF9MRU5HVEgocmVxKSB7XG4gICAgICB2YXIgYXV0aHR5cGUgPSBnZXRPcGVyYXRpb25BdXRodHlwZShyZXEpO1xuICAgICAgdmFyIHBheWxvYWRNZW1iZXIgPSBBV1MudXRpbC5nZXRSZXF1ZXN0UGF5bG9hZFNoYXBlKHJlcSk7XG4gICAgICBpZiAocmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBBV1MudXRpbC5zdHJpbmcuYnl0ZUxlbmd0aChyZXEuaHR0cFJlcXVlc3QuYm9keSk7XG4gICAgICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSBsZW5ndGg7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChwYXlsb2FkTWVtYmVyICYmIHBheWxvYWRNZW1iZXIuaXNTdHJlYW1pbmcpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkTWVtYmVyLnJlcXVpcmVzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vc3RyZWFtaW5nIHBheWxvYWQgcmVxdWlyZXMgbGVuZ3RoKHMzLCBnbGFjaWVyKVxuICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF1dGh0eXBlLmluZGV4T2YoJ3Vuc2lnbmVkLWJvZHknKSA+PSAwKSB7XG4gICAgICAgICAgICAgIC8vdW5ib3VuZGVkIHN0cmVhbWluZyBwYXlsb2FkKGxleCwgbWVkaWFzdG9yZSlcbiAgICAgICAgICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ1RyYW5zZmVyLUVuY29kaW5nJ10gPSAnY2h1bmtlZCc7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ1NFVF9IVFRQX0hPU1QnLCAnYWZ0ZXJCdWlsZCcsIGZ1bmN0aW9uIFNFVF9IVFRQX0hPU1QocmVxKSB7XG4gICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snSG9zdCddID0gcmVxLmh0dHBSZXF1ZXN0LmVuZHBvaW50Lmhvc3Q7XG4gICAgfSk7XG5cbiAgICBhZGQoJ1JFU1RBUlQnLCAncmVzdGFydCcsIGZ1bmN0aW9uIFJFU1RBUlQoKSB7XG4gICAgICB2YXIgZXJyID0gdGhpcy5yZXNwb25zZS5lcnJvcjtcbiAgICAgIGlmICghZXJyIHx8ICFlcnIucmV0cnlhYmxlKSByZXR1cm47XG5cbiAgICAgIHRoaXMuaHR0cFJlcXVlc3QgPSBuZXcgQVdTLkh0dHBSZXF1ZXN0KFxuICAgICAgICB0aGlzLnNlcnZpY2UuZW5kcG9pbnQsXG4gICAgICAgIHRoaXMuc2VydmljZS5yZWdpb25cbiAgICAgICk7XG5cbiAgICAgIGlmICh0aGlzLnJlc3BvbnNlLnJldHJ5Q291bnQgPCB0aGlzLnNlcnZpY2UuY29uZmlnLm1heFJldHJpZXMpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZS5yZXRyeUNvdW50Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlc3BvbnNlLmVycm9yID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBhZGRUb0hlYWQgPSB0cnVlO1xuICAgIGFkZEFzeW5jKCdESVNDT1ZFUl9FTkRQT0lOVCcsICdzaWduJywgRElTQ09WRVJfRU5EUE9JTlQsIGFkZFRvSGVhZCk7XG5cbiAgICBhZGRBc3luYygnU0lHTicsICdzaWduJywgZnVuY3Rpb24gU0lHTihyZXEsIGRvbmUpIHtcbiAgICAgIHZhciBzZXJ2aWNlID0gcmVxLnNlcnZpY2U7XG4gICAgICB2YXIgb3BlcmF0aW9ucyA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zIHx8IHt9O1xuICAgICAgdmFyIG9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gICAgICB2YXIgYXV0aHR5cGUgPSBvcGVyYXRpb24gPyBvcGVyYXRpb24uYXV0aHR5cGUgOiAnJztcbiAgICAgIGlmICghc2VydmljZS5hcGkuc2lnbmF0dXJlVmVyc2lvbiAmJiAhYXV0aHR5cGUgJiYgIXNlcnZpY2UuY29uZmlnLnNpZ25hdHVyZVZlcnNpb24pIHJldHVybiBkb25lKCk7IC8vIG5vbmVcblxuICAgICAgc2VydmljZS5jb25maWcuZ2V0Q3JlZGVudGlhbHMoZnVuY3Rpb24gKGVyciwgY3JlZGVudGlhbHMpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlcS5yZXNwb25zZS5lcnJvciA9IGVycjtcbiAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgZGF0ZSA9IHNlcnZpY2UuZ2V0U2tld0NvcnJlY3RlZERhdGUoKTtcbiAgICAgICAgICB2YXIgU2lnbmVyQ2xhc3MgPSBzZXJ2aWNlLmdldFNpZ25lckNsYXNzKHJlcSk7XG4gICAgICAgICAgdmFyIHNpZ25lciA9IG5ldyBTaWduZXJDbGFzcyhyZXEuaHR0cFJlcXVlc3QsXG4gICAgICAgICAgICBzZXJ2aWNlLmFwaS5zaWduaW5nTmFtZSB8fCBzZXJ2aWNlLmFwaS5lbmRwb2ludFByZWZpeCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc2lnbmF0dXJlQ2FjaGU6IHNlcnZpY2UuY29uZmlnLnNpZ25hdHVyZUNhY2hlLFxuICAgICAgICAgICAgICBvcGVyYXRpb246IG9wZXJhdGlvbixcbiAgICAgICAgICAgICAgc2lnbmF0dXJlVmVyc2lvbjogc2VydmljZS5hcGkuc2lnbmF0dXJlVmVyc2lvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgc2lnbmVyLnNldFNlcnZpY2VDbGllbnRJZChzZXJ2aWNlLl9jbGllbnRJZCk7XG5cbiAgICAgICAgICAvLyBjbGVhciBvbGQgYXV0aG9yaXphdGlvbiBoZWFkZXJzXG4gICAgICAgICAgZGVsZXRlIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydBdXRob3JpemF0aW9uJ107XG4gICAgICAgICAgZGVsZXRlIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydEYXRlJ107XG4gICAgICAgICAgZGVsZXRlIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydYLUFtei1EYXRlJ107XG5cbiAgICAgICAgICAvLyBhZGQgbmV3IGF1dGhvcml6YXRpb25cbiAgICAgICAgICBzaWduZXIuYWRkQXV0aG9yaXphdGlvbihjcmVkZW50aWFscywgZGF0ZSk7XG4gICAgICAgICAgcmVxLnNpZ25lZEF0ID0gZGF0ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlcS5yZXNwb25zZS5lcnJvciA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBhZGQoJ1ZBTElEQVRFX1JFU1BPTlNFJywgJ3ZhbGlkYXRlUmVzcG9uc2UnLCBmdW5jdGlvbiBWQUxJREFURV9SRVNQT05TRShyZXNwKSB7XG4gICAgICBpZiAodGhpcy5zZXJ2aWNlLnN1Y2Nlc3NmdWxSZXNwb25zZShyZXNwLCB0aGlzKSkge1xuICAgICAgICByZXNwLmRhdGEgPSB7fTtcbiAgICAgICAgcmVzcC5lcnJvciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwLmRhdGEgPSBudWxsO1xuICAgICAgICByZXNwLmVycm9yID0gQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgICAge2NvZGU6ICdVbmtub3duRXJyb3InLCBtZXNzYWdlOiAnQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZC4nfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRBc3luYygnU0VORCcsICdzZW5kJywgZnVuY3Rpb24gU0VORChyZXNwLCBkb25lKSB7XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5fYWJvcnRDYWxsYmFjayA9IGRvbmU7XG4gICAgICByZXNwLmVycm9yID0gbnVsbDtcbiAgICAgIHJlc3AuZGF0YSA9IG51bGw7XG5cbiAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGh0dHBSZXNwKSB7XG4gICAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLnN0cmVhbSA9IGh0dHBSZXNwO1xuICAgICAgICB2YXIgc3RyZWFtID0gcmVzcC5yZXF1ZXN0Lmh0dHBSZXF1ZXN0LnN0cmVhbTtcbiAgICAgICAgdmFyIHNlcnZpY2UgPSByZXNwLnJlcXVlc3Quc2VydmljZTtcbiAgICAgICAgdmFyIGFwaSA9IHNlcnZpY2UuYXBpO1xuICAgICAgICB2YXIgb3BlcmF0aW9uTmFtZSA9IHJlc3AucmVxdWVzdC5vcGVyYXRpb247XG4gICAgICAgIHZhciBvcGVyYXRpb24gPSBhcGkub3BlcmF0aW9uc1tvcGVyYXRpb25OYW1lXSB8fCB7fTtcblxuICAgICAgICBodHRwUmVzcC5vbignaGVhZGVycycsIGZ1bmN0aW9uIG9uSGVhZGVycyhzdGF0dXNDb2RlLCBoZWFkZXJzLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoXG4gICAgICAgICAgICAnaHR0cEhlYWRlcnMnLFxuICAgICAgICAgICAgW3N0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3AsIHN0YXR1c01lc3NhZ2VdXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmICghcmVzcC5odHRwUmVzcG9uc2Uuc3RyZWFtaW5nKSB7XG4gICAgICAgICAgICBpZiAoQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIpIHsgLy8gc3RyZWFtczIgQVBJIGNoZWNrXG4gICAgICAgICAgICAgIC8vIGlmIHdlIGRldGVjdCBldmVudCBzdHJlYW1zLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvXG4gICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgc3RyZWFtIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgIGlmIChvcGVyYXRpb24uaGFzRXZlbnRPdXRwdXQgJiYgc2VydmljZS5zdWNjZXNzZnVsUmVzcG9uc2UocmVzcCkpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIHJlYWRpbmcgdGhlIEluY29taW5nU3RyZWFtXG4gICAgICAgICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBEb25lJyk7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGh0dHBSZXNwLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uIG9uUmVhZGFibGUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBodHRwUmVzcC5yZWFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3AucmVxdWVzdC5lbWl0KCdodHRwRGF0YScsIFtkYXRhLCByZXNwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGxlZ2FjeSBzdHJlYW1zIEFQSVxuICAgICAgICAgICAgICBodHRwUmVzcC5vbignZGF0YScsIGZ1bmN0aW9uIG9uRGF0YShkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBEYXRhJywgW2RhdGEsIHJlc3BdKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBodHRwUmVzcC5vbignZW5kJywgZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0gfHwgIXN0cmVhbS5kaWRDYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKEFXUy5IdHRwQ2xpZW50LnN0cmVhbXNBcGlWZXJzaW9uID09PSAyICYmIChvcGVyYXRpb24uaGFzRXZlbnRPdXRwdXQgJiYgc2VydmljZS5zdWNjZXNzZnVsUmVzcG9uc2UocmVzcCkpKSB7XG4gICAgICAgICAgICAgIC8vIGRvbid0IGNvbmNhdGVuYXRlIHJlc3BvbnNlIGNodW5rcyB3aGVuIHN0cmVhbWluZyBldmVudCBzdHJlYW0gZGF0YSB3aGVuIHJlc3BvbnNlIGlzIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBEb25lJyk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHJvZ3Jlc3MoaHR0cFJlc3ApIHtcbiAgICAgICAgaHR0cFJlc3Aub24oJ3NlbmRQcm9ncmVzcycsIGZ1bmN0aW9uIG9uU2VuZFByb2dyZXNzKHZhbHVlKSB7XG4gICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBVcGxvYWRQcm9ncmVzcycsIFt2YWx1ZSwgcmVzcF0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBodHRwUmVzcC5vbigncmVjZWl2ZVByb2dyZXNzJywgZnVuY3Rpb24gb25SZWNlaXZlUHJvZ3Jlc3ModmFsdWUpIHtcbiAgICAgICAgICByZXNwLnJlcXVlc3QuZW1pdCgnaHR0cERvd25sb2FkUHJvZ3Jlc3MnLCBbdmFsdWUsIHJlc3BdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgIT09ICdSZXF1ZXN0QWJvcnRlZEVycm9yJykge1xuICAgICAgICAgIHZhciBlcnJDb2RlID0gZXJyLmNvZGUgPT09ICdUaW1lb3V0RXJyb3InID8gZXJyLmNvZGUgOiAnTmV0d29ya2luZ0Vycm9yJztcbiAgICAgICAgICBlcnIgPSBBV1MudXRpbC5lcnJvcihlcnIsIHtcbiAgICAgICAgICAgIGNvZGU6IGVyckNvZGUsXG4gICAgICAgICAgICByZWdpb246IHJlc3AucmVxdWVzdC5odHRwUmVxdWVzdC5yZWdpb24sXG4gICAgICAgICAgICBob3N0bmFtZTogcmVzcC5yZXF1ZXN0Lmh0dHBSZXF1ZXN0LmVuZHBvaW50Lmhvc3RuYW1lLFxuICAgICAgICAgICAgcmV0cnlhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzcC5lcnJvciA9IGVycjtcbiAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBFcnJvcicsIFtyZXNwLmVycm9yLCByZXNwXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZXhlY3V0ZVNlbmQoKSB7XG4gICAgICAgIHZhciBodHRwID0gQVdTLkh0dHBDbGllbnQuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdmFyIGh0dHBPcHRpb25zID0gcmVzcC5yZXF1ZXN0LnNlcnZpY2UuY29uZmlnLmh0dHBPcHRpb25zIHx8IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBzdHJlYW0gPSBodHRwLmhhbmRsZVJlcXVlc3QocmVzcC5yZXF1ZXN0Lmh0dHBSZXF1ZXN0LCBodHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLCBlcnJvcik7XG4gICAgICAgICAgcHJvZ3Jlc3Moc3RyZWFtKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHRpbWVEaWZmID0gKHJlc3AucmVxdWVzdC5zZXJ2aWNlLmdldFNrZXdDb3JyZWN0ZWREYXRlKCkgLSB0aGlzLnNpZ25lZEF0KSAvIDEwMDA7XG4gICAgICBpZiAodGltZURpZmYgPj0gNjAgKiAxMCkgeyAvLyBpZiB3ZSBzaWduZWQgMTBtaW4gYWdvLCByZS1zaWduXG4gICAgICAgIHRoaXMuZW1pdCgnc2lnbicsIFt0aGlzXSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgIGVsc2UgZXhlY3V0ZVNlbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGVjdXRlU2VuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdIVFRQX0hFQURFUlMnLCAnaHR0cEhlYWRlcnMnLFxuICAgICAgICBmdW5jdGlvbiBIVFRQX0hFQURFUlMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzcCwgc3RhdHVzTWVzc2FnZSkge1xuICAgICAgcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNNZXNzYWdlID0gc3RhdHVzTWVzc2FnZTtcbiAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgcmVzcC5odHRwUmVzcG9uc2UuYm9keSA9IEFXUy51dGlsLmJ1ZmZlci50b0J1ZmZlcignJyk7XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5idWZmZXJzID0gW107XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5udW1CeXRlcyA9IDA7XG4gICAgICB2YXIgZGF0ZUhlYWRlciA9IGhlYWRlcnMuZGF0ZSB8fCBoZWFkZXJzLkRhdGU7XG4gICAgICB2YXIgc2VydmljZSA9IHJlc3AucmVxdWVzdC5zZXJ2aWNlO1xuICAgICAgaWYgKGRhdGVIZWFkZXIpIHtcbiAgICAgICAgdmFyIHNlcnZlclRpbWUgPSBEYXRlLnBhcnNlKGRhdGVIZWFkZXIpO1xuICAgICAgICBpZiAoc2VydmljZS5jb25maWcuY29ycmVjdENsb2NrU2tld1xuICAgICAgICAgICAgJiYgc2VydmljZS5pc0Nsb2NrU2tld2VkKHNlcnZlclRpbWUpKSB7XG4gICAgICAgICAgc2VydmljZS5hcHBseUNsb2NrT2Zmc2V0KHNlcnZlclRpbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0hUVFBfREFUQScsICdodHRwRGF0YScsIGZ1bmN0aW9uIEhUVFBfREFUQShjaHVuaywgcmVzcCkge1xuICAgICAgaWYgKGNodW5rKSB7XG4gICAgICAgIGlmIChBV1MudXRpbC5pc05vZGUoKSkge1xuICAgICAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLm51bUJ5dGVzICs9IGNodW5rLmxlbmd0aDtcblxuICAgICAgICAgIHZhciB0b3RhbCA9IHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gICAgICAgICAgdmFyIHByb2dyZXNzID0geyBsb2FkZWQ6IHJlc3AuaHR0cFJlc3BvbnNlLm51bUJ5dGVzLCB0b3RhbDogdG90YWwgfTtcbiAgICAgICAgICByZXNwLnJlcXVlc3QuZW1pdCgnaHR0cERvd25sb2FkUHJvZ3Jlc3MnLCBbcHJvZ3Jlc3MsIHJlc3BdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLmJ1ZmZlcnMucHVzaChBV1MudXRpbC5idWZmZXIudG9CdWZmZXIoY2h1bmspKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnSFRUUF9ET05FJywgJ2h0dHBEb25lJywgZnVuY3Rpb24gSFRUUF9ET05FKHJlc3ApIHtcbiAgICAgIC8vIGNvbnZlcnQgYnVmZmVycyBhcnJheSBpbnRvIHNpbmdsZSBidWZmZXJcbiAgICAgIGlmIChyZXNwLmh0dHBSZXNwb25zZS5idWZmZXJzICYmIHJlc3AuaHR0cFJlc3BvbnNlLmJ1ZmZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgYm9keSA9IEFXUy51dGlsLmJ1ZmZlci5jb25jYXQocmVzcC5odHRwUmVzcG9uc2UuYnVmZmVycyk7XG4gICAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLmJvZHkgPSBib2R5O1xuICAgICAgfVxuICAgICAgZGVsZXRlIHJlc3AuaHR0cFJlc3BvbnNlLm51bUJ5dGVzO1xuICAgICAgZGVsZXRlIHJlc3AuaHR0cFJlc3BvbnNlLmJ1ZmZlcnM7XG4gICAgfSk7XG5cbiAgICBhZGQoJ0ZJTkFMSVpFX0VSUk9SJywgJ3JldHJ5JywgZnVuY3Rpb24gRklOQUxJWkVfRVJST1IocmVzcCkge1xuICAgICAgaWYgKHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgcmVzcC5lcnJvci5zdGF0dXNDb2RlID0gcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgaWYgKHJlc3AuZXJyb3IucmV0cnlhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXNwLmVycm9yLnJldHJ5YWJsZSA9IHRoaXMuc2VydmljZS5yZXRyeWFibGVFcnJvcihyZXNwLmVycm9yLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdJTlZBTElEQVRFX0NSRURFTlRJQUxTJywgJ3JldHJ5JywgZnVuY3Rpb24gSU5WQUxJREFURV9DUkVERU5USUFMUyhyZXNwKSB7XG4gICAgICBpZiAoIXJlc3AuZXJyb3IpIHJldHVybjtcbiAgICAgIHN3aXRjaCAocmVzcC5lcnJvci5jb2RlKSB7XG4gICAgICAgIGNhc2UgJ1JlcXVlc3RFeHBpcmVkJzogLy8gRUMyIG9ubHlcbiAgICAgICAgY2FzZSAnRXhwaXJlZFRva2VuRXhjZXB0aW9uJzpcbiAgICAgICAgY2FzZSAnRXhwaXJlZFRva2VuJzpcbiAgICAgICAgICByZXNwLmVycm9yLnJldHJ5YWJsZSA9IHRydWU7XG4gICAgICAgICAgcmVzcC5yZXF1ZXN0LnNlcnZpY2UuY29uZmlnLmNyZWRlbnRpYWxzLmV4cGlyZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdFWFBJUkVEX1NJR05BVFVSRScsICdyZXRyeScsIGZ1bmN0aW9uIEVYUElSRURfU0lHTkFUVVJFKHJlc3ApIHtcbiAgICAgIHZhciBlcnIgPSByZXNwLmVycm9yO1xuICAgICAgaWYgKCFlcnIpIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgZXJyLmNvZGUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlLm1hdGNoKC9TaWduYXR1cmUvKSAmJiBlcnIubWVzc2FnZS5tYXRjaCgvZXhwaXJlZC8pKSB7XG4gICAgICAgICAgcmVzcC5lcnJvci5yZXRyeWFibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0NMT0NLX1NLRVdFRCcsICdyZXRyeScsIGZ1bmN0aW9uIENMT0NLX1NLRVdFRChyZXNwKSB7XG4gICAgICBpZiAoIXJlc3AuZXJyb3IpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2UuY2xvY2tTa2V3RXJyb3IocmVzcC5lcnJvcilcbiAgICAgICAgICAmJiB0aGlzLnNlcnZpY2UuY29uZmlnLmNvcnJlY3RDbG9ja1NrZXcpIHtcbiAgICAgICAgcmVzcC5lcnJvci5yZXRyeWFibGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdSRURJUkVDVCcsICdyZXRyeScsIGZ1bmN0aW9uIFJFRElSRUNUKHJlc3ApIHtcbiAgICAgIGlmIChyZXNwLmVycm9yICYmIHJlc3AuZXJyb3Iuc3RhdHVzQ29kZSA+PSAzMDAgJiZcbiAgICAgICAgICByZXNwLmVycm9yLnN0YXR1c0NvZGUgPCA0MDAgJiYgcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVyc1snbG9jYXRpb24nXSkge1xuICAgICAgICB0aGlzLmh0dHBSZXF1ZXN0LmVuZHBvaW50ID1cbiAgICAgICAgICBuZXcgQVdTLkVuZHBvaW50KHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ2xvY2F0aW9uJ10pO1xuICAgICAgICB0aGlzLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0hvc3QnXSA9IHRoaXMuaHR0cFJlcXVlc3QuZW5kcG9pbnQuaG9zdDtcbiAgICAgICAgcmVzcC5lcnJvci5yZWRpcmVjdCA9IHRydWU7XG4gICAgICAgIHJlc3AuZXJyb3IucmV0cnlhYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnUkVUUllfQ0hFQ0snLCAncmV0cnknLCBmdW5jdGlvbiBSRVRSWV9DSEVDSyhyZXNwKSB7XG4gICAgICBpZiAocmVzcC5lcnJvcikge1xuICAgICAgICBpZiAocmVzcC5lcnJvci5yZWRpcmVjdCAmJiByZXNwLnJlZGlyZWN0Q291bnQgPCByZXNwLm1heFJlZGlyZWN0cykge1xuICAgICAgICAgIHJlc3AuZXJyb3IucmV0cnlEZWxheSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcC5yZXRyeUNvdW50IDwgcmVzcC5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgcmVzcC5lcnJvci5yZXRyeURlbGF5ID0gdGhpcy5zZXJ2aWNlLnJldHJ5RGVsYXlzKHJlc3AucmV0cnlDb3VudCwgcmVzcC5lcnJvcikgfHwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkQXN5bmMoJ1JFU0VUX1JFVFJZX1NUQVRFJywgJ2FmdGVyUmV0cnknLCBmdW5jdGlvbiBSRVNFVF9SRVRSWV9TVEFURShyZXNwLCBkb25lKSB7XG4gICAgICB2YXIgZGVsYXksIHdpbGxSZXRyeSA9IGZhbHNlO1xuXG4gICAgICBpZiAocmVzcC5lcnJvcikge1xuICAgICAgICBkZWxheSA9IHJlc3AuZXJyb3IucmV0cnlEZWxheSB8fCAwO1xuICAgICAgICBpZiAocmVzcC5lcnJvci5yZXRyeWFibGUgJiYgcmVzcC5yZXRyeUNvdW50IDwgcmVzcC5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgcmVzcC5yZXRyeUNvdW50Kys7XG4gICAgICAgICAgd2lsbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwLmVycm9yLnJlZGlyZWN0ICYmIHJlc3AucmVkaXJlY3RDb3VudCA8IHJlc3AubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgICAgcmVzcC5yZWRpcmVjdENvdW50Kys7XG4gICAgICAgICAgd2lsbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkZWxheSA8IDAgaXMgYSBzaWduYWwgZnJvbSBjdXN0b21CYWNrb2ZmIHRvIHNraXAgcmV0cmllc1xuICAgICAgaWYgKHdpbGxSZXRyeSAmJiBkZWxheSA+PSAwKSB7XG4gICAgICAgIHJlc3AuZXJyb3IgPSBudWxsO1xuICAgICAgICBzZXRUaW1lb3V0KGRvbmUsIGRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSksXG5cbiAgQ29yZVBvc3Q6IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICBhZGQoJ0VYVFJBQ1RfUkVRVUVTVF9JRCcsICdleHRyYWN0RGF0YScsIEFXUy51dGlsLmV4dHJhY3RSZXF1ZXN0SWQpO1xuICAgIGFkZCgnRVhUUkFDVF9SRVFVRVNUX0lEJywgJ2V4dHJhY3RFcnJvcicsIEFXUy51dGlsLmV4dHJhY3RSZXF1ZXN0SWQpO1xuXG4gICAgYWRkKCdFTk9URk9VTkRfRVJST1InLCAnaHR0cEVycm9yJywgZnVuY3Rpb24gRU5PVEZPVU5EX0VSUk9SKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnTmV0d29ya2luZ0Vycm9yJyAmJiBlcnIuZXJybm8gPT09ICdFTk9URk9VTkQnKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJ0luYWNjZXNzaWJsZSBob3N0OiBgJyArIGVyci5ob3N0bmFtZSArXG4gICAgICAgICAgJ1xcJy4gVGhpcyBzZXJ2aWNlIG1heSBub3QgYmUgYXZhaWxhYmxlIGluIHRoZSBgJyArIGVyci5yZWdpb24gK1xuICAgICAgICAgICdcXCcgcmVnaW9uLic7XG4gICAgICAgIHRoaXMucmVzcG9uc2UuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IobWVzc2FnZSksIHtcbiAgICAgICAgICBjb2RlOiAnVW5rbm93bkVuZHBvaW50JyxcbiAgICAgICAgICByZWdpb246IGVyci5yZWdpb24sXG4gICAgICAgICAgaG9zdG5hbWU6IGVyci5ob3N0bmFtZSxcbiAgICAgICAgICByZXRyeWFibGU6IHRydWUsXG4gICAgICAgICAgb3JpZ2luYWxFcnJvcjogZXJyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSxcblxuICBMb2dnZXI6IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICBhZGQoJ0xPR19SRVFVRVNUJywgJ2NvbXBsZXRlJywgZnVuY3Rpb24gTE9HX1JFUVVFU1QocmVzcCkge1xuICAgICAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgICAgIHZhciBsb2dnZXIgPSByZXEuc2VydmljZS5jb25maWcubG9nZ2VyO1xuICAgICAgaWYgKCFsb2dnZXIpIHJldHVybjtcbiAgICAgIGZ1bmN0aW9uIGZpbHRlclNlbnNpdGl2ZUxvZyhpbnB1dFNoYXBlLCBzaGFwZSkge1xuICAgICAgICBpZiAoIXNoYXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoaW5wdXRTaGFwZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnc3RydWN0dXJlJzpcbiAgICAgICAgICAgIHZhciBzdHJ1Y3QgPSB7fTtcbiAgICAgICAgICAgIEFXUy51dGlsLmVhY2goc2hhcGUsIGZ1bmN0aW9uKHN1YlNoYXBlTmFtZSwgc3ViU2hhcGUpIHtcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbnB1dFNoYXBlLm1lbWJlcnMsIHN1YlNoYXBlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBzdHJ1Y3Rbc3ViU2hhcGVOYW1lXSA9IGZpbHRlclNlbnNpdGl2ZUxvZyhpbnB1dFNoYXBlLm1lbWJlcnNbc3ViU2hhcGVOYW1lXSwgc3ViU2hhcGUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cnVjdFtzdWJTaGFwZU5hbWVdID0gc3ViU2hhcGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdDtcbiAgICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgICAgIHZhciBsaXN0ID0gW107XG4gICAgICAgICAgICBBV1MudXRpbC5hcnJheUVhY2goc2hhcGUsIGZ1bmN0aW9uKHN1YlNoYXBlLCBpbmRleCkge1xuICAgICAgICAgICAgICBsaXN0LnB1c2goZmlsdGVyU2Vuc2l0aXZlTG9nKGlucHV0U2hhcGUubWVtYmVyLCBzdWJTaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgICBjYXNlICdtYXAnOlxuICAgICAgICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgICAgICAgQVdTLnV0aWwuZWFjaChzaGFwZSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICBtYXBba2V5XSA9IGZpbHRlclNlbnNpdGl2ZUxvZyhpbnB1dFNoYXBlLnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChpbnB1dFNoYXBlLmlzU2Vuc2l0aXZlKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnKioqU2Vuc2l0aXZlSW5mb3JtYXRpb24qKionO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGJ1aWxkTWVzc2FnZSgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSByZXNwLnJlcXVlc3Quc2VydmljZS5nZXRTa2V3Q29ycmVjdGVkRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIGRlbHRhID0gKHRpbWUgLSByZXEuc3RhcnRUaW1lLmdldFRpbWUoKSkgLyAxMDAwO1xuICAgICAgICB2YXIgYW5zaSA9IGxvZ2dlci5pc1RUWSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgIHZhciBjZW5zb3JlZFBhcmFtcyA9IHJlcS5wYXJhbXM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICByZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucyAmJlxuICAgICAgICAgICAgICByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXSAmJlxuICAgICAgICAgICAgICByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5pbnB1dFxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgaW5wdXRTaGFwZSA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLmlucHV0O1xuICAgICAgICAgIGNlbnNvcmVkUGFyYW1zID0gZmlsdGVyU2Vuc2l0aXZlTG9nKGlucHV0U2hhcGUsIHJlcS5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJhbXMgPSByZXF1aXJlKCd1dGlsJykuaW5zcGVjdChjZW5zb3JlZFBhcmFtcywgdHJ1ZSwgbnVsbCk7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJyc7XG4gICAgICAgIGlmIChhbnNpKSBtZXNzYWdlICs9ICdcXHgxQlszM20nO1xuICAgICAgICBtZXNzYWdlICs9ICdbQVdTICcgKyByZXEuc2VydmljZS5zZXJ2aWNlSWRlbnRpZmllciArICcgJyArIHN0YXR1cztcbiAgICAgICAgbWVzc2FnZSArPSAnICcgKyBkZWx0YS50b1N0cmluZygpICsgJ3MgJyArIHJlc3AucmV0cnlDb3VudCArICcgcmV0cmllc10nO1xuICAgICAgICBpZiAoYW5zaSkgbWVzc2FnZSArPSAnXFx4MUJbMDsxbSc7XG4gICAgICAgIG1lc3NhZ2UgKz0gJyAnICsgQVdTLnV0aWwuc3RyaW5nLmxvd2VyRmlyc3QocmVxLm9wZXJhdGlvbik7XG4gICAgICAgIG1lc3NhZ2UgKz0gJygnICsgcGFyYW1zICsgJyknO1xuICAgICAgICBpZiAoYW5zaSkgbWVzc2FnZSArPSAnXFx4MUJbMG0nO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmUgPSBidWlsZE1lc3NhZ2UoKTtcbiAgICAgIGlmICh0eXBlb2YgbG9nZ2VyLmxvZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsb2dnZXIubG9nKGxpbmUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbG9nZ2VyLndyaXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxvZ2dlci53cml0ZShsaW5lICsgJ1xcbicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSxcblxuICBKc29uOiBuZXcgU2VxdWVudGlhbEV4ZWN1dG9yKCkuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAgdmFyIHN2YyA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvanNvbicpO1xuICAgIGFkZCgnQlVJTEQnLCAnYnVpbGQnLCBzdmMuYnVpbGRSZXF1ZXN0KTtcbiAgICBhZGQoJ0VYVFJBQ1RfREFUQScsICdleHRyYWN0RGF0YScsIHN2Yy5leHRyYWN0RGF0YSk7XG4gICAgYWRkKCdFWFRSQUNUX0VSUk9SJywgJ2V4dHJhY3RFcnJvcicsIHN2Yy5leHRyYWN0RXJyb3IpO1xuICB9KSxcblxuICBSZXN0OiBuZXcgU2VxdWVudGlhbEV4ZWN1dG9yKCkuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAgdmFyIHN2YyA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvcmVzdCcpO1xuICAgIGFkZCgnQlVJTEQnLCAnYnVpbGQnLCBzdmMuYnVpbGRSZXF1ZXN0KTtcbiAgICBhZGQoJ0VYVFJBQ1RfREFUQScsICdleHRyYWN0RGF0YScsIHN2Yy5leHRyYWN0RGF0YSk7XG4gICAgYWRkKCdFWFRSQUNUX0VSUk9SJywgJ2V4dHJhY3RFcnJvcicsIHN2Yy5leHRyYWN0RXJyb3IpO1xuICB9KSxcblxuICBSZXN0SnNvbjogbmV3IFNlcXVlbnRpYWxFeGVjdXRvcigpLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCkge1xuICAgIHZhciBzdmMgPSByZXF1aXJlKCcuL3Byb3RvY29sL3Jlc3RfanNvbicpO1xuICAgIGFkZCgnQlVJTEQnLCAnYnVpbGQnLCBzdmMuYnVpbGRSZXF1ZXN0KTtcbiAgICBhZGQoJ0VYVFJBQ1RfREFUQScsICdleHRyYWN0RGF0YScsIHN2Yy5leHRyYWN0RGF0YSk7XG4gICAgYWRkKCdFWFRSQUNUX0VSUk9SJywgJ2V4dHJhY3RFcnJvcicsIHN2Yy5leHRyYWN0RXJyb3IpO1xuICB9KSxcblxuICBSZXN0WG1sOiBuZXcgU2VxdWVudGlhbEV4ZWN1dG9yKCkuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAgdmFyIHN2YyA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvcmVzdF94bWwnKTtcbiAgICBhZGQoJ0JVSUxEJywgJ2J1aWxkJywgc3ZjLmJ1aWxkUmVxdWVzdCk7XG4gICAgYWRkKCdFWFRSQUNUX0RBVEEnLCAnZXh0cmFjdERhdGEnLCBzdmMuZXh0cmFjdERhdGEpO1xuICAgIGFkZCgnRVhUUkFDVF9FUlJPUicsICdleHRyYWN0RXJyb3InLCBzdmMuZXh0cmFjdEVycm9yKTtcbiAgfSksXG5cbiAgUXVlcnk6IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICB2YXIgc3ZjID0gcmVxdWlyZSgnLi9wcm90b2NvbC9xdWVyeScpO1xuICAgIGFkZCgnQlVJTEQnLCAnYnVpbGQnLCBzdmMuYnVpbGRSZXF1ZXN0KTtcbiAgICBhZGQoJ0VYVFJBQ1RfREFUQScsICdleHRyYWN0RGF0YScsIHN2Yy5leHRyYWN0RGF0YSk7XG4gICAgYWRkKCdFWFRSQUNUX0VSUk9SJywgJ2V4dHJhY3RFcnJvcicsIHN2Yy5leHRyYWN0RXJyb3IpO1xuICB9KVxufTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcblxuLyoqXG4gKiBUaGUgZW5kcG9pbnQgdGhhdCBhIHNlcnZpY2Ugd2lsbCB0YWxrIHRvLCBmb3IgZXhhbXBsZSxcbiAqIGAnaHR0cHM6Ly9lYzIuYXAtc291dGhlYXN0LTEuYW1hem9uYXdzLmNvbSdgLiBJZlxuICogeW91IG5lZWQgdG8gb3ZlcnJpZGUgYW4gZW5kcG9pbnQgZm9yIGEgc2VydmljZSwgeW91IGNhblxuICogc2V0IHRoZSBlbmRwb2ludCBvbiBhIHNlcnZpY2UgYnkgcGFzc2luZyB0aGUgZW5kcG9pbnRcbiAqIG9iamVjdCB3aXRoIHRoZSBgZW5kcG9pbnRgIG9wdGlvbiBrZXk6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGVwID0gbmV3IEFXUy5FbmRwb2ludCgnYXdzcHJveHkuZXhhbXBsZS5jb20nKTtcbiAqIHZhciBzMyA9IG5ldyBBV1MuUzMoe2VuZHBvaW50OiBlcH0pO1xuICogczMuc2VydmljZS5lbmRwb2ludC5ob3N0bmFtZSA9PSAnYXdzcHJveHkuZXhhbXBsZS5jb20nXG4gKiBgYGBcbiAqXG4gKiBOb3RlIHRoYXQgaWYgeW91IGRvIG5vdCBzcGVjaWZ5IGEgcHJvdG9jb2wsIHRoZSBwcm90b2NvbCB3aWxsXG4gKiBiZSBzZWxlY3RlZCBiYXNlZCBvbiB5b3VyIGN1cnJlbnQge0FXUy5jb25maWd9IGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQCFhdHRyaWJ1dGUgcHJvdG9jb2xcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgcHJvdG9jb2wgKGh0dHAgb3IgaHR0cHMpIG9mIHRoZSBlbmRwb2ludFxuICogICAgIFVSTFxuICogQCFhdHRyaWJ1dGUgaG9zdG5hbWVcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgaG9zdCBwb3J0aW9uIG9mIHRoZSBlbmRwb2ludCwgZS5nLixcbiAqICAgICBleGFtcGxlLmNvbVxuICogQCFhdHRyaWJ1dGUgaG9zdFxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBob3N0IHBvcnRpb24gb2YgdGhlIGVuZHBvaW50IGluY2x1ZGluZ1xuICogICAgIHRoZSBwb3J0LCBlLmcuLCBleGFtcGxlLmNvbTo4MFxuICogQCFhdHRyaWJ1dGUgcG9ydFxuICogICBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgcG9ydCBvZiB0aGUgZW5kcG9pbnRcbiAqIEAhYXR0cmlidXRlIGhyZWZcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgZnVsbCBVUkwgb2YgdGhlIGVuZHBvaW50XG4gKi9cbkFXUy5FbmRwb2ludCA9IGluaGVyaXQoe1xuXG4gIC8qKlxuICAgKiBAb3ZlcmxvYWQgRW5kcG9pbnQoZW5kcG9pbnQpXG4gICAqICAgQ29uc3RydWN0cyBhIG5ldyBlbmRwb2ludCBnaXZlbiBhbiBlbmRwb2ludCBVUkwuIElmIHRoZVxuICAgKiAgIFVSTCBvbWl0cyBhIHByb3RvY29sIChodHRwIG9yIGh0dHBzKSwgdGhlIGRlZmF1bHQgcHJvdG9jb2xcbiAgICogICBzZXQgaW4gdGhlIGdsb2JhbCB7QVdTLmNvbmZpZ30gd2lsbCBiZSB1c2VkLlxuICAgKiAgIEBwYXJhbSBlbmRwb2ludCBbU3RyaW5nXSB0aGUgVVJMIHRvIGNvbnN0cnVjdCBhbiBlbmRwb2ludCBmcm9tXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gRW5kcG9pbnQoZW5kcG9pbnQsIGNvbmZpZykge1xuICAgIEFXUy51dGlsLmhpZGVQcm9wZXJ0aWVzKHRoaXMsIFsnc2xhc2hlcycsICdhdXRoJywgJ2hhc2gnLCAnc2VhcmNoJywgJ3F1ZXJ5J10pO1xuXG4gICAgaWYgKHR5cGVvZiBlbmRwb2ludCA9PT0gJ3VuZGVmaW5lZCcgfHwgZW5kcG9pbnQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmRwb2ludDogJyArIGVuZHBvaW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmRwb2ludCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBBV1MudXRpbC5jb3B5KGVuZHBvaW50KTtcbiAgICB9XG5cbiAgICBpZiAoIWVuZHBvaW50Lm1hdGNoKC9eaHR0cC8pKSB7XG4gICAgICB2YXIgdXNlU1NMID0gY29uZmlnICYmIGNvbmZpZy5zc2xFbmFibGVkICE9PSB1bmRlZmluZWQgP1xuICAgICAgICBjb25maWcuc3NsRW5hYmxlZCA6IEFXUy5jb25maWcuc3NsRW5hYmxlZDtcbiAgICAgIGVuZHBvaW50ID0gKHVzZVNTTCA/ICdodHRwcycgOiAnaHR0cCcpICsgJzovLycgKyBlbmRwb2ludDtcbiAgICB9XG5cbiAgICBBV1MudXRpbC51cGRhdGUodGhpcywgQVdTLnV0aWwudXJsUGFyc2UoZW5kcG9pbnQpKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgcG9ydCBwcm9wZXJ0eSBpcyBzZXQgYXMgYW4gaW50ZWdlclxuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBhcnNlSW50KHRoaXMucG9ydCwgMTApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBvcnQgPSB0aGlzLnByb3RvY29sID09PSAnaHR0cHM6JyA/IDQ0MyA6IDgwO1xuICAgIH1cbiAgfVxuXG59KTtcblxuLyoqXG4gKiBUaGUgbG93IGxldmVsIEhUVFAgcmVxdWVzdCBvYmplY3QsIGVuY2Fwc3VsYXRpbmcgYWxsIEhUVFAgaGVhZGVyXG4gKiBhbmQgYm9keSBkYXRhIHNlbnQgYnkgYSBzZXJ2aWNlIHJlcXVlc3QuXG4gKlxuICogQCFhdHRyaWJ1dGUgbWV0aG9kXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIEhUVFAgbWV0aG9kIG9mIHRoZSByZXF1ZXN0XG4gKiBAIWF0dHJpYnV0ZSBwYXRoXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIHBhdGggcG9ydGlvbiBvZiB0aGUgVVJJLCBlLmcuLFxuICogICAgIFwiL2xpc3QvP3N0YXJ0PTUmbnVtPTEwXCJcbiAqIEAhYXR0cmlidXRlIGhlYWRlcnNcbiAqICAgQHJldHVybiBbbWFwPFN0cmluZyxTdHJpbmc+XVxuICogICAgIGEgbWFwIG9mIGhlYWRlciBrZXlzIGFuZCB0aGVpciByZXNwZWN0aXZlIHZhbHVlc1xuICogQCFhdHRyaWJ1dGUgYm9keVxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSByZXF1ZXN0IGJvZHkgcGF5bG9hZFxuICogQCFhdHRyaWJ1dGUgZW5kcG9pbnRcbiAqICAgQHJldHVybiBbQVdTLkVuZHBvaW50XSB0aGUgZW5kcG9pbnQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAIWF0dHJpYnV0ZSByZWdpb25cbiAqICAgQGFwaSBwcml2YXRlXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIHJlZ2lvbiwgZm9yIHNpZ25pbmcgcHVycG9zZXMgb25seS5cbiAqL1xuQVdTLkh0dHBSZXF1ZXN0ID0gaW5oZXJpdCh7XG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIEh0dHBSZXF1ZXN0KGVuZHBvaW50LCByZWdpb24pIHtcbiAgICBlbmRwb2ludCA9IG5ldyBBV1MuRW5kcG9pbnQoZW5kcG9pbnQpO1xuICAgIHRoaXMubWV0aG9kID0gJ1BPU1QnO1xuICAgIHRoaXMucGF0aCA9IGVuZHBvaW50LnBhdGggfHwgJy8nO1xuICAgIHRoaXMuaGVhZGVycyA9IHt9O1xuICAgIHRoaXMuYm9keSA9ICcnO1xuICAgIHRoaXMuZW5kcG9pbnQgPSBlbmRwb2ludDtcbiAgICB0aGlzLnJlZ2lvbiA9IHJlZ2lvbjtcbiAgICB0aGlzLl91c2VyQWdlbnQgPSAnJztcbiAgICB0aGlzLnNldFVzZXJBZ2VudCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNldFVzZXJBZ2VudDogZnVuY3Rpb24gc2V0VXNlckFnZW50KCkge1xuICAgIHRoaXMuX3VzZXJBZ2VudCA9IHRoaXMuaGVhZGVyc1t0aGlzLmdldFVzZXJBZ2VudEhlYWRlck5hbWUoKV0gPSBBV1MudXRpbC51c2VyQWdlbnQoKTtcbiAgfSxcblxuICBnZXRVc2VyQWdlbnRIZWFkZXJOYW1lOiBmdW5jdGlvbiBnZXRVc2VyQWdlbnRIZWFkZXJOYW1lKCkge1xuICAgIHZhciBwcmVmaXggPSBBV1MudXRpbC5pc0Jyb3dzZXIoKSA/ICdYLUFtei0nIDogJyc7XG4gICAgcmV0dXJuIHByZWZpeCArICdVc2VyLUFnZW50JztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhcHBlbmRUb1VzZXJBZ2VudDogZnVuY3Rpb24gYXBwZW5kVG9Vc2VyQWdlbnQoYWdlbnRQYXJ0aWFsKSB7XG4gICAgaWYgKHR5cGVvZiBhZ2VudFBhcnRpYWwgPT09ICdzdHJpbmcnICYmIGFnZW50UGFydGlhbCkge1xuICAgICAgdGhpcy5fdXNlckFnZW50ICs9ICcgJyArIGFnZW50UGFydGlhbDtcbiAgICB9XG4gICAgdGhpcy5oZWFkZXJzW3RoaXMuZ2V0VXNlckFnZW50SGVhZGVyTmFtZSgpXSA9IHRoaXMuX3VzZXJBZ2VudDtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRVc2VyQWdlbnQ6IGZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckFnZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtTdHJpbmddIHRoZSBwYXJ0IG9mIHRoZSB7cGF0aH0gZXhjbHVkaW5nIHRoZVxuICAgKiAgIHF1ZXJ5IHN0cmluZ1xuICAgKi9cbiAgcGF0aG5hbWU6IGZ1bmN0aW9uIHBhdGhuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnBhdGguc3BsaXQoJz8nLCAxKVswXTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiBbU3RyaW5nXSB0aGUgcXVlcnkgc3RyaW5nIHBvcnRpb24gb2YgdGhlIHtwYXRofVxuICAgKi9cbiAgc2VhcmNoOiBmdW5jdGlvbiBzZWFyY2goKSB7XG4gICAgdmFyIHF1ZXJ5ID0gdGhpcy5wYXRoLnNwbGl0KCc/JywgMilbMV07XG4gICAgaWYgKHF1ZXJ5KSB7XG4gICAgICBxdWVyeSA9IEFXUy51dGlsLnF1ZXJ5U3RyaW5nUGFyc2UocXVlcnkpO1xuICAgICAgcmV0dXJuIEFXUy51dGlsLnF1ZXJ5UGFyYW1zVG9TdHJpbmcocXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiB1cGRhdGUgaHR0cFJlcXVlc3QgZW5kcG9pbnQgd2l0aCBlbmRwb2ludCBzdHJpbmdcbiAgICovXG4gIHVwZGF0ZUVuZHBvaW50OiBmdW5jdGlvbiB1cGRhdGVFbmRwb2ludChlbmRwb2ludFN0cikge1xuICAgIHZhciBuZXdFbmRwb2ludCA9IG5ldyBBV1MuRW5kcG9pbnQoZW5kcG9pbnRTdHIpO1xuICAgIHRoaXMuZW5kcG9pbnQgPSBuZXdFbmRwb2ludDtcbiAgICB0aGlzLnBhdGggPSBuZXdFbmRwb2ludC5wYXRoIHx8ICcvJztcbiAgfVxufSk7XG5cbi8qKlxuICogVGhlIGxvdyBsZXZlbCBIVFRQIHJlc3BvbnNlIG9iamVjdCwgZW5jYXBzdWxhdGluZyBhbGwgSFRUUCBoZWFkZXJcbiAqIGFuZCBib2R5IGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBzdGF0dXNDb2RlXG4gKiAgIEByZXR1cm4gW0ludGVnZXJdIHRoZSBIVFRQIHN0YXR1cyBjb2RlIG9mIHRoZSByZXNwb25zZSAoZS5nLiwgMjAwLCA0MDQpXG4gKiBAIWF0dHJpYnV0ZSBoZWFkZXJzXG4gKiAgIEByZXR1cm4gW21hcDxTdHJpbmcsU3RyaW5nPl1cbiAqICAgICAgYSBtYXAgb2YgcmVzcG9uc2UgaGVhZGVyIGtleXMgYW5kIHRoZWlyIHJlc3BlY3RpdmUgdmFsdWVzXG4gKiBAIWF0dHJpYnV0ZSBib2R5XG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIHJlc3BvbnNlIGJvZHkgcGF5bG9hZFxuICogQCFhdHRyaWJ1dGUgW3JdIHN0cmVhbWluZ1xuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRoaXMgcmVzcG9uc2UgaXMgYmVpbmcgc3RyZWFtZWQgYXQgYSBsb3ctbGV2ZWwuXG4gKiAgICAgRGVmYXVsdHMgdG8gYGZhbHNlYCAoYnVmZmVyZWQgcmVhZHMpLiBEbyBub3QgbW9kaWZ5IHRoaXMgbWFudWFsbHksIHVzZVxuICogICAgIHtjcmVhdGVVbmJ1ZmZlcmVkU3RyZWFtfSB0byBjb252ZXJ0IHRoZSBzdHJlYW0gdG8gdW5idWZmZXJlZCBtb2RlXG4gKiAgICAgaW5zdGVhZC5cbiAqL1xuQVdTLkh0dHBSZXNwb25zZSA9IGluaGVyaXQoe1xuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBIdHRwUmVzcG9uc2UoKSB7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVhZGVycyA9IHt9O1xuICAgIHRoaXMuYm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0cmVhbWluZyA9IGZhbHNlO1xuICAgIHRoaXMuc3RyZWFtID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRGlzYWJsZXMgYnVmZmVyaW5nIG9uIHRoZSBIVFRQIHJlc3BvbnNlIGFuZCByZXR1cm5zIHRoZSBzdHJlYW0gZm9yIHJlYWRpbmcuXG4gICAqIEByZXR1cm4gW1N0cmVhbSwgWE1MSHR0cFJlcXVlc3QsIG51bGxdIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBvYmplY3QuXG4gICAqICAgVXNlIHRoaXMgb2JqZWN0IHRvIGRpcmVjdGx5IHJlYWQgZGF0YSBvZmYgb2YgdGhlIHN0cmVhbS5cbiAgICogQG5vdGUgVGhpcyBvYmplY3QgaXMgb25seSBhdmFpbGFibGUgYWZ0ZXIgdGhlIHtBV1MuUmVxdWVzdH5odHRwSGVhZGVyc31cbiAgICogICBldmVudCBoYXMgZmlyZWQuIFRoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIHByaW9yIHRvXG4gICAqICAge0FXUy5SZXF1ZXN0fmh0dHBEYXRhfS5cbiAgICogQGV4YW1wbGUgVGFraW5nIGNvbnRyb2wgb2YgYSBzdHJlYW1cbiAgICogICByZXF1ZXN0Lm9uKCdodHRwSGVhZGVycycsIGZ1bmN0aW9uKHN0YXR1c0NvZGUsIGhlYWRlcnMpIHtcbiAgICogICAgIGlmIChzdGF0dXNDb2RlIDwgMzAwKSB7XG4gICAqICAgICAgIGlmIChoZWFkZXJzLmV0YWcgPT09ICd4eXonKSB7XG4gICAqICAgICAgICAgLy8gcGlwZSB0aGUgc3RyZWFtLCBkaXNhYmxpbmcgYnVmZmVyaW5nXG4gICAqICAgICAgICAgdmFyIHN0cmVhbSA9IHRoaXMucmVzcG9uc2UuaHR0cFJlc3BvbnNlLmNyZWF0ZVVuYnVmZmVyZWRTdHJlYW0oKTtcbiAgICogICAgICAgICBzdHJlYW0ucGlwZShwcm9jZXNzLnN0ZG91dCk7XG4gICAqICAgICAgIH0gZWxzZSB7IC8vIGFib3J0IHRoaXMgcmVxdWVzdCBhbmQgc2V0IGEgYmV0dGVyIGVycm9yIG1lc3NhZ2VcbiAgICogICAgICAgICB0aGlzLmFib3J0KCk7XG4gICAqICAgICAgICAgdGhpcy5yZXNwb25zZS5lcnJvciA9IG5ldyBFcnJvcignSW52YWxpZCBFVGFnJyk7XG4gICAqICAgICAgIH1cbiAgICogICAgIH1cbiAgICogICB9KS5zZW5kKGNvbnNvbGUubG9nKTtcbiAgICovXG4gIGNyZWF0ZVVuYnVmZmVyZWRTdHJlYW06IGZ1bmN0aW9uIGNyZWF0ZVVuYnVmZmVyZWRTdHJlYW0oKSB7XG4gICAgdGhpcy5zdHJlYW1pbmcgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLnN0cmVhbTtcbiAgfVxufSk7XG5cblxuQVdTLkh0dHBDbGllbnQgPSBpbmhlcml0KHt9KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLkh0dHBDbGllbnQuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiBnZXRJbnN0YW5jZSgpIHtcbiAgaWYgKHRoaXMuc2luZ2xldG9uID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnNpbmdsZXRvbiA9IG5ldyB0aGlzKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuc2luZ2xldG9uO1xufTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xucmVxdWlyZSgnLi4vaHR0cCcpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuWEhSQ2xpZW50ID0gQVdTLnV0aWwuaW5oZXJpdCh7XG4gIGhhbmRsZVJlcXVlc3Q6IGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3QoaHR0cFJlcXVlc3QsIGh0dHBPcHRpb25zLCBjYWxsYmFjaywgZXJyQ2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVuZHBvaW50ID0gaHR0cFJlcXVlc3QuZW5kcG9pbnQ7XG4gICAgdmFyIGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgdmFyIGhyZWYgPSBlbmRwb2ludC5wcm90b2NvbCArICcvLycgKyBlbmRwb2ludC5ob3N0bmFtZTtcbiAgICBpZiAoZW5kcG9pbnQucG9ydCAhPT0gODAgJiYgZW5kcG9pbnQucG9ydCAhPT0gNDQzKSB7XG4gICAgICBocmVmICs9ICc6JyArIGVuZHBvaW50LnBvcnQ7XG4gICAgfVxuICAgIGhyZWYgKz0gaHR0cFJlcXVlc3QucGF0aDtcblxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSwgaGVhZGVyc0VtaXR0ZWQgPSBmYWxzZTtcbiAgICBodHRwUmVxdWVzdC5zdHJlYW0gPSB4aHI7XG5cbiAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcigncmVhZHlzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDApIHJldHVybjsgLy8gMCBjb2RlIGlzIGludmFsaWRcbiAgICAgIH0gY2F0Y2ggKGUpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPj0gdGhpcy5IRUFERVJTX1JFQ0VJVkVEICYmICFoZWFkZXJzRW1pdHRlZCkge1xuICAgICAgICBlbWl0dGVyLnN0YXR1c0NvZGUgPSB4aHIuc3RhdHVzO1xuICAgICAgICBlbWl0dGVyLmhlYWRlcnMgPSBzZWxmLnBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAgICAgICBlbWl0dGVyLmVtaXQoXG4gICAgICAgICAgJ2hlYWRlcnMnLFxuICAgICAgICAgIGVtaXR0ZXIuc3RhdHVzQ29kZSxcbiAgICAgICAgICBlbWl0dGVyLmhlYWRlcnMsXG4gICAgICAgICAgeGhyLnN0YXR1c1RleHRcbiAgICAgICAgKTtcbiAgICAgICAgaGVhZGVyc0VtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgIHNlbGYuZmluaXNoUmVxdWVzdCh4aHIsIGVtaXR0ZXIpO1xuICAgICAgfVxuICAgIH0sIGZhbHNlKTtcbiAgICB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgZW1pdHRlci5lbWl0KCdzZW5kUHJvZ3Jlc3MnLCBldnQpO1xuICAgIH0pO1xuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIGVtaXR0ZXIuZW1pdCgncmVjZWl2ZVByb2dyZXNzJywgZXZ0KTtcbiAgICB9LCBmYWxzZSk7XG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWVvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBlcnJDYWxsYmFjayhBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoJ1RpbWVvdXQnKSwge2NvZGU6ICdUaW1lb3V0RXJyb3InfSkpO1xuICAgIH0sIGZhbHNlKTtcbiAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICBlcnJDYWxsYmFjayhBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoJ05ldHdvcmsgRmFpbHVyZScpLCB7XG4gICAgICAgIGNvZGU6ICdOZXR3b3JraW5nRXJyb3InXG4gICAgICB9KSk7XG4gICAgfSwgZmFsc2UpO1xuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGVyckNhbGxiYWNrKEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcignUmVxdWVzdCBhYm9ydGVkJyksIHtcbiAgICAgICAgY29kZTogJ1JlcXVlc3RBYm9ydGVkRXJyb3InXG4gICAgICB9KSk7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgY2FsbGJhY2soZW1pdHRlcik7XG4gICAgeGhyLm9wZW4oaHR0cFJlcXVlc3QubWV0aG9kLCBocmVmLCBodHRwT3B0aW9ucy54aHJBc3luYyAhPT0gZmFsc2UpO1xuICAgIEFXUy51dGlsLmVhY2goaHR0cFJlcXVlc3QuaGVhZGVycywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgIT09ICdDb250ZW50LUxlbmd0aCcgJiYga2V5ICE9PSAnVXNlci1BZ2VudCcgJiYga2V5ICE9PSAnSG9zdCcpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoaHR0cE9wdGlvbnMudGltZW91dCAmJiBodHRwT3B0aW9ucy54aHJBc3luYyAhPT0gZmFsc2UpIHtcbiAgICAgIHhoci50aW1lb3V0ID0gaHR0cE9wdGlvbnMudGltZW91dDtcbiAgICB9XG5cbiAgICBpZiAoaHR0cE9wdGlvbnMueGhyV2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG4gICAgdHJ5IHsgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7IH0gY2F0Y2ggKGUpIHt9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKGh0dHBSZXF1ZXN0LmJvZHkpIHtcbiAgICAgICAgeGhyLnNlbmQoaHR0cFJlcXVlc3QuYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGh0dHBSZXF1ZXN0LmJvZHkgJiYgdHlwZW9mIGh0dHBSZXF1ZXN0LmJvZHkuYnVmZmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICB4aHIuc2VuZChodHRwUmVxdWVzdC5ib2R5LmJ1ZmZlcik7IC8vIHNlbmQgQXJyYXlCdWZmZXIgZGlyZWN0bHlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZW1pdHRlcjtcbiAgfSxcblxuICBwYXJzZUhlYWRlcnM6IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgICBBV1MudXRpbC5hcnJheUVhY2gocmF3SGVhZGVycy5zcGxpdCgvXFxyP1xcbi8pLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgdmFyIGtleSA9IGxpbmUuc3BsaXQoJzonLCAxKVswXTtcbiAgICAgIHZhciB2YWx1ZSA9IGxpbmUuc3Vic3RyaW5nKGtleS5sZW5ndGggKyAyKTtcbiAgICAgIGlmIChrZXkubGVuZ3RoID4gMCkgaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfSxcblxuICBmaW5pc2hSZXF1ZXN0OiBmdW5jdGlvbiBmaW5pc2hSZXF1ZXN0KHhociwgZW1pdHRlcikge1xuICAgIHZhciBidWZmZXI7XG4gICAgaWYgKHhoci5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcicgJiYgeGhyLnJlc3BvbnNlKSB7XG4gICAgICB2YXIgYWIgPSB4aHIucmVzcG9uc2U7XG4gICAgICBidWZmZXIgPSBuZXcgQVdTLnV0aWwuQnVmZmVyKGFiLmJ5dGVMZW5ndGgpO1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7ICsraSkge1xuICAgICAgICBidWZmZXJbaV0gPSB2aWV3W2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAoIWJ1ZmZlciAmJiB0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYnVmZmVyID0gbmV3IEFXUy51dGlsLkJ1ZmZlcih4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgaWYgKGJ1ZmZlcikgZW1pdHRlci5lbWl0KCdkYXRhJywgYnVmZmVyKTtcbiAgICBlbWl0dGVyLmVtaXQoJ2VuZCcpO1xuICB9XG59KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLkh0dHBDbGllbnQucHJvdG90eXBlID0gQVdTLlhIUkNsaWVudC5wcm90b3R5cGU7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5IdHRwQ2xpZW50LnN0cmVhbXNBcGlWZXJzaW9uID0gMTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5mdW5jdGlvbiBKc29uQnVpbGRlcigpIHsgfVxuXG5Kc29uQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbih2YWx1ZSwgc2hhcGUpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUpKTtcbn07XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUpIHtcbiAgaWYgKCFzaGFwZSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIHN3aXRjaCAoc2hhcGUudHlwZSkge1xuICAgIGNhc2UgJ3N0cnVjdHVyZSc6IHJldHVybiB0cmFuc2xhdGVTdHJ1Y3R1cmUodmFsdWUsIHNoYXBlKTtcbiAgICBjYXNlICdtYXAnOiByZXR1cm4gdHJhbnNsYXRlTWFwKHZhbHVlLCBzaGFwZSk7XG4gICAgY2FzZSAnbGlzdCc6IHJldHVybiB0cmFuc2xhdGVMaXN0KHZhbHVlLCBzaGFwZSk7XG4gICAgZGVmYXVsdDogcmV0dXJuIHRyYW5zbGF0ZVNjYWxhcih2YWx1ZSwgc2hhcGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVN0cnVjdHVyZShzdHJ1Y3R1cmUsIHNoYXBlKSB7XG4gIHZhciBzdHJ1Y3QgPSB7fTtcbiAgdXRpbC5lYWNoKHN0cnVjdHVyZSwgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgbWVtYmVyU2hhcGUgPSBzaGFwZS5tZW1iZXJzW25hbWVdO1xuICAgIGlmIChtZW1iZXJTaGFwZSkge1xuICAgICAgaWYgKG1lbWJlclNoYXBlLmxvY2F0aW9uICE9PSAnYm9keScpIHJldHVybjtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBtZW1iZXJTaGFwZS5pc0xvY2F0aW9uTmFtZSA/IG1lbWJlclNoYXBlLm5hbWUgOiBuYW1lO1xuICAgICAgdmFyIHJlc3VsdCA9IHRyYW5zbGF0ZSh2YWx1ZSwgbWVtYmVyU2hhcGUpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSBzdHJ1Y3RbbG9jYXRpb25OYW1lXSA9IHJlc3VsdDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc3RydWN0O1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVMaXN0KGxpc3QsIHNoYXBlKSB7XG4gIHZhciBvdXQgPSBbXTtcbiAgdXRpbC5hcnJheUVhY2gobGlzdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNsYXRlKHZhbHVlLCBzaGFwZS5tZW1iZXIpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkgb3V0LnB1c2gocmVzdWx0KTtcbiAgfSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZU1hcChtYXAsIHNoYXBlKSB7XG4gIHZhciBvdXQgPSB7fTtcbiAgdXRpbC5lYWNoKG1hcCwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB0cmFuc2xhdGUodmFsdWUsIHNoYXBlLnZhbHVlKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIG91dFtrZXldID0gcmVzdWx0O1xuICB9KTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlU2NhbGFyKHZhbHVlLCBzaGFwZSkge1xuICByZXR1cm4gc2hhcGUudG9XaXJlRm9ybWF0KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBKc29uQnVpbGRlcjtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5mdW5jdGlvbiBKc29uUGFyc2VyKCkgeyB9XG5cbkpzb25QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odmFsdWUsIHNoYXBlKSB7XG4gIHJldHVybiB0cmFuc2xhdGUoSlNPTi5wYXJzZSh2YWx1ZSksIHNoYXBlKTtcbn07XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUpIHtcbiAgaWYgKCFzaGFwZSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIHN3aXRjaCAoc2hhcGUudHlwZSkge1xuICAgIGNhc2UgJ3N0cnVjdHVyZSc6IHJldHVybiB0cmFuc2xhdGVTdHJ1Y3R1cmUodmFsdWUsIHNoYXBlKTtcbiAgICBjYXNlICdtYXAnOiByZXR1cm4gdHJhbnNsYXRlTWFwKHZhbHVlLCBzaGFwZSk7XG4gICAgY2FzZSAnbGlzdCc6IHJldHVybiB0cmFuc2xhdGVMaXN0KHZhbHVlLCBzaGFwZSk7XG4gICAgZGVmYXVsdDogcmV0dXJuIHRyYW5zbGF0ZVNjYWxhcih2YWx1ZSwgc2hhcGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVN0cnVjdHVyZShzdHJ1Y3R1cmUsIHNoYXBlKSB7XG4gIGlmIChzdHJ1Y3R1cmUgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICB2YXIgc3RydWN0ID0ge307XG4gIHZhciBzaGFwZU1lbWJlcnMgPSBzaGFwZS5tZW1iZXJzO1xuICB1dGlsLmVhY2goc2hhcGVNZW1iZXJzLCBmdW5jdGlvbihuYW1lLCBtZW1iZXJTaGFwZSkge1xuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBtZW1iZXJTaGFwZS5pc0xvY2F0aW9uTmFtZSA/IG1lbWJlclNoYXBlLm5hbWUgOiBuYW1lO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RydWN0dXJlLCBsb2NhdGlvbk5hbWUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdHJ1Y3R1cmVbbG9jYXRpb25OYW1lXTtcbiAgICAgIHZhciByZXN1bHQgPSB0cmFuc2xhdGUodmFsdWUsIG1lbWJlclNoYXBlKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkgc3RydWN0W25hbWVdID0gcmVzdWx0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzdHJ1Y3Q7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZUxpc3QobGlzdCwgc2hhcGUpIHtcbiAgaWYgKGxpc3QgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICB2YXIgb3V0ID0gW107XG4gIHV0aWwuYXJyYXlFYWNoKGxpc3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUubWVtYmVyKTtcbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIG91dC5wdXNoKG51bGwpO1xuICAgIGVsc2Ugb3V0LnB1c2gocmVzdWx0KTtcbiAgfSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZU1hcChtYXAsIHNoYXBlKSB7XG4gIGlmIChtYXAgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICB2YXIgb3V0ID0ge307XG4gIHV0aWwuZWFjaChtYXAsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNsYXRlKHZhbHVlLCBzaGFwZS52YWx1ZSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSBvdXRba2V5XSA9IG51bGw7XG4gICAgZWxzZSBvdXRba2V5XSA9IHJlc3VsdDtcbiAgfSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVNjYWxhcih2YWx1ZSwgc2hhcGUpIHtcbiAgcmV0dXJuIHNoYXBlLnRvVHlwZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gSnNvblBhcnNlcjtcbiIsInZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9uJyk7XG52YXIgT3BlcmF0aW9uID0gcmVxdWlyZSgnLi9vcGVyYXRpb24nKTtcbnZhciBTaGFwZSA9IHJlcXVpcmUoJy4vc2hhcGUnKTtcbnZhciBQYWdpbmF0b3IgPSByZXF1aXJlKCcuL3BhZ2luYXRvcicpO1xudmFyIFJlc291cmNlV2FpdGVyID0gcmVxdWlyZSgnLi9yZXNvdXJjZV93YWl0ZXInKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgcHJvcGVydHkgPSB1dGlsLnByb3BlcnR5O1xudmFyIG1lbW9pemVkUHJvcGVydHkgPSB1dGlsLm1lbW9pemVkUHJvcGVydHk7XG5cbmZ1bmN0aW9uIEFwaShhcGksIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBhcGkgPSBhcGkgfHwge307XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmFwaSA9IHRoaXM7XG5cbiAgYXBpLm1ldGFkYXRhID0gYXBpLm1ldGFkYXRhIHx8IHt9O1xuXG4gIHByb3BlcnR5KHRoaXMsICdpc0FwaScsIHRydWUsIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2FwaVZlcnNpb24nLCBhcGkubWV0YWRhdGEuYXBpVmVyc2lvbik7XG4gIHByb3BlcnR5KHRoaXMsICdlbmRwb2ludFByZWZpeCcsIGFwaS5tZXRhZGF0YS5lbmRwb2ludFByZWZpeCk7XG4gIHByb3BlcnR5KHRoaXMsICdzaWduaW5nTmFtZScsIGFwaS5tZXRhZGF0YS5zaWduaW5nTmFtZSk7XG4gIHByb3BlcnR5KHRoaXMsICdnbG9iYWxFbmRwb2ludCcsIGFwaS5tZXRhZGF0YS5nbG9iYWxFbmRwb2ludCk7XG4gIHByb3BlcnR5KHRoaXMsICdzaWduYXR1cmVWZXJzaW9uJywgYXBpLm1ldGFkYXRhLnNpZ25hdHVyZVZlcnNpb24pO1xuICBwcm9wZXJ0eSh0aGlzLCAnanNvblZlcnNpb24nLCBhcGkubWV0YWRhdGEuanNvblZlcnNpb24pO1xuICBwcm9wZXJ0eSh0aGlzLCAndGFyZ2V0UHJlZml4JywgYXBpLm1ldGFkYXRhLnRhcmdldFByZWZpeCk7XG4gIHByb3BlcnR5KHRoaXMsICdwcm90b2NvbCcsIGFwaS5tZXRhZGF0YS5wcm90b2NvbCk7XG4gIHByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBGb3JtYXQnLCBhcGkubWV0YWRhdGEudGltZXN0YW1wRm9ybWF0KTtcbiAgcHJvcGVydHkodGhpcywgJ3htbE5hbWVzcGFjZVVyaScsIGFwaS5tZXRhZGF0YS54bWxOYW1lc3BhY2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnYWJicmV2aWF0aW9uJywgYXBpLm1ldGFkYXRhLnNlcnZpY2VBYmJyZXZpYXRpb24pO1xuICBwcm9wZXJ0eSh0aGlzLCAnZnVsbE5hbWUnLCBhcGkubWV0YWRhdGEuc2VydmljZUZ1bGxOYW1lKTtcbiAgcHJvcGVydHkodGhpcywgJ3NlcnZpY2VJZCcsIGFwaS5tZXRhZGF0YS5zZXJ2aWNlSWQpO1xuXG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ2NsYXNzTmFtZScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBuYW1lID0gYXBpLm1ldGFkYXRhLnNlcnZpY2VBYmJyZXZpYXRpb24gfHwgYXBpLm1ldGFkYXRhLnNlcnZpY2VGdWxsTmFtZTtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBudWxsO1xuXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXkFtYXpvbnxBV1NcXHMqfFxcKC4qfFxccyt8XFxXKy9nLCAnJyk7XG4gICAgaWYgKG5hbWUgPT09ICdFbGFzdGljTG9hZEJhbGFuY2luZycpIG5hbWUgPSAnRUxCJztcbiAgICByZXR1cm4gbmFtZTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYWRkRW5kcG9pbnRPcGVyYXRpb24obmFtZSwgb3BlcmF0aW9uKSB7XG4gICAgaWYgKG9wZXJhdGlvbi5lbmRwb2ludG9wZXJhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgcHJvcGVydHkoc2VsZiwgJ2VuZHBvaW50T3BlcmF0aW9uJywgdXRpbC5zdHJpbmcubG93ZXJGaXJzdChuYW1lKSk7XG4gICAgfVxuICB9XG5cbiAgcHJvcGVydHkodGhpcywgJ29wZXJhdGlvbnMnLCBuZXcgQ29sbGVjdGlvbihhcGkub3BlcmF0aW9ucywgb3B0aW9ucywgZnVuY3Rpb24obmFtZSwgb3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBPcGVyYXRpb24obmFtZSwgb3BlcmF0aW9uLCBvcHRpb25zKTtcbiAgfSwgdXRpbC5zdHJpbmcubG93ZXJGaXJzdCwgYWRkRW5kcG9pbnRPcGVyYXRpb24pKTtcblxuICBwcm9wZXJ0eSh0aGlzLCAnc2hhcGVzJywgbmV3IENvbGxlY3Rpb24oYXBpLnNoYXBlcywgb3B0aW9ucywgZnVuY3Rpb24obmFtZSwgc2hhcGUpIHtcbiAgICByZXR1cm4gU2hhcGUuY3JlYXRlKHNoYXBlLCBvcHRpb25zKTtcbiAgfSkpO1xuXG4gIHByb3BlcnR5KHRoaXMsICdwYWdpbmF0b3JzJywgbmV3IENvbGxlY3Rpb24oYXBpLnBhZ2luYXRvcnMsIG9wdGlvbnMsIGZ1bmN0aW9uKG5hbWUsIHBhZ2luYXRvcikge1xuICAgIHJldHVybiBuZXcgUGFnaW5hdG9yKG5hbWUsIHBhZ2luYXRvciwgb3B0aW9ucyk7XG4gIH0pKTtcblxuICBwcm9wZXJ0eSh0aGlzLCAnd2FpdGVycycsIG5ldyBDb2xsZWN0aW9uKGFwaS53YWl0ZXJzLCBvcHRpb25zLCBmdW5jdGlvbihuYW1lLCB3YWl0ZXIpIHtcbiAgICByZXR1cm4gbmV3IFJlc291cmNlV2FpdGVyKG5hbWUsIHdhaXRlciwgb3B0aW9ucyk7XG4gIH0sIHV0aWwuc3RyaW5nLmxvd2VyRmlyc3QpKTtcblxuICBpZiAob3B0aW9ucy5kb2N1bWVudGF0aW9uKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ2RvY3VtZW50YXRpb24nLCBhcGkuZG9jdW1lbnRhdGlvbik7XG4gICAgcHJvcGVydHkodGhpcywgJ2RvY3VtZW50YXRpb25VcmwnLCBhcGkuZG9jdW1lbnRhdGlvblVybCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBcGk7XG4iLCJ2YXIgbWVtb2l6ZWRQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL3V0aWwnKS5tZW1vaXplZFByb3BlcnR5O1xuXG5mdW5jdGlvbiBtZW1vaXplKG5hbWUsIHZhbHVlLCBmYWN0b3J5LCBuYW1lVHIpIHtcbiAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCBuYW1lVHIobmFtZSksIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmYWN0b3J5KG5hbWUsIHZhbHVlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIENvbGxlY3Rpb24oaXRlcmFibGUsIG9wdGlvbnMsIGZhY3RvcnksIG5hbWVUciwgY2FsbGJhY2spIHtcbiAgbmFtZVRyID0gbmFtZVRyIHx8IFN0cmluZztcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZvciAodmFyIGlkIGluIGl0ZXJhYmxlKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpdGVyYWJsZSwgaWQpKSB7XG4gICAgICBtZW1vaXplLmNhbGwoc2VsZiwgaWQsIGl0ZXJhYmxlW2lkXSwgZmFjdG9yeSwgbmFtZVRyKTtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soaWQsIGl0ZXJhYmxlW2lkXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbjtcbiIsInZhciBTaGFwZSA9IHJlcXVpcmUoJy4vc2hhcGUnKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgcHJvcGVydHkgPSB1dGlsLnByb3BlcnR5O1xudmFyIG1lbW9pemVkUHJvcGVydHkgPSB1dGlsLm1lbW9pemVkUHJvcGVydHk7XG5cbmZ1bmN0aW9uIE9wZXJhdGlvbihuYW1lLCBvcGVyYXRpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBwcm9wZXJ0eSh0aGlzLCAnbmFtZScsIG9wZXJhdGlvbi5uYW1lIHx8IG5hbWUpO1xuICBwcm9wZXJ0eSh0aGlzLCAnYXBpJywgb3B0aW9ucy5hcGksIGZhbHNlKTtcblxuICBvcGVyYXRpb24uaHR0cCA9IG9wZXJhdGlvbi5odHRwIHx8IHt9O1xuICBwcm9wZXJ0eSh0aGlzLCAnZW5kcG9pbnQnLCBvcGVyYXRpb24uZW5kcG9pbnQpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaHR0cE1ldGhvZCcsIG9wZXJhdGlvbi5odHRwLm1ldGhvZCB8fCAnUE9TVCcpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaHR0cFBhdGgnLCBvcGVyYXRpb24uaHR0cC5yZXF1ZXN0VXJpIHx8ICcvJyk7XG4gIHByb3BlcnR5KHRoaXMsICdhdXRodHlwZScsIG9wZXJhdGlvbi5hdXRodHlwZSB8fCAnJyk7XG4gIHByb3BlcnR5KFxuICAgIHRoaXMsXG4gICAgJ2VuZHBvaW50RGlzY292ZXJ5UmVxdWlyZWQnLFxuICAgIG9wZXJhdGlvbi5lbmRwb2ludGRpc2NvdmVyeSA/XG4gICAgICAob3BlcmF0aW9uLmVuZHBvaW50ZGlzY292ZXJ5LnJlcXVpcmVkID8gJ1JFUVVJUkVEJyA6ICdPUFRJT05BTCcpIDpcbiAgICAnTlVMTCdcbiAgKTtcblxuICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdpbnB1dCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmICghb3BlcmF0aW9uLmlucHV0KSB7XG4gICAgICByZXR1cm4gbmV3IFNoYXBlLmNyZWF0ZSh7dHlwZTogJ3N0cnVjdHVyZSd9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIFNoYXBlLmNyZWF0ZShvcGVyYXRpb24uaW5wdXQsIG9wdGlvbnMpO1xuICB9KTtcblxuICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdvdXRwdXQnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoIW9wZXJhdGlvbi5vdXRwdXQpIHtcbiAgICAgIHJldHVybiBuZXcgU2hhcGUuY3JlYXRlKHt0eXBlOiAnc3RydWN0dXJlJ30sIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gU2hhcGUuY3JlYXRlKG9wZXJhdGlvbi5vdXRwdXQsIG9wdGlvbnMpO1xuICB9KTtcblxuICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdlcnJvcnMnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGlzdCA9IFtdO1xuICAgIGlmICghb3BlcmF0aW9uLmVycm9ycykgcmV0dXJuIG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wZXJhdGlvbi5lcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3QucHVzaChTaGFwZS5jcmVhdGUob3BlcmF0aW9uLmVycm9yc1tpXSwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9KTtcblxuICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdwYWdpbmF0b3InLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5hcGkucGFnaW5hdG9yc1tuYW1lXTtcbiAgfSk7XG5cbiAgaWYgKG9wdGlvbnMuZG9jdW1lbnRhdGlvbikge1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uJywgb3BlcmF0aW9uLmRvY3VtZW50YXRpb24pO1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uVXJsJywgb3BlcmF0aW9uLmRvY3VtZW50YXRpb25VcmwpO1xuICB9XG5cbiAgLy8gaWRlbXBvdGVudE1lbWJlcnMgb25seSB0cmFja3MgdG9wLWxldmVsIGlucHV0IHNoYXBlc1xuICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdpZGVtcG90ZW50TWVtYmVycycsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZGVtcG90ZW50TWVtYmVycyA9IFtdO1xuICAgIHZhciBpbnB1dCA9IHNlbGYuaW5wdXQ7XG4gICAgdmFyIG1lbWJlcnMgPSBpbnB1dC5tZW1iZXJzO1xuICAgIGlmICghaW5wdXQubWVtYmVycykge1xuICAgICAgcmV0dXJuIGlkZW1wb3RlbnRNZW1iZXJzO1xuICAgIH1cbiAgICBmb3IgKHZhciBuYW1lIGluIG1lbWJlcnMpIHtcbiAgICAgIGlmICghbWVtYmVycy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtZW1iZXJzW25hbWVdLmlzSWRlbXBvdGVudCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZGVtcG90ZW50TWVtYmVycy5wdXNoKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWRlbXBvdGVudE1lbWJlcnM7XG4gIH0pO1xuXG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ2hhc0V2ZW50T3V0cHV0JywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dHB1dCA9IHNlbGYub3V0cHV0O1xuICAgIHJldHVybiBoYXNFdmVudFN0cmVhbShvdXRwdXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFzRXZlbnRTdHJlYW0odG9wTGV2ZWxTaGFwZSkge1xuICB2YXIgbWVtYmVycyA9IHRvcExldmVsU2hhcGUubWVtYmVycztcbiAgdmFyIHBheWxvYWQgPSB0b3BMZXZlbFNoYXBlLnBheWxvYWQ7XG5cbiAgaWYgKCF0b3BMZXZlbFNoYXBlLm1lbWJlcnMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocGF5bG9hZCkge1xuICAgIHZhciBwYXlsb2FkTWVtYmVyID0gbWVtYmVyc1twYXlsb2FkXTtcbiAgICByZXR1cm4gcGF5bG9hZE1lbWJlci5pc0V2ZW50U3RyZWFtO1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgYW55IG1lbWJlciBpcyBhbiBldmVudCBzdHJlYW1cbiAgZm9yICh2YXIgbmFtZSBpbiBtZW1iZXJzKSB7XG4gICAgaWYgKCFtZW1iZXJzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBpZiAobWVtYmVyc1tuYW1lXS5pc0V2ZW50U3RyZWFtID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gT3BlcmF0aW9uO1xuIiwidmFyIHByb3BlcnR5ID0gcmVxdWlyZSgnLi4vdXRpbCcpLnByb3BlcnR5O1xuXG5mdW5jdGlvbiBQYWdpbmF0b3IobmFtZSwgcGFnaW5hdG9yKSB7XG4gIHByb3BlcnR5KHRoaXMsICdpbnB1dFRva2VuJywgcGFnaW5hdG9yLmlucHV0X3Rva2VuKTtcbiAgcHJvcGVydHkodGhpcywgJ2xpbWl0S2V5JywgcGFnaW5hdG9yLmxpbWl0X2tleSk7XG4gIHByb3BlcnR5KHRoaXMsICdtb3JlUmVzdWx0cycsIHBhZ2luYXRvci5tb3JlX3Jlc3VsdHMpO1xuICBwcm9wZXJ0eSh0aGlzLCAnb3V0cHV0VG9rZW4nLCBwYWdpbmF0b3Iub3V0cHV0X3Rva2VuKTtcbiAgcHJvcGVydHkodGhpcywgJ3Jlc3VsdEtleScsIHBhZ2luYXRvci5yZXN1bHRfa2V5KTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBQYWdpbmF0b3I7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBwcm9wZXJ0eSA9IHV0aWwucHJvcGVydHk7XG5cbmZ1bmN0aW9uIFJlc291cmNlV2FpdGVyKG5hbWUsIHdhaXRlciwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgcHJvcGVydHkodGhpcywgJ25hbWUnLCBuYW1lKTtcbiAgcHJvcGVydHkodGhpcywgJ2FwaScsIG9wdGlvbnMuYXBpLCBmYWxzZSk7XG5cbiAgaWYgKHdhaXRlci5vcGVyYXRpb24pIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnb3BlcmF0aW9uJywgdXRpbC5zdHJpbmcubG93ZXJGaXJzdCh3YWl0ZXIub3BlcmF0aW9uKSk7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBrZXlzID0gW1xuICAgICd0eXBlJyxcbiAgICAnZGVzY3JpcHRpb24nLFxuICAgICdkZWxheScsXG4gICAgJ21heEF0dGVtcHRzJyxcbiAgICAnYWNjZXB0b3JzJ1xuICBdO1xuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSB3YWl0ZXJba2V5XTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHByb3BlcnR5KHNlbGYsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVzb3VyY2VXYWl0ZXI7XG4iLCJ2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbicpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuZnVuY3Rpb24gcHJvcGVydHkob2JqLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHV0aWwucHJvcGVydHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtZW1vaXplZFByb3BlcnR5KG9iaiwgbmFtZSkge1xuICBpZiAoIW9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGVbbmFtZV0pIHtcbiAgICB1dGlsLm1lbW9pemVkUHJvcGVydHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBTaGFwZShzaGFwZSwgb3B0aW9ucywgbWVtYmVyTmFtZSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBwcm9wZXJ0eSh0aGlzLCAnc2hhcGUnLCBzaGFwZS5zaGFwZSk7XG4gIHByb3BlcnR5KHRoaXMsICdhcGknLCBvcHRpb25zLmFwaSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAndHlwZScsIHNoYXBlLnR5cGUpO1xuICBwcm9wZXJ0eSh0aGlzLCAnZW51bScsIHNoYXBlLmVudW0pO1xuICBwcm9wZXJ0eSh0aGlzLCAnbWluJywgc2hhcGUubWluKTtcbiAgcHJvcGVydHkodGhpcywgJ21heCcsIHNoYXBlLm1heCk7XG4gIHByb3BlcnR5KHRoaXMsICdwYXR0ZXJuJywgc2hhcGUucGF0dGVybik7XG4gIHByb3BlcnR5KHRoaXMsICdsb2NhdGlvbicsIHNoYXBlLmxvY2F0aW9uIHx8IHRoaXMubG9jYXRpb24gfHwgJ2JvZHknKTtcbiAgcHJvcGVydHkodGhpcywgJ25hbWUnLCB0aGlzLm5hbWUgfHwgc2hhcGUueG1sTmFtZSB8fCBzaGFwZS5xdWVyeU5hbWUgfHxcbiAgICBzaGFwZS5sb2NhdGlvbk5hbWUgfHwgbWVtYmVyTmFtZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc1N0cmVhbWluZycsIHNoYXBlLnN0cmVhbWluZyB8fCB0aGlzLmlzU3RyZWFtaW5nIHx8IGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ3JlcXVpcmVzTGVuZ3RoJywgc2hhcGUucmVxdWlyZXNMZW5ndGgsIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzQ29tcG9zaXRlJywgc2hhcGUuaXNDb21wb3NpdGUgfHwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNTaGFwZScsIHRydWUsIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzUXVlcnlOYW1lJywgQm9vbGVhbihzaGFwZS5xdWVyeU5hbWUpLCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc0xvY2F0aW9uTmFtZScsIEJvb2xlYW4oc2hhcGUubG9jYXRpb25OYW1lKSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNJZGVtcG90ZW50Jywgc2hhcGUuaWRlbXBvdGVuY3lUb2tlbiA9PT0gdHJ1ZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc0pzb25WYWx1ZScsIHNoYXBlLmpzb252YWx1ZSA9PT0gdHJ1ZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc1NlbnNpdGl2ZScsIHNoYXBlLnNlbnNpdGl2ZSA9PT0gdHJ1ZSB8fCBzaGFwZS5wcm90b3R5cGUgJiYgc2hhcGUucHJvdG90eXBlLnNlbnNpdGl2ZSA9PT0gdHJ1ZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc0V2ZW50U3RyZWFtJywgQm9vbGVhbihzaGFwZS5ldmVudHN0cmVhbSksIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzRXZlbnQnLCBCb29sZWFuKHNoYXBlLmV2ZW50KSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNFdmVudFBheWxvYWQnLCBCb29sZWFuKHNoYXBlLmV2ZW50cGF5bG9hZCksIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzRXZlbnRIZWFkZXInLCBCb29sZWFuKHNoYXBlLmV2ZW50aGVhZGVyKSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNUaW1lc3RhbXBGb3JtYXRTZXQnLCBCb29sZWFuKHNoYXBlLnRpbWVzdGFtcEZvcm1hdCkgfHwgc2hhcGUucHJvdG90eXBlICYmIHNoYXBlLnByb3RvdHlwZS5pc1RpbWVzdGFtcEZvcm1hdFNldCA9PT0gdHJ1ZSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnZW5kcG9pbnREaXNjb3ZlcnlJZCcsIEJvb2xlYW4oc2hhcGUuZW5kcG9pbnRkaXNjb3ZlcnlpZCksIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2hvc3RMYWJlbCcsIEJvb2xlYW4oc2hhcGUuaG9zdExhYmVsKSwgZmFsc2UpO1xuXG4gIGlmIChvcHRpb25zLmRvY3VtZW50YXRpb24pIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnZG9jdW1lbnRhdGlvbicsIHNoYXBlLmRvY3VtZW50YXRpb24pO1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uVXJsJywgc2hhcGUuZG9jdW1lbnRhdGlvblVybCk7XG4gIH1cblxuICBpZiAoc2hhcGUueG1sQXR0cmlidXRlKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ2lzWG1sQXR0cmlidXRlJywgc2hhcGUueG1sQXR0cmlidXRlIHx8IGZhbHNlKTtcbiAgfVxuXG4gIC8vIHR5cGUgY29udmVyc2lvbiBhbmQgcGFyc2luZ1xuICBwcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdFZhbHVlJywgbnVsbCk7XG4gIHRoaXMudG9XaXJlRm9ybWF0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgdGhpcy50b1R5cGUgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblNoYXBlLm5vcm1hbGl6ZWRUeXBlcyA9IHtcbiAgY2hhcmFjdGVyOiAnc3RyaW5nJyxcbiAgZG91YmxlOiAnZmxvYXQnLFxuICBsb25nOiAnaW50ZWdlcicsXG4gIHNob3J0OiAnaW50ZWdlcicsXG4gIGJpZ2ludGVnZXI6ICdpbnRlZ2VyJyxcbiAgYmlnZGVjaW1hbDogJ2Zsb2F0JyxcbiAgYmxvYjogJ2JpbmFyeSdcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblNoYXBlLnR5cGVzID0ge1xuICAnc3RydWN0dXJlJzogU3RydWN0dXJlU2hhcGUsXG4gICdsaXN0JzogTGlzdFNoYXBlLFxuICAnbWFwJzogTWFwU2hhcGUsXG4gICdib29sZWFuJzogQm9vbGVhblNoYXBlLFxuICAndGltZXN0YW1wJzogVGltZXN0YW1wU2hhcGUsXG4gICdmbG9hdCc6IEZsb2F0U2hhcGUsXG4gICdpbnRlZ2VyJzogSW50ZWdlclNoYXBlLFxuICAnc3RyaW5nJzogU3RyaW5nU2hhcGUsXG4gICdiYXNlNjQnOiBCYXNlNjRTaGFwZSxcbiAgJ2JpbmFyeSc6IEJpbmFyeVNoYXBlXG59O1xuXG5TaGFwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShzaGFwZSwgb3B0aW9ucykge1xuICBpZiAoc2hhcGUuc2hhcGUpIHtcbiAgICB2YXIgcmVmU2hhcGUgPSBvcHRpb25zLmFwaS5zaGFwZXNbc2hhcGUuc2hhcGVdO1xuICAgIGlmICghcmVmU2hhcGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc2hhcGUgcmVmZXJlbmNlOiAnICsgc2hhcGUuc2hhcGUpO1xuICAgIH1cblxuICAgIHJldHVybiByZWZTaGFwZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuU2hhcGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHNoYXBlLCBvcHRpb25zLCBtZW1iZXJOYW1lKSB7XG4gIGlmIChzaGFwZS5pc1NoYXBlKSByZXR1cm4gc2hhcGU7XG5cbiAgdmFyIHJlZlNoYXBlID0gU2hhcGUucmVzb2x2ZShzaGFwZSwgb3B0aW9ucyk7XG4gIGlmIChyZWZTaGFwZSkge1xuICAgIHZhciBmaWx0ZXJlZEtleXMgPSBPYmplY3Qua2V5cyhzaGFwZSk7XG4gICAgaWYgKCFvcHRpb25zLmRvY3VtZW50YXRpb24pIHtcbiAgICAgIGZpbHRlcmVkS2V5cyA9IGZpbHRlcmVkS2V5cy5maWx0ZXIoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gIW5hbWUubWF0Y2goL2RvY3VtZW50YXRpb24vKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhbiBpbmxpbmUgc2hhcGUgd2l0aCBleHRyYSBtZW1iZXJzXG4gICAgdmFyIElubGluZVNoYXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWZTaGFwZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHNoYXBlLCBvcHRpb25zLCBtZW1iZXJOYW1lKTtcbiAgICB9O1xuICAgIElubGluZVNoYXBlLnByb3RvdHlwZSA9IHJlZlNoYXBlO1xuICAgIHJldHVybiBuZXcgSW5saW5lU2hhcGUoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzZXQgdHlwZSBpZiBub3Qgc2V0XG4gICAgaWYgKCFzaGFwZS50eXBlKSB7XG4gICAgICBpZiAoc2hhcGUubWVtYmVycykgc2hhcGUudHlwZSA9ICdzdHJ1Y3R1cmUnO1xuICAgICAgZWxzZSBpZiAoc2hhcGUubWVtYmVyKSBzaGFwZS50eXBlID0gJ2xpc3QnO1xuICAgICAgZWxzZSBpZiAoc2hhcGUua2V5KSBzaGFwZS50eXBlID0gJ21hcCc7XG4gICAgICBlbHNlIHNoYXBlLnR5cGUgPSAnc3RyaW5nJztcbiAgICB9XG5cbiAgICAvLyBub3JtYWxpemUgdHlwZXNcbiAgICB2YXIgb3JpZ1R5cGUgPSBzaGFwZS50eXBlO1xuICAgIGlmIChTaGFwZS5ub3JtYWxpemVkVHlwZXNbc2hhcGUudHlwZV0pIHtcbiAgICAgIHNoYXBlLnR5cGUgPSBTaGFwZS5ub3JtYWxpemVkVHlwZXNbc2hhcGUudHlwZV07XG4gICAgfVxuXG4gICAgaWYgKFNoYXBlLnR5cGVzW3NoYXBlLnR5cGVdKSB7XG4gICAgICByZXR1cm4gbmV3IFNoYXBlLnR5cGVzW3NoYXBlLnR5cGVdKHNoYXBlLCBvcHRpb25zLCBtZW1iZXJOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgc2hhcGUgdHlwZTogJyArIG9yaWdUeXBlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIENvbXBvc2l0ZVNoYXBlKHNoYXBlKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHByb3BlcnR5KHRoaXMsICdpc0NvbXBvc2l0ZScsIHRydWUpO1xuXG4gIGlmIChzaGFwZS5mbGF0dGVuZWQpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnZmxhdHRlbmVkJywgc2hhcGUuZmxhdHRlbmVkIHx8IGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBTdHJ1Y3R1cmVTaGFwZShzaGFwZSwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZXF1aXJlZE1hcCA9IG51bGwsIGZpcnN0SW5pdCA9ICF0aGlzLmlzU2hhcGU7XG5cbiAgQ29tcG9zaXRlU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoZmlyc3RJbml0KSB7XG4gICAgcHJvcGVydHkodGhpcywgJ2RlZmF1bHRWYWx1ZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH0pO1xuICAgIHByb3BlcnR5KHRoaXMsICdtZW1iZXJzJywge30pO1xuICAgIHByb3BlcnR5KHRoaXMsICdtZW1iZXJOYW1lcycsIFtdKTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAncmVxdWlyZWQnLCBbXSk7XG4gICAgcHJvcGVydHkodGhpcywgJ2lzUmVxdWlyZWQnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9KTtcbiAgfVxuXG4gIGlmIChzaGFwZS5tZW1iZXJzKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ21lbWJlcnMnLCBuZXcgQ29sbGVjdGlvbihzaGFwZS5tZW1iZXJzLCBvcHRpb25zLCBmdW5jdGlvbihuYW1lLCBtZW1iZXIpIHtcbiAgICAgIHJldHVybiBTaGFwZS5jcmVhdGUobWVtYmVyLCBvcHRpb25zLCBuYW1lKTtcbiAgICB9KSk7XG4gICAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnbWVtYmVyTmFtZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzaGFwZS54bWxPcmRlciB8fCBPYmplY3Qua2V5cyhzaGFwZS5tZW1iZXJzKTtcbiAgICB9KTtcblxuICAgIGlmIChzaGFwZS5ldmVudCkge1xuICAgICAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnZXZlbnRQYXlsb2FkTWVtYmVyTmFtZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWVtYmVycyA9IHNlbGYubWVtYmVycztcbiAgICAgICAgdmFyIG1lbWJlck5hbWVzID0gc2VsZi5tZW1iZXJOYW1lcztcbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIG1lbWJlcnMgdG8gZmluZCBvbmVzIHRoYXQgYXJlIGV2ZW50IHBheWxvYWRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gbWVtYmVyTmFtZXMubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKG1lbWJlcnNbbWVtYmVyTmFtZXNbaV1dLmlzRXZlbnRQYXlsb2FkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVtYmVyTmFtZXNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnZXZlbnRIZWFkZXJNZW1iZXJOYW1lcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWVtYmVycyA9IHNlbGYubWVtYmVycztcbiAgICAgICAgdmFyIG1lbWJlck5hbWVzID0gc2VsZi5tZW1iZXJOYW1lcztcbiAgICAgICAgdmFyIGV2ZW50SGVhZGVyTWVtYmVyTmFtZXMgPSBbXTtcbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIG1lbWJlcnMgdG8gZmluZCBvbmVzIHRoYXQgYXJlIGV2ZW50IGhlYWRlcnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBtZW1iZXJOYW1lcy5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAobWVtYmVyc1ttZW1iZXJOYW1lc1tpXV0uaXNFdmVudEhlYWRlcikge1xuICAgICAgICAgICAgZXZlbnRIZWFkZXJNZW1iZXJOYW1lcy5wdXNoKG1lbWJlck5hbWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50SGVhZGVyTWVtYmVyTmFtZXM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2hhcGUucmVxdWlyZWQpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAncmVxdWlyZWQnLCBzaGFwZS5yZXF1aXJlZCk7XG4gICAgcHJvcGVydHkodGhpcywgJ2lzUmVxdWlyZWQnLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAoIXJlcXVpcmVkTWFwKSB7XG4gICAgICAgIHJlcXVpcmVkTWFwID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhcGUucmVxdWlyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZXF1aXJlZE1hcFtzaGFwZS5yZXF1aXJlZFtpXV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXF1aXJlZE1hcFtuYW1lXTtcbiAgICB9LCBmYWxzZSwgdHJ1ZSk7XG4gIH1cblxuICBwcm9wZXJ0eSh0aGlzLCAncmVzdWx0V3JhcHBlcicsIHNoYXBlLnJlc3VsdFdyYXBwZXIgfHwgbnVsbCk7XG5cbiAgaWYgKHNoYXBlLnBheWxvYWQpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAncGF5bG9hZCcsIHNoYXBlLnBheWxvYWQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzaGFwZS54bWxOYW1lc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ3htbE5hbWVzcGFjZVVyaScsIHNoYXBlLnhtbE5hbWVzcGFjZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNoYXBlLnhtbE5hbWVzcGFjZSA9PT0gJ29iamVjdCcpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAneG1sTmFtZXNwYWNlUHJlZml4Jywgc2hhcGUueG1sTmFtZXNwYWNlLnByZWZpeCk7XG4gICAgcHJvcGVydHkodGhpcywgJ3htbE5hbWVzcGFjZVVyaScsIHNoYXBlLnhtbE5hbWVzcGFjZS51cmkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIExpc3RTaGFwZShzaGFwZSwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXMsIGZpcnN0SW5pdCA9ICF0aGlzLmlzU2hhcGU7XG4gIENvbXBvc2l0ZVNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGZpcnN0SW5pdCkge1xuICAgIHByb3BlcnR5KHRoaXMsICdkZWZhdWx0VmFsdWUnLCBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9KTtcbiAgfVxuXG4gIGlmIChzaGFwZS5tZW1iZXIpIHtcbiAgICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdtZW1iZXInLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBTaGFwZS5jcmVhdGUoc2hhcGUubWVtYmVyLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0aGlzLmZsYXR0ZW5lZCkge1xuICAgIHZhciBvbGROYW1lID0gdGhpcy5uYW1lO1xuICAgIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ25hbWUnLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzZWxmLm1lbWJlci5uYW1lIHx8IG9sZE5hbWU7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gTWFwU2hhcGUoc2hhcGUsIG9wdGlvbnMpIHtcbiAgdmFyIGZpcnN0SW5pdCA9ICF0aGlzLmlzU2hhcGU7XG4gIENvbXBvc2l0ZVNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGZpcnN0SW5pdCkge1xuICAgIHByb3BlcnR5KHRoaXMsICdkZWZhdWx0VmFsdWUnLCBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9KTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAna2V5JywgU2hhcGUuY3JlYXRlKHt0eXBlOiAnc3RyaW5nJ30sIG9wdGlvbnMpKTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAndmFsdWUnLCBTaGFwZS5jcmVhdGUoe3R5cGU6ICdzdHJpbmcnfSwgb3B0aW9ucykpO1xuICB9XG5cbiAgaWYgKHNoYXBlLmtleSkge1xuICAgIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ2tleScsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFNoYXBlLmNyZWF0ZShzaGFwZS5rZXksIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIGlmIChzaGFwZS52YWx1ZSkge1xuICAgIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ3ZhbHVlJywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gU2hhcGUuY3JlYXRlKHNoYXBlLnZhbHVlLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUaW1lc3RhbXBTaGFwZShzaGFwZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKHNoYXBlLnRpbWVzdGFtcEZvcm1hdCkge1xuICAgIHByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBGb3JtYXQnLCBzaGFwZS50aW1lc3RhbXBGb3JtYXQpO1xuICB9IGVsc2UgaWYgKHNlbGYuaXNUaW1lc3RhbXBGb3JtYXRTZXQgJiYgdGhpcy50aW1lc3RhbXBGb3JtYXQpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAndGltZXN0YW1wRm9ybWF0JywgdGhpcy50aW1lc3RhbXBGb3JtYXQpO1xuICB9IGVsc2UgaWYgKHRoaXMubG9jYXRpb24gPT09ICdoZWFkZXInKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcEZvcm1hdCcsICdyZmM4MjInKTtcbiAgfSBlbHNlIGlmICh0aGlzLmxvY2F0aW9uID09PSAncXVlcnlzdHJpbmcnKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcEZvcm1hdCcsICdpc284NjAxJyk7XG4gIH0gZWxzZSBpZiAodGhpcy5hcGkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuYXBpLnByb3RvY29sKSB7XG4gICAgICBjYXNlICdqc29uJzpcbiAgICAgIGNhc2UgJ3Jlc3QtanNvbic6XG4gICAgICAgIHByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBGb3JtYXQnLCAndW5peFRpbWVzdGFtcCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Jlc3QteG1sJzpcbiAgICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIGNhc2UgJ2VjMic6XG4gICAgICAgIHByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBGb3JtYXQnLCAnaXNvODYwMScpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0aGlzLnRvVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuICAgIGlmICh0eXBlb2YgdmFsdWUudG9VVENTdHJpbmcgPT09ICdmdW5jdGlvbicpIHJldHVybiB2YWx1ZTtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID9cbiAgICAgICAgICAgdXRpbC5kYXRlLnBhcnNlVGltZXN0YW1wKHZhbHVlKSA6IG51bGw7XG4gIH07XG5cbiAgdGhpcy50b1dpcmVGb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLmRhdGUuZm9ybWF0KHZhbHVlLCBzZWxmLnRpbWVzdGFtcEZvcm1hdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFN0cmluZ1NoYXBlKCkge1xuICBTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIHZhciBudWxsTGVzc1Byb3RvY29scyA9IFsncmVzdC14bWwnLCAncXVlcnknLCAnZWMyJ107XG4gIHRoaXMudG9UeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YWx1ZSA9IHRoaXMuYXBpICYmIG51bGxMZXNzUHJvdG9jb2xzLmluZGV4T2YodGhpcy5hcGkucHJvdG9jb2wpID4gLTEgP1xuICAgICAgdmFsdWUgfHwgJycgOiB2YWx1ZTtcbiAgICBpZiAodGhpcy5pc0pzb25WYWx1ZSkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgPT09ICdmdW5jdGlvbicgP1xuICAgICAgdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlO1xuICB9O1xuXG4gIHRoaXMudG9XaXJlRm9ybWF0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5pc0pzb25WYWx1ZSA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBGbG9hdFNoYXBlKCkge1xuICBTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIHRoaXMudG9UeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICB9O1xuICB0aGlzLnRvV2lyZUZvcm1hdCA9IHRoaXMudG9UeXBlO1xufVxuXG5mdW5jdGlvbiBJbnRlZ2VyU2hhcGUoKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdGhpcy50b1R5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfTtcbiAgdGhpcy50b1dpcmVGb3JtYXQgPSB0aGlzLnRvVHlwZTtcbn1cblxuZnVuY3Rpb24gQmluYXJ5U2hhcGUoKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRoaXMudG9UeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgYnVmID0gdXRpbC5iYXNlNjQuZGVjb2RlKHZhbHVlKTtcbiAgICBpZiAodGhpcy5pc1NlbnNpdGl2ZSAmJiB1dGlsLmlzTm9kZSgpICYmIHR5cGVvZiB1dGlsLkJ1ZmZlci5hbGxvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAvKiBOb2RlLmpzIGNhbiBjcmVhdGUgYSBCdWZmZXIgdGhhdCBpcyBub3QgaXNvbGF0ZWQuXG4gICAqIGkuZS4gYnVmLmJ5dGVMZW5ndGggIT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aFxuICAgKiBUaGlzIG1lYW5zIHRoYXQgdGhlIHNlbnNpdGl2ZSBkYXRhIGlzIGFjY2Vzc2libGUgdG8gYW55b25lIHdpdGggYWNjZXNzIHRvIGJ1Zi5idWZmZXIuXG4gICAqIElmIHRoaXMgaXMgdGhlIG5vZGUgc2hhcmVkIEJ1ZmZlciwgdGhlbiBvdGhlciBjb2RlIHdpdGhpbiB0aGlzIHByb2Nlc3MgX2NvdWxkXyBmaW5kIHRoaXMgc2VjcmV0LlxuICAgKiBDb3B5IHNlbnNpdGl2ZSBkYXRhIHRvIGFuIGlzb2xhdGVkIEJ1ZmZlciBhbmQgemVybyB0aGUgc2Vuc2l0aXZlIGRhdGEuXG4gICAqIFdoaWxlIHRoaXMgaXMgc2FmZSB0byBkbyBoZXJlLCBjb3B5aW5nIHRoaXMgY29kZSBzb21ld2hlcmUgZWxzZSBtYXkgcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAqL1xuICAgICAgdmFyIHNlY3VyZUJ1ZiA9IHV0aWwuQnVmZmVyLmFsbG9jKGJ1Zi5sZW5ndGgsIGJ1Zik7XG4gICAgICBidWYuZmlsbCgwKTtcbiAgICAgIGJ1ZiA9IHNlY3VyZUJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfTtcbiAgdGhpcy50b1dpcmVGb3JtYXQgPSB1dGlsLmJhc2U2NC5lbmNvZGU7XG59XG5cbmZ1bmN0aW9uIEJhc2U2NFNoYXBlKCkge1xuICBCaW5hcnlTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBCb29sZWFuU2hhcGUoKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdGhpcy50b1R5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdmFsdWUgPT09ICd0cnVlJztcbiAgfTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU2hhcGUuc2hhcGVzID0ge1xuICBTdHJ1Y3R1cmVTaGFwZTogU3RydWN0dXJlU2hhcGUsXG4gIExpc3RTaGFwZTogTGlzdFNoYXBlLFxuICBNYXBTaGFwZTogTWFwU2hhcGUsXG4gIFN0cmluZ1NoYXBlOiBTdHJpbmdTaGFwZSxcbiAgQm9vbGVhblNoYXBlOiBCb29sZWFuU2hhcGUsXG4gIEJhc2U2NFNoYXBlOiBCYXNlNjRTaGFwZVxufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBTaGFwZTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlBhcmFtVmFsaWRhdG9yID0gQVdTLnV0aWwuaW5oZXJpdCh7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdmFsaWRhdG9yIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHZhbGlkYXRpb24gW0Jvb2xlYW58bWFwXSB3aGV0aGVyIGlucHV0IHBhcmFtZXRlcnMgc2hvdWxkIGJlXG4gICAqICAgICB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgb3BlcmF0aW9uIGRlc2NyaXB0aW9uIGJlZm9yZSBzZW5kaW5nIHRoZVxuICAgKiAgICAgcmVxdWVzdC4gUGFzcyBhIG1hcCB0byBlbmFibGUgYW55IG9mIHRoZSBmb2xsb3dpbmcgc3BlY2lmaWNcbiAgICogICAgIHZhbGlkYXRpb24gZmVhdHVyZXM6XG4gICAqXG4gICAqICAgICAqICoqbWluKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBtZWV0cyB0aGUgbWluXG4gICAqICAgICAgIGNvbnN0cmFpbnQuIFRoaXMgaXMgZW5hYmxlZCBieSBkZWZhdWx0IHdoZW4gcGFyYW1WYWxpZGF0aW9uIGlzIHNldFxuICAgKiAgICAgICB0byBgdHJ1ZWAuXG4gICAqICAgICAqICoqbWF4KiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBtZWV0cyB0aGUgbWF4XG4gICAqICAgICAgIGNvbnN0cmFpbnQuXG4gICAqICAgICAqICoqcGF0dGVybioqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgc3RyaW5nIHZhbHVlIG1hdGNoZXMgYVxuICAgKiAgICAgICByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAqICAgICAqICoqZW51bSoqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgc3RyaW5nIHZhbHVlIG1hdGNoZXMgb25lXG4gICAqICAgICAgIG9mIHRoZSBhbGxvd2FibGUgZW51bSB2YWx1ZXMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gUGFyYW1WYWxpZGF0b3IodmFsaWRhdGlvbikge1xuICAgIGlmICh2YWxpZGF0aW9uID09PSB0cnVlIHx8IHZhbGlkYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsaWRhdGlvbiA9IHsnbWluJzogdHJ1ZX07XG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGlvbiA9IHZhbGlkYXRpb247XG4gIH0sXG5cbiAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKHNoYXBlLCBwYXJhbXMsIGNvbnRleHQpIHtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMudmFsaWRhdGVNZW1iZXIoc2hhcGUsIHBhcmFtcyB8fCB7fSwgY29udGV4dCB8fCAncGFyYW1zJyk7XG5cbiAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIG1zZyA9IHRoaXMuZXJyb3JzLmpvaW4oJ1xcbiogJyk7XG4gICAgICBtc2cgPSAnVGhlcmUgd2VyZSAnICsgdGhpcy5lcnJvcnMubGVuZ3RoICtcbiAgICAgICAgJyB2YWxpZGF0aW9uIGVycm9yczpcXG4qICcgKyBtc2c7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IobXNnKSxcbiAgICAgICAge2NvZGU6ICdNdWx0aXBsZVZhbGlkYXRpb25FcnJvcnMnLCBlcnJvcnM6IHRoaXMuZXJyb3JzfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRocm93IHRoaXMuZXJyb3JzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgZmFpbDogZnVuY3Rpb24gZmFpbChjb2RlLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5lcnJvcnMucHVzaChBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IobWVzc2FnZSksIHtjb2RlOiBjb2RlfSkpO1xuICB9LFxuXG4gIHZhbGlkYXRlU3RydWN0dXJlOiBmdW5jdGlvbiB2YWxpZGF0ZVN0cnVjdHVyZShzaGFwZSwgcGFyYW1zLCBjb250ZXh0KSB7XG4gICAgdGhpcy52YWxpZGF0ZVR5cGUocGFyYW1zLCBjb250ZXh0LCBbJ29iamVjdCddLCAnc3RydWN0dXJlJyk7XG5cbiAgICB2YXIgcGFyYW1OYW1lO1xuICAgIGZvciAodmFyIGkgPSAwOyBzaGFwZS5yZXF1aXJlZCAmJiBpIDwgc2hhcGUucmVxdWlyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcmFtTmFtZSA9IHNoYXBlLnJlcXVpcmVkW2ldO1xuICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW3BhcmFtTmFtZV07XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmZhaWwoJ01pc3NpbmdSZXF1aXJlZFBhcmFtZXRlcicsXG4gICAgICAgICAgJ01pc3NpbmcgcmVxdWlyZWQga2V5IFxcJycgKyBwYXJhbU5hbWUgKyAnXFwnIGluICcgKyBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSBoYXNoIG1lbWJlcnNcbiAgICBmb3IgKHBhcmFtTmFtZSBpbiBwYXJhbXMpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgcGFyYW1OYW1lKSkgY29udGludWU7XG5cbiAgICAgIHZhciBwYXJhbVZhbHVlID0gcGFyYW1zW3BhcmFtTmFtZV0sXG4gICAgICAgICAgbWVtYmVyU2hhcGUgPSBzaGFwZS5tZW1iZXJzW3BhcmFtTmFtZV07XG5cbiAgICAgIGlmIChtZW1iZXJTaGFwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBtZW1iZXJDb250ZXh0ID0gW2NvbnRleHQsIHBhcmFtTmFtZV0uam9pbignLicpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlTWVtYmVyKG1lbWJlclNoYXBlLCBwYXJhbVZhbHVlLCBtZW1iZXJDb250ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmFpbCgnVW5leHBlY3RlZFBhcmFtZXRlcicsXG4gICAgICAgICAgJ1VuZXhwZWN0ZWQga2V5IFxcJycgKyBwYXJhbU5hbWUgKyAnXFwnIGZvdW5kIGluICcgKyBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICB2YWxpZGF0ZU1lbWJlcjogZnVuY3Rpb24gdmFsaWRhdGVNZW1iZXIoc2hhcGUsIHBhcmFtLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgICBjYXNlICdzdHJ1Y3R1cmUnOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVN0cnVjdHVyZShzaGFwZSwgcGFyYW0sIGNvbnRleHQpO1xuICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlTGlzdChzaGFwZSwgcGFyYW0sIGNvbnRleHQpO1xuICAgICAgY2FzZSAnbWFwJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVNYXAoc2hhcGUsIHBhcmFtLCBjb250ZXh0KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlU2NhbGFyKHNoYXBlLCBwYXJhbSwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlTGlzdDogZnVuY3Rpb24gdmFsaWRhdGVMaXN0KHNoYXBlLCBwYXJhbXMsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy52YWxpZGF0ZVR5cGUocGFyYW1zLCBjb250ZXh0LCBbQXJyYXldKSkge1xuICAgICAgdGhpcy52YWxpZGF0ZVJhbmdlKHNoYXBlLCBwYXJhbXMubGVuZ3RoLCBjb250ZXh0LCAnbGlzdCBtZW1iZXIgY291bnQnKTtcbiAgICAgIC8vIHZhbGlkYXRlIGFycmF5IG1lbWJlcnNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVNZW1iZXIoc2hhcGUubWVtYmVyLCBwYXJhbXNbaV0sIGNvbnRleHQgKyAnWycgKyBpICsgJ10nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVNYXA6IGZ1bmN0aW9uIHZhbGlkYXRlTWFwKHNoYXBlLCBwYXJhbXMsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy52YWxpZGF0ZVR5cGUocGFyYW1zLCBjb250ZXh0LCBbJ29iamVjdCddLCAnbWFwJykpIHtcbiAgICAgIC8vIEJ1aWxkIHVwIGEgY291bnQgb2YgbWFwIG1lbWJlcnMgdG8gdmFsaWRhdGUgcmFuZ2UgdHJhaXRzLlxuICAgICAgdmFyIG1hcENvdW50ID0gMDtcbiAgICAgIGZvciAodmFyIHBhcmFtIGluIHBhcmFtcykge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIHBhcmFtKSkgY29udGludWU7XG4gICAgICAgIC8vIFZhbGlkYXRlIGFueSBtYXAga2V5IHRyYWl0IGNvbnN0cmFpbnRzXG4gICAgICAgIHRoaXMudmFsaWRhdGVNZW1iZXIoc2hhcGUua2V5LCBwYXJhbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ICsgJ1trZXk9XFwnJyArIHBhcmFtICsgJ1xcJ10nKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU1lbWJlcihzaGFwZS52YWx1ZSwgcGFyYW1zW3BhcmFtXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ICsgJ1tcXCcnICsgcGFyYW0gKyAnXFwnXScpO1xuICAgICAgICBtYXBDb3VudCsrO1xuICAgICAgfVxuICAgICAgdGhpcy52YWxpZGF0ZVJhbmdlKHNoYXBlLCBtYXBDb3VudCwgY29udGV4dCwgJ21hcCBtZW1iZXIgY291bnQnKTtcbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVTY2FsYXI6IGZ1bmN0aW9uIHZhbGlkYXRlU2NhbGFyKHNoYXBlLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIHN3aXRjaCAoc2hhcGUudHlwZSkge1xuICAgICAgY2FzZSBudWxsOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVN0cmluZyhzaGFwZSwgdmFsdWUsIGNvbnRleHQpO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlUGF5bG9hZCh2YWx1ZSwgY29udGV4dCk7XG4gICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVOdW1iZXIoc2hhcGUsIHZhbHVlLCBjb250ZXh0KTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVR5cGUodmFsdWUsIGNvbnRleHQsIFsnYm9vbGVhbiddKTtcbiAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlVHlwZSh2YWx1ZSwgY29udGV4dCwgW0RhdGUsXG4gICAgICAgICAgL15cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfShcXC5cXGQrKT9aJC8sICdudW1iZXInXSxcbiAgICAgICAgICAnRGF0ZSBvYmplY3QsIElTTy04NjAxIHN0cmluZywgb3IgYSBVTklYIHRpbWVzdGFtcCcpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFpbCgnVW5rb3duVHlwZScsICdVbmhhbmRsZWQgdHlwZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS50eXBlICsgJyBmb3IgJyArIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcoc2hhcGUsIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbGlkVHlwZXMgPSBbJ3N0cmluZyddO1xuICAgIGlmIChzaGFwZS5pc0pzb25WYWx1ZSkge1xuICAgICAgdmFsaWRUeXBlcyA9IHZhbGlkVHlwZXMuY29uY2F0KFsnbnVtYmVyJywgJ29iamVjdCcsICdib29sZWFuJ10pO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdGhpcy52YWxpZGF0ZVR5cGUodmFsdWUsIGNvbnRleHQsIHZhbGlkVHlwZXMpKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlRW51bShzaGFwZSwgdmFsdWUsIGNvbnRleHQpO1xuICAgICAgdGhpcy52YWxpZGF0ZVJhbmdlKHNoYXBlLCB2YWx1ZS5sZW5ndGgsIGNvbnRleHQsICdzdHJpbmcgbGVuZ3RoJyk7XG4gICAgICB0aGlzLnZhbGlkYXRlUGF0dGVybihzaGFwZSwgdmFsdWUsIGNvbnRleHQpO1xuICAgICAgdGhpcy52YWxpZGF0ZVVyaShzaGFwZSwgdmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZVVyaTogZnVuY3Rpb24gdmFsaWRhdGVVcmkoc2hhcGUsIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgaWYgKHNoYXBlWydsb2NhdGlvbiddID09PSAndXJpJykge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmZhaWwoJ1VyaVBhcmFtZXRlckVycm9yJywgJ0V4cGVjdGVkIHVyaSBwYXJhbWV0ZXIgdG8gaGF2ZSBsZW5ndGggPj0gMSwnXG4gICAgICAgICAgKyAnIGJ1dCBmb3VuZCBcIicgKyB2YWx1ZSArJ1wiIGZvciAnICsgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlUGF0dGVybjogZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuKHNoYXBlLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnZhbGlkYXRpb25bJ3BhdHRlcm4nXSAmJiBzaGFwZVsncGF0dGVybiddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghKG5ldyBSZWdFeHAoc2hhcGVbJ3BhdHRlcm4nXSkpLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnUGF0dGVybk1hdGNoRXJyb3InLCAnUHJvdmlkZWQgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgJ1xuICAgICAgICAgICsgJ2RvZXMgbm90IG1hdGNoIHJlZ2V4IHBhdHRlcm4gLycgKyBzaGFwZVsncGF0dGVybiddICsgJy8gZm9yICdcbiAgICAgICAgICArIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZVJhbmdlOiBmdW5jdGlvbiB2YWxpZGF0ZVJhbmdlKHNoYXBlLCB2YWx1ZSwgY29udGV4dCwgZGVzY3JpcHRvcikge1xuICAgIGlmICh0aGlzLnZhbGlkYXRpb25bJ21pbiddKSB7XG4gICAgICBpZiAoc2hhcGVbJ21pbiddICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPCBzaGFwZVsnbWluJ10pIHtcbiAgICAgICAgdGhpcy5mYWlsKCdNaW5SYW5nZUVycm9yJywgJ0V4cGVjdGVkICcgKyBkZXNjcmlwdG9yICsgJyA+PSAnXG4gICAgICAgICAgKyBzaGFwZVsnbWluJ10gKyAnLCBidXQgZm91bmQgJyArIHZhbHVlICsgJyBmb3IgJyArIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy52YWxpZGF0aW9uWydtYXgnXSkge1xuICAgICAgaWYgKHNoYXBlWydtYXgnXSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlID4gc2hhcGVbJ21heCddKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnTWF4UmFuZ2VFcnJvcicsICdFeHBlY3RlZCAnICsgZGVzY3JpcHRvciArICcgPD0gJ1xuICAgICAgICAgICsgc2hhcGVbJ21heCddICsgJywgYnV0IGZvdW5kICcgKyB2YWx1ZSArICcgZm9yICcgKyBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVFbnVtOiBmdW5jdGlvbiB2YWxpZGF0ZVJhbmdlKHNoYXBlLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnZhbGlkYXRpb25bJ2VudW0nXSAmJiBzaGFwZVsnZW51bSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEZhaWwgaWYgdGhlIHN0cmluZyB2YWx1ZSBpcyBub3QgcHJlc2VudCBpbiB0aGUgZW51bSBsaXN0XG4gICAgICBpZiAoc2hhcGVbJ2VudW0nXS5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5mYWlsKCdFbnVtRXJyb3InLCAnRm91bmQgc3RyaW5nIHZhbHVlIG9mICcgKyB2YWx1ZSArICcsIGJ1dCAnXG4gICAgICAgICAgKyAnZXhwZWN0ZWQgJyArIHNoYXBlWydlbnVtJ10uam9pbignfCcpICsgJyBmb3IgJyArIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZVR5cGU6IGZ1bmN0aW9uIHZhbGlkYXRlVHlwZSh2YWx1ZSwgY29udGV4dCwgYWNjZXB0ZWRUeXBlcywgdHlwZSkge1xuICAgIC8vIFdlIHdpbGwgbm90IGxvZyBhbiBlcnJvciBmb3IgbnVsbCBvciB1bmRlZmluZWQsIGJ1dCB3ZSB3aWxsIHJldHVyblxuICAgIC8vIGZhbHNlIHNvIHRoYXQgY2FsbGVycyBrbm93IHRoYXQgdGhlIGV4cGVjdGVkIHR5cGUgd2FzIG5vdCBzdHJpY3RseSBtZXQuXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBmb3VuZEludmFsaWRUeXBlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY2NlcHRlZFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIGFjY2VwdGVkVHlwZXNbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IGFjY2VwdGVkVHlwZXNbaV0pIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChhY2NlcHRlZFR5cGVzW2ldIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIGlmICgodmFsdWUgfHwgJycpLnRvU3RyaW5nKCkubWF0Y2goYWNjZXB0ZWRUeXBlc1tpXSkpIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgYWNjZXB0ZWRUeXBlc1tpXSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChBV1MudXRpbC5pc1R5cGUodmFsdWUsIGFjY2VwdGVkVHlwZXNbaV0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCF0eXBlICYmICFmb3VuZEludmFsaWRUeXBlKSBhY2NlcHRlZFR5cGVzID0gYWNjZXB0ZWRUeXBlcy5zbGljZSgpO1xuICAgICAgICBhY2NlcHRlZFR5cGVzW2ldID0gQVdTLnV0aWwudHlwZU5hbWUoYWNjZXB0ZWRUeXBlc1tpXSk7XG4gICAgICB9XG4gICAgICBmb3VuZEludmFsaWRUeXBlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYWNjZXB0ZWRUeXBlID0gdHlwZTtcbiAgICBpZiAoIWFjY2VwdGVkVHlwZSkge1xuICAgICAgYWNjZXB0ZWRUeXBlID0gYWNjZXB0ZWRUeXBlcy5qb2luKCcsICcpLnJlcGxhY2UoLywoW14sXSspJC8sICcsIG9yJDEnKTtcbiAgICB9XG5cbiAgICB2YXIgdm93ZWwgPSBhY2NlcHRlZFR5cGUubWF0Y2goL15bYWVpb3VdL2kpID8gJ24nIDogJyc7XG4gICAgdGhpcy5mYWlsKCdJbnZhbGlkUGFyYW1ldGVyVHlwZScsICdFeHBlY3RlZCAnICsgY29udGV4dCArICcgdG8gYmUgYScgK1xuICAgICAgICAgICAgICB2b3dlbCArICcgJyArIGFjY2VwdGVkVHlwZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHZhbGlkYXRlTnVtYmVyOiBmdW5jdGlvbiB2YWxpZGF0ZU51bWJlcihzaGFwZSwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgY2FzdGVkVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIGlmIChjYXN0ZWRWYWx1ZS50b1N0cmluZygpID09PSB2YWx1ZSkgdmFsdWUgPSBjYXN0ZWRWYWx1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMudmFsaWRhdGVUeXBlKHZhbHVlLCBjb250ZXh0LCBbJ251bWJlciddKSkge1xuICAgICAgdGhpcy52YWxpZGF0ZVJhbmdlKHNoYXBlLCB2YWx1ZSwgY29udGV4dCwgJ251bWVyaWMgdmFsdWUnKTtcbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVQYXlsb2FkOiBmdW5jdGlvbiB2YWxpZGF0ZVBheWxvYWQodmFsdWUsIGNvbnRleHQpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSByZXR1cm47XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykgcmV0dXJuOyAvLyB0eXBlZCBhcnJheXNcbiAgICBpZiAoQVdTLnV0aWwuaXNOb2RlKCkpIHsgLy8gc3BlY2lhbCBjaGVjayBmb3IgYnVmZmVyL3N0cmVhbSBpbiBOb2RlLmpzXG4gICAgICB2YXIgU3RyZWFtID0gQVdTLnV0aWwuc3RyZWFtLlN0cmVhbTtcbiAgICAgIGlmIChBV1MudXRpbC5CdWZmZXIuaXNCdWZmZXIodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyZWFtKSByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgQmxvYiAhPT0gdm9pZCAwICYmIHZhbHVlIGluc3RhbmNlb2YgQmxvYikgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0eXBlcyA9IFsnQnVmZmVyJywgJ1N0cmVhbScsICdGaWxlJywgJ0Jsb2InLCAnQXJyYXlCdWZmZXInLCAnRGF0YVZpZXcnXTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKEFXUy51dGlsLmlzVHlwZSh2YWx1ZSwgdHlwZXNbaV0pKSByZXR1cm47XG4gICAgICAgIGlmIChBV1MudXRpbC50eXBlTmFtZSh2YWx1ZS5jb25zdHJ1Y3RvcikgPT09IHR5cGVzW2ldKSByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mYWlsKCdJbnZhbGlkUGFyYW1ldGVyVHlwZScsICdFeHBlY3RlZCAnICsgY29udGV4dCArICcgdG8gYmUgYSAnICtcbiAgICAgICdzdHJpbmcsIEJ1ZmZlciwgU3RyZWFtLCBCbG9iLCBvciB0eXBlZCBhcnJheSBvYmplY3QnKTtcbiAgfVxufSk7XG4iLCJ2YXIgdXRpbCA9ICByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG4vKipcbiAqIFByZXBlbmQgcHJlZml4IGRlZmluZWQgYnkgQVBJIG1vZGVsIHRvIGVuZHBvaW50IHRoYXQncyBhbHJlYWR5XG4gKiBjb25zdHJ1Y3RlZC4gVGhpcyBmZWF0dXJlIGRvZXMgbm90IGFwcGx5IHRvIG9wZXJhdGlvbnMgdXNpbmdcbiAqIGVuZHBvaW50IGRpc2NvdmVyeSBhbmQgY2FuIGJlIGRpc2FibGVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBvcHVsYXRlSG9zdFByZWZpeChyZXF1ZXN0KSAge1xuICB2YXIgZW5hYmxlZCA9IHJlcXVlc3Quc2VydmljZS5jb25maWcuaG9zdFByZWZpeEVuYWJsZWQ7XG4gIGlmICghZW5hYmxlZCkgcmV0dXJuIHJlcXVlc3Q7XG4gIHZhciBvcGVyYXRpb25Nb2RlbCA9IHJlcXVlc3Quc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl07XG4gIC8vZG9uJ3QgbWFyc2hhbCBob3N0IHByZWZpeCB3aGVuIG9wZXJhdGlvbiBoYXMgZW5kcG9pbnQgZGlzY292ZXJ5IHRyYWl0c1xuICBpZiAoaGFzRW5kcG9pbnREaXNjb3ZlcihyZXF1ZXN0KSkgcmV0dXJuIHJlcXVlc3Q7XG4gIGlmIChvcGVyYXRpb25Nb2RlbC5lbmRwb2ludCAmJiBvcGVyYXRpb25Nb2RlbC5lbmRwb2ludC5ob3N0UHJlZml4KSB7XG4gICAgdmFyIGhvc3RQcmVmaXhOb3RhdGlvbiA9IG9wZXJhdGlvbk1vZGVsLmVuZHBvaW50Lmhvc3RQcmVmaXg7XG4gICAgdmFyIGhvc3RQcmVmaXggPSBleHBhbmRIb3N0UHJlZml4KGhvc3RQcmVmaXhOb3RhdGlvbiwgcmVxdWVzdC5wYXJhbXMsIG9wZXJhdGlvbk1vZGVsLmlucHV0KTtcbiAgICBwcmVwZW5kRW5kcG9pbnRQcmVmaXgocmVxdWVzdC5odHRwUmVxdWVzdC5lbmRwb2ludCwgaG9zdFByZWZpeCk7XG4gICAgdmFsaWRhdGVIb3N0bmFtZShyZXF1ZXN0Lmh0dHBSZXF1ZXN0LmVuZHBvaW50Lmhvc3RuYW1lKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdDtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaGFzRW5kcG9pbnREaXNjb3ZlcihyZXF1ZXN0KSB7XG4gIHZhciBhcGkgPSByZXF1ZXN0LnNlcnZpY2UuYXBpO1xuICB2YXIgb3BlcmF0aW9uTW9kZWwgPSBhcGkub3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl07XG4gIHZhciBpc0VuZHBvaW50T3BlcmF0aW9uID0gYXBpLmVuZHBvaW50T3BlcmF0aW9uICYmIChhcGkuZW5kcG9pbnRPcGVyYXRpb24gPT09IHV0aWwuc3RyaW5nLmxvd2VyRmlyc3Qob3BlcmF0aW9uTW9kZWwubmFtZSkpO1xuICByZXR1cm4gKG9wZXJhdGlvbk1vZGVsLmVuZHBvaW50RGlzY292ZXJ5UmVxdWlyZWQgIT09ICdOVUxMJyB8fCBpc0VuZHBvaW50T3BlcmF0aW9uID09PSB0cnVlKTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXhwYW5kSG9zdFByZWZpeChob3N0UHJlZml4Tm90YXRpb24sIHBhcmFtcywgc2hhcGUpIHtcbiAgdXRpbC5lYWNoKHNoYXBlLm1lbWJlcnMsIGZ1bmN0aW9uKG5hbWUsIG1lbWJlcikge1xuICAgIGlmIChtZW1iZXIuaG9zdExhYmVsID09PSB0cnVlKSB7XG4gICAgICBpZiAodHlwZW9mIHBhcmFtc1tuYW1lXSAhPT0gJ3N0cmluZycgfHwgcGFyYW1zW25hbWVdID09PSAnJykge1xuICAgICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgICAgbWVzc2FnZTogJ1BhcmFtZXRlciAnICsgbmFtZSArICcgc2hvdWxkIGJlIGEgbm9uLWVtcHR5IHN0cmluZy4nLFxuICAgICAgICAgIGNvZGU6ICdJbnZhbGlkUGFyYW1ldGVyJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ1xcXFx7JyArIG5hbWUgKyAnXFxcXH0nLCAnZycpO1xuICAgICAgaG9zdFByZWZpeE5vdGF0aW9uID0gaG9zdFByZWZpeE5vdGF0aW9uLnJlcGxhY2UocmVnZXgsIHBhcmFtc1tuYW1lXSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGhvc3RQcmVmaXhOb3RhdGlvbjtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJlcGVuZEVuZHBvaW50UHJlZml4KGVuZHBvaW50LCBwcmVmaXgpIHtcbiAgaWYgKGVuZHBvaW50Lmhvc3QpIHtcbiAgICBlbmRwb2ludC5ob3N0ID0gcHJlZml4ICsgZW5kcG9pbnQuaG9zdDtcbiAgfVxuICBpZiAoZW5kcG9pbnQuaG9zdG5hbWUpIHtcbiAgICBlbmRwb2ludC5ob3N0bmFtZSA9IHByZWZpeCArIGVuZHBvaW50Lmhvc3RuYW1lO1xuICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSG9zdG5hbWUoaG9zdG5hbWUpIHtcbiAgdmFyIGxhYmVscyA9IGhvc3RuYW1lLnNwbGl0KCcuJyk7XG4gIC8vUmVmZXJlbmNlOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTEyMyNzZWN0aW9uLTJcbiAgdmFyIGhvc3RQYXR0ZXJuID0gL15bYS16QS1aMC05XXsxfSR8XlthLXpBLVowLTldW2EtekEtWjAtOVxcLV0qW2EtekEtWjAtOV0kLztcbiAgdXRpbC5hcnJheUVhY2gobGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgIGlmICghbGFiZWwubGVuZ3RoIHx8IGxhYmVsLmxlbmd0aCA8IDEgfHwgbGFiZWwubGVuZ3RoID4gNjMpIHtcbiAgICAgIHRocm93IHV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ1ZhbGlkYXRpb25FcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdIb3N0bmFtZSBsYWJlbCBsZW5ndGggc2hvdWxkIGJlIGJldHdlZW4gMSB0byA2MyBjaGFyYWN0ZXJzLCBpbmNsdXNpdmUuJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghaG9zdFBhdHRlcm4udGVzdChsYWJlbCkpIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLFxuICAgICAgICB7Y29kZTogJ1ZhbGlkYXRpb25FcnJvcicsIG1lc3NhZ2U6IGxhYmVsICsgJyBpcyBub3QgaG9zdG5hbWUgY29tcGF0aWJsZS4nfSk7XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBvcHVsYXRlSG9zdFByZWZpeDogcG9wdWxhdGVIb3N0UHJlZml4XG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgSnNvbkJ1aWxkZXIgPSByZXF1aXJlKCcuLi9qc29uL2J1aWxkZXInKTtcbnZhciBKc29uUGFyc2VyID0gcmVxdWlyZSgnLi4vanNvbi9wYXJzZXInKTtcbnZhciBwb3B1bGF0ZUhvc3RQcmVmaXggPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5wb3B1bGF0ZUhvc3RQcmVmaXg7XG5cbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdChyZXEpIHtcbiAgdmFyIGh0dHBSZXF1ZXN0ID0gcmVxLmh0dHBSZXF1ZXN0O1xuICB2YXIgYXBpID0gcmVxLnNlcnZpY2UuYXBpO1xuICB2YXIgdGFyZ2V0ID0gYXBpLnRhcmdldFByZWZpeCArICcuJyArIGFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLm5hbWU7XG4gIHZhciB2ZXJzaW9uID0gYXBpLmpzb25WZXJzaW9uIHx8ICcxLjAnO1xuICB2YXIgaW5wdXQgPSBhcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5pbnB1dDtcbiAgdmFyIGJ1aWxkZXIgPSBuZXcgSnNvbkJ1aWxkZXIoKTtcblxuICBpZiAodmVyc2lvbiA9PT0gMSkgdmVyc2lvbiA9ICcxLjAnO1xuICBodHRwUmVxdWVzdC5ib2R5ID0gYnVpbGRlci5idWlsZChyZXEucGFyYW1zIHx8IHt9LCBpbnB1dCk7XG4gIGh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtYW16LWpzb24tJyArIHZlcnNpb247XG4gIGh0dHBSZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LVRhcmdldCddID0gdGFyZ2V0O1xuXG4gIHBvcHVsYXRlSG9zdFByZWZpeChyZXEpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RXJyb3IocmVzcCkge1xuICB2YXIgZXJyb3IgPSB7fTtcbiAgdmFyIGh0dHBSZXNwb25zZSA9IHJlc3AuaHR0cFJlc3BvbnNlO1xuXG4gIGVycm9yLmNvZGUgPSBodHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXpuLWVycm9ydHlwZSddIHx8ICdVbmtub3duRXJyb3InO1xuICBpZiAodHlwZW9mIGVycm9yLmNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgZXJyb3IuY29kZSA9IGVycm9yLmNvZGUuc3BsaXQoJzonKVswXTtcbiAgfVxuXG4gIGlmIChodHRwUmVzcG9uc2UuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBlID0gSlNPTi5wYXJzZShodHRwUmVzcG9uc2UuYm9keS50b1N0cmluZygpKTtcbiAgICAgIGlmIChlLl9fdHlwZSB8fCBlLmNvZGUpIHtcbiAgICAgICAgZXJyb3IuY29kZSA9IChlLl9fdHlwZSB8fCBlLmNvZGUpLnNwbGl0KCcjJykucG9wKCk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ1JlcXVlc3RFbnRpdHlUb29MYXJnZScpIHtcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9ICdSZXF1ZXN0IGJvZHkgbXVzdCBiZSBsZXNzIHRoYW4gMSBNQic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gKGUubWVzc2FnZSB8fCBlLk1lc3NhZ2UgfHwgbnVsbCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3Iuc3RhdHVzQ29kZSA9IGh0dHBSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgZXJyb3IubWVzc2FnZSA9IGh0dHBSZXNwb25zZS5zdGF0dXNNZXNzYWdlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlcnJvci5zdGF0dXNDb2RlID0gaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgZXJyb3IubWVzc2FnZSA9IGh0dHBSZXNwb25zZS5zdGF0dXNDb2RlLnRvU3RyaW5nKCk7XG4gIH1cblxuICByZXNwLmVycm9yID0gdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwgZXJyb3IpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RGF0YShyZXNwKSB7XG4gIHZhciBib2R5ID0gcmVzcC5odHRwUmVzcG9uc2UuYm9keS50b1N0cmluZygpIHx8ICd7fSc7XG4gIGlmIChyZXNwLnJlcXVlc3Quc2VydmljZS5jb25maWcuY29udmVydFJlc3BvbnNlVHlwZXMgPT09IGZhbHNlKSB7XG4gICAgcmVzcC5kYXRhID0gSlNPTi5wYXJzZShib2R5KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gcmVzcC5yZXF1ZXN0LnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVzcC5yZXF1ZXN0Lm9wZXJhdGlvbl07XG4gICAgdmFyIHNoYXBlID0gb3BlcmF0aW9uLm91dHB1dCB8fCB7fTtcbiAgICB2YXIgcGFyc2VyID0gbmV3IEpzb25QYXJzZXIoKTtcbiAgICByZXNwLmRhdGEgPSBwYXJzZXIucGFyc2UoYm9keSwgc2hhcGUpO1xuICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBidWlsZFJlcXVlc3Q6IGJ1aWxkUmVxdWVzdCxcbiAgZXh0cmFjdEVycm9yOiBleHRyYWN0RXJyb3IsXG4gIGV4dHJhY3REYXRhOiBleHRyYWN0RGF0YVxufTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBRdWVyeVBhcmFtU2VyaWFsaXplciA9IHJlcXVpcmUoJy4uL3F1ZXJ5L3F1ZXJ5X3BhcmFtX3NlcmlhbGl6ZXInKTtcbnZhciBTaGFwZSA9IHJlcXVpcmUoJy4uL21vZGVsL3NoYXBlJyk7XG52YXIgcG9wdWxhdGVIb3N0UHJlZml4ID0gcmVxdWlyZSgnLi9oZWxwZXJzJykucG9wdWxhdGVIb3N0UHJlZml4O1xuXG5mdW5jdGlvbiBidWlsZFJlcXVlc3QocmVxKSB7XG4gIHZhciBvcGVyYXRpb24gPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgdmFyIGh0dHBSZXF1ZXN0ID0gcmVxLmh0dHBSZXF1ZXN0O1xuICBodHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9XG4gICAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD11dGYtOCc7XG4gIGh0dHBSZXF1ZXN0LnBhcmFtcyA9IHtcbiAgICBWZXJzaW9uOiByZXEuc2VydmljZS5hcGkuYXBpVmVyc2lvbixcbiAgICBBY3Rpb246IG9wZXJhdGlvbi5uYW1lXG4gIH07XG5cbiAgLy8gY29udmVydCB0aGUgcmVxdWVzdCBwYXJhbWV0ZXJzIGludG8gYSBsaXN0IG9mIHF1ZXJ5IHBhcmFtcyxcbiAgLy8gZS5nLiBEZWVwbHkuTmVzdGVkUGFyYW0uMC5OYW1lPXZhbHVlXG4gIHZhciBidWlsZGVyID0gbmV3IFF1ZXJ5UGFyYW1TZXJpYWxpemVyKCk7XG4gIGJ1aWxkZXIuc2VyaWFsaXplKHJlcS5wYXJhbXMsIG9wZXJhdGlvbi5pbnB1dCwgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBodHRwUmVxdWVzdC5wYXJhbXNbbmFtZV0gPSB2YWx1ZTtcbiAgfSk7XG4gIGh0dHBSZXF1ZXN0LmJvZHkgPSB1dGlsLnF1ZXJ5UGFyYW1zVG9TdHJpbmcoaHR0cFJlcXVlc3QucGFyYW1zKTtcblxuICBwb3B1bGF0ZUhvc3RQcmVmaXgocmVxKTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVycm9yKHJlc3ApIHtcbiAgdmFyIGRhdGEsIGJvZHkgPSByZXNwLmh0dHBSZXNwb25zZS5ib2R5LnRvU3RyaW5nKCk7XG4gIGlmIChib2R5Lm1hdGNoKCc8VW5rbm93bk9wZXJhdGlvbkV4Y2VwdGlvbicpKSB7XG4gICAgZGF0YSA9IHtcbiAgICAgIENvZGU6ICdVbmtub3duT3BlcmF0aW9uJyxcbiAgICAgIE1lc3NhZ2U6ICdVbmtub3duIG9wZXJhdGlvbiAnICsgcmVzcC5yZXF1ZXN0Lm9wZXJhdGlvblxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBuZXcgQVdTLlhNTC5QYXJzZXIoKS5wYXJzZShib2R5KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkYXRhID0ge1xuICAgICAgICBDb2RlOiByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICBNZXNzYWdlOiByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNNZXNzYWdlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChkYXRhLnJlcXVlc3RJZCAmJiAhcmVzcC5yZXF1ZXN0SWQpIHJlc3AucmVxdWVzdElkID0gZGF0YS5yZXF1ZXN0SWQ7XG4gIGlmIChkYXRhLkVycm9ycykgZGF0YSA9IGRhdGEuRXJyb3JzO1xuICBpZiAoZGF0YS5FcnJvcikgZGF0YSA9IGRhdGEuRXJyb3I7XG4gIGlmIChkYXRhLkNvZGUpIHtcbiAgICByZXNwLmVycm9yID0gdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgY29kZTogZGF0YS5Db2RlLFxuICAgICAgbWVzc2FnZTogZGF0YS5NZXNzYWdlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVzcC5lcnJvciA9IHV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgIGNvZGU6IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICBtZXNzYWdlOiBudWxsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdERhdGEocmVzcCkge1xuICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHZhciBzaGFwZSA9IG9wZXJhdGlvbi5vdXRwdXQgfHwge307XG4gIHZhciBvcmlnUnVsZXMgPSBzaGFwZTtcblxuICBpZiAob3JpZ1J1bGVzLnJlc3VsdFdyYXBwZXIpIHtcbiAgICB2YXIgdG1wID0gU2hhcGUuY3JlYXRlKHt0eXBlOiAnc3RydWN0dXJlJ30pO1xuICAgIHRtcC5tZW1iZXJzW29yaWdSdWxlcy5yZXN1bHRXcmFwcGVyXSA9IHNoYXBlO1xuICAgIHRtcC5tZW1iZXJOYW1lcyA9IFtvcmlnUnVsZXMucmVzdWx0V3JhcHBlcl07XG4gICAgdXRpbC5wcm9wZXJ0eShzaGFwZSwgJ25hbWUnLCBzaGFwZS5yZXN1bHRXcmFwcGVyKTtcbiAgICBzaGFwZSA9IHRtcDtcbiAgfVxuXG4gIHZhciBwYXJzZXIgPSBuZXcgQVdTLlhNTC5QYXJzZXIoKTtcblxuICAvLyBUT0RPOiBSZWZhY3RvciBYTUwgUGFyc2VyIHRvIHBhcnNlIFJlcXVlc3RJZCBmcm9tIHJlc3BvbnNlLlxuICBpZiAoc2hhcGUgJiYgc2hhcGUubWVtYmVycyAmJiAhc2hhcGUubWVtYmVycy5fWEFNWlJlcXVlc3RJZCkge1xuICAgIHZhciByZXF1ZXN0SWRTaGFwZSA9IFNoYXBlLmNyZWF0ZShcbiAgICAgIHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgIHsgYXBpOiB7IHByb3RvY29sOiAncXVlcnknIH0gfSxcbiAgICAgICdyZXF1ZXN0SWQnXG4gICAgKTtcbiAgICBzaGFwZS5tZW1iZXJzLl9YQU1aUmVxdWVzdElkID0gcmVxdWVzdElkU2hhcGU7XG4gIH1cblxuICB2YXIgZGF0YSA9IHBhcnNlci5wYXJzZShyZXNwLmh0dHBSZXNwb25zZS5ib2R5LnRvU3RyaW5nKCksIHNoYXBlKTtcbiAgcmVzcC5yZXF1ZXN0SWQgPSBkYXRhLl9YQU1aUmVxdWVzdElkIHx8IGRhdGEucmVxdWVzdElkO1xuXG4gIGlmIChkYXRhLl9YQU1aUmVxdWVzdElkKSBkZWxldGUgZGF0YS5fWEFNWlJlcXVlc3RJZDtcblxuICBpZiAob3JpZ1J1bGVzLnJlc3VsdFdyYXBwZXIpIHtcbiAgICBpZiAoZGF0YVtvcmlnUnVsZXMucmVzdWx0V3JhcHBlcl0pIHtcbiAgICAgIHV0aWwudXBkYXRlKGRhdGEsIGRhdGFbb3JpZ1J1bGVzLnJlc3VsdFdyYXBwZXJdKTtcbiAgICAgIGRlbGV0ZSBkYXRhW29yaWdSdWxlcy5yZXN1bHRXcmFwcGVyXTtcbiAgICB9XG4gIH1cblxuICByZXNwLmRhdGEgPSBkYXRhO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYnVpbGRSZXF1ZXN0OiBidWlsZFJlcXVlc3QsXG4gIGV4dHJhY3RFcnJvcjogZXh0cmFjdEVycm9yLFxuICBleHRyYWN0RGF0YTogZXh0cmFjdERhdGFcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBwb3B1bGF0ZUhvc3RQcmVmaXggPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5wb3B1bGF0ZUhvc3RQcmVmaXg7XG5cbmZ1bmN0aW9uIHBvcHVsYXRlTWV0aG9kKHJlcSkge1xuICByZXEuaHR0cFJlcXVlc3QubWV0aG9kID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0uaHR0cE1ldGhvZDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVVUkkoZW5kcG9pbnRQYXRoLCBvcGVyYXRpb25QYXRoLCBpbnB1dCwgcGFyYW1zKSB7XG4gIHZhciB1cmkgPSBbZW5kcG9pbnRQYXRoLCBvcGVyYXRpb25QYXRoXS5qb2luKCcvJyk7XG4gIHVyaSA9IHVyaS5yZXBsYWNlKC9cXC8rL2csICcvJyk7XG5cbiAgdmFyIHF1ZXJ5U3RyaW5nID0ge30sIHF1ZXJ5U3RyaW5nU2V0ID0gZmFsc2U7XG4gIHV0aWwuZWFjaChpbnB1dC5tZW1iZXJzLCBmdW5jdGlvbiAobmFtZSwgbWVtYmVyKSB7XG4gICAgdmFyIHBhcmFtVmFsdWUgPSBwYXJhbXNbbmFtZV07XG4gICAgaWYgKHBhcmFtVmFsdWUgPT09IG51bGwgfHwgcGFyYW1WYWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gJ3VyaScpIHtcbiAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ1xcXFx7JyArIG1lbWJlci5uYW1lICsgJyhcXFxcKyk/XFxcXH0nKTtcbiAgICAgIHVyaSA9IHVyaS5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbihfLCBwbHVzKSB7XG4gICAgICAgIHZhciBmbiA9IHBsdXMgPyB1dGlsLnVyaUVzY2FwZVBhdGggOiB1dGlsLnVyaUVzY2FwZTtcbiAgICAgICAgcmV0dXJuIGZuKFN0cmluZyhwYXJhbVZhbHVlKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gJ3F1ZXJ5c3RyaW5nJykge1xuICAgICAgcXVlcnlTdHJpbmdTZXQgPSB0cnVlO1xuXG4gICAgICBpZiAobWVtYmVyLnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICBxdWVyeVN0cmluZ1ttZW1iZXIubmFtZV0gPSBwYXJhbVZhbHVlLm1hcChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbC51cmlFc2NhcGUobWVtYmVyLm1lbWJlci50b1dpcmVGb3JtYXQodmFsKS50b1N0cmluZygpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG1lbWJlci50eXBlID09PSAnbWFwJykge1xuICAgICAgICB1dGlsLmVhY2gocGFyYW1WYWx1ZSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcXVlcnlTdHJpbmdba2V5XSA9IHZhbHVlLm1hcChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHV0aWwudXJpRXNjYXBlKFN0cmluZyh2YWwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWVyeVN0cmluZ1trZXldID0gdXRpbC51cmlFc2NhcGUoU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5U3RyaW5nW21lbWJlci5uYW1lXSA9IHV0aWwudXJpRXNjYXBlKG1lbWJlci50b1dpcmVGb3JtYXQocGFyYW1WYWx1ZSkudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAocXVlcnlTdHJpbmdTZXQpIHtcbiAgICB1cmkgKz0gKHVyaS5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/Jyk7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgdXRpbC5hcnJheUVhY2goT2JqZWN0LmtleXMocXVlcnlTdHJpbmcpLnNvcnQoKSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocXVlcnlTdHJpbmdba2V5XSkpIHtcbiAgICAgICAgcXVlcnlTdHJpbmdba2V5XSA9IFtxdWVyeVN0cmluZ1trZXldXTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVlcnlTdHJpbmdba2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJ0cy5wdXNoKHV0aWwudXJpRXNjYXBlKFN0cmluZyhrZXkpKSArICc9JyArIHF1ZXJ5U3RyaW5nW2tleV1baV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVyaSArPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICByZXR1cm4gdXJpO1xufVxuXG5mdW5jdGlvbiBwb3B1bGF0ZVVSSShyZXEpIHtcbiAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICB2YXIgaW5wdXQgPSBvcGVyYXRpb24uaW5wdXQ7XG5cbiAgdmFyIHVyaSA9IGdlbmVyYXRlVVJJKHJlcS5odHRwUmVxdWVzdC5lbmRwb2ludC5wYXRoLCBvcGVyYXRpb24uaHR0cFBhdGgsIGlucHV0LCByZXEucGFyYW1zKTtcbiAgcmVxLmh0dHBSZXF1ZXN0LnBhdGggPSB1cmk7XG59XG5cbmZ1bmN0aW9uIHBvcHVsYXRlSGVhZGVycyhyZXEpIHtcbiAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICB1dGlsLmVhY2gob3BlcmF0aW9uLmlucHV0Lm1lbWJlcnMsIGZ1bmN0aW9uIChuYW1lLCBtZW1iZXIpIHtcbiAgICB2YXIgdmFsdWUgPSByZXEucGFyYW1zW25hbWVdO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICBpZiAobWVtYmVyLmxvY2F0aW9uID09PSAnaGVhZGVycycgJiYgbWVtYmVyLnR5cGUgPT09ICdtYXAnKSB7XG4gICAgICB1dGlsLmVhY2godmFsdWUsIGZ1bmN0aW9uKGtleSwgbWVtYmVyVmFsdWUpIHtcbiAgICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbbWVtYmVyLm5hbWUgKyBrZXldID0gbWVtYmVyVmFsdWU7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gJ2hlYWRlcicpIHtcbiAgICAgIHZhbHVlID0gbWVtYmVyLnRvV2lyZUZvcm1hdCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgIGlmIChtZW1iZXIuaXNKc29uVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB1dGlsLmJhc2U2NC5lbmNvZGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbbWVtYmVyLm5hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYnVpbGRSZXF1ZXN0KHJlcSkge1xuICBwb3B1bGF0ZU1ldGhvZChyZXEpO1xuICBwb3B1bGF0ZVVSSShyZXEpO1xuICBwb3B1bGF0ZUhlYWRlcnMocmVxKTtcbiAgcG9wdWxhdGVIb3N0UHJlZml4KHJlcSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFcnJvcigpIHtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdERhdGEocmVzcCkge1xuICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgciA9IHJlc3AuaHR0cFJlc3BvbnNlO1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHZhciBvdXRwdXQgPSBvcGVyYXRpb24ub3V0cHV0O1xuXG4gIC8vIG5vcm1hbGl6ZSBoZWFkZXJzIG5hbWVzIHRvIGxvd2VyLWNhc2VkIGtleXMgZm9yIG1hdGNoaW5nXG4gIHZhciBoZWFkZXJzID0ge307XG4gIHV0aWwuZWFjaChyLmhlYWRlcnMsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaGVhZGVyc1trLnRvTG93ZXJDYXNlKCldID0gdjtcbiAgfSk7XG5cbiAgdXRpbC5lYWNoKG91dHB1dC5tZW1iZXJzLCBmdW5jdGlvbihuYW1lLCBtZW1iZXIpIHtcbiAgICB2YXIgaGVhZGVyID0gKG1lbWJlci5uYW1lIHx8IG5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gJ2hlYWRlcnMnICYmIG1lbWJlci50eXBlID09PSAnbWFwJykge1xuICAgICAgZGF0YVtuYW1lXSA9IHt9O1xuICAgICAgdmFyIGxvY2F0aW9uID0gbWVtYmVyLmlzTG9jYXRpb25OYW1lID8gbWVtYmVyLm5hbWUgOiAnJztcbiAgICAgIHZhciBwYXR0ZXJuID0gbmV3IFJlZ0V4cCgnXicgKyBsb2NhdGlvbiArICcoLispJywgJ2knKTtcbiAgICAgIHV0aWwuZWFjaChyLmhlYWRlcnMsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBrLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgZGF0YVtuYW1lXVtyZXN1bHRbMV1dID0gdjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChtZW1iZXIubG9jYXRpb24gPT09ICdoZWFkZXInKSB7XG4gICAgICBpZiAoaGVhZGVyc1toZWFkZXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbWVtYmVyLmlzSnNvblZhbHVlID9cbiAgICAgICAgICB1dGlsLmJhc2U2NC5kZWNvZGUoaGVhZGVyc1toZWFkZXJdKSA6XG4gICAgICAgICAgaGVhZGVyc1toZWFkZXJdO1xuICAgICAgICBkYXRhW25hbWVdID0gbWVtYmVyLnRvVHlwZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtZW1iZXIubG9jYXRpb24gPT09ICdzdGF0dXNDb2RlJykge1xuICAgICAgZGF0YVtuYW1lXSA9IHBhcnNlSW50KHIuc3RhdHVzQ29kZSwgMTApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmVzcC5kYXRhID0gZGF0YTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJ1aWxkUmVxdWVzdDogYnVpbGRSZXF1ZXN0LFxuICBleHRyYWN0RXJyb3I6IGV4dHJhY3RFcnJvcixcbiAgZXh0cmFjdERhdGE6IGV4dHJhY3REYXRhLFxuICBnZW5lcmF0ZVVSSTogZ2VuZXJhdGVVUklcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBSZXN0ID0gcmVxdWlyZSgnLi9yZXN0Jyk7XG52YXIgSnNvbiA9IHJlcXVpcmUoJy4vanNvbicpO1xudmFyIEpzb25CdWlsZGVyID0gcmVxdWlyZSgnLi4vanNvbi9idWlsZGVyJyk7XG52YXIgSnNvblBhcnNlciA9IHJlcXVpcmUoJy4uL2pzb24vcGFyc2VyJyk7XG5cbmZ1bmN0aW9uIHBvcHVsYXRlQm9keShyZXEpIHtcbiAgdmFyIGJ1aWxkZXIgPSBuZXcgSnNvbkJ1aWxkZXIoKTtcbiAgdmFyIGlucHV0ID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0uaW5wdXQ7XG5cbiAgaWYgKGlucHV0LnBheWxvYWQpIHtcbiAgICB2YXIgcGFyYW1zID0ge307XG4gICAgdmFyIHBheWxvYWRTaGFwZSA9IGlucHV0Lm1lbWJlcnNbaW5wdXQucGF5bG9hZF07XG4gICAgcGFyYW1zID0gcmVxLnBhcmFtc1tpbnB1dC5wYXlsb2FkXTtcbiAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIGlmIChwYXlsb2FkU2hhcGUudHlwZSA9PT0gJ3N0cnVjdHVyZScpIHtcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5ib2R5ID0gYnVpbGRlci5idWlsZChwYXJhbXMsIHBheWxvYWRTaGFwZSk7XG4gICAgICBhcHBseUNvbnRlbnRUeXBlSGVhZGVyKHJlcSk7XG4gICAgfSBlbHNlIHsgLy8gbm9uLUpTT04gcGF5bG9hZFxuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmJvZHkgPSBwYXJhbXM7XG4gICAgICBpZiAocGF5bG9hZFNoYXBlLnR5cGUgPT09ICdiaW5hcnknIHx8IHBheWxvYWRTaGFwZS5pc1N0cmVhbWluZykge1xuICAgICAgICBhcHBseUNvbnRlbnRUeXBlSGVhZGVyKHJlcSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBib2R5ID0gYnVpbGRlci5idWlsZChyZXEucGFyYW1zLCBpbnB1dCk7XG4gICAgaWYgKGJvZHkgIT09ICd7fScgfHwgcmVxLmh0dHBSZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcpIHsgLy9kb24ndCBzZW5kIGVtcHR5IGJvZHkgZm9yIEdFVCBtZXRob2RcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5ib2R5ID0gYm9keTtcbiAgICB9XG4gICAgYXBwbHlDb250ZW50VHlwZUhlYWRlcihyZXEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5Q29udGVudFR5cGVIZWFkZXIocmVxLCBpc0JpbmFyeSkge1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHZhciBpbnB1dCA9IG9wZXJhdGlvbi5pbnB1dDtcblxuICBpZiAoIXJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSkge1xuICAgIHZhciB0eXBlID0gaXNCaW5hcnkgPyAnYmluYXJ5L29jdGV0LXN0cmVhbScgOiAnYXBwbGljYXRpb24vanNvbic7XG4gICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdHlwZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFJlcXVlc3QocmVxKSB7XG4gIFJlc3QuYnVpbGRSZXF1ZXN0KHJlcSk7XG5cbiAgLy8gbmV2ZXIgc2VuZCBib2R5IHBheWxvYWQgb24gSEVBRC9ERUxFVEVcbiAgaWYgKFsnSEVBRCcsICdERUxFVEUnXS5pbmRleE9mKHJlcS5odHRwUmVxdWVzdC5tZXRob2QpIDwgMCkge1xuICAgIHBvcHVsYXRlQm9keShyZXEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFcnJvcihyZXNwKSB7XG4gIEpzb24uZXh0cmFjdEVycm9yKHJlc3ApO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RGF0YShyZXNwKSB7XG4gIFJlc3QuZXh0cmFjdERhdGEocmVzcCk7XG5cbiAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICB2YXIgcnVsZXMgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5vdXRwdXQgfHwge307XG4gIHZhciBwYXJzZXI7XG4gIHZhciBoYXNFdmVudE91dHB1dCA9IG9wZXJhdGlvbi5oYXNFdmVudE91dHB1dDtcblxuICBpZiAocnVsZXMucGF5bG9hZCkge1xuICAgIHZhciBwYXlsb2FkTWVtYmVyID0gcnVsZXMubWVtYmVyc1tydWxlcy5wYXlsb2FkXTtcbiAgICB2YXIgYm9keSA9IHJlc3AuaHR0cFJlc3BvbnNlLmJvZHk7XG4gICAgaWYgKHBheWxvYWRNZW1iZXIuaXNFdmVudFN0cmVhbSkge1xuICAgICAgcGFyc2VyID0gbmV3IEpzb25QYXJzZXIoKTtcbiAgICAgIHJlc3AuZGF0YVtwYXlsb2FkXSA9IHV0aWwuY3JlYXRlRXZlbnRTdHJlYW0oXG4gICAgICAgIEFXUy5IdHRwQ2xpZW50LnN0cmVhbXNBcGlWZXJzaW9uID09PSAyID8gcmVzcC5odHRwUmVzcG9uc2Uuc3RyZWFtIDogYm9keSxcbiAgICAgICAgcGFyc2VyLFxuICAgICAgICBwYXlsb2FkTWVtYmVyXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZE1lbWJlci50eXBlID09PSAnc3RydWN0dXJlJyB8fCBwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBKc29uUGFyc2VyKCk7XG4gICAgICByZXNwLmRhdGFbcnVsZXMucGF5bG9hZF0gPSBwYXJzZXIucGFyc2UoYm9keSwgcGF5bG9hZE1lbWJlcik7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdiaW5hcnknIHx8IHBheWxvYWRNZW1iZXIuaXNTdHJlYW1pbmcpIHtcbiAgICAgIHJlc3AuZGF0YVtydWxlcy5wYXlsb2FkXSA9IGJvZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3AuZGF0YVtydWxlcy5wYXlsb2FkXSA9IHBheWxvYWRNZW1iZXIudG9UeXBlKGJvZHkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZGF0YSA9IHJlc3AuZGF0YTtcbiAgICBKc29uLmV4dHJhY3REYXRhKHJlc3ApO1xuICAgIHJlc3AuZGF0YSA9IHV0aWwubWVyZ2UoZGF0YSwgcmVzcC5kYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYnVpbGRSZXF1ZXN0OiBidWlsZFJlcXVlc3QsXG4gIGV4dHJhY3RFcnJvcjogZXh0cmFjdEVycm9yLFxuICBleHRyYWN0RGF0YTogZXh0cmFjdERhdGFcbn07XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgUmVzdCA9IHJlcXVpcmUoJy4vcmVzdCcpO1xuXG5mdW5jdGlvbiBwb3B1bGF0ZUJvZHkocmVxKSB7XG4gIHZhciBpbnB1dCA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLmlucHV0O1xuICB2YXIgYnVpbGRlciA9IG5ldyBBV1MuWE1MLkJ1aWxkZXIoKTtcbiAgdmFyIHBhcmFtcyA9IHJlcS5wYXJhbXM7XG5cbiAgdmFyIHBheWxvYWQgPSBpbnB1dC5wYXlsb2FkO1xuICBpZiAocGF5bG9hZCkge1xuICAgIHZhciBwYXlsb2FkTWVtYmVyID0gaW5wdXQubWVtYmVyc1twYXlsb2FkXTtcbiAgICBwYXJhbXMgPSBwYXJhbXNbcGF5bG9hZF07XG4gICAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICBpZiAocGF5bG9hZE1lbWJlci50eXBlID09PSAnc3RydWN0dXJlJykge1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gcGF5bG9hZE1lbWJlci5uYW1lO1xuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmJvZHkgPSBidWlsZGVyLnRvWE1MKHBhcmFtcywgcGF5bG9hZE1lbWJlciwgcm9vdEVsZW1lbnQsIHRydWUpO1xuICAgIH0gZWxzZSB7IC8vIG5vbi14bWwgcGF5bG9hZFxuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmJvZHkgPSBwYXJhbXM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcS5odHRwUmVxdWVzdC5ib2R5ID0gYnVpbGRlci50b1hNTChwYXJhbXMsIGlucHV0LCBpbnB1dC5uYW1lIHx8XG4gICAgICBpbnB1dC5zaGFwZSB8fCB1dGlsLnN0cmluZy51cHBlckZpcnN0KHJlcS5vcGVyYXRpb24pICsgJ1JlcXVlc3QnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFJlcXVlc3QocmVxKSB7XG4gIFJlc3QuYnVpbGRSZXF1ZXN0KHJlcSk7XG5cbiAgLy8gbmV2ZXIgc2VuZCBib2R5IHBheWxvYWQgb24gR0VUL0hFQURcbiAgaWYgKFsnR0VUJywgJ0hFQUQnXS5pbmRleE9mKHJlcS5odHRwUmVxdWVzdC5tZXRob2QpIDwgMCkge1xuICAgIHBvcHVsYXRlQm9keShyZXEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFcnJvcihyZXNwKSB7XG4gIFJlc3QuZXh0cmFjdEVycm9yKHJlc3ApO1xuXG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSBuZXcgQVdTLlhNTC5QYXJzZXIoKS5wYXJzZShyZXNwLmh0dHBSZXNwb25zZS5ib2R5LnRvU3RyaW5nKCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGF0YSA9IHtcbiAgICAgIENvZGU6IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICBNZXNzYWdlOiByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNNZXNzYWdlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChkYXRhLkVycm9ycykgZGF0YSA9IGRhdGEuRXJyb3JzO1xuICBpZiAoZGF0YS5FcnJvcikgZGF0YSA9IGRhdGEuRXJyb3I7XG4gIGlmIChkYXRhLkNvZGUpIHtcbiAgICByZXNwLmVycm9yID0gdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgY29kZTogZGF0YS5Db2RlLFxuICAgICAgbWVzc2FnZTogZGF0YS5NZXNzYWdlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVzcC5lcnJvciA9IHV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgIGNvZGU6IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICBtZXNzYWdlOiBudWxsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdERhdGEocmVzcCkge1xuICBSZXN0LmV4dHJhY3REYXRhKHJlc3ApO1xuXG4gIHZhciBwYXJzZXI7XG4gIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gIHZhciBib2R5ID0gcmVzcC5odHRwUmVzcG9uc2UuYm9keTtcbiAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICB2YXIgb3V0cHV0ID0gb3BlcmF0aW9uLm91dHB1dDtcblxuICB2YXIgaGFzRXZlbnRPdXRwdXQgPSBvcGVyYXRpb24uaGFzRXZlbnRPdXRwdXQ7XG5cbiAgdmFyIHBheWxvYWQgPSBvdXRwdXQucGF5bG9hZDtcbiAgaWYgKHBheWxvYWQpIHtcbiAgICB2YXIgcGF5bG9hZE1lbWJlciA9IG91dHB1dC5tZW1iZXJzW3BheWxvYWRdO1xuICAgIGlmIChwYXlsb2FkTWVtYmVyLmlzRXZlbnRTdHJlYW0pIHtcbiAgICAgIHBhcnNlciA9IG5ldyBBV1MuWE1MLlBhcnNlcigpO1xuICAgICAgcmVzcC5kYXRhW3BheWxvYWRdID0gdXRpbC5jcmVhdGVFdmVudFN0cmVhbShcbiAgICAgICAgQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIgPyByZXNwLmh0dHBSZXNwb25zZS5zdHJlYW0gOiByZXNwLmh0dHBSZXNwb25zZS5ib2R5LFxuICAgICAgICBwYXJzZXIsXG4gICAgICAgIHBheWxvYWRNZW1iZXJcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdzdHJ1Y3R1cmUnKSB7XG4gICAgICBwYXJzZXIgPSBuZXcgQVdTLlhNTC5QYXJzZXIoKTtcbiAgICAgIHJlc3AuZGF0YVtwYXlsb2FkXSA9IHBhcnNlci5wYXJzZShib2R5LnRvU3RyaW5nKCksIHBheWxvYWRNZW1iZXIpO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZE1lbWJlci50eXBlID09PSAnYmluYXJ5JyB8fCBwYXlsb2FkTWVtYmVyLmlzU3RyZWFtaW5nKSB7XG4gICAgICByZXNwLmRhdGFbcGF5bG9hZF0gPSBib2R5O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNwLmRhdGFbcGF5bG9hZF0gPSBwYXlsb2FkTWVtYmVyLnRvVHlwZShib2R5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYm9keS5sZW5ndGggPiAwKSB7XG4gICAgcGFyc2VyID0gbmV3IEFXUy5YTUwuUGFyc2VyKCk7XG4gICAgdmFyIGRhdGEgPSBwYXJzZXIucGFyc2UoYm9keS50b1N0cmluZygpLCBvdXRwdXQpO1xuICAgIHV0aWwudXBkYXRlKHJlc3AuZGF0YSwgZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJ1aWxkUmVxdWVzdDogYnVpbGRSZXF1ZXN0LFxuICBleHRyYWN0RXJyb3I6IGV4dHJhY3RFcnJvcixcbiAgZXh0cmFjdERhdGE6IGV4dHJhY3REYXRhXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmZ1bmN0aW9uIFF1ZXJ5UGFyYW1TZXJpYWxpemVyKCkge1xufVxuXG5RdWVyeVBhcmFtU2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24ocGFyYW1zLCBzaGFwZSwgZm4pIHtcbiAgc2VyaWFsaXplU3RydWN0dXJlKCcnLCBwYXJhbXMsIHNoYXBlLCBmbik7XG59O1xuXG5mdW5jdGlvbiB1Y2ZpcnN0KHNoYXBlKSB7XG4gIGlmIChzaGFwZS5pc1F1ZXJ5TmFtZSB8fCBzaGFwZS5hcGkucHJvdG9jb2wgIT09ICdlYzInKSB7XG4gICAgcmV0dXJuIHNoYXBlLm5hbWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNoYXBlLm5hbWVbMF0udG9VcHBlckNhc2UoKSArIHNoYXBlLm5hbWUuc3Vic3RyKDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVN0cnVjdHVyZShwcmVmaXgsIHN0cnVjdCwgcnVsZXMsIGZuKSB7XG4gIHV0aWwuZWFjaChydWxlcy5tZW1iZXJzLCBmdW5jdGlvbihuYW1lLCBtZW1iZXIpIHtcbiAgICB2YXIgdmFsdWUgPSBzdHJ1Y3RbbmFtZV07XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIHZhciBtZW1iZXJOYW1lID0gdWNmaXJzdChtZW1iZXIpO1xuICAgIG1lbWJlck5hbWUgPSBwcmVmaXggPyBwcmVmaXggKyAnLicgKyBtZW1iZXJOYW1lIDogbWVtYmVyTmFtZTtcbiAgICBzZXJpYWxpemVNZW1iZXIobWVtYmVyTmFtZSwgdmFsdWUsIG1lbWJlciwgZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplTWFwKG5hbWUsIG1hcCwgcnVsZXMsIGZuKSB7XG4gIHZhciBpID0gMTtcbiAgdXRpbC5lYWNoKG1hcCwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgcHJlZml4ID0gcnVsZXMuZmxhdHRlbmVkID8gJy4nIDogJy5lbnRyeS4nO1xuICAgIHZhciBwb3NpdGlvbiA9IHByZWZpeCArIChpKyspICsgJy4nO1xuICAgIHZhciBrZXlOYW1lID0gcG9zaXRpb24gKyAocnVsZXMua2V5Lm5hbWUgfHwgJ2tleScpO1xuICAgIHZhciB2YWx1ZU5hbWUgPSBwb3NpdGlvbiArIChydWxlcy52YWx1ZS5uYW1lIHx8ICd2YWx1ZScpO1xuICAgIHNlcmlhbGl6ZU1lbWJlcihuYW1lICsga2V5TmFtZSwga2V5LCBydWxlcy5rZXksIGZuKTtcbiAgICBzZXJpYWxpemVNZW1iZXIobmFtZSArIHZhbHVlTmFtZSwgdmFsdWUsIHJ1bGVzLnZhbHVlLCBmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVMaXN0KG5hbWUsIGxpc3QsIHJ1bGVzLCBmbikge1xuICB2YXIgbWVtYmVyUnVsZXMgPSBydWxlcy5tZW1iZXIgfHwge307XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgZm4uY2FsbCh0aGlzLCBuYW1lLCBudWxsKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB1dGlsLmFycmF5RWFjaChsaXN0LCBmdW5jdGlvbiAodiwgbikge1xuICAgIHZhciBzdWZmaXggPSAnLicgKyAobiArIDEpO1xuICAgIGlmIChydWxlcy5hcGkucHJvdG9jb2wgPT09ICdlYzInKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGZvciBFQzJcbiAgICAgIHN1ZmZpeCA9IHN1ZmZpeCArICcnOyAvLyBtYWtlIGxpbnRlciBoYXBweVxuICAgIH0gZWxzZSBpZiAocnVsZXMuZmxhdHRlbmVkKSB7XG4gICAgICBpZiAobWVtYmVyUnVsZXMubmFtZSkge1xuICAgICAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICBwYXJ0cy5wdXNoKHVjZmlyc3QobWVtYmVyUnVsZXMpKTtcbiAgICAgICAgbmFtZSA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VmZml4ID0gJy4nICsgKG1lbWJlclJ1bGVzLm5hbWUgPyBtZW1iZXJSdWxlcy5uYW1lIDogJ21lbWJlcicpICsgc3VmZml4O1xuICAgIH1cbiAgICBzZXJpYWxpemVNZW1iZXIobmFtZSArIHN1ZmZpeCwgdiwgbWVtYmVyUnVsZXMsIGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZU1lbWJlcihuYW1lLCB2YWx1ZSwgcnVsZXMsIGZuKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gIGlmIChydWxlcy50eXBlID09PSAnc3RydWN0dXJlJykge1xuICAgIHNlcmlhbGl6ZVN0cnVjdHVyZShuYW1lLCB2YWx1ZSwgcnVsZXMsIGZuKTtcbiAgfSBlbHNlIGlmIChydWxlcy50eXBlID09PSAnbGlzdCcpIHtcbiAgICBzZXJpYWxpemVMaXN0KG5hbWUsIHZhbHVlLCBydWxlcywgZm4pO1xuICB9IGVsc2UgaWYgKHJ1bGVzLnR5cGUgPT09ICdtYXAnKSB7XG4gICAgc2VyaWFsaXplTWFwKG5hbWUsIHZhbHVlLCBydWxlcywgZm4pO1xuICB9IGVsc2Uge1xuICAgIGZuKG5hbWUsIHJ1bGVzLnRvV2lyZUZvcm1hdCh2YWx1ZSkudG9TdHJpbmcoKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBRdWVyeVBhcmFtU2VyaWFsaXplcjtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAvL3Byb3ZpZGUgcmVhbHRpbWUgY2xvY2sgZm9yIHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50XG4gIG5vdzogZnVuY3Rpb24gbm93KCkge1xuICAgIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH1cbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIHJlZ2lvbkNvbmZpZyA9IHJlcXVpcmUoJy4vcmVnaW9uX2NvbmZpZ19kYXRhLmpzb24nKTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVSZWdpb25QcmVmaXgocmVnaW9uKSB7XG4gIGlmICghcmVnaW9uKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcGFydHMgPSByZWdpb24uc3BsaXQoJy0nKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA8IDMpIHJldHVybiBudWxsO1xuICByZXR1cm4gcGFydHMuc2xpY2UoMCwgcGFydHMubGVuZ3RoIC0gMikuam9pbignLScpICsgJy0qJztcbn1cblxuZnVuY3Rpb24gZGVyaXZlZEtleXMoc2VydmljZSkge1xuICB2YXIgcmVnaW9uID0gc2VydmljZS5jb25maWcucmVnaW9uO1xuICB2YXIgcmVnaW9uUHJlZml4ID0gZ2VuZXJhdGVSZWdpb25QcmVmaXgocmVnaW9uKTtcbiAgdmFyIGVuZHBvaW50UHJlZml4ID0gc2VydmljZS5hcGkuZW5kcG9pbnRQcmVmaXg7XG5cbiAgcmV0dXJuIFtcbiAgICBbcmVnaW9uLCBlbmRwb2ludFByZWZpeF0sXG4gICAgW3JlZ2lvblByZWZpeCwgZW5kcG9pbnRQcmVmaXhdLFxuICAgIFtyZWdpb24sICcqJ10sXG4gICAgW3JlZ2lvblByZWZpeCwgJyonXSxcbiAgICBbJyonLCBlbmRwb2ludFByZWZpeF0sXG4gICAgWycqJywgJyonXVxuICBdLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1bMF0gJiYgaXRlbVsxXSA/IGl0ZW0uam9pbignLycpIDogbnVsbDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5Q29uZmlnKHNlcnZpY2UsIGNvbmZpZykge1xuICB1dGlsLmVhY2goY29uZmlnLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSA9PT0gJ2dsb2JhbEVuZHBvaW50JykgcmV0dXJuO1xuICAgIGlmIChzZXJ2aWNlLmNvbmZpZ1trZXldID09PSB1bmRlZmluZWQgfHwgc2VydmljZS5jb25maWdba2V5XSA9PT0gbnVsbCkge1xuICAgICAgc2VydmljZS5jb25maWdba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZUVuZHBvaW50KHNlcnZpY2UpIHtcbiAgdmFyIGtleXMgPSBkZXJpdmVkS2V5cyhzZXJ2aWNlKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFrZXkpIGNvbnRpbnVlO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWdpb25Db25maWcucnVsZXMsIGtleSkpIHtcbiAgICAgIHZhciBjb25maWcgPSByZWdpb25Db25maWcucnVsZXNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25maWcgPSByZWdpb25Db25maWcucGF0dGVybnNbY29uZmlnXTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IGR1YWxzdGFjayBlbmRwb2ludFxuICAgICAgaWYgKHNlcnZpY2UuY29uZmlnLnVzZUR1YWxzdGFjayAmJiB1dGlsLmlzRHVhbHN0YWNrQXZhaWxhYmxlKHNlcnZpY2UpKSB7XG4gICAgICAgIGNvbmZpZyA9IHV0aWwuY29weShjb25maWcpO1xuICAgICAgICBjb25maWcuZW5kcG9pbnQgPSAne3NlcnZpY2V9LmR1YWxzdGFjay57cmVnaW9ufS5hbWF6b25hd3MuY29tJztcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IGdsb2JhbCBlbmRwb2ludFxuICAgICAgc2VydmljZS5pc0dsb2JhbEVuZHBvaW50ID0gISFjb25maWcuZ2xvYmFsRW5kcG9pbnQ7XG5cbiAgICAgIC8vIHNpZ25hdHVyZSB2ZXJzaW9uXG4gICAgICBpZiAoIWNvbmZpZy5zaWduYXR1cmVWZXJzaW9uKSBjb25maWcuc2lnbmF0dXJlVmVyc2lvbiA9ICd2NCc7XG5cbiAgICAgIC8vIG1lcmdlIGNvbmZpZ1xuICAgICAgYXBwbHlDb25maWcoc2VydmljZSwgY29uZmlnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RW5kcG9pbnRTdWZmaXgocmVnaW9uKSB7XG4gIHZhciByZWdpb25SZWdleGVzID0ge1xuICAgICdeKHVzfGV1fGFwfHNhfGNhfG1lKVxcXFwtXFxcXHcrXFxcXC1cXFxcZCskJzogJ2FtYXpvbmF3cy5jb20nLFxuICAgICdeY25cXFxcLVxcXFx3K1xcXFwtXFxcXGQrJCc6ICdhbWF6b25hd3MuY29tLmNuJyxcbiAgICAnXnVzXFxcXC1nb3ZcXFxcLVxcXFx3K1xcXFwtXFxcXGQrJCc6ICdhbWF6b25hd3MuY29tJyxcbiAgICAnXnVzXFxcXC1pc29cXFxcLVxcXFx3K1xcXFwtXFxcXGQrJCc6ICdjMnMuaWMuZ292JyxcbiAgICAnXnVzXFxcXC1pc29iXFxcXC1cXFxcdytcXFxcLVxcXFxkKyQnOiAnc2Mycy5zZ292LmdvdidcbiAgfTtcbiAgdmFyIGRlZmF1bHRTdWZmaXggPSAnYW1hem9uYXdzLmNvbSc7XG4gIHZhciByZWdleGVzID0gT2JqZWN0LmtleXMocmVnaW9uUmVnZXhlcyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnZXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByZWdpb25QYXR0ZXJuID0gUmVnRXhwKHJlZ2V4ZXNbaV0pO1xuICAgIHZhciBkbnNTdWZmaXggPSByZWdpb25SZWdleGVzW3JlZ2V4ZXNbaV1dO1xuICAgIGlmIChyZWdpb25QYXR0ZXJuLnRlc3QocmVnaW9uKSkgcmV0dXJuIGRuc1N1ZmZpeDtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFN1ZmZpeDtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbmZpZ3VyZUVuZHBvaW50OiBjb25maWd1cmVFbmRwb2ludCxcbiAgZ2V0RW5kcG9pbnRTdWZmaXg6IGdldEVuZHBvaW50U3VmZml4XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcInJ1bGVzXCI6IHtcbiAgICBcIiovKlwiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwie3NlcnZpY2V9LntyZWdpb259LmFtYXpvbmF3cy5jb21cIlxuICAgIH0sXG4gICAgXCJjbi0qLypcIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcIntzZXJ2aWNlfS57cmVnaW9ufS5hbWF6b25hd3MuY29tLmNuXCJcbiAgICB9LFxuICAgIFwiKi9idWRnZXRzXCI6IFwiZ2xvYmFsU1NMXCIsXG4gICAgXCIqL2Nsb3VkZnJvbnRcIjogXCJnbG9iYWxTU0xcIixcbiAgICBcIiovaWFtXCI6IFwiZ2xvYmFsU1NMXCIsXG4gICAgXCIqL3N0c1wiOiBcImdsb2JhbFNTTFwiLFxuICAgIFwiKi9pbXBvcnRleHBvcnRcIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcIntzZXJ2aWNlfS5hbWF6b25hd3MuY29tXCIsXG4gICAgICBcInNpZ25hdHVyZVZlcnNpb25cIjogXCJ2MlwiLFxuICAgICAgXCJnbG9iYWxFbmRwb2ludFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIiovcm91dGU1M1wiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwiaHR0cHM6Ly97c2VydmljZX0uYW1hem9uYXdzLmNvbVwiLFxuICAgICAgXCJzaWduYXR1cmVWZXJzaW9uXCI6IFwidjNodHRwc1wiLFxuICAgICAgXCJnbG9iYWxFbmRwb2ludFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIiovd2FmXCI6IFwiZ2xvYmFsU1NMXCIsXG4gICAgXCJ1cy1nb3YtKi9pYW1cIjogXCJnbG9iYWxHb3ZDbG91ZFwiLFxuICAgIFwidXMtZ292LSovc3RzXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0ue3JlZ2lvbn0uYW1hem9uYXdzLmNvbVwiXG4gICAgfSxcbiAgICBcInVzLWdvdi13ZXN0LTEvczNcIjogXCJzM3NpZ25hdHVyZVwiLFxuICAgIFwidXMtd2VzdC0xL3MzXCI6IFwiczNzaWduYXR1cmVcIixcbiAgICBcInVzLXdlc3QtMi9zM1wiOiBcInMzc2lnbmF0dXJlXCIsXG4gICAgXCJldS13ZXN0LTEvczNcIjogXCJzM3NpZ25hdHVyZVwiLFxuICAgIFwiYXAtc291dGhlYXN0LTEvczNcIjogXCJzM3NpZ25hdHVyZVwiLFxuICAgIFwiYXAtc291dGhlYXN0LTIvczNcIjogXCJzM3NpZ25hdHVyZVwiLFxuICAgIFwiYXAtbm9ydGhlYXN0LTEvczNcIjogXCJzM3NpZ25hdHVyZVwiLFxuICAgIFwic2EtZWFzdC0xL3MzXCI6IFwiczNzaWduYXR1cmVcIixcbiAgICBcInVzLWVhc3QtMS9zM1wiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwie3NlcnZpY2V9LmFtYXpvbmF3cy5jb21cIixcbiAgICAgIFwic2lnbmF0dXJlVmVyc2lvblwiOiBcInMzXCJcbiAgICB9LFxuICAgIFwidXMtZWFzdC0xL3NkYlwiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwie3NlcnZpY2V9LmFtYXpvbmF3cy5jb21cIixcbiAgICAgIFwic2lnbmF0dXJlVmVyc2lvblwiOiBcInYyXCJcbiAgICB9LFxuICAgIFwiKi9zZGJcIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcIntzZXJ2aWNlfS57cmVnaW9ufS5hbWF6b25hd3MuY29tXCIsXG4gICAgICBcInNpZ25hdHVyZVZlcnNpb25cIjogXCJ2MlwiXG4gICAgfVxuICB9LFxuXG4gIFwicGF0dGVybnNcIjoge1xuICAgIFwiZ2xvYmFsU1NMXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJodHRwczovL3tzZXJ2aWNlfS5hbWF6b25hd3MuY29tXCIsXG4gICAgICBcImdsb2JhbEVuZHBvaW50XCI6IHRydWVcbiAgICB9LFxuICAgIFwiZ2xvYmFsR292Q2xvdWRcIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcIntzZXJ2aWNlfS51cy1nb3YuYW1hem9uYXdzLmNvbVwiXG4gICAgfSxcbiAgICBcInMzc2lnbmF0dXJlXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0ue3JlZ2lvbn0uYW1hem9uYXdzLmNvbVwiLFxuICAgICAgXCJzaWduYXR1cmVWZXJzaW9uXCI6IFwiczNcIlxuICAgIH1cbiAgfVxufVxuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIEFjY2VwdG9yU3RhdGVNYWNoaW5lID0gcmVxdWlyZSgnLi9zdGF0ZV9tYWNoaW5lJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG52YXIgZG9tYWluID0gQVdTLnV0aWwuZG9tYWluO1xudmFyIGptZXNwYXRoID0gcmVxdWlyZSgnam1lc3BhdGgnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIGhhcmRFcnJvclN0YXRlcyA9IHtzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDF9O1xuXG5mdW5jdGlvbiBpc1Rlcm1pbmFsU3RhdGUobWFjaGluZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhhcmRFcnJvclN0YXRlcywgbWFjaGluZS5fYXNtLmN1cnJlbnRTdGF0ZSk7XG59XG5cbnZhciBmc20gPSBuZXcgQWNjZXB0b3JTdGF0ZU1hY2hpbmUoKTtcbmZzbS5zZXR1cFN0YXRlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHJhbnNpdGlvbiA9IGZ1bmN0aW9uKF8sIGRvbmUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5faGFsdEhhbmRsZXJzT25FcnJvciA9IGZhbHNlO1xuXG4gICAgc2VsZi5lbWl0KHNlbGYuX2FzbS5jdXJyZW50U3RhdGUsIGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoaXNUZXJtaW5hbFN0YXRlKHNlbGYpKSB7XG4gICAgICAgICAgaWYgKGRvbWFpbiAmJiBzZWxmLmRvbWFpbiBpbnN0YW5jZW9mIGRvbWFpbi5Eb21haW4pIHtcbiAgICAgICAgICAgIGVyci5kb21haW5FbWl0dGVyID0gc2VsZjtcbiAgICAgICAgICAgIGVyci5kb21haW4gPSBzZWxmLmRvbWFpbjtcbiAgICAgICAgICAgIGVyci5kb21haW5UaHJvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYuZG9tYWluLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnJlc3BvbnNlLmVycm9yID0gZXJyO1xuICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZShzZWxmLnJlc3BvbnNlLmVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9O1xuXG4gIHRoaXMuYWRkU3RhdGUoJ3ZhbGlkYXRlJywgJ2J1aWxkJywgJ2Vycm9yJywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2J1aWxkJywgJ2FmdGVyQnVpbGQnLCAncmVzdGFydCcsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdhZnRlckJ1aWxkJywgJ3NpZ24nLCAncmVzdGFydCcsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdzaWduJywgJ3NlbmQnLCAncmV0cnknLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgncmV0cnknLCAnYWZ0ZXJSZXRyeScsICdhZnRlclJldHJ5JywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2FmdGVyUmV0cnknLCAnc2lnbicsICdlcnJvcicsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdzZW5kJywgJ3ZhbGlkYXRlUmVzcG9uc2UnLCAncmV0cnknLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgndmFsaWRhdGVSZXNwb25zZScsICdleHRyYWN0RGF0YScsICdleHRyYWN0RXJyb3InLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgnZXh0cmFjdEVycm9yJywgJ2V4dHJhY3REYXRhJywgJ3JldHJ5JywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2V4dHJhY3REYXRhJywgJ3N1Y2Nlc3MnLCAncmV0cnknLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgncmVzdGFydCcsICdidWlsZCcsICdlcnJvcicsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdzdWNjZXNzJywgJ2NvbXBsZXRlJywgJ2NvbXBsZXRlJywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2Vycm9yJywgJ2NvbXBsZXRlJywgJ2NvbXBsZXRlJywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2NvbXBsZXRlJywgbnVsbCwgbnVsbCwgdHJhbnNpdGlvbik7XG59O1xuZnNtLnNldHVwU3RhdGVzKCk7XG5cbi8qKlxuICogIyMgQXN5bmNocm9ub3VzIFJlcXVlc3RzXG4gKlxuICogQWxsIHJlcXVlc3RzIG1hZGUgdGhyb3VnaCB0aGUgU0RLIGFyZSBhc3luY2hyb25vdXMgYW5kIHVzZSBhXG4gKiBjYWxsYmFjayBpbnRlcmZhY2UuIEVhY2ggc2VydmljZSBtZXRob2QgdGhhdCBraWNrcyBvZmYgYSByZXF1ZXN0XG4gKiByZXR1cm5zIGFuIGBBV1MuUmVxdWVzdGAgb2JqZWN0IHRoYXQgeW91IGNhbiB1c2UgdG8gcmVnaXN0ZXJcbiAqIGNhbGxiYWNrcy5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBzZXJ2aWNlIG1ldGhvZCByZXR1cm5zIHRoZSByZXF1ZXN0XG4gKiBvYmplY3QgYXMgXCJyZXF1ZXN0XCIsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlZ2lzdGVyIGNhbGxiYWNrczpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyByZXF1ZXN0IGlzIGFuIEFXUy5SZXF1ZXN0IG9iamVjdFxuICogdmFyIHJlcXVlc3QgPSBlYzIuZGVzY3JpYmVJbnN0YW5jZXMoKTtcbiAqXG4gKiAvLyByZWdpc3RlciBjYWxsYmFja3Mgb24gcmVxdWVzdCB0byByZXRyaWV2ZSByZXNwb25zZSBkYXRhXG4gKiByZXF1ZXN0Lm9uKCdzdWNjZXNzJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAqICAgY29uc29sZS5sb2cocmVzcG9uc2UuZGF0YSk7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFdoZW4gYSByZXF1ZXN0IGlzIHJlYWR5IHRvIGJlIHNlbnQsIHRoZSB7c2VuZH0gbWV0aG9kIHNob3VsZFxuICogYmUgY2FsbGVkOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHJlcXVlc3Quc2VuZCgpO1xuICogYGBgXG4gKlxuICogU2luY2UgcmVnaXN0ZXJlZCBjYWxsYmFja3MgbWF5IG9yIG1heSBub3QgYmUgaWRlbXBvdGVudCwgcmVxdWVzdHMgc2hvdWxkIG9ubHlcbiAqIGJlIHNlbnQgb25jZS4gVG8gcGVyZm9ybSB0aGUgc2FtZSBvcGVyYXRpb24gbXVsdGlwbGUgdGltZXMsIHlvdSB3aWxsIG5lZWQgdG9cbiAqIGNyZWF0ZSBtdWx0aXBsZSByZXF1ZXN0IG9iamVjdHMsIGVhY2ggd2l0aCBpdHMgb3duIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqICMjIFJlbW92aW5nIERlZmF1bHQgTGlzdGVuZXJzIGZvciBFdmVudHNcbiAqXG4gKiBSZXF1ZXN0IG9iamVjdHMgYXJlIGJ1aWx0IHdpdGggZGVmYXVsdCBsaXN0ZW5lcnMgZm9yIHRoZSB2YXJpb3VzIGV2ZW50cyxcbiAqIGRlcGVuZGluZyBvbiB0aGUgc2VydmljZSB0eXBlLiBJbiBzb21lIGNhc2VzLCB5b3UgbWF5IHdhbnQgdG8gcmVtb3ZlXG4gKiBzb21lIGJ1aWx0LWluIGxpc3RlbmVycyB0byBjdXN0b21pemUgYmVoYXZpb3VyLiBEb2luZyB0aGlzIHJlcXVpcmVzXG4gKiBhY2Nlc3MgdG8gdGhlIGJ1aWx0LWluIGxpc3RlbmVyIGZ1bmN0aW9ucywgd2hpY2ggYXJlIGV4cG9zZWQgdGhyb3VnaFxuICogdGhlIHtBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZX0gbmFtZXNwYWNlLiBGb3IgaW5zdGFuY2UsIHlvdSBtYXlcbiAqIHdhbnQgdG8gY3VzdG9taXplIHRoZSBIVFRQIGhhbmRsZXIgdXNlZCB3aGVuIHNlbmRpbmcgYSByZXF1ZXN0LiBJbiB0aGlzXG4gKiBjYXNlLCB5b3UgY2FuIHJlbW92ZSB0aGUgYnVpbHQtaW4gbGlzdGVuZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSAnc2VuZCdcbiAqIGV2ZW50LCB0aGUge0FXUy5FdmVudExpc3RlbmVycy5Db3JlLlNFTkR9IGxpc3RlbmVyIGFuZCBhZGQgeW91ciBvd24uXG4gKlxuICogIyMgTXVsdGlwbGUgQ2FsbGJhY2tzIGFuZCBDaGFpbmluZ1xuICpcbiAqIFlvdSBjYW4gcmVnaXN0ZXIgbXVsdGlwbGUgY2FsbGJhY2tzIG9uIGFueSByZXF1ZXN0IG9iamVjdC4gVGhlXG4gKiBjYWxsYmFja3MgY2FuIGJlIHJlZ2lzdGVyZWQgZm9yIGRpZmZlcmVudCBldmVudHMsIG9yIGFsbCBmb3IgdGhlXG4gKiBzYW1lIGV2ZW50LiBJbiBhZGRpdGlvbiwgeW91IGNhbiBjaGFpbiBjYWxsYmFjayByZWdpc3RyYXRpb24sIGZvclxuICogZXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiByZXF1ZXN0LlxuICogICBvbignc3VjY2VzcycsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gKiAgICAgY29uc29sZS5sb2coXCJTdWNjZXNzIVwiKTtcbiAqICAgfSkuXG4gKiAgIG9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yLCByZXNwb25zZSkge1xuICogICAgIGNvbnNvbGUubG9nKFwiRXJyb3IhXCIpO1xuICogICB9KS5cbiAqICAgb24oJ2NvbXBsZXRlJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAqICAgICBjb25zb2xlLmxvZyhcIkFsd2F5cyFcIik7XG4gKiAgIH0pLlxuICogICBzZW5kKCk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgYWJvdmUgZXhhbXBsZSB3aWxsIHByaW50IGVpdGhlciBcIlN1Y2Nlc3MhIEFsd2F5cyFcIiwgb3IgXCJFcnJvciEgQWx3YXlzIVwiLFxuICogZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIHJlcXVlc3Qgc3VjY2VlZGVkIG9yIG5vdC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBodHRwUmVxdWVzdFxuICogICBAcmVhZG9ubHlcbiAqICAgQCFncm91cCBIVFRQIFByb3BlcnRpZXNcbiAqICAgQHJldHVybiBbQVdTLkh0dHBSZXF1ZXN0XSB0aGUgcmF3IEhUVFAgcmVxdWVzdCBvYmplY3RcbiAqICAgICBjb250YWluaW5nIHJlcXVlc3QgaGVhZGVycyBhbmQgYm9keSBpbmZvcm1hdGlvblxuICogICAgIHNlbnQgYnkgdGhlIHNlcnZpY2UuXG4gKlxuICogQCFhdHRyaWJ1dGUgc3RhcnRUaW1lXG4gKiAgIEByZWFkb25seVxuICogICBAIWdyb3VwIE9wZXJhdGlvbiBQcm9wZXJ0aWVzXG4gKiAgIEByZXR1cm4gW0RhdGVdIHRoZSB0aW1lIHRoYXQgdGhlIHJlcXVlc3Qgc3RhcnRlZFxuICpcbiAqIEAhZ3JvdXAgUmVxdWVzdCBCdWlsZGluZyBFdmVudHNcbiAqXG4gKiBAIWV2ZW50IHZhbGlkYXRlKHJlcXVlc3QpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIGEgcmVxdWVzdCBpcyBiZWluZyB2YWxpZGF0ZWQuIExpc3RlbmVyc1xuICogICBzaG91bGQgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHJlcXVlc3Qgc2hvdWxkIG5vdCBiZSBzZW50LlxuICogICBAcGFyYW0gcmVxdWVzdCBbUmVxdWVzdF0gdGhlIHJlcXVlc3Qgb2JqZWN0IGJlaW5nIHNlbnRcbiAqICAgQHNlZSBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9DUkVERU5USUFMU1xuICogICBAc2VlIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlZBTElEQVRFX1JFR0lPTlxuICogICBAZXhhbXBsZSBFbnN1cmluZyB0aGF0IGEgY2VydGFpbiBwYXJhbWV0ZXIgaXMgc2V0IGJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdFxuICogICAgIHZhciByZXEgPSBzMy5wdXRPYmplY3QocGFyYW1zKTtcbiAqICAgICByZXEub24oJ3ZhbGlkYXRlJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICBpZiAoIXJlcS5wYXJhbXMuQm9keS5tYXRjaCgvXkhlbGxvXFxzLykpIHtcbiAqICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb2R5IG11c3Qgc3RhcnQgd2l0aCBcIkhlbGxvIFwiJyk7XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKiAgICAgcmVxLnNlbmQoZnVuY3Rpb24oZXJyLCBkYXRhKSB7IC4uLiB9KTtcbiAqXG4gKiBAIWV2ZW50IGJ1aWxkKHJlcXVlc3QpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIHRoZSByZXF1ZXN0IHBheWxvYWQgaXMgYmVpbmcgYnVpbHQuIExpc3RlbmVyc1xuICogICBzaG91bGQgZmlsbCB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIHRvIHNlbmQgdGhlIHJlcXVlc3RcbiAqICAgb3ZlciBIVFRQLlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH52YWxpZGF0ZSlcbiAqICAgQGV4YW1wbGUgQWRkIGEgY3VzdG9tIEhUVFAgaGVhZGVyIHRvIGEgcmVxdWVzdFxuICogICAgIHZhciByZXEgPSBzMy5wdXRPYmplY3QocGFyYW1zKTtcbiAqICAgICByZXEub24oJ2J1aWxkJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snQ3VzdG9tLUhlYWRlciddID0gJ3ZhbHVlJztcbiAqICAgICB9KTtcbiAqICAgICByZXEuc2VuZChmdW5jdGlvbihlcnIsIGRhdGEpIHsgLi4uIH0pO1xuICpcbiAqIEAhZXZlbnQgc2lnbihyZXF1ZXN0KVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgcmVxdWVzdCBpcyBiZWluZyBzaWduZWQuIExpc3RlbmVycyBzaG91bGRcbiAqICAgYWRkIHRoZSBjb3JyZWN0IGF1dGhlbnRpY2F0aW9uIGhlYWRlcnMgYW5kL29yIGFkanVzdCB0aGUgYm9keSxcbiAqICAgZGVwZW5kaW5nIG9uIHRoZSBhdXRoZW50aWNhdGlvbiBtZWNoYW5pc20gYmVpbmcgdXNlZC5cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+dmFsaWRhdGUpXG4gKlxuICogQCFncm91cCBSZXF1ZXN0IFNlbmRpbmcgRXZlbnRzXG4gKlxuICogQCFldmVudCBzZW5kKHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgcmVxdWVzdCBpcyByZWFkeSB0byBiZSBzZW50LiBMaXN0ZW5lcnNcbiAqICAgc2hvdWxkIGNhbGwgdGhlIHVuZGVybHlpbmcgdHJhbnNwb3J0IGxheWVyIHRvIGluaXRpYXRlXG4gKiAgIHRoZSBzZW5kaW5nIG9mIHRoZSByZXF1ZXN0LlxuICogICBAcGFyYW0gcmVzcG9uc2UgW1Jlc3BvbnNlXSB0aGUgcmVzcG9uc2Ugb2JqZWN0XG4gKiAgIEBjb250ZXh0IFtSZXF1ZXN0XSB0aGUgcmVxdWVzdCBvYmplY3QgdGhhdCB3YXMgc2VudFxuICogICBAc2VlIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlNFTkRcbiAqXG4gKiBAIWV2ZW50IHJldHJ5KHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiBhIHJlcXVlc3QgZmFpbGVkIGFuZCBtaWdodCBuZWVkIHRvIGJlIHJldHJpZWQgb3IgcmVkaXJlY3RlZC5cbiAqICAgSWYgdGhlIHJlc3BvbnNlIGlzIHJldHJ5YWJsZSwgdGhlIGxpc3RlbmVyIHNob3VsZCBzZXQgdGhlXG4gKiAgIGByZXNwb25zZS5lcnJvci5yZXRyeWFibGVgIHByb3BlcnR5IHRvIGB0cnVlYCwgYW5kIG9wdGlvbmFsbHkgc2V0XG4gKiAgIGByZXNwb25zZS5lcnJvci5yZXRyeURlbGF5YCB0byB0aGUgbWlsbGlzZWNvbmQgZGVsYXkgZm9yIHRoZSBuZXh0IGF0dGVtcHQuXG4gKiAgIEluIHRoZSBjYXNlIG9mIGEgcmVkaXJlY3QsIGByZXNwb25zZS5lcnJvci5yZWRpcmVjdGAgc2hvdWxkIGJlIHNldCB0b1xuICogICBgdHJ1ZWAgd2l0aCBgcmV0cnlEZWxheWAgc2V0IHRvIGFuIG9wdGlvbmFsIGRlbGF5IG9uIHRoZSBuZXh0IHJlcXVlc3QuXG4gKlxuICogICBJZiBhIGxpc3RlbmVyIGRlY2lkZXMgdGhhdCBhIHJlcXVlc3Qgc2hvdWxkIG5vdCBiZSByZXRyaWVkLFxuICogICBpdCBzaG91bGQgc2V0IGJvdGggYHJldHJ5YWJsZWAgYW5kIGByZWRpcmVjdGAgdG8gZmFsc2UuXG4gKlxuICogICBOb3RlIHRoYXQgYSByZXRyeWFibGUgZXJyb3Igd2lsbCBiZSByZXRyaWVkIGF0IG1vc3RcbiAqICAge0FXUy5Db25maWcubWF4UmV0cmllc30gdGltZXMgKGJhc2VkIG9uIHRoZSBzZXJ2aWNlIG9iamVjdCdzIGNvbmZpZykuXG4gKiAgIFNpbWlsYXJseSwgYSByZXF1ZXN0IHRoYXQgaXMgcmVkaXJlY3RlZCB3aWxsIG9ubHkgcmVkaXJlY3QgYXQgbW9zdFxuICogICB7QVdTLkNvbmZpZy5tYXhSZWRpcmVjdHN9IHRpbWVzLlxuICpcbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAZXhhbXBsZSBBZGRpbmcgYSBjdXN0b20gcmV0cnkgZm9yIGEgNDA0IHJlc3BvbnNlXG4gKiAgICAgcmVxdWVzdC5vbigncmV0cnknLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICogICAgICAgLy8gdGhpcyByZXNvdXJjZSBpcyBub3QgeWV0IGF2YWlsYWJsZSwgd2FpdCAxMCBzZWNvbmRzIHRvIGdldCBpdCBhZ2FpblxuICogICAgICAgaWYgKHJlc3BvbnNlLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDQgJiYgcmVzcG9uc2UuZXJyb3IpIHtcbiAqICAgICAgICAgcmVzcG9uc2UuZXJyb3IucmV0cnlhYmxlID0gdHJ1ZTsgICAvLyByZXRyeSB0aGlzIGVycm9yXG4gKiAgICAgICAgIHJlc3BvbnNlLmVycm9yLnJldHJ5RGVsYXkgPSAxMDAwMDsgLy8gd2FpdCAxMCBzZWNvbmRzXG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogQCFncm91cCBEYXRhIFBhcnNpbmcgRXZlbnRzXG4gKlxuICogQCFldmVudCBleHRyYWN0RXJyb3IocmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCBvbiBhbGwgbm9uLTJ4eCByZXF1ZXN0cyBzbyB0aGF0IGxpc3RlbmVycyBjYW4gZXh0cmFjdFxuICogICBlcnJvciBkZXRhaWxzIGZyb20gdGhlIHJlc3BvbnNlIGJvZHkuIExpc3RlbmVycyB0byB0aGlzIGV2ZW50XG4gKiAgIHNob3VsZCBzZXQgdGhlIGByZXNwb25zZS5lcnJvcmAgcHJvcGVydHkuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqXG4gKiBAIWV2ZW50IGV4dHJhY3REYXRhKHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgaW4gc3VjY2Vzc2Z1bCByZXF1ZXN0cyB0byBhbGxvdyBsaXN0ZW5lcnMgdG9cbiAqICAgZGUtc2VyaWFsaXplIHRoZSByZXNwb25zZSBib2R5IGludG8gYHJlc3BvbnNlLmRhdGFgLlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKlxuICogQCFncm91cCBDb21wbGV0aW9uIEV2ZW50c1xuICpcbiAqIEAhZXZlbnQgc3VjY2VzcyhyZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIHJlcXVlc3QgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAqICAgYHJlc3BvbnNlLmRhdGFgIHdpbGwgY29udGFpbiB0aGUgcmVzcG9uc2UgZGF0YSBhbmRcbiAqICAgYHJlc3BvbnNlLmVycm9yYCB3aWxsIGJlIG51bGwuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqXG4gKiBAIWV2ZW50IGVycm9yKGVycm9yLCByZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzIGF0IGFueSBwb2ludCBkdXJpbmcgdGhlXG4gKiAgIHJlcXVlc3QuIGByZXNwb25zZS5lcnJvcmAgd2lsbCBjb250YWluIGRldGFpbHMgYWJvdXQgdGhlIGVycm9yXG4gKiAgIHRoYXQgb2NjdXJyZWQuIGByZXNwb25zZS5kYXRhYCB3aWxsIGJlIG51bGwuXG4gKiAgIEBwYXJhbSBlcnJvciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIGFib3V0XG4gKiAgICAgdGhlIGVycm9yIHRoYXQgb2NjdXJyZWQuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqXG4gKiBAIWV2ZW50IGNvbXBsZXRlKHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbmV2ZXIgYSByZXF1ZXN0IGN5Y2xlIGNvbXBsZXRlcy4gYHJlc3BvbnNlLmVycm9yYFxuICogICBzaG91bGQgYmUgY2hlY2tlZCwgc2luY2UgdGhlIHJlcXVlc3QgbWF5IGhhdmUgZmFpbGVkLlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKlxuICogQCFncm91cCBIVFRQIEV2ZW50c1xuICpcbiAqIEAhZXZlbnQgaHR0cEhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzcG9uc2UsIHN0YXR1c01lc3NhZ2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIGhlYWRlcnMgYXJlIHNlbnQgYnkgdGhlIHJlbW90ZSBzZXJ2ZXJcbiAqICAgQHBhcmFtIHN0YXR1c0NvZGUgW0ludGVnZXJdIHRoZSBIVFRQIHJlc3BvbnNlIGNvZGVcbiAqICAgQHBhcmFtIGhlYWRlcnMgW21hcDxTdHJpbmcsU3RyaW5nPl0gdGhlIHJlc3BvbnNlIGhlYWRlcnNcbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQHBhcmFtIHN0YXR1c01lc3NhZ2UgW1N0cmluZ10gQSBzdGF0dXMgbWVzc2FnZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBIVFRQXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlIGNvZGVcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEAhZXZlbnQgaHR0cERhdGEoY2h1bmssIHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiBkYXRhIGlzIHNlbnQgYnkgdGhlIHJlbW90ZSBzZXJ2ZXJcbiAqICAgQHBhcmFtIGNodW5rIFtCdWZmZXJdIHRoZSBidWZmZXIgZGF0YSBjb250YWluaW5nIHRoZSBuZXh0IGRhdGEgY2h1bmtcbiAqICAgICBmcm9tIHRoZSBzZXJ2ZXJcbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAc2VlIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLkhUVFBfREFUQVxuICpcbiAqIEAhZXZlbnQgaHR0cFVwbG9hZFByb2dyZXNzKHByb2dyZXNzLCByZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIEhUVFAgcmVxdWVzdCBoYXMgdXBsb2FkZWQgbW9yZSBkYXRhXG4gKiAgIEBwYXJhbSBwcm9ncmVzcyBbbWFwXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgYGxvYWRlZGAgYW5kIGB0b3RhbGAgYnl0ZXNcbiAqICAgICBvZiB0aGUgcmVxdWVzdC5cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAbm90ZSBUaGlzIGV2ZW50IHdpbGwgbm90IGJlIGVtaXR0ZWQgaW4gTm9kZS5qcyAwLjgueC5cbiAqXG4gKiBAIWV2ZW50IGh0dHBEb3dubG9hZFByb2dyZXNzKHByb2dyZXNzLCByZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIEhUVFAgcmVxdWVzdCBoYXMgZG93bmxvYWRlZCBtb3JlIGRhdGFcbiAqICAgQHBhcmFtIHByb2dyZXNzIFttYXBdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgbG9hZGVkYCBhbmQgYHRvdGFsYCBieXRlc1xuICogICAgIG9mIHRoZSByZXF1ZXN0LlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBub3RlIFRoaXMgZXZlbnQgd2lsbCBub3QgYmUgZW1pdHRlZCBpbiBOb2RlLmpzIDAuOC54LlxuICpcbiAqIEAhZXZlbnQgaHR0cEVycm9yKGVycm9yLCByZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIEhUVFAgcmVxdWVzdCBmYWlsZWRcbiAqICAgQHBhcmFtIGVycm9yIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCB0aGF0IHdhcyB0aHJvd25cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEAhZXZlbnQgaHR0cERvbmUocmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIHRoZSBzZXJ2ZXIgaXMgZmluaXNoZWQgc2VuZGluZyBkYXRhXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqXG4gKiBAc2VlIEFXUy5SZXNwb25zZVxuICovXG5BV1MuUmVxdWVzdCA9IGluaGVyaXQoe1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVxdWVzdCBmb3IgYW4gb3BlcmF0aW9uIG9uIGEgZ2l2ZW4gc2VydmljZSB3aXRoXG4gICAqIGEgc2V0IG9mIGlucHV0IHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSBzZXJ2aWNlIFtBV1MuU2VydmljZV0gdGhlIHNlcnZpY2UgdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uIG9uXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gW1N0cmluZ10gdGhlIG9wZXJhdGlvbiB0byBwZXJmb3JtIG9uIHRoZSBzZXJ2aWNlXG4gICAqIEBwYXJhbSBwYXJhbXMgW09iamVjdF0gcGFyYW1ldGVycyB0byBzZW5kIHRvIHRoZSBvcGVyYXRpb24uXG4gICAqICAgU2VlIHRoZSBvcGVyYXRpb24ncyBkb2N1bWVudGF0aW9uIGZvciB0aGUgZm9ybWF0IG9mIHRoZVxuICAgKiAgIHBhcmFtZXRlcnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gUmVxdWVzdChzZXJ2aWNlLCBvcGVyYXRpb24sIHBhcmFtcykge1xuICAgIHZhciBlbmRwb2ludCA9IHNlcnZpY2UuZW5kcG9pbnQ7XG4gICAgdmFyIHJlZ2lvbiA9IHNlcnZpY2UuY29uZmlnLnJlZ2lvbjtcbiAgICB2YXIgY3VzdG9tVXNlckFnZW50ID0gc2VydmljZS5jb25maWcuY3VzdG9tVXNlckFnZW50O1xuXG4gICAgLy8gZ2xvYmFsIGVuZHBvaW50cyBzaWduIGFzIHVzLWVhc3QtMVxuICAgIGlmIChzZXJ2aWNlLmlzR2xvYmFsRW5kcG9pbnQpIHJlZ2lvbiA9ICd1cy1lYXN0LTEnO1xuXG4gICAgdGhpcy5kb21haW4gPSBkb21haW4gJiYgZG9tYWluLmFjdGl2ZTtcbiAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIHRoaXMub3BlcmF0aW9uID0gb3BlcmF0aW9uO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIHRoaXMuaHR0cFJlcXVlc3QgPSBuZXcgQVdTLkh0dHBSZXF1ZXN0KGVuZHBvaW50LCByZWdpb24pO1xuICAgIHRoaXMuaHR0cFJlcXVlc3QuYXBwZW5kVG9Vc2VyQWdlbnQoY3VzdG9tVXNlckFnZW50KTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IHNlcnZpY2UuZ2V0U2tld0NvcnJlY3RlZERhdGUoKTtcblxuICAgIHRoaXMucmVzcG9uc2UgPSBuZXcgQVdTLlJlc3BvbnNlKHRoaXMpO1xuICAgIHRoaXMuX2FzbSA9IG5ldyBBY2NlcHRvclN0YXRlTWFjaGluZShmc20uc3RhdGVzLCAndmFsaWRhdGUnKTtcbiAgICB0aGlzLl9oYWx0SGFuZGxlcnNPbkVycm9yID0gZmFsc2U7XG5cbiAgICBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5lbWl0ID0gdGhpcy5lbWl0RXZlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEAhZ3JvdXAgU2VuZGluZyBhIFJlcXVlc3RcbiAgICovXG5cbiAgLyoqXG4gICAqIEBvdmVybG9hZCBzZW5kKGNhbGxiYWNrID0gbnVsbClcbiAgICogICBTZW5kcyB0aGUgcmVxdWVzdCBvYmplY3QuXG4gICAqXG4gICAqICAgQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgZGF0YSlcbiAgICogICAgIElmIGEgY2FsbGJhY2sgaXMgc3VwcGxpZWQsIGl0IGlzIGNhbGxlZCB3aGVuIGEgcmVzcG9uc2UgaXMgcmV0dXJuZWRcbiAgICogICAgIGZyb20gdGhlIHNlcnZpY2UuXG4gICAqICAgICBAY29udGV4dCBbQVdTLlJlcXVlc3RdIHRoZSByZXF1ZXN0IG9iamVjdCBiZWluZyBzZW50LlxuICAgKiAgICAgQHBhcmFtIGVyciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgcmVxdWVzdC5cbiAgICogICAgICAgU2V0IHRvIGBudWxsYCBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsLlxuICAgKiAgICAgQHBhcmFtIGRhdGEgW09iamVjdF0gdGhlIGRlLXNlcmlhbGl6ZWQgZGF0YSByZXR1cm5lZCBmcm9tXG4gICAqICAgICAgIHRoZSByZXF1ZXN0LiBTZXQgdG8gYG51bGxgIGlmIGEgcmVxdWVzdCBlcnJvciBvY2N1cnMuXG4gICAqICAgQGV4YW1wbGUgU2VuZGluZyBhIHJlcXVlc3Qgd2l0aCBhIGNhbGxiYWNrXG4gICAqICAgICByZXF1ZXN0ID0gczMucHV0T2JqZWN0KHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknfSk7XG4gICAqICAgICByZXF1ZXN0LnNlbmQoZnVuY3Rpb24oZXJyLCBkYXRhKSB7IGNvbnNvbGUubG9nKGVyciwgZGF0YSk7IH0pO1xuICAgKiAgIEBleGFtcGxlIFNlbmRpbmcgYSByZXF1ZXN0IHdpdGggbm8gY2FsbGJhY2sgKHVzaW5nIGV2ZW50IGhhbmRsZXJzKVxuICAgKiAgICAgcmVxdWVzdCA9IHMzLnB1dE9iamVjdCh7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5J30pO1xuICAgKiAgICAgcmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbihyZXNwb25zZSkgeyAuLi4gfSk7IC8vIHJlZ2lzdGVyIGEgY2FsbGJhY2tcbiAgICogICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgKi9cbiAgc2VuZDogZnVuY3Rpb24gc2VuZChjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgLy8gYXBwZW5kIHRvIHVzZXIgYWdlbnRcbiAgICAgIHRoaXMuaHR0cFJlcXVlc3QuYXBwZW5kVG9Vc2VyQWdlbnQoJ2NhbGxiYWNrJyk7XG4gICAgICB0aGlzLm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwocmVzcCwgcmVzcC5lcnJvciwgcmVzcC5kYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnJ1blRvKCk7XG5cbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZTtcbiAgfSxcblxuICAvKipcbiAgICogQCFtZXRob2QgIHByb21pc2UoKVxuICAgKiAgIFNlbmRzIHRoZSByZXF1ZXN0IGFuZCByZXR1cm5zIGEgJ3RoZW5hYmxlJyBwcm9taXNlLlxuICAgKlxuICAgKiAgIFR3byBjYWxsYmFja3MgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSBgdGhlbmAgbWV0aG9kIG9uIHRoZSByZXR1cm5lZCBwcm9taXNlLlxuICAgKiAgIFRoZSBmaXJzdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQsIGFuZCB0aGUgc2Vjb25kXG4gICAqICAgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgQGNhbGxiYWNrIGZ1bGZpbGxlZENhbGxiYWNrIGZ1bmN0aW9uKGRhdGEpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLlxuICAgKiAgICAgQHBhcmFtIGRhdGEgW09iamVjdF0gdGhlIGRlLXNlcmlhbGl6ZWQgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSByZXF1ZXN0LlxuICAgKiAgIEBjYWxsYmFjayByZWplY3RlZENhbGxiYWNrIGZ1bmN0aW9uKGVycm9yKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgICAgQHBhcmFtIGVycm9yIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSByZXF1ZXN0LlxuICAgKiAgIEByZXR1cm4gW1Byb21pc2VdIEEgcHJvbWlzZSB0aGF0IHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSByZXF1ZXN0LlxuICAgKiAgIEBleGFtcGxlIFNlbmRpbmcgYSByZXF1ZXN0IHVzaW5nIHByb21pc2VzLlxuICAgKiAgICAgdmFyIHJlcXVlc3QgPSBzMy5wdXRPYmplY3Qoe0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleSd9KTtcbiAgICogICAgIHZhciByZXN1bHQgPSByZXF1ZXN0LnByb21pc2UoKTtcbiAgICogICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uKGRhdGEpIHsgLi4uIH0sIGZ1bmN0aW9uKGVycm9yKSB7IC4uLiB9KTtcbiAgICovXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuVG8oJ3NlbmQnLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcnVuVG86IGZ1bmN0aW9uIHJ1blRvKHN0YXRlLCBkb25lKSB7XG4gICAgdGhpcy5fYXNtLnJ1blRvKHN0YXRlLCBkb25lLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQWJvcnRzIGEgcmVxdWVzdCwgZW1pdHRpbmcgdGhlIGVycm9yIGFuZCBjb21wbGV0ZSBldmVudHMuXG4gICAqXG4gICAqIEAhbWFjcm8gbm9icm93c2VyXG4gICAqIEBleGFtcGxlIEFib3J0aW5nIGEgcmVxdWVzdCBhZnRlciBzZW5kaW5nXG4gICAqICAgdmFyIHBhcmFtcyA9IHtcbiAgICogICAgIEJ1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsXG4gICAqICAgICBCb2R5OiBCdWZmZXIuYWxsb2MoMTAyNCAqIDEwMjQgKiA1KSAvLyA1TUIgcGF5bG9hZFxuICAgKiAgIH07XG4gICAqICAgdmFyIHJlcXVlc3QgPSBzMy5wdXRPYmplY3QocGFyYW1zKTtcbiAgICogICByZXF1ZXN0LnNlbmQoZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgKiAgICAgaWYgKGVycikgY29uc29sZS5sb2coXCJFcnJvcjpcIiwgZXJyLmNvZGUsIGVyci5tZXNzYWdlKTtcbiAgICogICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgLy8gYWJvcnQgcmVxdWVzdCBpbiAxIHNlY29uZFxuICAgKiAgIHNldFRpbWVvdXQocmVxdWVzdC5hYm9ydC5iaW5kKHJlcXVlc3QpLCAxMDAwKTtcbiAgICpcbiAgICogICAvLyBwcmludHMgXCJFcnJvcjogUmVxdWVzdEFib3J0ZWRFcnJvciBSZXF1ZXN0IGFib3J0ZWQgYnkgdXNlclwiXG4gICAqIEByZXR1cm4gW0FXUy5SZXF1ZXN0XSB0aGUgc2FtZSByZXF1ZXN0IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgKiBAc2luY2UgdjEuNC4wXG4gICAqL1xuICBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3ZhbGlkYXRlUmVzcG9uc2UnKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnZXh0cmFjdEVycm9yJyk7XG4gICAgdGhpcy5vbigndmFsaWRhdGVSZXNwb25zZScsIGZ1bmN0aW9uIGFkZEFib3J0ZWRFcnJvcihyZXNwKSB7XG4gICAgICByZXNwLmVycm9yID0gQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCdSZXF1ZXN0IGFib3J0ZWQgYnkgdXNlcicpLCB7XG4gICAgICAgICBjb2RlOiAnUmVxdWVzdEFib3J0ZWRFcnJvcicsIHJldHJ5YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuaHR0cFJlcXVlc3Quc3RyZWFtICYmICF0aGlzLmh0dHBSZXF1ZXN0LnN0cmVhbS5kaWRDYWxsYmFjaykgeyAvLyBhYm9ydCBIVFRQIHN0cmVhbVxuICAgICAgdGhpcy5odHRwUmVxdWVzdC5zdHJlYW0uYWJvcnQoKTtcbiAgICAgIGlmICh0aGlzLmh0dHBSZXF1ZXN0Ll9hYm9ydENhbGxiYWNrKSB7XG4gICAgICAgICB0aGlzLmh0dHBSZXF1ZXN0Ll9hYm9ydENhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnc2VuZCcpOyAvLyBoYXZlbid0IHNlbnQgeWV0LCBzbyBsZXQncyBub3RcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBlYWNoIHBhZ2Ugb2YgcmVzdWx0cyBnaXZlbiBhIHBhZ2VhYmxlIHJlcXVlc3QsIGNhbGxpbmdcbiAgICogdGhlIHByb3ZpZGVkIGNhbGxiYWNrIHdpdGggZWFjaCBwYWdlIG9mIGRhdGEuIEFmdGVyIGFsbCBwYWdlcyBoYXZlIGJlZW5cbiAgICogcmV0cmlldmVkLCB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggYG51bGxgIGRhdGEuXG4gICAqXG4gICAqIEBub3RlIFRoaXMgb3BlcmF0aW9uIGNhbiBnZW5lcmF0ZSBtdWx0aXBsZSByZXF1ZXN0cyB0byBhIHNlcnZpY2UuXG4gICAqIEBleGFtcGxlIEl0ZXJhdGluZyBvdmVyIG11bHRpcGxlIHBhZ2VzIG9mIG9iamVjdHMgaW4gYW4gUzMgYnVja2V0XG4gICAqICAgdmFyIHBhZ2VzID0gMTtcbiAgICogICBzMy5saXN0T2JqZWN0cygpLmVhY2hQYWdlKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICAgaWYgKGVycikgcmV0dXJuO1xuICAgKiAgICAgY29uc29sZS5sb2coXCJQYWdlXCIsIHBhZ2VzKyspO1xuICAgKiAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICAgfSk7XG4gICAqIEBleGFtcGxlIEl0ZXJhdGluZyBvdmVyIG11bHRpcGxlIHBhZ2VzIHdpdGggYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrXG4gICAqICAgczMubGlzdE9iamVjdHMocGFyYW1zKS5lYWNoUGFnZShmdW5jdGlvbihlcnIsIGRhdGEsIGRvbmUpIHtcbiAgICogICAgIGRvU29tZXRoaW5nQXN5bmNBbmRPckV4cGVuc2l2ZShmdW5jdGlvbigpIHtcbiAgICogICAgICAgLy8gVGhlIG5leHQgcGFnZSBvZiByZXN1bHRzIGlzbid0IGZldGNoZWQgdW50aWwgZG9uZSBpcyBjYWxsZWRcbiAgICogICAgICAgZG9uZSgpO1xuICAgKiAgICAgfSk7XG4gICAqICAgfSk7XG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGRhdGEsIFtkb25lQ2FsbGJhY2tdKVxuICAgKiAgIENhbGxlZCB3aXRoIGVhY2ggcGFnZSBvZiByZXN1bHRpbmcgZGF0YSBmcm9tIHRoZSByZXF1ZXN0LiBJZiB0aGVcbiAgICogICBvcHRpb25hbCBgZG9uZUNhbGxiYWNrYCBpcyBwcm92aWRlZCBpbiB0aGUgZnVuY3Rpb24sIGl0IG11c3QgYmUgY2FsbGVkXG4gICAqICAgd2hlbiB0aGUgY2FsbGJhY2sgaXMgY29tcGxldGUuXG4gICAqXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGFuIGVycm9yIG9iamVjdCwgaWYgYW4gZXJyb3Igb2NjdXJyZWQuXG4gICAqICAgQHBhcmFtIGRhdGEgW09iamVjdF0gYSBzaW5nbGUgcGFnZSBvZiByZXNwb25zZSBkYXRhLiBJZiB0aGVyZSBpcyBub1xuICAgKiAgICAgbW9yZSBkYXRhLCB0aGlzIG9iamVjdCB3aWxsIGJlIGBudWxsYC5cbiAgICogICBAcGFyYW0gZG9uZUNhbGxiYWNrIFtGdW5jdGlvbl0gYW4gb3B0aW9uYWwgZG9uZSBjYWxsYmFjay4gSWYgdGhpc1xuICAgKiAgICAgYXJndW1lbnQgaXMgZGVmaW5lZCBpbiB0aGUgZnVuY3Rpb24gZGVjbGFyYXRpb24sIGl0IHNob3VsZCBiZSBjYWxsZWRcbiAgICogICAgIHdoZW4gdGhlIG5leHQgcGFnZSBpcyByZWFkeSB0byBiZSByZXRyaWV2ZWQuIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiAgICAgY29udHJvbGxpbmcgc2VyaWFsIHBhZ2luYXRpb24gYWNyb3NzIGFzeW5jaHJvbm91cyBvcGVyYXRpb25zLlxuICAgKiAgIEByZXR1cm4gW0Jvb2xlYW5dIGlmIHRoZSBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAsIHBhZ2luYXRpb24gd2lsbFxuICAgKiAgICAgc3RvcC5cbiAgICpcbiAgICogQHNlZSBBV1MuUmVxdWVzdC5lYWNoSXRlbVxuICAgKiBAc2VlIEFXUy5SZXNwb25zZS5uZXh0UGFnZVxuICAgKiBAc2luY2UgdjEuNC4wXG4gICAqL1xuICBlYWNoUGFnZTogZnVuY3Rpb24gZWFjaFBhZ2UoY2FsbGJhY2spIHtcbiAgICAvLyBNYWtlIGFsbCBjYWxsYmFja3MgYXN5bmMtaXNoXG4gICAgY2FsbGJhY2sgPSBBV1MudXRpbC5mbi5tYWtlQXN5bmMoY2FsbGJhY2ssIDMpO1xuXG4gICAgZnVuY3Rpb24gd3JhcHBlZENhbGxiYWNrKHJlc3BvbnNlKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHJlc3BvbnNlLCByZXNwb25zZS5lcnJvciwgcmVzcG9uc2UuZGF0YSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChyZXNwb25zZS5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICAgICAgcmVzcG9uc2UubmV4dFBhZ2UoKS5vbignY29tcGxldGUnLCB3cmFwcGVkQ2FsbGJhY2spLnNlbmQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHJlc3BvbnNlLCBudWxsLCBudWxsLCBBV1MudXRpbC5mbi5ub29wKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5vbignY29tcGxldGUnLCB3cmFwcGVkQ2FsbGJhY2spLnNlbmQoKTtcbiAgfSxcblxuICAvKipcbiAgICogRW51bWVyYXRlcyBvdmVyIGluZGl2aWR1YWwgaXRlbXMgb2YgYSByZXF1ZXN0LCBwYWdpbmcgdGhlIHJlc3BvbnNlcyBpZlxuICAgKiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIEBhcGkgZXhwZXJpbWVudGFsXG4gICAqIEBzaW5jZSB2MS40LjBcbiAgICovXG4gIGVhY2hJdGVtOiBmdW5jdGlvbiBlYWNoSXRlbShjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmdW5jdGlvbiB3cmFwcGVkQ2FsbGJhY2soZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7XG5cbiAgICAgIHZhciBjb25maWcgPSBzZWxmLnNlcnZpY2UucGFnaW5hdGlvbkNvbmZpZyhzZWxmLm9wZXJhdGlvbik7XG4gICAgICB2YXIgcmVzdWx0S2V5ID0gY29uZmlnLnJlc3VsdEtleTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdEtleSkpIHJlc3VsdEtleSA9IHJlc3VsdEtleVswXTtcbiAgICAgIHZhciBpdGVtcyA9IGptZXNwYXRoLnNlYXJjaChkYXRhLCByZXN1bHRLZXkpO1xuICAgICAgdmFyIGNvbnRpbnVlSXRlcmF0aW9uID0gdHJ1ZTtcbiAgICAgIEFXUy51dGlsLmFycmF5RWFjaChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBjb250aW51ZUl0ZXJhdGlvbiA9IGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuICAgICAgICBpZiAoY29udGludWVJdGVyYXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIEFXUy51dGlsLmFib3J0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250aW51ZUl0ZXJhdGlvbjtcbiAgICB9XG5cbiAgICB0aGlzLmVhY2hQYWdlKHdyYXBwZWRDYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIG9wZXJhdGlvbiBjYW4gcmV0dXJuIG11bHRpcGxlIHBhZ2VzIG9mXG4gICAqICAgcmVzcG9uc2UgZGF0YS5cbiAgICogQHNlZSBBV1MuUmVzcG9uc2UuZWFjaFBhZ2VcbiAgICogQHNpbmNlIHYxLjQuMFxuICAgKi9cbiAgaXNQYWdlYWJsZTogZnVuY3Rpb24gaXNQYWdlYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLnBhZ2luYXRpb25Db25maWcodGhpcy5vcGVyYXRpb24pID8gdHJ1ZSA6IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZW5kcyB0aGUgcmVxdWVzdCBhbmQgY29udmVydHMgdGhlIHJlcXVlc3Qgb2JqZWN0IGludG8gYSByZWFkYWJsZSBzdHJlYW1cbiAgICogdGhhdCBjYW4gYmUgcmVhZCBmcm9tIG9yIHBpcGVkIGludG8gYSB3cml0YWJsZSBzdHJlYW0uXG4gICAqXG4gICAqIEBub3RlIFRoZSBkYXRhIHJlYWQgZnJvbSBhIHJlYWRhYmxlIHN0cmVhbSBjb250YWlucyBvbmx5XG4gICAqICAgdGhlIHJhdyBIVFRQIGJvZHkgY29udGVudHMuXG4gICAqIEBleGFtcGxlIE1hbnVhbGx5IHJlYWRpbmcgZnJvbSBhIHN0cmVhbVxuICAgKiAgIHJlcXVlc3QuY3JlYXRlUmVhZFN0cmVhbSgpLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkge1xuICAgKiAgICAgY29uc29sZS5sb2coXCJHb3QgZGF0YTpcIiwgZGF0YS50b1N0cmluZygpKTtcbiAgICogICB9KTtcbiAgICogQGV4YW1wbGUgUGlwaW5nIGEgcmVxdWVzdCBib2R5IGludG8gYSBmaWxlXG4gICAqICAgdmFyIG91dCA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKCcvcGF0aC90by9vdXRmaWxlLmpwZycpO1xuICAgKiAgIHMzLnNlcnZpY2UuZ2V0T2JqZWN0KHBhcmFtcykuY3JlYXRlUmVhZFN0cmVhbSgpLnBpcGUob3V0KTtcbiAgICogQHJldHVybiBbU3RyZWFtXSB0aGUgcmVhZGFibGUgc3RyZWFtIG9iamVjdCB0aGF0IGNhbiBiZSBwaXBlZFxuICAgKiAgIG9yIHJlYWQgZnJvbSAoYnkgcmVnaXN0ZXJpbmcgJ2RhdGEnIGV2ZW50IGxpc3RlbmVycykuXG4gICAqIEAhbWFjcm8gbm9icm93c2VyXG4gICAqL1xuICBjcmVhdGVSZWFkU3RyZWFtOiBmdW5jdGlvbiBjcmVhdGVSZWFkU3RyZWFtKCkge1xuICAgIHZhciBzdHJlYW1zID0gQVdTLnV0aWwuc3RyZWFtO1xuICAgIHZhciByZXEgPSB0aGlzO1xuICAgIHZhciBzdHJlYW0gPSBudWxsO1xuXG4gICAgaWYgKEFXUy5IdHRwQ2xpZW50LnN0cmVhbXNBcGlWZXJzaW9uID09PSAyKSB7XG4gICAgICBzdHJlYW0gPSBuZXcgc3RyZWFtcy5QYXNzVGhyb3VnaCgpO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHsgcmVxLnNlbmQoKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbSA9IG5ldyBzdHJlYW1zLlN0cmVhbSgpO1xuICAgICAgc3RyZWFtLnJlYWRhYmxlID0gdHJ1ZTtcblxuICAgICAgc3RyZWFtLnNlbnQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5vbignbmV3TGlzdGVuZXInLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoIXN0cmVhbS5zZW50ICYmIGV2ZW50ID09PSAnZGF0YScpIHtcbiAgICAgICAgICBzdHJlYW0uc2VudCA9IHRydWU7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHsgcmVxLnNlbmQoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbignaHR0cEhlYWRlcnMnLCBmdW5jdGlvbiBzdHJlYW1IZWFkZXJzKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3ApIHtcbiAgICAgIGlmIChzdGF0dXNDb2RlIDwgMzAwKSB7XG4gICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcignaHR0cERhdGEnLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5IVFRQX0RBVEEpO1xuICAgICAgICByZXEucmVtb3ZlTGlzdGVuZXIoJ2h0dHBFcnJvcicsIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLkhUVFBfRVJST1IpO1xuICAgICAgICByZXEub24oJ2h0dHBFcnJvcicsIGZ1bmN0aW9uIHN0cmVhbUh0dHBFcnJvcihlcnJvcikge1xuICAgICAgICAgIHJlc3AuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICByZXNwLmVycm9yLnJldHJ5YWJsZSA9IGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc2hvdWxkQ2hlY2tDb250ZW50TGVuZ3RoID0gZmFsc2U7XG4gICAgICAgIHZhciBleHBlY3RlZExlbjtcbiAgICAgICAgaWYgKHJlcS5odHRwUmVxdWVzdC5tZXRob2QgIT09ICdIRUFEJykge1xuICAgICAgICAgIGV4cGVjdGVkTGVuID0gcGFyc2VJbnQoaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBlY3RlZExlbiAhPT0gdW5kZWZpbmVkICYmICFpc05hTihleHBlY3RlZExlbikgJiYgZXhwZWN0ZWRMZW4gPj0gMCkge1xuICAgICAgICAgIHNob3VsZENoZWNrQ29udGVudExlbmd0aCA9IHRydWU7XG4gICAgICAgICAgdmFyIHJlY2VpdmVkTGVuID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGVja0NvbnRlbnRMZW5ndGhBbmRFbWl0ID0gZnVuY3Rpb24gY2hlY2tDb250ZW50TGVuZ3RoQW5kRW1pdCgpIHtcbiAgICAgICAgICBpZiAoc2hvdWxkQ2hlY2tDb250ZW50TGVuZ3RoICYmIHJlY2VpdmVkTGVuICE9PSBleHBlY3RlZExlbikge1xuICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcignU3RyZWFtIGNvbnRlbnQgbGVuZ3RoIG1pc21hdGNoLiBSZWNlaXZlZCAnICtcbiAgICAgICAgICAgICAgICByZWNlaXZlZExlbiArICcgb2YgJyArIGV4cGVjdGVkTGVuICsgJyBieXRlcy4nKSxcbiAgICAgICAgICAgICAgeyBjb2RlOiAnU3RyZWFtQ29udGVudExlbmd0aE1pc21hdGNoJyB9XG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEFXUy5IdHRwQ2xpZW50LnN0cmVhbXNBcGlWZXJzaW9uID09PSAyKSB7XG4gICAgICAgICAgICBzdHJlYW0uZW5kKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGh0dHBTdHJlYW0gPSByZXNwLmh0dHBSZXNwb25zZS5jcmVhdGVVbmJ1ZmZlcmVkU3RyZWFtKCk7XG5cbiAgICAgICAgaWYgKEFXUy5IdHRwQ2xpZW50LnN0cmVhbXNBcGlWZXJzaW9uID09PSAyKSB7XG4gICAgICAgICAgaWYgKHNob3VsZENoZWNrQ29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aEFjY3VtdWxhdG9yID0gbmV3IHN0cmVhbXMuUGFzc1Rocm91Z2goKTtcbiAgICAgICAgICAgIGxlbmd0aEFjY3VtdWxhdG9yLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZExlbiArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHN0cmVhbXMuUGFzc1Rocm91Z2gucHJvdG90eXBlLl93cml0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbGVuZ3RoQWNjdW11bGF0b3Iub24oJ2VuZCcsIGNoZWNrQ29udGVudExlbmd0aEFuZEVtaXQpO1xuICAgICAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICBzaG91bGRDaGVja0NvbnRlbnRMZW5ndGggPSBmYWxzZTtcbiAgICAgICAgICAgICAgaHR0cFN0cmVhbS51bnBpcGUobGVuZ3RoQWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgICBsZW5ndGhBY2N1bXVsYXRvci5lbWl0KCdlbmQnKTtcbiAgICAgICAgICAgICAgbGVuZ3RoQWNjdW11bGF0b3IuZW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGh0dHBTdHJlYW0ucGlwZShsZW5ndGhBY2N1bXVsYXRvcikucGlwZShzdHJlYW0sIHsgZW5kOiBmYWxzZSB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHR0cFN0cmVhbS5waXBlKHN0cmVhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgaWYgKHNob3VsZENoZWNrQ29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgaHR0cFN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICBpZiAoYXJnICYmIGFyZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZExlbiArPSBhcmcubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBodHRwU3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGFyZyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaHR0cFN0cmVhbS5vbignZW5kJywgY2hlY2tDb250ZW50TGVuZ3RoQW5kRW1pdCk7XG4gICAgICAgIH1cblxuICAgICAgICBodHRwU3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHNob3VsZENoZWNrQ29udGVudExlbmd0aCA9IGZhbHNlO1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIFtBcnJheSxSZXNwb25zZV0gYXJncyBUaGlzIHNob3VsZCBiZSB0aGUgcmVzcG9uc2Ugb2JqZWN0LFxuICAgKiAgIG9yIGFuIGFycmF5IG9mIGFyZ3MgdG8gc2VuZCB0byB0aGUgZXZlbnQuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZW1pdEV2ZW50OiBmdW5jdGlvbiBlbWl0KGV2ZW50TmFtZSwgYXJncywgZG9uZSkge1xuICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ2Z1bmN0aW9uJykgeyBkb25lID0gYXJnczsgYXJncyA9IG51bGw7IH1cbiAgICBpZiAoIWRvbmUpIGRvbmUgPSBmdW5jdGlvbigpIHsgfTtcbiAgICBpZiAoIWFyZ3MpIGFyZ3MgPSB0aGlzLmV2ZW50UGFyYW1ldGVycyhldmVudE5hbWUsIHRoaXMucmVzcG9uc2UpO1xuXG4gICAgdmFyIG9yaWdFbWl0ID0gQVdTLlNlcXVlbnRpYWxFeGVjdXRvci5wcm90b3R5cGUuZW1pdDtcbiAgICBvcmlnRW1pdC5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgYXJncywgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikgdGhpcy5yZXNwb25zZS5lcnJvciA9IGVycjtcbiAgICAgIGRvbmUuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGV2ZW50UGFyYW1ldGVyczogZnVuY3Rpb24gZXZlbnRQYXJhbWV0ZXJzKGV2ZW50TmFtZSkge1xuICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICBjYXNlICdyZXN0YXJ0JzpcbiAgICAgIGNhc2UgJ3ZhbGlkYXRlJzpcbiAgICAgIGNhc2UgJ3NpZ24nOlxuICAgICAgY2FzZSAnYnVpbGQnOlxuICAgICAgY2FzZSAnYWZ0ZXJWYWxpZGF0ZSc6XG4gICAgICBjYXNlICdhZnRlckJ1aWxkJzpcbiAgICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgcmV0dXJuIFt0aGlzLnJlc3BvbnNlLmVycm9yLCB0aGlzLnJlc3BvbnNlXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbdGhpcy5yZXNwb25zZV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHByZXNpZ246IGZ1bmN0aW9uIHByZXNpZ24oZXhwaXJlcywgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBleHBpcmVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGV4cGlyZXM7XG4gICAgICBleHBpcmVzID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBV1MuU2lnbmVycy5QcmVzaWduKCkuc2lnbih0aGlzLnRvR2V0KCksIGV4cGlyZXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpc1ByZXNpZ25lZDogZnVuY3Rpb24gaXNQcmVzaWduZWQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmh0dHBSZXF1ZXN0LmhlYWRlcnMsICdwcmVzaWduZWQtZXhwaXJlcycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHRvVW5hdXRoZW50aWNhdGVkOiBmdW5jdGlvbiB0b1VuYXV0aGVudGljYXRlZCgpIHtcbiAgICB0aGlzLl91bkF1dGhlbnRpY2F0ZWQgPSB0cnVlO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJywgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfQ1JFREVOVElBTFMpO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3NpZ24nLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5TSUdOKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB0b0dldDogZnVuY3Rpb24gdG9HZXQoKSB7XG4gICAgaWYgKHRoaXMuc2VydmljZS5hcGkucHJvdG9jb2wgPT09ICdxdWVyeScgfHxcbiAgICAgICAgdGhpcy5zZXJ2aWNlLmFwaS5wcm90b2NvbCA9PT0gJ2VjMicpIHtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2J1aWxkJywgdGhpcy5idWlsZEFzR2V0KTtcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXIoJ2J1aWxkJywgdGhpcy5idWlsZEFzR2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYnVpbGRBc0dldDogZnVuY3Rpb24gYnVpbGRBc0dldChyZXF1ZXN0KSB7XG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC5tZXRob2QgPSAnR0VUJztcbiAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnBhdGggPSByZXF1ZXN0LnNlcnZpY2UuZW5kcG9pbnQucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJz8nICsgcmVxdWVzdC5odHRwUmVxdWVzdC5ib2R5O1xuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QuYm9keSA9ICcnO1xuXG4gICAgLy8gZG9uJ3QgbmVlZCB0aGVzZSBoZWFkZXJzIG9uIGEgR0VUIHJlcXVlc3RcbiAgICBkZWxldGUgcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LUxlbmd0aCddO1xuICAgIGRlbGV0ZSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGhhbHRIYW5kbGVyc09uRXJyb3I6IGZ1bmN0aW9uIGhhbHRIYW5kbGVyc09uRXJyb3IoKSB7XG4gICAgdGhpcy5faGFsdEhhbmRsZXJzT25FcnJvciA9IHRydWU7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuUmVxdWVzdC5hZGRQcm9taXNlc1RvQ2xhc3MgPSBmdW5jdGlvbiBhZGRQcm9taXNlc1RvQ2xhc3MoUHJvbWlzZURlcGVuZGVuY3kpIHtcbiAgdGhpcy5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uIHByb21pc2UoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIGFwcGVuZCB0byB1c2VyIGFnZW50XG4gICAgdGhpcy5odHRwUmVxdWVzdC5hcHBlbmRUb1VzZXJBZ2VudCgncHJvbWlzZScpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZURlcGVuZGVuY3koZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBzZWxmLm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgaWYgKHJlc3AuZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QocmVzcC5lcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVmaW5lICRyZXNwb25zZSBwcm9wZXJ0eSBzbyB0aGF0IGl0IGlzIG5vdCBlbnVtYmVyYWJsZVxuICAgICAgICAgIC8vIHRoaXMgcHJldmVudHMgY2lyY3VsYXIgcmVmZXJlbmNlIGVycm9ycyB3aGVuIHN0cmluZ2lmeWluZyB0aGUgSlNPTiBvYmplY3RcbiAgICAgICAgICByZXNvbHZlKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIHJlc3AuZGF0YSB8fCB7fSxcbiAgICAgICAgICAgICckcmVzcG9uc2UnLFxuICAgICAgICAgICAge3ZhbHVlOiByZXNwfVxuICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNlbGYucnVuVG8oKTtcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5SZXF1ZXN0LmRlbGV0ZVByb21pc2VzRnJvbUNsYXNzID0gZnVuY3Rpb24gZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MoKSB7XG4gIGRlbGV0ZSB0aGlzLnByb3RvdHlwZS5wcm9taXNlO1xufTtcblxuQVdTLnV0aWwuYWRkUHJvbWlzZXMoQVdTLlJlcXVlc3QpO1xuXG5BV1MudXRpbC5taXhpbihBV1MuUmVxdWVzdCwgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcik7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpLiBZb3VcbiAqIG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBBIGNvcHkgb2ZcbiAqIHRoZSBMaWNlbnNlIGlzIGxvY2F0ZWQgYXRcbiAqXG4gKiAgICAgaHR0cDovL2F3cy5hbWF6b24uY29tL2FwYWNoZTIuMC9cbiAqXG4gKiBvciBpbiB0aGUgXCJsaWNlbnNlXCIgZmlsZSBhY2NvbXBhbnlpbmcgdGhpcyBmaWxlLiBUaGlzIGZpbGUgaXNcbiAqIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0ZcbiAqIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpY1xuICogbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG52YXIgam1lc3BhdGggPSByZXF1aXJlKCdqbWVzcGF0aCcpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDSEVDS19BQ0NFUFRPUlMocmVzcCkge1xuICB2YXIgd2FpdGVyID0gcmVzcC5yZXF1ZXN0Ll93YWl0ZXI7XG4gIHZhciBhY2NlcHRvcnMgPSB3YWl0ZXIuY29uZmlnLmFjY2VwdG9ycztcbiAgdmFyIGFjY2VwdG9yTWF0Y2hlZCA9IGZhbHNlO1xuICB2YXIgc3RhdGUgPSAncmV0cnknO1xuXG4gIGFjY2VwdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGFjY2VwdG9yKSB7XG4gICAgaWYgKCFhY2NlcHRvck1hdGNoZWQpIHtcbiAgICAgIHZhciBtYXRjaGVyID0gd2FpdGVyLm1hdGNoZXJzW2FjY2VwdG9yLm1hdGNoZXJdO1xuICAgICAgaWYgKG1hdGNoZXIgJiYgbWF0Y2hlcihyZXNwLCBhY2NlcHRvci5leHBlY3RlZCwgYWNjZXB0b3IuYXJndW1lbnQpKSB7XG4gICAgICAgIGFjY2VwdG9yTWF0Y2hlZCA9IHRydWU7XG4gICAgICAgIHN0YXRlID0gYWNjZXB0b3Iuc3RhdGU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoIWFjY2VwdG9yTWF0Y2hlZCAmJiByZXNwLmVycm9yKSBzdGF0ZSA9ICdmYWlsdXJlJztcblxuICBpZiAoc3RhdGUgPT09ICdzdWNjZXNzJykge1xuICAgIHdhaXRlci5zZXRTdWNjZXNzKHJlc3ApO1xuICB9IGVsc2Uge1xuICAgIHdhaXRlci5zZXRFcnJvcihyZXNwLCBzdGF0ZSA9PT0gJ3JldHJ5Jyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlJlc291cmNlV2FpdGVyID0gaW5oZXJpdCh7XG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgYSBnaXZlbiBzdGF0ZSBvbiBhIHNlcnZpY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSBzZXJ2aWNlIFtTZXJ2aWNlXSB0aGUgc2VydmljZSBvYmplY3QgdG8gd2FpdCBvblxuICAgKiBAcGFyYW0gc3RhdGUgW1N0cmluZ10gdGhlIHN0YXRlIChkZWZpbmVkIGluIHdhaXRlciBjb25maWd1cmF0aW9uKSB0byB3YWl0XG4gICAqICAgZm9yLlxuICAgKiBAZXhhbXBsZSBDcmVhdGUgYSB3YWl0ZXIgZm9yIHJ1bm5pbmcgRUMyIGluc3RhbmNlc1xuICAgKiAgIHZhciBlYzIgPSBuZXcgQVdTLkVDMjtcbiAgICogICB2YXIgd2FpdGVyID0gbmV3IEFXUy5SZXNvdXJjZVdhaXRlcihlYzIsICdpbnN0YW5jZVJ1bm5pbmcnKTtcbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBjb25zdHJ1Y3RvcihzZXJ2aWNlLCBzdGF0ZSkge1xuICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMubG9hZFdhaXRlckNvbmZpZyh0aGlzLnN0YXRlKTtcbiAgfSxcblxuICBzZXJ2aWNlOiBudWxsLFxuXG4gIHN0YXRlOiBudWxsLFxuXG4gIGNvbmZpZzogbnVsbCxcblxuICBtYXRjaGVyczoge1xuICAgIHBhdGg6IGZ1bmN0aW9uKHJlc3AsIGV4cGVjdGVkLCBhcmd1bWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGptZXNwYXRoLnNlYXJjaChyZXNwLmRhdGEsIGFyZ3VtZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBqbWVzcGF0aC5zdHJpY3REZWVwRXF1YWwocmVzdWx0LGV4cGVjdGVkKTtcbiAgICB9LFxuXG4gICAgcGF0aEFsbDogZnVuY3Rpb24ocmVzcCwgZXhwZWN0ZWQsIGFyZ3VtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IGptZXNwYXRoLnNlYXJjaChyZXNwLmRhdGEsIGFyZ3VtZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHRzKSkgcmVzdWx0cyA9IFtyZXN1bHRzXTtcbiAgICAgIHZhciBudW1SZXN1bHRzID0gcmVzdWx0cy5sZW5ndGg7XG4gICAgICBpZiAoIW51bVJlc3VsdHMpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGluZCA9IDAgOyBpbmQgPCBudW1SZXN1bHRzOyBpbmQrKykge1xuICAgICAgICBpZiAoIWptZXNwYXRoLnN0cmljdERlZXBFcXVhbChyZXN1bHRzW2luZF0sIGV4cGVjdGVkKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIHBhdGhBbnk6IGZ1bmN0aW9uKHJlc3AsIGV4cGVjdGVkLCBhcmd1bWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBqbWVzcGF0aC5zZWFyY2gocmVzcC5kYXRhLCBhcmd1bWVudCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0cykpIHJlc3VsdHMgPSBbcmVzdWx0c107XG4gICAgICB2YXIgbnVtUmVzdWx0cyA9IHJlc3VsdHMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaW5kID0gMCA7IGluZCA8IG51bVJlc3VsdHM7IGluZCsrKSB7XG4gICAgICAgIGlmIChqbWVzcGF0aC5zdHJpY3REZWVwRXF1YWwocmVzdWx0c1tpbmRdLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBzdGF0dXM6IGZ1bmN0aW9uKHJlc3AsIGV4cGVjdGVkKSB7XG4gICAgICB2YXIgc3RhdHVzQ29kZSA9IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICByZXR1cm4gKHR5cGVvZiBzdGF0dXNDb2RlID09PSAnbnVtYmVyJykgJiYgKHN0YXR1c0NvZGUgPT09IGV4cGVjdGVkKTtcbiAgICB9LFxuXG4gICAgZXJyb3I6IGZ1bmN0aW9uKHJlc3AsIGV4cGVjdGVkKSB7XG4gICAgICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiByZXNwLmVycm9yKSB7XG4gICAgICAgIHJldHVybiBleHBlY3RlZCA9PT0gcmVzcC5lcnJvci5jb2RlO1xuICAgICAgfVxuICAgICAgLy8gaWYgZXhwZWN0ZWQgaXMgbm90IHN0cmluZywgY2FuIGJlIGJvb2xlYW4gaW5kaWNhdGluZyBwcmVzZW5jZSBvZiBlcnJvclxuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSAhIXJlc3AuZXJyb3I7XG4gICAgfVxuICB9LFxuXG4gIGxpc3RlbmVyczogbmV3IEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICBhZGQoJ1JFVFJZX0NIRUNLJywgJ3JldHJ5JywgZnVuY3Rpb24ocmVzcCkge1xuICAgICAgdmFyIHdhaXRlciA9IHJlc3AucmVxdWVzdC5fd2FpdGVyO1xuICAgICAgaWYgKHJlc3AuZXJyb3IgJiYgcmVzcC5lcnJvci5jb2RlID09PSAnUmVzb3VyY2VOb3RSZWFkeScpIHtcbiAgICAgICAgcmVzcC5lcnJvci5yZXRyeURlbGF5ID0gKHdhaXRlci5jb25maWcuZGVsYXkgfHwgMCkgKiAxMDAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdDSEVDS19PVVRQVVQnLCAnZXh0cmFjdERhdGEnLCBDSEVDS19BQ0NFUFRPUlMpO1xuXG4gICAgYWRkKCdDSEVDS19FUlJPUicsICdleHRyYWN0RXJyb3InLCBDSEVDS19BQ0NFUFRPUlMpO1xuICB9KSxcblxuICAvKipcbiAgICogQHJldHVybiBbQVdTLlJlcXVlc3RdXG4gICAqL1xuICB3YWl0OiBmdW5jdGlvbiB3YWl0KHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7IHBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zICYmIHBhcmFtcy4kd2FpdGVyKSB7XG4gICAgICBwYXJhbXMgPSBBV1MudXRpbC5jb3B5KHBhcmFtcyk7XG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy4kd2FpdGVyLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLmNvbmZpZy5kZWxheSA9IHBhcmFtcy4kd2FpdGVyLmRlbGF5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMuJHdhaXRlci5tYXhBdHRlbXB0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5jb25maWcubWF4QXR0ZW1wdHMgPSBwYXJhbXMuJHdhaXRlci5tYXhBdHRlbXB0cztcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBwYXJhbXMuJHdhaXRlcjtcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IHRoaXMuc2VydmljZS5tYWtlUmVxdWVzdCh0aGlzLmNvbmZpZy5vcGVyYXRpb24sIHBhcmFtcyk7XG4gICAgcmVxdWVzdC5fd2FpdGVyID0gdGhpcztcbiAgICByZXF1ZXN0LnJlc3BvbnNlLm1heFJldHJpZXMgPSB0aGlzLmNvbmZpZy5tYXhBdHRlbXB0cztcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVycyh0aGlzLmxpc3RlbmVycyk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHJlcXVlc3Quc2VuZChjYWxsYmFjayk7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH0sXG5cbiAgc2V0U3VjY2VzczogZnVuY3Rpb24gc2V0U3VjY2VzcyhyZXNwKSB7XG4gICAgcmVzcC5lcnJvciA9IG51bGw7XG4gICAgcmVzcC5kYXRhID0gcmVzcC5kYXRhIHx8IHt9O1xuICAgIHJlc3AucmVxdWVzdC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2V4dHJhY3REYXRhJyk7XG4gIH0sXG5cbiAgc2V0RXJyb3I6IGZ1bmN0aW9uIHNldEVycm9yKHJlc3AsIHJldHJ5YWJsZSkge1xuICAgIHJlc3AuZGF0YSA9IG51bGw7XG4gICAgcmVzcC5lcnJvciA9IEFXUy51dGlsLmVycm9yKHJlc3AuZXJyb3IgfHwgbmV3IEVycm9yKCksIHtcbiAgICAgIGNvZGU6ICdSZXNvdXJjZU5vdFJlYWR5JyxcbiAgICAgIG1lc3NhZ2U6ICdSZXNvdXJjZSBpcyBub3QgaW4gdGhlIHN0YXRlICcgKyB0aGlzLnN0YXRlLFxuICAgICAgcmV0cnlhYmxlOiByZXRyeWFibGVcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogTG9hZHMgd2FpdGVyIGNvbmZpZ3VyYXRpb24gZnJvbSBBUEkgY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxvYWRXYWl0ZXJDb25maWc6IGZ1bmN0aW9uIGxvYWRXYWl0ZXJDb25maWcoc3RhdGUpIHtcbiAgICBpZiAoIXRoaXMuc2VydmljZS5hcGkud2FpdGVyc1tzdGF0ZV0pIHtcbiAgICAgIHRocm93IG5ldyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnU3RhdGVOb3RGb3VuZEVycm9yJyxcbiAgICAgICAgbWVzc2FnZTogJ1N0YXRlICcgKyBzdGF0ZSArICcgbm90IGZvdW5kLidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuY29uZmlnID0gQVdTLnV0aWwuY29weSh0aGlzLnNlcnZpY2UuYXBpLndhaXRlcnNbc3RhdGVdKTtcbiAgfVxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG52YXIgam1lc3BhdGggPSByZXF1aXJlKCdqbWVzcGF0aCcpO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgZW5jYXBzdWxhdGVzIHRoZSByZXNwb25zZSBpbmZvcm1hdGlvblxuICogZnJvbSBhIHNlcnZpY2UgcmVxdWVzdCBvcGVyYXRpb24gc2VudCB0aHJvdWdoIHtBV1MuUmVxdWVzdH0uXG4gKiBUaGUgcmVzcG9uc2Ugb2JqZWN0IGhhcyB0d28gbWFpbiBwcm9wZXJ0aWVzIGZvciBnZXR0aW5nIGluZm9ybWF0aW9uXG4gKiBiYWNrIGZyb20gYSByZXF1ZXN0OlxuICpcbiAqICMjIFRoZSBgZGF0YWAgcHJvcGVydHlcbiAqXG4gKiBUaGUgYHJlc3BvbnNlLmRhdGFgIHByb3BlcnR5IGNvbnRhaW5zIHRoZSBzZXJpYWxpemVkIG9iamVjdCBkYXRhXG4gKiByZXRyaWV2ZWQgZnJvbSB0aGUgc2VydmljZSByZXF1ZXN0LiBGb3IgaW5zdGFuY2UsIGZvciBhblxuICogQW1hem9uIER5bmFtb0RCIGBsaXN0VGFibGVzYCBtZXRob2QgY2FsbCwgdGhlIHJlc3BvbnNlIGRhdGEgbWlnaHRcbiAqIGxvb2sgbGlrZTpcbiAqXG4gKiBgYGBcbiAqID4gcmVzcC5kYXRhXG4gKiB7IFRhYmxlTmFtZXM6XG4gKiAgICBbICd0YWJsZTEnLCAndGFibGUyJywgLi4uIF0gfVxuICogYGBgXG4gKlxuICogVGhlIGBkYXRhYCBwcm9wZXJ0eSBjYW4gYmUgbnVsbCBpZiBhbiBlcnJvciBvY2N1cnMgKHNlZSBiZWxvdykuXG4gKlxuICogIyMgVGhlIGBlcnJvcmAgcHJvcGVydHlcbiAqXG4gKiBJbiB0aGUgZXZlbnQgb2YgYSBzZXJ2aWNlIGVycm9yIChvciB0cmFuc2ZlciBlcnJvciksIHRoZVxuICogYHJlc3BvbnNlLmVycm9yYCBwcm9wZXJ0eSB3aWxsIGJlIGZpbGxlZCB3aXRoIHRoZSBnaXZlblxuICogZXJyb3IgZGF0YSBpbiB0aGUgZm9ybTpcbiAqXG4gKiBgYGBcbiAqIHsgY29kZTogJ1NIT1JUX1VOSVFVRV9FUlJPUl9DT0RFJyxcbiAqICAgbWVzc2FnZTogJ1NvbWUgaHVtYW4gcmVhZGFibGUgZXJyb3IgbWVzc2FnZScgfVxuICogYGBgXG4gKlxuICogSW4gdGhlIGNhc2Ugb2YgYW4gZXJyb3IsIHRoZSBgZGF0YWAgcHJvcGVydHkgd2lsbCBiZSBgbnVsbGAuXG4gKiBOb3RlIHRoYXQgaWYgeW91IGhhbmRsZSBldmVudHMgdGhhdCBjYW4gYmUgaW4gYSBmYWlsdXJlIHN0YXRlLFxuICogeW91IHNob3VsZCBhbHdheXMgY2hlY2sgd2hldGhlciBgcmVzcG9uc2UuZXJyb3JgIGlzIHNldFxuICogYmVmb3JlIGF0dGVtcHRpbmcgdG8gYWNjZXNzIHRoZSBgcmVzcG9uc2UuZGF0YWAgcHJvcGVydHkuXG4gKlxuICogQCFhdHRyaWJ1dGUgZGF0YVxuICogICBAcmVhZG9ubHlcbiAqICAgQCFncm91cCBEYXRhIFByb3BlcnRpZXNcbiAqICAgQG5vdGUgSW5zaWRlIG9mIGEge0FXUy5SZXF1ZXN0fmh0dHBEYXRhfSBldmVudCwgdGhpc1xuICogICAgIHByb3BlcnR5IGNvbnRhaW5zIGEgc2luZ2xlIHJhdyBwYWNrZXQgaW5zdGVhZCBvZiB0aGVcbiAqICAgICBmdWxsIGRlLXNlcmlhbGl6ZWQgc2VydmljZSByZXNwb25zZS5cbiAqICAgQHJldHVybiBbT2JqZWN0XSB0aGUgZGUtc2VyaWFsaXplZCByZXNwb25zZSBkYXRhXG4gKiAgICAgZnJvbSB0aGUgc2VydmljZS5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBlcnJvclxuICogICBBbiBzdHJ1Y3R1cmUgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCBhIHNlcnZpY2VcbiAqICAgb3IgbmV0d29ya2luZyBlcnJvci5cbiAqICAgQHJlYWRvbmx5XG4gKiAgIEAhZ3JvdXAgRGF0YSBQcm9wZXJ0aWVzXG4gKiAgIEBub3RlIFRoaXMgYXR0cmlidXRlIGlzIG9ubHkgZmlsbGVkIGlmIGEgc2VydmljZSBvclxuICogICAgIG5ldHdvcmtpbmcgZXJyb3Igb2NjdXJzLlxuICogICBAcmV0dXJuIFtFcnJvcl1cbiAqICAgICAqIGNvZGUgW1N0cmluZ10gYSB1bmlxdWUgc2hvcnQgY29kZSByZXByZXNlbnRpbmcgdGhlXG4gKiAgICAgICBlcnJvciB0aGF0IHdhcyBlbWl0dGVkLlxuICogICAgICogbWVzc2FnZSBbU3RyaW5nXSBhIGxvbmdlciBodW1hbiByZWFkYWJsZSBlcnJvciBtZXNzYWdlXG4gKiAgICAgKiByZXRyeWFibGUgW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIGVycm9yIG1lc3NhZ2UgaXNcbiAqICAgICAgIHJldHJ5YWJsZS5cbiAqICAgICAqIHN0YXR1c0NvZGUgW051bWVyaWNdIGluIHRoZSBjYXNlIG9mIGEgcmVxdWVzdCB0aGF0IHJlYWNoZWQgdGhlIHNlcnZpY2UsXG4gKiAgICAgICB0aGlzIHZhbHVlIGNvbnRhaW5zIHRoZSByZXNwb25zZSBzdGF0dXMgY29kZS5cbiAqICAgICAqIHRpbWUgW0RhdGVdIHRoZSBkYXRlIHRpbWUgb2JqZWN0IHdoZW4gdGhlIGVycm9yIG9jY3VycmVkLlxuICogICAgICogaG9zdG5hbWUgW1N0cmluZ10gc2V0IHdoZW4gYSBuZXR3b3JraW5nIGVycm9yIG9jY3VycyB0byBlYXNpbHlcbiAqICAgICAgIGlkZW50aWZ5IHRoZSBlbmRwb2ludCBvZiB0aGUgcmVxdWVzdC5cbiAqICAgICAqIHJlZ2lvbiBbU3RyaW5nXSBzZXQgd2hlbiBhIG5ldHdvcmtpbmcgZXJyb3Igb2NjdXJzIHRvIGVhc2lseVxuICogICAgICAgaWRlbnRpZnkgdGhlIHJlZ2lvbiBvZiB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSByZXF1ZXN0SWRcbiAqICAgQHJlYWRvbmx5XG4gKiAgIEAhZ3JvdXAgRGF0YSBQcm9wZXJ0aWVzXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIHVuaXF1ZSByZXF1ZXN0IElEIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVzcG9uc2UuXG4gKiAgICAgTG9nIHRoaXMgdmFsdWUgd2hlbiBkZWJ1Z2dpbmcgcmVxdWVzdHMgZm9yIEFXUyBzdXBwb3J0LlxuICpcbiAqIEAhYXR0cmlidXRlIHJldHJ5Q291bnRcbiAqICAgQHJlYWRvbmx5XG4gKiAgIEAhZ3JvdXAgT3BlcmF0aW9uIFByb3BlcnRpZXNcbiAqICAgQHJldHVybiBbSW50ZWdlcl0gdGhlIG51bWJlciBvZiByZXRyaWVzIHRoYXQgd2VyZVxuICogICAgIGF0dGVtcHRlZCBiZWZvcmUgdGhlIHJlcXVlc3Qgd2FzIGNvbXBsZXRlZC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSByZWRpcmVjdENvdW50XG4gKiAgIEByZWFkb25seVxuICogICBAIWdyb3VwIE9wZXJhdGlvbiBQcm9wZXJ0aWVzXG4gKiAgIEByZXR1cm4gW0ludGVnZXJdIHRoZSBudW1iZXIgb2YgcmVkaXJlY3RzIHRoYXQgd2VyZVxuICogICAgIGZvbGxvd2VkIGJlZm9yZSB0aGUgcmVxdWVzdCB3YXMgY29tcGxldGVkLlxuICpcbiAqIEAhYXR0cmlidXRlIGh0dHBSZXNwb25zZVxuICogICBAcmVhZG9ubHlcbiAqICAgQCFncm91cCBIVFRQIFByb3BlcnRpZXNcbiAqICAgQHJldHVybiBbQVdTLkh0dHBSZXNwb25zZV0gdGhlIHJhdyBIVFRQIHJlc3BvbnNlIG9iamVjdFxuICogICAgIGNvbnRhaW5pbmcgdGhlIHJlc3BvbnNlIGhlYWRlcnMgYW5kIGJvZHkgaW5mb3JtYXRpb25cbiAqICAgICBmcm9tIHRoZSBzZXJ2ZXIuXG4gKlxuICogQHNlZSBBV1MuUmVxdWVzdFxuICovXG5BV1MuUmVzcG9uc2UgPSBpbmhlcml0KHtcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gUmVzcG9uc2UocmVxdWVzdCkge1xuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xuICAgIHRoaXMucmVkaXJlY3RDb3VudCA9IDA7XG4gICAgdGhpcy5odHRwUmVzcG9uc2UgPSBuZXcgQVdTLkh0dHBSZXNwb25zZSgpO1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICB0aGlzLm1heFJldHJpZXMgPSByZXF1ZXN0LnNlcnZpY2UubnVtUmV0cmllcygpO1xuICAgICAgdGhpcy5tYXhSZWRpcmVjdHMgPSByZXF1ZXN0LnNlcnZpY2UuY29uZmlnLm1heFJlZGlyZWN0cztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcmVxdWVzdCBmb3IgdGhlIG5leHQgcGFnZSBvZiByZXNwb25zZSBkYXRhLCBjYWxsaW5nIHRoZVxuICAgKiBjYWxsYmFjayB3aXRoIHRoZSBwYWdlIGRhdGEgaWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZC5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgZGF0YSlcbiAgICogICBDYWxsZWQgd2hlbiBhIHBhZ2Ugb2YgZGF0YSBpcyByZXR1cm5lZCBmcm9tIHRoZSBuZXh0IHJlcXVlc3QuXG4gICAqXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGFuIGVycm9yIG9iamVjdCwgaWYgYW4gZXJyb3Igb2NjdXJyZWQgaW4gdGhlIHJlcXVlc3RcbiAgICogICBAcGFyYW0gZGF0YSBbT2JqZWN0XSB0aGUgbmV4dCBwYWdlIG9mIGRhdGEsIG9yIG51bGwsIGlmIHRoZXJlIGFyZSBub1xuICAgKiAgICAgbW9yZSBwYWdlcyBsZWZ0LlxuICAgKiBAcmV0dXJuIFtBV1MuUmVxdWVzdF0gdGhlIHJlcXVlc3Qgb2JqZWN0IGZvciB0aGUgbmV4dCBwYWdlIG9mIGRhdGFcbiAgICogQHJldHVybiBbbnVsbF0gaWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWQgYW5kIHRoZXJlIGFyZSBubyBwYWdlcyBsZWZ0XG4gICAqICAgdG8gcmV0cmlldmUuXG4gICAqIEBzaW5jZSB2MS40LjBcbiAgICovXG4gIG5leHRQYWdlOiBmdW5jdGlvbiBuZXh0UGFnZShjYWxsYmFjaykge1xuICAgIHZhciBjb25maWc7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzLnJlcXVlc3Quc2VydmljZTtcbiAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5yZXF1ZXN0Lm9wZXJhdGlvbjtcbiAgICB0cnkge1xuICAgICAgY29uZmlnID0gc2VydmljZS5wYWdpbmF0aW9uQ29uZmlnKG9wZXJhdGlvbiwgdHJ1ZSk7XG4gICAgfSBjYXRjaCAoZSkgeyB0aGlzLmVycm9yID0gZTsgfVxuXG4gICAgaWYgKCF0aGlzLmhhc05leHRQYWdlKCkpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2sodGhpcy5lcnJvciwgbnVsbCk7XG4gICAgICBlbHNlIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9IEFXUy51dGlsLmNvcHkodGhpcy5yZXF1ZXN0LnBhcmFtcyk7XG4gICAgaWYgKCF0aGlzLm5leHRQYWdlVG9rZW5zKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjayhudWxsLCBudWxsKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpbnB1dFRva2VucyA9IGNvbmZpZy5pbnB1dFRva2VuO1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dFRva2VucyA9PT0gJ3N0cmluZycpIGlucHV0VG9rZW5zID0gW2lucHV0VG9rZW5zXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXRUb2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFyYW1zW2lucHV0VG9rZW5zW2ldXSA9IHRoaXMubmV4dFBhZ2VUb2tlbnNbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VydmljZS5tYWtlUmVxdWVzdCh0aGlzLnJlcXVlc3Qub3BlcmF0aW9uLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgbW9yZSBwYWdlcyBvZiBkYXRhIGNhbiBiZSByZXR1cm5lZCBieSBmdXJ0aGVyXG4gICAqICAgcmVxdWVzdHNcbiAgICogQHNpbmNlIHYxLjQuMFxuICAgKi9cbiAgaGFzTmV4dFBhZ2U6IGZ1bmN0aW9uIGhhc05leHRQYWdlKCkge1xuICAgIHRoaXMuY2FjaGVOZXh0UGFnZVRva2VucygpO1xuICAgIGlmICh0aGlzLm5leHRQYWdlVG9rZW5zKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5uZXh0UGFnZVRva2VucyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNhY2hlTmV4dFBhZ2VUb2tlbnM6IGZ1bmN0aW9uIGNhY2hlTmV4dFBhZ2VUb2tlbnMoKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnbmV4dFBhZ2VUb2tlbnMnKSkgcmV0dXJuIHRoaXMubmV4dFBhZ2VUb2tlbnM7XG4gICAgdGhpcy5uZXh0UGFnZVRva2VucyA9IHVuZGVmaW5lZDtcblxuICAgIHZhciBjb25maWcgPSB0aGlzLnJlcXVlc3Quc2VydmljZS5wYWdpbmF0aW9uQ29uZmlnKHRoaXMucmVxdWVzdC5vcGVyYXRpb24pO1xuICAgIGlmICghY29uZmlnKSByZXR1cm4gdGhpcy5uZXh0UGFnZVRva2VucztcblxuICAgIHRoaXMubmV4dFBhZ2VUb2tlbnMgPSBudWxsO1xuICAgIGlmIChjb25maWcubW9yZVJlc3VsdHMpIHtcbiAgICAgIGlmICgham1lc3BhdGguc2VhcmNoKHRoaXMuZGF0YSwgY29uZmlnLm1vcmVSZXN1bHRzKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0UGFnZVRva2VucztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZXhwcnMgPSBjb25maWcub3V0cHV0VG9rZW47XG4gICAgaWYgKHR5cGVvZiBleHBycyA9PT0gJ3N0cmluZycpIGV4cHJzID0gW2V4cHJzXTtcbiAgICBBV1MudXRpbC5hcnJheUVhY2guY2FsbCh0aGlzLCBleHBycywgZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgIHZhciBvdXRwdXQgPSBqbWVzcGF0aC5zZWFyY2godGhpcy5kYXRhLCBleHByKTtcbiAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgdGhpcy5uZXh0UGFnZVRva2VucyA9IHRoaXMubmV4dFBhZ2VUb2tlbnMgfHwgW107XG4gICAgICAgIHRoaXMubmV4dFBhZ2VUb2tlbnMucHVzaChvdXRwdXQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMubmV4dFBhZ2VUb2tlbnM7XG4gIH1cblxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIGJ5dGVMZW5ndGggPSBBV1MudXRpbC5zdHJpbmcuYnl0ZUxlbmd0aDtcbnZhciBCdWZmZXIgPSBBV1MudXRpbC5CdWZmZXI7XG5cbi8qKlxuICogVGhlIG1hbmFnZWQgdXBsb2FkZXIgYWxsb3dzIGZvciBlYXN5IGFuZCBlZmZpY2llbnQgdXBsb2FkaW5nIG9mIGJ1ZmZlcnMsXG4gKiBibG9icywgb3Igc3RyZWFtcywgdXNpbmcgYSBjb25maWd1cmFibGUgYW1vdW50IG9mIGNvbmN1cnJlbmN5IHRvIHBlcmZvcm1cbiAqIG11bHRpcGFydCB1cGxvYWRzIHdoZXJlIHBvc3NpYmxlLiBUaGlzIGFic3RyYWN0aW9uIGFsc28gZW5hYmxlcyB1cGxvYWRpbmdcbiAqIHN0cmVhbXMgb2YgdW5rbm93biBzaXplIGR1ZSB0byB0aGUgdXNlIG9mIG11bHRpcGFydCB1cGxvYWRzLlxuICpcbiAqIFRvIGNvbnN0cnVjdCBhIG1hbmFnZWQgdXBsb2FkIG9iamVjdCwgc2VlIHRoZSB7Y29uc3RydWN0b3J9IGZ1bmN0aW9uLlxuICpcbiAqICMjIFRyYWNraW5nIHVwbG9hZCBwcm9ncmVzc1xuICpcbiAqIFRoZSBtYW5hZ2VkIHVwbG9hZCBvYmplY3QgY2FuIGFsc28gdHJhY2sgcHJvZ3Jlc3MgYnkgYXR0YWNoaW5nIGFuXG4gKiAnaHR0cFVwbG9hZFByb2dyZXNzJyBsaXN0ZW5lciB0byB0aGUgdXBsb2FkIG1hbmFnZXIuIFRoaXMgZXZlbnQgaXMgc2ltaWxhclxuICogdG8ge0FXUy5SZXF1ZXN0fmh0dHBVcGxvYWRQcm9ncmVzc30gYnV0IGdyb3VwcyBhbGwgY29uY3VycmVudCB1cGxvYWQgcHJvZ3Jlc3NcbiAqIGludG8gYSBzaW5nbGUgZXZlbnQuIFNlZSB7QVdTLlMzLk1hbmFnZWRVcGxvYWR+aHR0cFVwbG9hZFByb2dyZXNzfSBmb3IgbW9yZVxuICogaW5mb3JtYXRpb24uXG4gKlxuICogIyMgSGFuZGxpbmcgTXVsdGlwYXJ0IENsZWFudXBcbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGlzIGNsYXNzIHdpbGwgYXV0b21hdGljYWxseSBjbGVhbiB1cCBhbnkgbXVsdGlwYXJ0IHVwbG9hZHNcbiAqIHdoZW4gYW4gaW5kaXZpZHVhbCBwYXJ0IHVwbG9hZCBmYWlscy4gVGhpcyBiZWhhdmlvciBjYW4gYmUgZGlzYWJsZWQgaW4gb3JkZXJcbiAqIHRvIG1hbnVhbGx5IGhhbmRsZSBmYWlsdXJlcyBieSBzZXR0aW5nIHRoZSBgbGVhdmVQYXJ0c09uRXJyb3JgIGNvbmZpZ3VyYXRpb25cbiAqIG9wdGlvbiB0byBgdHJ1ZWAgd2hlbiBpbml0aWFsaXppbmcgdGhlIHVwbG9hZCBvYmplY3QuXG4gKlxuICogQCFldmVudCBodHRwVXBsb2FkUHJvZ3Jlc3MocHJvZ3Jlc3MpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIHRoZSB1cGxvYWRlciBoYXMgdXBsb2FkZWQgbW9yZSBkYXRhLlxuICogICBAbm90ZSBUaGUgYHRvdGFsYCBwcm9wZXJ0eSBtYXkgbm90IGJlIHNldCBpZiB0aGUgc3RyZWFtIGJlaW5nIHVwbG9hZGVkIGhhc1xuICogICAgIG5vdCB5ZXQgZmluaXNoZWQgY2h1bmtpbmcuIEluIHRoaXMgY2FzZSB0aGUgYHRvdGFsYCB3aWxsIGJlIHVuZGVmaW5lZFxuICogICAgIHVudGlsIHRoZSB0b3RhbCBzdHJlYW0gc2l6ZSBpcyBrbm93bi5cbiAqICAgQG5vdGUgVGhpcyBldmVudCB3aWxsIG5vdCBiZSBlbWl0dGVkIGluIE5vZGUuanMgMC44LnguXG4gKiAgIEBwYXJhbSBwcm9ncmVzcyBbbWFwXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgYGxvYWRlZGAgYW5kIGB0b3RhbGAgYnl0ZXNcbiAqICAgICBvZiB0aGUgcmVxdWVzdCBhbmQgdGhlIGBrZXlgIG9mIHRoZSBTMyBvYmplY3QuIE5vdGUgdGhhdCBgdG90YWxgIG1heSBiZSB1bmRlZmluZWQgdW50aWwgdGhlIHBheWxvYWRcbiAqICAgICBzaXplIGlzIGtub3duLlxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKi9cbkFXUy5TMy5NYW5hZ2VkVXBsb2FkID0gQVdTLnV0aWwuaW5oZXJpdCh7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbWFuYWdlZCB1cGxvYWQgb2JqZWN0IHdpdGggYSBzZXQgb2YgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAbm90ZSBBIFwiQm9keVwiIHBhcmFtZXRlciBpcyByZXF1aXJlZCB0byBiZSBzZXQgcHJpb3IgdG8gY2FsbGluZyB7c2VuZH0uXG4gICAqIEBub3RlIEluIE5vZGUuanMsIHNlbmRpbmcgXCJCb2R5XCIgYXMge2h0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fb2JqZWN0X21vZGUgb2JqZWN0LW1vZGUgc3RyZWFtfVxuICAgKiAgIG1heSByZXN1bHQgaW4gdXBsb2FkIGhhbmdzLiBVc2luZyBidWZmZXIgc3RyZWFtIGlzIHByZWZlcmFibGUuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBwYXJhbXMgW21hcF0gYSBtYXAgb2YgcGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSB1cGxvYWRcbiAgICogICByZXF1ZXN0cy4gVGhlIFwiQm9keVwiIHBhcmFtZXRlciBpcyByZXF1aXJlZCB0byBiZSBzcGVjaWZpZWQgZWl0aGVyIG9uXG4gICAqICAgdGhlIHNlcnZpY2Ugb3IgaW4gdGhlIHBhcmFtcyBvcHRpb24uXG4gICAqIEBub3RlIENvbnRlbnRNRDUgc2hvdWxkIG5vdCBiZSBwcm92aWRlZCB3aGVuIHVzaW5nIHRoZSBtYW5hZ2VkIHVwbG9hZCBvYmplY3QuXG4gICAqICAgSW5zdGVhZCwgc2V0dGluZyBcImNvbXB1dGVDaGVja3N1bXNcIiB0byB0cnVlIHdpbGwgZW5hYmxlIGF1dG9tYXRpYyBDb250ZW50TUQ1IGdlbmVyYXRpb25cbiAgICogICBieSB0aGUgbWFuYWdlZCB1cGxvYWQgb2JqZWN0LlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgcXVldWVTaXplIFtOdW1iZXJdICg0KSB0aGUgc2l6ZSBvZiB0aGUgY29uY3VycmVudCBxdWV1ZVxuICAgKiAgIG1hbmFnZXIgdG8gdXBsb2FkIHBhcnRzIGluIHBhcmFsbGVsLiBTZXQgdG8gMSBmb3Igc3luY2hyb25vdXMgdXBsb2FkaW5nXG4gICAqICAgb2YgcGFydHMuIE5vdGUgdGhhdCB0aGUgdXBsb2FkZXIgd2lsbCBidWZmZXIgYXQgbW9zdCBxdWV1ZVNpemUgKiBwYXJ0U2l6ZVxuICAgKiAgIGJ5dGVzIGludG8gbWVtb3J5IGF0IGFueSBnaXZlbiB0aW1lLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgcGFydFNpemUgW051bWJlcl0gKDVtYikgdGhlIHNpemUgaW4gYnl0ZXMgZm9yIGVhY2hcbiAgICogICBpbmRpdmlkdWFsIHBhcnQgdG8gYmUgdXBsb2FkZWQuIEFkanVzdCB0aGUgcGFydCBzaXplIHRvIGVuc3VyZSB0aGUgbnVtYmVyXG4gICAqICAgb2YgcGFydHMgZG9lcyBub3QgZXhjZWVkIHttYXhUb3RhbFBhcnRzfS4gU2VlIHttaW5QYXJ0U2l6ZX0gZm9yIHRoZVxuICAgKiAgIG1pbmltdW0gYWxsb3dlZCBwYXJ0IHNpemUuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBsZWF2ZVBhcnRzT25FcnJvciBbQm9vbGVhbl0gKGZhbHNlKSB3aGV0aGVyIHRvIGFib3J0IHRoZVxuICAgKiAgIG11bHRpcGFydCB1cGxvYWQgaWYgYW4gZXJyb3Igb2NjdXJzLiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBoYW5kbGVcbiAgICogICBmYWlsdXJlcyBtYW51YWxseS5cbiAgICogQG9wdGlvbiBvcHRpb25zIHNlcnZpY2UgW0FXUy5TM10gYW4gb3B0aW9uYWwgUzMgc2VydmljZSBvYmplY3QgdG8gdXNlIGZvclxuICAgKiAgIHJlcXVlc3RzLiBUaGlzIG9iamVjdCBtaWdodCBoYXZlIGJvdW5kIHBhcmFtZXRlcnMgdXNlZCBieSB0aGUgdXBsb2FkZXIuXG4gICAqIEBvcHRpb24gb3B0aW9ucyB0YWdzIFtBcnJheTxtYXA+XSBUaGUgdGFncyB0byBhcHBseSB0byB0aGUgdXBsb2FkZWQgb2JqZWN0LlxuICAgKiAgIEVhY2ggdGFnIHNob3VsZCBoYXZlIGEgYEtleWAgYW5kIGBWYWx1ZWAga2V5cy5cbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBkZWZhdWx0IHVwbG9hZGVyIGZvciBhIHN0cmVhbSBvYmplY3RcbiAgICogICB2YXIgdXBsb2FkID0gbmV3IEFXUy5TMy5NYW5hZ2VkVXBsb2FkKHtcbiAgICogICAgIHBhcmFtczoge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsIEJvZHk6IHN0cmVhbX1cbiAgICogICB9KTtcbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYW4gdXBsb2FkZXIgd2l0aCBjb25jdXJyZW5jeSBvZiAxIGFuZCBwYXJ0U2l6ZSBvZiAxMG1iXG4gICAqICAgdmFyIHVwbG9hZCA9IG5ldyBBV1MuUzMuTWFuYWdlZFVwbG9hZCh7XG4gICAqICAgICBwYXJ0U2l6ZTogMTAgKiAxMDI0ICogMTAyNCwgcXVldWVTaXplOiAxLFxuICAgKiAgICAgcGFyYW1zOiB7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5JywgQm9keTogc3RyZWFtfVxuICAgKiAgIH0pO1xuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhbiB1cGxvYWRlciB3aXRoIHRhZ3NcbiAgICogICB2YXIgdXBsb2FkID0gbmV3IEFXUy5TMy5NYW5hZ2VkVXBsb2FkKHtcbiAgICogICAgIHBhcmFtczoge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsIEJvZHk6IHN0cmVhbX0sXG4gICAqICAgICB0YWdzOiBbe0tleTogJ3RhZzEnLCBWYWx1ZTogJ3ZhbHVlMSd9LCB7S2V5OiAndGFnMicsIFZhbHVlOiAndmFsdWUyJ31dXG4gICAqICAgfSk7XG4gICAqIEBzZWUgc2VuZFxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIE1hbmFnZWRVcGxvYWQob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yLmNhbGwoc2VsZik7XG4gICAgc2VsZi5ib2R5ID0gbnVsbDtcbiAgICBzZWxmLnNsaWNlRm4gPSBudWxsO1xuICAgIHNlbGYuY2FsbGJhY2sgPSBudWxsO1xuICAgIHNlbGYucGFydHMgPSB7fTtcbiAgICBzZWxmLmNvbXBsZXRlSW5mbyA9IFtdO1xuICAgIHNlbGYuZmlsbFF1ZXVlID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmNhbGxiYWNrKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYm9keSBwYXlsb2FkICcgKyB0eXBlb2Ygc2VsZi5ib2R5KSk7XG4gICAgfTtcblxuICAgIHNlbGYuY29uZmlndXJlKG9wdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbmZpZ3VyZTogZnVuY3Rpb24gY29uZmlndXJlKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnBhcnRTaXplID0gdGhpcy5taW5QYXJ0U2l6ZTtcblxuICAgIGlmIChvcHRpb25zLnF1ZXVlU2l6ZSkgdGhpcy5xdWV1ZVNpemUgPSBvcHRpb25zLnF1ZXVlU2l6ZTtcbiAgICBpZiAob3B0aW9ucy5wYXJ0U2l6ZSkgdGhpcy5wYXJ0U2l6ZSA9IG9wdGlvbnMucGFydFNpemU7XG4gICAgaWYgKG9wdGlvbnMubGVhdmVQYXJ0c09uRXJyb3IpIHRoaXMubGVhdmVQYXJ0c09uRXJyb3IgPSB0cnVlO1xuICAgIGlmIChvcHRpb25zLnRhZ3MpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLnRhZ3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGFncyBtdXN0IGJlIHNwZWNpZmllZCBhcyBhbiBhcnJheTsgJyArXG4gICAgICAgICAgdHlwZW9mIG9wdGlvbnMudGFncyArICcgcHJvdmlkZWQuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnRhZ3MgPSBvcHRpb25zLnRhZ3M7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFydFNpemUgPCB0aGlzLm1pblBhcnRTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRTaXplIG11c3QgYmUgZ3JlYXRlciB0aGFuICcgK1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluUGFydFNpemUpO1xuICAgIH1cblxuICAgIHRoaXMuc2VydmljZSA9IG9wdGlvbnMuc2VydmljZTtcbiAgICB0aGlzLmJpbmRTZXJ2aWNlT2JqZWN0KG9wdGlvbnMucGFyYW1zKTtcbiAgICB0aGlzLnZhbGlkYXRlQm9keSgpO1xuICAgIHRoaXMuYWRqdXN0VG90YWxCeXRlcygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxlYXZlUGFydHNPbkVycm9yOiBmYWxzZSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBxdWV1ZVNpemU6IDQsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcGFydFNpemU6IG51bGwsXG5cbiAgLyoqXG4gICAqIEByZWFkb25seVxuICAgKiBAcmV0dXJuIFtOdW1iZXJdIHRoZSBtaW5pbXVtIG51bWJlciBvZiBieXRlcyBmb3IgYW4gaW5kaXZpZHVhbCBwYXJ0XG4gICAqICAgdXBsb2FkLlxuICAgKi9cbiAgbWluUGFydFNpemU6IDEwMjQgKiAxMDI0ICogNSxcblxuICAvKipcbiAgICogQHJlYWRvbmx5XG4gICAqIEByZXR1cm4gW051bWJlcl0gdGhlIG1heGltdW0gYWxsb3dlZCBudW1iZXIgb2YgcGFydHMgaW4gYSBtdWx0aXBhcnQgdXBsb2FkLlxuICAgKi9cbiAgbWF4VG90YWxQYXJ0czogMTAwMDAsXG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyB0aGUgbWFuYWdlZCB1cGxvYWQgZm9yIHRoZSBwYXlsb2FkLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBkYXRhKVxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBhbiBlcnJvciBvciBudWxsIGlmIG5vIGVycm9yIG9jY3VycmVkLlxuICAgKiAgIEBwYXJhbSBkYXRhIFttYXBdIFRoZSByZXNwb25zZSBkYXRhIGZyb20gdGhlIHN1Y2Nlc3NmdWwgdXBsb2FkOlxuICAgKiAgICAgKiBgTG9jYXRpb25gIChTdHJpbmcpIHRoZSBVUkwgb2YgdGhlIHVwbG9hZGVkIG9iamVjdFxuICAgKiAgICAgKiBgRVRhZ2AgKFN0cmluZykgdGhlIEVUYWcgb2YgdGhlIHVwbG9hZGVkIG9iamVjdFxuICAgKiAgICAgKiBgQnVja2V0YCAoU3RyaW5nKSB0aGUgYnVja2V0IHRvIHdoaWNoIHRoZSBvYmplY3Qgd2FzIHVwbG9hZGVkXG4gICAqICAgICAqIGBLZXlgIChTdHJpbmcpIHRoZSBrZXkgdG8gd2hpY2ggdGhlIG9iamVjdCB3YXMgdXBsb2FkZWRcbiAgICogQGV4YW1wbGUgU2VuZGluZyBhIG1hbmFnZWQgdXBsb2FkIG9iamVjdFxuICAgKiAgIHZhciBwYXJhbXMgPSB7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5JywgQm9keTogc3RyZWFtfTtcbiAgICogICB2YXIgdXBsb2FkID0gbmV3IEFXUy5TMy5NYW5hZ2VkVXBsb2FkKHtwYXJhbXM6IHBhcmFtc30pO1xuICAgKiAgIHVwbG9hZC5zZW5kKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICAgY29uc29sZS5sb2coZXJyLCBkYXRhKTtcbiAgICogICB9KTtcbiAgICovXG4gIHNlbmQ6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuZmFpbGVkID0gZmFsc2U7XG4gICAgc2VsZi5jYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB0aHJvdyBlcnI7IH07XG5cbiAgICB2YXIgcnVuRmlsbCA9IHRydWU7XG4gICAgaWYgKHNlbGYuc2xpY2VGbikge1xuICAgICAgc2VsZi5maWxsUXVldWUgPSBzZWxmLmZpbGxCdWZmZXI7XG4gICAgfSBlbHNlIGlmIChBV1MudXRpbC5pc05vZGUoKSkge1xuICAgICAgdmFyIFN0cmVhbSA9IEFXUy51dGlsLnN0cmVhbS5TdHJlYW07XG4gICAgICBpZiAoc2VsZi5ib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XG4gICAgICAgIHJ1bkZpbGwgPSBmYWxzZTtcbiAgICAgICAgc2VsZi5maWxsUXVldWUgPSBzZWxmLmZpbGxTdHJlYW07XG4gICAgICAgIHNlbGYucGFydEJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgc2VsZi5ib2R5LlxuICAgICAgICAgIG9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikgeyBzZWxmLmNsZWFudXAoZXJyKTsgfSkuXG4gICAgICAgICAgb24oJ3JlYWRhYmxlJywgZnVuY3Rpb24oKSB7IHNlbGYuZmlsbFF1ZXVlKCk7IH0pLlxuICAgICAgICAgIG9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuaXNEb25lQ2h1bmtpbmcgPSB0cnVlO1xuICAgICAgICAgICAgc2VsZi5udW1QYXJ0cyA9IHNlbGYudG90YWxQYXJ0TnVtYmVycztcbiAgICAgICAgICAgIHNlbGYuZmlsbFF1ZXVlLmNhbGwoc2VsZik7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmlzRG9uZUNodW5raW5nICYmIHNlbGYudG90YWxQYXJ0TnVtYmVycyA+PSAxICYmIHNlbGYuZG9uZVBhcnRzID09PSBzZWxmLm51bVBhcnRzKSB7XG4gICAgICAgICAgICAgIHNlbGYuZmluaXNoTXVsdGlQYXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJ1bkZpbGwpIHNlbGYuZmlsbFF1ZXVlLmNhbGwoc2VsZik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEAhbWV0aG9kICBwcm9taXNlKClcbiAgICogICBSZXR1cm5zIGEgJ3RoZW5hYmxlJyBwcm9taXNlLlxuICAgKlxuICAgKiAgIFR3byBjYWxsYmFja3MgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSBgdGhlbmAgbWV0aG9kIG9uIHRoZSByZXR1cm5lZCBwcm9taXNlLlxuICAgKiAgIFRoZSBmaXJzdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQsIGFuZCB0aGUgc2Vjb25kXG4gICAqICAgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgQGNhbGxiYWNrIGZ1bGZpbGxlZENhbGxiYWNrIGZ1bmN0aW9uKGRhdGEpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLlxuICAgKiAgICAgQHBhcmFtIGRhdGEgW21hcF0gVGhlIHJlc3BvbnNlIGRhdGEgZnJvbSB0aGUgc3VjY2Vzc2Z1bCB1cGxvYWQ6XG4gICAqICAgICAgIGBMb2NhdGlvbmAgKFN0cmluZykgdGhlIFVSTCBvZiB0aGUgdXBsb2FkZWQgb2JqZWN0XG4gICAqICAgICAgIGBFVGFnYCAoU3RyaW5nKSB0aGUgRVRhZyBvZiB0aGUgdXBsb2FkZWQgb2JqZWN0XG4gICAqICAgICAgIGBCdWNrZXRgIChTdHJpbmcpIHRoZSBidWNrZXQgdG8gd2hpY2ggdGhlIG9iamVjdCB3YXMgdXBsb2FkZWRcbiAgICogICAgICAgYEtleWAgKFN0cmluZykgdGhlIGtleSB0byB3aGljaCB0aGUgb2JqZWN0IHdhcyB1cGxvYWRlZFxuICAgKiAgIEBjYWxsYmFjayByZWplY3RlZENhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICAgIEBwYXJhbSBlcnIgW0Vycm9yXSBhbiBlcnJvciBvciBudWxsIGlmIG5vIGVycm9yIG9jY3VycmVkLlxuICAgKiAgIEByZXR1cm4gW1Byb21pc2VdIEEgcHJvbWlzZSB0aGF0IHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSB1cGxvYWQgcmVxdWVzdC5cbiAgICogICBAZXhhbXBsZSBTZW5kaW5nIGFuIHVwbG9hZCByZXF1ZXN0IHVzaW5nIHByb21pc2VzLlxuICAgKiAgICAgdmFyIHVwbG9hZCA9IHMzLnVwbG9hZCh7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5JywgQm9keTogc3RyZWFtfSk7XG4gICAqICAgICB2YXIgcHJvbWlzZSA9IHVwbG9hZC5wcm9taXNlKCk7XG4gICAqICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZGF0YSkgeyAuLi4gfSwgZnVuY3Rpb24oZXJyKSB7IC4uLiB9KTtcbiAgICovXG5cbiAgLyoqXG4gICAqIEFib3J0cyBhIG1hbmFnZWQgdXBsb2FkLCBpbmNsdWRpbmcgYWxsIGNvbmN1cnJlbnQgdXBsb2FkIHJlcXVlc3RzLlxuICAgKiBAbm90ZSBCeSBkZWZhdWx0LCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gd2lsbCBjbGVhbnVwIGEgbXVsdGlwYXJ0IHVwbG9hZFxuICAgKiAgIGlmIG9uZSB3YXMgY3JlYXRlZC4gVG8gbGVhdmUgdGhlIG11bHRpcGFydCB1cGxvYWQgYXJvdW5kIGFmdGVyIGFib3J0aW5nXG4gICAqICAgYSByZXF1ZXN0LCBjb25maWd1cmUgYGxlYXZlUGFydHNPbkVycm9yYCB0byBgdHJ1ZWAgaW4gdGhlIHtjb25zdHJ1Y3Rvcn0uXG4gICAqIEBub3RlIENhbGxpbmcge2Fib3J0fSBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudCB3aWxsIG5vdCBhYm9ydCBhbnkgcmVxdWVzdHNcbiAgICogICB0aGF0IGFyZSBhbHJlYWR5IGluIGZsaWdodC4gSWYgYSBtdWx0aXBhcnQgdXBsb2FkIHdhcyBjcmVhdGVkLCBhbnkgcGFydHNcbiAgICogICBub3QgeWV0IHVwbG9hZGVkIHdpbGwgbm90IGJlIHNlbnQsIGFuZCB0aGUgbXVsdGlwYXJ0IHVwbG9hZCB3aWxsIGJlIGNsZWFuZWQgdXAuXG4gICAqIEBleGFtcGxlIEFib3J0aW5nIGFuIHVwbG9hZFxuICAgKiAgIHZhciBwYXJhbXMgPSB7XG4gICAqICAgICBCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLFxuICAgKiAgICAgQm9keTogQnVmZmVyLmFsbG9jKDEwMjQgKiAxMDI0ICogMjUpIC8vIDI1TUIgcGF5bG9hZFxuICAgKiAgIH07XG4gICAqICAgdmFyIHVwbG9hZCA9IHMzLnVwbG9hZChwYXJhbXMpO1xuICAgKiAgIHVwbG9hZC5zZW5kKGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICogICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKFwiRXJyb3I6XCIsIGVyci5jb2RlLCBlcnIubWVzc2FnZSk7XG4gICAqICAgICBlbHNlIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgKiAgIH0pO1xuICAgKlxuICAgKiAgIC8vIGFib3J0IHJlcXVlc3QgaW4gMSBzZWNvbmRcbiAgICogICBzZXRUaW1lb3V0KHVwbG9hZC5hYm9ydC5iaW5kKHVwbG9hZCksIDEwMDApO1xuICAgKi9cbiAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvL2Fib3J0IHB1dE9iamVjdCByZXF1ZXN0XG4gICAgaWYgKHNlbGYuaXNEb25lQ2h1bmtpbmcgPT09IHRydWUgJiYgc2VsZi50b3RhbFBhcnROdW1iZXJzID09PSAxICYmIHNlbGYuc2luZ2xlUGFydCkge1xuICAgICAgc2VsZi5zaW5nbGVQYXJ0LmFib3J0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuY2xlYW51cChBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCBieSB1c2VyJyksIHtcbiAgICAgICAgY29kZTogJ1JlcXVlc3RBYm9ydGVkRXJyb3InLCByZXRyeWFibGU6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHZhbGlkYXRlQm9keTogZnVuY3Rpb24gdmFsaWRhdGVCb2R5KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmJvZHkgPSBzZWxmLnNlcnZpY2UuY29uZmlnLnBhcmFtcy5Cb2R5O1xuICAgIGlmICh0eXBlb2Ygc2VsZi5ib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgc2VsZi5ib2R5ID0gQVdTLnV0aWwuYnVmZmVyLnRvQnVmZmVyKHNlbGYuYm9keSk7XG4gICAgfSBlbHNlIGlmICghc2VsZi5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcmFtcy5Cb2R5IGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIHNlbGYuc2xpY2VGbiA9IEFXUy51dGlsLmFycmF5U2xpY2VGbihzZWxmLmJvZHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGJpbmRTZXJ2aWNlT2JqZWN0OiBmdW5jdGlvbiBiaW5kU2VydmljZU9iamVjdChwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIGJpbmQgcGFyYW1ldGVycyB0byBuZXcgc2VydmljZSBvYmplY3RcbiAgICBpZiAoIXNlbGYuc2VydmljZSkge1xuICAgICAgc2VsZi5zZXJ2aWNlID0gbmV3IEFXUy5TMyh7cGFyYW1zOiBwYXJhbXN9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlcnZpY2UgPSBzZWxmLnNlcnZpY2U7XG4gICAgICB2YXIgY29uZmlnID0gQVdTLnV0aWwuY29weShzZXJ2aWNlLmNvbmZpZyk7XG4gICAgICBjb25maWcuc2lnbmF0dXJlVmVyc2lvbiA9IHNlcnZpY2UuZ2V0U2lnbmF0dXJlVmVyc2lvbigpO1xuICAgICAgc2VsZi5zZXJ2aWNlID0gbmV3IHNlcnZpY2UuY29uc3RydWN0b3IuX19zdXBlcl9fKGNvbmZpZyk7XG4gICAgICBzZWxmLnNlcnZpY2UuY29uZmlnLnBhcmFtcyA9XG4gICAgICAgIEFXUy51dGlsLm1lcmdlKHNlbGYuc2VydmljZS5jb25maWcucGFyYW1zIHx8IHt9LCBwYXJhbXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhZGp1c3RUb3RhbEJ5dGVzOiBmdW5jdGlvbiBhZGp1c3RUb3RhbEJ5dGVzKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0cnkgeyAvLyB0cnkgdG8gZ2V0IHRvdGFsQnl0ZXNcbiAgICAgIHNlbGYudG90YWxCeXRlcyA9IGJ5dGVMZW5ndGgoc2VsZi5ib2R5KTtcbiAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgIC8vIHRyeSB0byBhZGp1c3QgcGFydFNpemUgaWYgd2Uga25vdyBwYXlsb2FkIGxlbmd0aFxuICAgIGlmIChzZWxmLnRvdGFsQnl0ZXMpIHtcbiAgICAgIHZhciBuZXdQYXJ0U2l6ZSA9IE1hdGguY2VpbChzZWxmLnRvdGFsQnl0ZXMgLyBzZWxmLm1heFRvdGFsUGFydHMpO1xuICAgICAgaWYgKG5ld1BhcnRTaXplID4gc2VsZi5wYXJ0U2l6ZSkgc2VsZi5wYXJ0U2l6ZSA9IG5ld1BhcnRTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnRvdGFsQnl0ZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGlzRG9uZUNodW5raW5nOiBmYWxzZSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwYXJ0UG9zOiAwLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHRvdGFsQ2h1bmtlZEJ5dGVzOiAwLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHRvdGFsVXBsb2FkZWRCeXRlczogMCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB0b3RhbEJ5dGVzOiB1bmRlZmluZWQsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbnVtUGFydHM6IDAsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdG90YWxQYXJ0TnVtYmVyczogMCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhY3RpdmVQYXJ0czogMCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBkb25lUGFydHM6IDAsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcGFydHM6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29tcGxldGVJbmZvOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGZhaWxlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbXVsdGlwYXJ0UmVxOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHBhcnRCdWZmZXJzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHBhcnRCdWZmZXJMZW5ndGg6IDAsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZmlsbEJ1ZmZlcjogZnVuY3Rpb24gZmlsbEJ1ZmZlcigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGJvZHlMZW4gPSBieXRlTGVuZ3RoKHNlbGYuYm9keSk7XG5cbiAgICBpZiAoYm9keUxlbiA9PT0gMCkge1xuICAgICAgc2VsZi5pc0RvbmVDaHVua2luZyA9IHRydWU7XG4gICAgICBzZWxmLm51bVBhcnRzID0gMTtcbiAgICAgIHNlbGYubmV4dENodW5rKHNlbGYuYm9keSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKHNlbGYuYWN0aXZlUGFydHMgPCBzZWxmLnF1ZXVlU2l6ZSAmJiBzZWxmLnBhcnRQb3MgPCBib2R5TGVuKSB7XG4gICAgICB2YXIgZW5kUG9zID0gTWF0aC5taW4oc2VsZi5wYXJ0UG9zICsgc2VsZi5wYXJ0U2l6ZSwgYm9keUxlbik7XG4gICAgICB2YXIgYnVmID0gc2VsZi5zbGljZUZuLmNhbGwoc2VsZi5ib2R5LCBzZWxmLnBhcnRQb3MsIGVuZFBvcyk7XG4gICAgICBzZWxmLnBhcnRQb3MgKz0gc2VsZi5wYXJ0U2l6ZTtcblxuICAgICAgaWYgKGJ5dGVMZW5ndGgoYnVmKSA8IHNlbGYucGFydFNpemUgfHwgc2VsZi5wYXJ0UG9zID09PSBib2R5TGVuKSB7XG4gICAgICAgIHNlbGYuaXNEb25lQ2h1bmtpbmcgPSB0cnVlO1xuICAgICAgICBzZWxmLm51bVBhcnRzID0gc2VsZi50b3RhbFBhcnROdW1iZXJzICsgMTtcbiAgICAgIH1cbiAgICAgIHNlbGYubmV4dENodW5rKGJ1Zik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGZpbGxTdHJlYW06IGZ1bmN0aW9uIGZpbGxTdHJlYW0oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLmFjdGl2ZVBhcnRzID49IHNlbGYucXVldWVTaXplKSByZXR1cm47XG5cbiAgICB2YXIgYnVmID0gc2VsZi5ib2R5LnJlYWQoc2VsZi5wYXJ0U2l6ZSAtIHNlbGYucGFydEJ1ZmZlckxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgc2VsZi5ib2R5LnJlYWQoKTtcbiAgICBpZiAoYnVmKSB7XG4gICAgICBzZWxmLnBhcnRCdWZmZXJzLnB1c2goYnVmKTtcbiAgICAgIHNlbGYucGFydEJ1ZmZlckxlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgICAgc2VsZi50b3RhbENodW5rZWRCeXRlcyArPSBidWYubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChzZWxmLnBhcnRCdWZmZXJMZW5ndGggPj0gc2VsZi5wYXJ0U2l6ZSkge1xuICAgICAgLy8gaWYgd2UgaGF2ZSBzaW5nbGUgYnVmZmVyIHdlIGF2b2lkIGNvcHlmdWxsIGNvbmNhdFxuICAgICAgdmFyIHBidWYgPSBzZWxmLnBhcnRCdWZmZXJzLmxlbmd0aCA9PT0gMSA/XG4gICAgICAgIHNlbGYucGFydEJ1ZmZlcnNbMF0gOiBCdWZmZXIuY29uY2F0KHNlbGYucGFydEJ1ZmZlcnMpO1xuICAgICAgc2VsZi5wYXJ0QnVmZmVycyA9IFtdO1xuICAgICAgc2VsZi5wYXJ0QnVmZmVyTGVuZ3RoID0gMDtcblxuICAgICAgLy8gaWYgd2UgaGF2ZSBtb3JlIHRoYW4gcGFydFNpemUsIHB1c2ggdGhlIHJlc3QgYmFjayBvbiB0aGUgcXVldWVcbiAgICAgIGlmIChwYnVmLmxlbmd0aCA+IHNlbGYucGFydFNpemUpIHtcbiAgICAgICAgdmFyIHJlc3QgPSBwYnVmLnNsaWNlKHNlbGYucGFydFNpemUpO1xuICAgICAgICBzZWxmLnBhcnRCdWZmZXJzLnB1c2gocmVzdCk7XG4gICAgICAgIHNlbGYucGFydEJ1ZmZlckxlbmd0aCArPSByZXN0Lmxlbmd0aDtcbiAgICAgICAgcGJ1ZiA9IHBidWYuc2xpY2UoMCwgc2VsZi5wYXJ0U2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYubmV4dENodW5rKHBidWYpO1xuICAgIH1cblxuICAgIGlmIChzZWxmLmlzRG9uZUNodW5raW5nICYmICFzZWxmLmlzRG9uZVNlbmRpbmcpIHtcbiAgICAgIC8vIGlmIHdlIGhhdmUgc2luZ2xlIGJ1ZmZlciB3ZSBhdm9pZCBjb3B5ZnVsbCBjb25jYXRcbiAgICAgIHBidWYgPSBzZWxmLnBhcnRCdWZmZXJzLmxlbmd0aCA9PT0gMSA/XG4gICAgICAgICAgc2VsZi5wYXJ0QnVmZmVyc1swXSA6IEJ1ZmZlci5jb25jYXQoc2VsZi5wYXJ0QnVmZmVycyk7XG4gICAgICBzZWxmLnBhcnRCdWZmZXJzID0gW107XG4gICAgICBzZWxmLnBhcnRCdWZmZXJMZW5ndGggPSAwO1xuICAgICAgc2VsZi50b3RhbEJ5dGVzID0gc2VsZi50b3RhbENodW5rZWRCeXRlcztcbiAgICAgIHNlbGYuaXNEb25lU2VuZGluZyA9IHRydWU7XG5cbiAgICAgIGlmIChzZWxmLm51bVBhcnRzID09PSAwIHx8IHBidWYubGVuZ3RoID4gMCkge1xuICAgICAgICBzZWxmLm51bVBhcnRzKys7XG4gICAgICAgIHNlbGYubmV4dENodW5rKHBidWYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYuYm9keS5yZWFkKDApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG5leHRDaHVuazogZnVuY3Rpb24gbmV4dENodW5rKGNodW5rKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLmZhaWxlZCkgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgcGFydE51bWJlciA9ICsrc2VsZi50b3RhbFBhcnROdW1iZXJzO1xuICAgIGlmIChzZWxmLmlzRG9uZUNodW5raW5nICYmIHBhcnROdW1iZXIgPT09IDEpIHtcbiAgICAgIHZhciBwYXJhbXMgPSB7Qm9keTogY2h1bmt9O1xuICAgICAgaWYgKHRoaXMudGFncykge1xuICAgICAgICBwYXJhbXMuVGFnZ2luZyA9IHRoaXMuZ2V0VGFnZ2luZ0hlYWRlcigpO1xuICAgICAgfVxuICAgICAgdmFyIHJlcSA9IHNlbGYuc2VydmljZS5wdXRPYmplY3QocGFyYW1zKTtcbiAgICAgIHJlcS5fbWFuYWdlZFVwbG9hZCA9IHNlbGY7XG4gICAgICByZXEub24oJ2h0dHBVcGxvYWRQcm9ncmVzcycsIHNlbGYucHJvZ3Jlc3MpLnNlbmQoc2VsZi5maW5pc2hTaW5nbGVQYXJ0KTtcbiAgICAgIHNlbGYuc2luZ2xlUGFydCA9IHJlcTsgLy9zYXZlIHRoZSBzaW5nbGUgcGFydCByZXF1ZXN0XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHNlbGYuc2VydmljZS5jb25maWcucGFyYW1zLkNvbnRlbnRNRDUpIHtcbiAgICAgIHZhciBlcnIgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoJ1RoZSBDb250ZW50LU1ENSB5b3Ugc3BlY2lmaWVkIGlzIGludmFsaWQgZm9yIG11bHRpLXBhcnQgdXBsb2Fkcy4nKSwge1xuICAgICAgICBjb2RlOiAnSW52YWxpZERpZ2VzdCcsIHJldHJ5YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICBzZWxmLmNsZWFudXAoZXJyKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChzZWxmLmNvbXBsZXRlSW5mb1twYXJ0TnVtYmVyXSAmJiBzZWxmLmNvbXBsZXRlSW5mb1twYXJ0TnVtYmVyXS5FVGFnICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gQWxyZWFkeSB1cGxvYWRlZCB0aGlzIHBhcnQuXG4gICAgfVxuXG4gICAgc2VsZi5hY3RpdmVQYXJ0cysrO1xuICAgIGlmICghc2VsZi5zZXJ2aWNlLmNvbmZpZy5wYXJhbXMuVXBsb2FkSWQpIHtcblxuICAgICAgaWYgKCFzZWxmLm11bHRpcGFydFJlcSkgeyAvLyBjcmVhdGUgbXVsdGlwYXJ0XG4gICAgICAgIHNlbGYubXVsdGlwYXJ0UmVxID0gc2VsZi5zZXJ2aWNlLmNyZWF0ZU11bHRpcGFydFVwbG9hZCgpO1xuICAgICAgICBzZWxmLm11bHRpcGFydFJlcS5vbignc3VjY2VzcycsIGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgICBzZWxmLnNlcnZpY2UuY29uZmlnLnBhcmFtcy5VcGxvYWRJZCA9IHJlc3AuZGF0YS5VcGxvYWRJZDtcbiAgICAgICAgICBzZWxmLm11bHRpcGFydFJlcSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLnF1ZXVlQ2h1bmtzKGNodW5rLCBwYXJ0TnVtYmVyKTtcbiAgICAgICAgc2VsZi5tdWx0aXBhcnRSZXEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgc2VsZi5jbGVhbnVwKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLm11bHRpcGFydFJlcS5zZW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnF1ZXVlQ2h1bmtzKGNodW5rLCBwYXJ0TnVtYmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBtdWx0aXBhcnQgaXMgY3JlYXRlZCwganVzdCBzZW5kXG4gICAgICBzZWxmLnVwbG9hZFBhcnQoY2h1bmssIHBhcnROdW1iZXIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRUYWdnaW5nSGVhZGVyOiBmdW5jdGlvbiBnZXRUYWdnaW5nSGVhZGVyKCkge1xuICAgIHZhciBrdlBhaXJTdHJpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGt2UGFpclN0cmluZ3MucHVzaChBV1MudXRpbC51cmlFc2NhcGUodGhpcy50YWdzW2ldLktleSkgKyAnPScgK1xuICAgICAgICBBV1MudXRpbC51cmlFc2NhcGUodGhpcy50YWdzW2ldLlZhbHVlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGt2UGFpclN0cmluZ3Muam9pbignJicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHVwbG9hZFBhcnQ6IGZ1bmN0aW9uIHVwbG9hZFBhcnQoY2h1bmssIHBhcnROdW1iZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcGFydFBhcmFtcyA9IHtcbiAgICAgIEJvZHk6IGNodW5rLFxuICAgICAgQ29udGVudExlbmd0aDogQVdTLnV0aWwuc3RyaW5nLmJ5dGVMZW5ndGgoY2h1bmspLFxuICAgICAgUGFydE51bWJlcjogcGFydE51bWJlclxuICAgIH07XG5cbiAgICB2YXIgcGFydEluZm8gPSB7RVRhZzogbnVsbCwgUGFydE51bWJlcjogcGFydE51bWJlcn07XG4gICAgc2VsZi5jb21wbGV0ZUluZm9bcGFydE51bWJlcl0gPSBwYXJ0SW5mbztcblxuICAgIHZhciByZXEgPSBzZWxmLnNlcnZpY2UudXBsb2FkUGFydChwYXJ0UGFyYW1zKTtcbiAgICBzZWxmLnBhcnRzW3BhcnROdW1iZXJdID0gcmVxO1xuICAgIHJlcS5fbGFzdFVwbG9hZGVkQnl0ZXMgPSAwO1xuICAgIHJlcS5fbWFuYWdlZFVwbG9hZCA9IHNlbGY7XG4gICAgcmVxLm9uKCdodHRwVXBsb2FkUHJvZ3Jlc3MnLCBzZWxmLnByb2dyZXNzKTtcbiAgICByZXEuc2VuZChmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGRlbGV0ZSBzZWxmLnBhcnRzW3BhcnRQYXJhbXMuUGFydE51bWJlcl07XG4gICAgICBzZWxmLmFjdGl2ZVBhcnRzLS07XG5cbiAgICAgIGlmICghZXJyICYmICghZGF0YSB8fCAhZGF0YS5FVGFnKSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICdObyBhY2Nlc3MgdG8gRVRhZyBwcm9wZXJ0eSBvbiByZXNwb25zZS4nO1xuICAgICAgICBpZiAoQVdTLnV0aWwuaXNCcm93c2VyKCkpIHtcbiAgICAgICAgICBtZXNzYWdlICs9ICcgQ2hlY2sgQ09SUyBjb25maWd1cmF0aW9uIHRvIGV4cG9zZSBFVGFnIGhlYWRlci4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyID0gQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKG1lc3NhZ2UpLCB7XG4gICAgICAgICAgY29kZTogJ0VUYWdNaXNzaW5nJywgcmV0cnlhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIpIHJldHVybiBzZWxmLmNsZWFudXAoZXJyKTtcbiAgICAgIC8vcHJldmVudCBzZW5kaW5nIHBhcnQgYmVpbmcgcmV0dXJuZWQgdHdpY2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLXNkay1qcy9pc3N1ZXMvMjMwNClcbiAgICAgIGlmIChzZWxmLmNvbXBsZXRlSW5mb1twYXJ0TnVtYmVyXSAmJiBzZWxmLmNvbXBsZXRlSW5mb1twYXJ0TnVtYmVyXS5FVGFnICE9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgIHBhcnRJbmZvLkVUYWcgPSBkYXRhLkVUYWc7XG4gICAgICBzZWxmLmRvbmVQYXJ0cysrO1xuICAgICAgaWYgKHNlbGYuaXNEb25lQ2h1bmtpbmcgJiYgc2VsZi5kb25lUGFydHMgPT09IHNlbGYubnVtUGFydHMpIHtcbiAgICAgICAgc2VsZi5maW5pc2hNdWx0aVBhcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuZmlsbFF1ZXVlLmNhbGwoc2VsZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcXVldWVDaHVua3M6IGZ1bmN0aW9uIHF1ZXVlQ2h1bmtzKGNodW5rLCBwYXJ0TnVtYmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYubXVsdGlwYXJ0UmVxLm9uKCdzdWNjZXNzJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLnVwbG9hZFBhcnQoY2h1bmssIHBhcnROdW1iZXIpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNsZWFudXA6IGZ1bmN0aW9uIGNsZWFudXAoZXJyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLmZhaWxlZCkgcmV0dXJuO1xuXG4gICAgLy8gY2xlYW4gdXAgc3RyZWFtXG4gICAgaWYgKHR5cGVvZiBzZWxmLmJvZHkucmVtb3ZlQWxsTGlzdGVuZXJzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiBzZWxmLmJvZHkucmVzdW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzZWxmLmJvZHkucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZWFkYWJsZScpO1xuICAgICAgc2VsZi5ib2R5LnJlbW92ZUFsbExpc3RlbmVycygnZW5kJyk7XG4gICAgICBzZWxmLmJvZHkucmVzdW1lKCk7XG4gICAgfVxuXG4gICAgLy8gY2xlYW51cCBtdWx0aXBhcnRSZXEgbGlzdGVuZXJzXG4gICAgaWYgKHNlbGYubXVsdGlwYXJ0UmVxKSB7XG4gICAgICBzZWxmLm11bHRpcGFydFJlcS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3N1Y2Nlc3MnKTtcbiAgICAgIHNlbGYubXVsdGlwYXJ0UmVxLnJlbW92ZUFsbExpc3RlbmVycygnZXJyb3InKTtcbiAgICAgIHNlbGYubXVsdGlwYXJ0UmVxLnJlbW92ZUFsbExpc3RlbmVycygnY29tcGxldGUnKTtcbiAgICAgIGRlbGV0ZSBzZWxmLm11bHRpcGFydFJlcTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5zZXJ2aWNlLmNvbmZpZy5wYXJhbXMuVXBsb2FkSWQgJiYgIXNlbGYubGVhdmVQYXJ0c09uRXJyb3IpIHtcbiAgICAgIHNlbGYuc2VydmljZS5hYm9ydE11bHRpcGFydFVwbG9hZCgpLnNlbmQoKTtcbiAgICB9IGVsc2UgaWYgKHNlbGYubGVhdmVQYXJ0c09uRXJyb3IpIHtcbiAgICAgIHNlbGYuaXNEb25lQ2h1bmtpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBBV1MudXRpbC5lYWNoKHNlbGYucGFydHMsIGZ1bmN0aW9uKHBhcnROdW1iZXIsIHBhcnQpIHtcbiAgICAgIHBhcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjb21wbGV0ZScpO1xuICAgICAgcGFydC5hYm9ydCgpO1xuICAgIH0pO1xuXG4gICAgc2VsZi5hY3RpdmVQYXJ0cyA9IDA7XG4gICAgc2VsZi5wYXJ0UG9zID0gMDtcbiAgICBzZWxmLm51bVBhcnRzID0gMDtcbiAgICBzZWxmLnRvdGFsUGFydE51bWJlcnMgPSAwO1xuICAgIHNlbGYucGFydHMgPSB7fTtcbiAgICBzZWxmLmZhaWxlZCA9IHRydWU7XG4gICAgc2VsZi5jYWxsYmFjayhlcnIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGZpbmlzaE11bHRpUGFydDogZnVuY3Rpb24gZmluaXNoTXVsdGlQYXJ0KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY29tcGxldGVQYXJhbXMgPSB7IE11bHRpcGFydFVwbG9hZDogeyBQYXJ0czogc2VsZi5jb21wbGV0ZUluZm8uc2xpY2UoMSkgfSB9O1xuICAgIHNlbGYuc2VydmljZS5jb21wbGV0ZU11bHRpcGFydFVwbG9hZChjb21wbGV0ZVBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNsZWFudXAoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEuTG9jYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGEuTG9jYXRpb24gPSBkYXRhLkxvY2F0aW9uLnJlcGxhY2UoLyUyRi9nLCAnLycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxmLnRhZ3MpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc2VsZi50YWdzW2ldLlZhbHVlID0gU3RyaW5nKHNlbGYudGFnc1tpXS5WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5zZXJ2aWNlLnB1dE9iamVjdFRhZ2dpbmcoXG4gICAgICAgICAge1RhZ2dpbmc6IHtUYWdTZXQ6IHNlbGYudGFnc319LFxuICAgICAgICAgIGZ1bmN0aW9uKGUsIGQpIHtcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgIHNlbGYuY2FsbGJhY2soZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLmNhbGxiYWNrKGUsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBmaW5pc2hTaW5nbGVQYXJ0OiBmdW5jdGlvbiBmaW5pc2hTaW5nbGVQYXJ0KGVyciwgZGF0YSkge1xuICAgIHZhciB1cGxvYWQgPSB0aGlzLnJlcXVlc3QuX21hbmFnZWRVcGxvYWQ7XG4gICAgdmFyIGh0dHBSZXEgPSB0aGlzLnJlcXVlc3QuaHR0cFJlcXVlc3Q7XG4gICAgdmFyIGVuZHBvaW50ID0gaHR0cFJlcS5lbmRwb2ludDtcbiAgICBpZiAoZXJyKSByZXR1cm4gdXBsb2FkLmNhbGxiYWNrKGVycik7XG4gICAgZGF0YS5Mb2NhdGlvbiA9XG4gICAgICBbZW5kcG9pbnQucHJvdG9jb2wsICcvLycsIGVuZHBvaW50Lmhvc3QsIGh0dHBSZXEucGF0aF0uam9pbignJyk7XG4gICAgZGF0YS5rZXkgPSB0aGlzLnJlcXVlc3QucGFyYW1zLktleTsgLy8gd2lsbCBzdGF5IHVuZG9jdW1lbnRlZFxuICAgIGRhdGEuS2V5ID0gdGhpcy5yZXF1ZXN0LnBhcmFtcy5LZXk7XG4gICAgZGF0YS5CdWNrZXQgPSB0aGlzLnJlcXVlc3QucGFyYW1zLkJ1Y2tldDtcbiAgICB1cGxvYWQuY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwcm9ncmVzczogZnVuY3Rpb24gcHJvZ3Jlc3MoaW5mbykge1xuICAgIHZhciB1cGxvYWQgPSB0aGlzLl9tYW5hZ2VkVXBsb2FkO1xuICAgIGlmICh0aGlzLm9wZXJhdGlvbiA9PT0gJ3B1dE9iamVjdCcpIHtcbiAgICAgIGluZm8ucGFydCA9IDE7XG4gICAgICBpbmZvLmtleSA9IHRoaXMucGFyYW1zLktleTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBsb2FkLnRvdGFsVXBsb2FkZWRCeXRlcyArPSBpbmZvLmxvYWRlZCAtIHRoaXMuX2xhc3RVcGxvYWRlZEJ5dGVzO1xuICAgICAgdGhpcy5fbGFzdFVwbG9hZGVkQnl0ZXMgPSBpbmZvLmxvYWRlZDtcbiAgICAgIGluZm8gPSB7XG4gICAgICAgIGxvYWRlZDogdXBsb2FkLnRvdGFsVXBsb2FkZWRCeXRlcyxcbiAgICAgICAgdG90YWw6IHVwbG9hZC50b3RhbEJ5dGVzLFxuICAgICAgICBwYXJ0OiB0aGlzLnBhcmFtcy5QYXJ0TnVtYmVyLFxuICAgICAgICBrZXk6IHRoaXMucGFyYW1zLktleVxuICAgICAgfTtcbiAgICB9XG4gICAgdXBsb2FkLmVtaXQoJ2h0dHBVcGxvYWRQcm9ncmVzcycsIFtpbmZvXSk7XG4gIH1cbn0pO1xuXG5BV1MudXRpbC5taXhpbihBV1MuUzMuTWFuYWdlZFVwbG9hZCwgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcik7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TMy5NYW5hZ2VkVXBsb2FkLmFkZFByb21pc2VzVG9DbGFzcyA9IGZ1bmN0aW9uIGFkZFByb21pc2VzVG9DbGFzcyhQcm9taXNlRGVwZW5kZW5jeSkge1xuICB0aGlzLnByb3RvdHlwZS5wcm9taXNlID0gQVdTLnV0aWwucHJvbWlzaWZ5TWV0aG9kKCdzZW5kJywgUHJvbWlzZURlcGVuZGVuY3kpO1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlMzLk1hbmFnZWRVcGxvYWQuZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MgPSBmdW5jdGlvbiBkZWxldGVQcm9taXNlc0Zyb21DbGFzcygpIHtcbiAgZGVsZXRlIHRoaXMucHJvdG90eXBlLnByb21pc2U7XG59O1xuXG5BV1MudXRpbC5hZGRQcm9taXNlcyhBV1MuUzMuTWFuYWdlZFVwbG9hZCk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlMzLk1hbmFnZWRVcGxvYWQ7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKiBAIW1ldGhvZCBvbihldmVudE5hbWUsIGNhbGxiYWNrKVxuICogICBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgY2FsbGJhY2sgZm9yIHRoZSBldmVudCBnaXZlbiBieSBgZXZlbnROYW1lYC5cbiAqICAgUGFyYW1ldGVycyBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGRlcGVuZCBvbiB0aGUgaW5kaXZpZHVhbCBldmVudFxuICogICBiZWluZyB0cmlnZ2VyZWQuIFNlZSB0aGUgZXZlbnQgZG9jdW1lbnRhdGlvbiBmb3IgdGhvc2UgcGFyYW1ldGVycy5cbiAqXG4gKiAgIEBwYXJhbSBldmVudE5hbWUgW1N0cmluZ10gdGhlIGV2ZW50IG5hbWUgdG8gcmVnaXN0ZXIgdGhlIGxpc3RlbmVyIGZvclxuICogICBAcGFyYW0gY2FsbGJhY2sgW0Z1bmN0aW9uXSB0aGUgbGlzdGVuZXIgY2FsbGJhY2sgZnVuY3Rpb25cbiAqICAgQHBhcmFtIHRvSGVhZCBbQm9vbGVhbl0gYXR0YWNoIHRoZSBsaXN0ZW5lciBjYWxsYmFjayB0byB0aGUgaGVhZCBvZiBjYWxsYmFjayBhcnJheSBpZiBzZXQgdG8gdHJ1ZS5cbiAqICAgICBEZWZhdWx0IHRvIGJlIGZhbHNlLlxuICogICBAcmV0dXJuIFtBV1MuU2VxdWVudGlhbEV4ZWN1dG9yXSB0aGUgc2FtZSBvYmplY3QgZm9yIGNoYWluaW5nXG4gKi9cbkFXUy5TZXF1ZW50aWFsRXhlY3V0b3IgPSBBV1MudXRpbC5pbmhlcml0KHtcblxuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gU2VxdWVudGlhbEV4ZWN1dG9yKCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxpc3RlbmVyczogZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9ldmVudHNbZXZlbnROYW1lXSA/IHRoaXMuX2V2ZW50c1tldmVudE5hbWVdLnNsaWNlKDApIDogW107XG4gIH0sXG5cbiAgb246IGZ1bmN0aW9uIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRvSGVhZCkge1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgdG9IZWFkID9cbiAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0udW5zaGlmdChsaXN0ZW5lcikgOlxuICAgICAgICB0aGlzLl9ldmVudHNbZXZlbnROYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0gPSBbbGlzdGVuZXJdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBvbkFzeW5jOiBmdW5jdGlvbiBvbkFzeW5jKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRvSGVhZCkge1xuICAgIGxpc3RlbmVyLl9pc0FzeW5jID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyLCB0b0hlYWQpO1xuICB9LFxuXG4gIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldmVudE5hbWVdO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgdmFyIHBvc2l0aW9uID0gLTE7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPiAtMSkge1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1tldmVudE5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZW1pdDogZnVuY3Rpb24gZW1pdChldmVudE5hbWUsIGV2ZW50QXJncywgZG9uZUNhbGxiYWNrKSB7XG4gICAgaWYgKCFkb25lQ2FsbGJhY2spIGRvbmVDYWxsYmFjayA9IGZ1bmN0aW9uKCkgeyB9O1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyhldmVudE5hbWUpO1xuICAgIHZhciBjb3VudCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgdGhpcy5jYWxsTGlzdGVuZXJzKGxpc3RlbmVycywgZXZlbnRBcmdzLCBkb25lQ2FsbGJhY2spO1xuICAgIHJldHVybiBjb3VudCA+IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2FsbExpc3RlbmVyczogZnVuY3Rpb24gY2FsbExpc3RlbmVycyhsaXN0ZW5lcnMsIGFyZ3MsIGRvbmVDYWxsYmFjaywgcHJldkVycm9yKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlcnJvciA9IHByZXZFcnJvciB8fCBudWxsO1xuXG4gICAgZnVuY3Rpb24gY2FsbE5leHRMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyb3IgPSBBV1MudXRpbC5lcnJvcihlcnJvciB8fCBuZXcgRXJyb3IoKSwgZXJyKTtcbiAgICAgICAgaWYgKHNlbGYuX2hhbHRIYW5kbGVyc09uRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZG9uZUNhbGxiYWNrLmNhbGwoc2VsZiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZWxmLmNhbGxMaXN0ZW5lcnMobGlzdGVuZXJzLCBhcmdzLCBkb25lQ2FsbGJhY2ssIGVycm9yKTtcbiAgICB9XG5cbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVycy5zaGlmdCgpO1xuICAgICAgaWYgKGxpc3RlbmVyLl9pc0FzeW5jKSB7IC8vIGFzeW5jaHJvbm91cyBsaXN0ZW5lclxuICAgICAgICBsaXN0ZW5lci5hcHBseShzZWxmLCBhcmdzLmNvbmNhdChbY2FsbE5leHRMaXN0ZW5lcl0pKTtcbiAgICAgICAgcmV0dXJuOyAvLyBzdG9wIGhlcmUsIGNhbGxOZXh0TGlzdGVuZXIgd2lsbCBjb250aW51ZVxuICAgICAgfSBlbHNlIHsgLy8gc3luY2hyb25vdXMgbGlzdGVuZXJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsaXN0ZW5lci5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZXJyb3IgPSBBV1MudXRpbC5lcnJvcihlcnJvciB8fCBuZXcgRXJyb3IoKSwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgc2VsZi5faGFsdEhhbmRsZXJzT25FcnJvcikge1xuICAgICAgICAgIGRvbmVDYWxsYmFjay5jYWxsKHNlbGYsIGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZG9uZUNhbGxiYWNrLmNhbGwoc2VsZiwgZXJyb3IpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIG9yIGNvcGllcyBhIHNldCBvZiBsaXN0ZW5lcnMgZnJvbSBhbm90aGVyIGxpc3Qgb2ZcbiAgICogbGlzdGVuZXJzIG9yIFNlcXVlbnRpYWxFeGVjdXRvciBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSBsaXN0ZW5lcnMgW21hcDxTdHJpbmcsQXJyYXk8RnVuY3Rpb24+PiwgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcl1cbiAgICogICBhIGxpc3Qgb2YgZXZlbnRzIGFuZCBjYWxsYmFja3MsIG9yIGFuIGV2ZW50IGVtaXR0ZXIgb2JqZWN0XG4gICAqICAgY29udGFpbmluZyBsaXN0ZW5lcnMgdG8gYWRkIHRvIHRoaXMgZW1pdHRlciBvYmplY3QuXG4gICAqIEByZXR1cm4gW0FXUy5TZXF1ZW50aWFsRXhlY3V0b3JdIHRoZSBlbWl0dGVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgKiBAZXhhbXBsZSBBZGRpbmcgbGlzdGVuZXJzIGZyb20gYSBtYXAgb2YgbGlzdGVuZXJzXG4gICAqICAgZW1pdHRlci5hZGRMaXN0ZW5lcnMoe1xuICAgKiAgICAgZXZlbnQxOiBbZnVuY3Rpb24oKSB7IC4uLiB9LCBmdW5jdGlvbigpIHsgLi4uIH1dLFxuICAgKiAgICAgZXZlbnQyOiBbZnVuY3Rpb24oKSB7IC4uLiB9XVxuICAgKiAgIH0pO1xuICAgKiAgIGVtaXR0ZXIuZW1pdCgnZXZlbnQxJyk7IC8vIGVtaXR0ZXIgaGFzIGV2ZW50MVxuICAgKiAgIGVtaXR0ZXIuZW1pdCgnZXZlbnQyJyk7IC8vIGVtaXR0ZXIgaGFzIGV2ZW50MlxuICAgKiBAZXhhbXBsZSBBZGRpbmcgbGlzdGVuZXJzIGZyb20gYW5vdGhlciBlbWl0dGVyIG9iamVjdFxuICAgKiAgIHZhciBlbWl0dGVyMSA9IG5ldyBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yKCk7XG4gICAqICAgZW1pdHRlcjEub24oJ2V2ZW50MScsIGZ1bmN0aW9uKCkgeyAuLi4gfSk7XG4gICAqICAgZW1pdHRlcjEub24oJ2V2ZW50MicsIGZ1bmN0aW9uKCkgeyAuLi4gfSk7XG4gICAqICAgdmFyIGVtaXR0ZXIyID0gbmV3IEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IoKTtcbiAgICogICBlbWl0dGVyMi5hZGRMaXN0ZW5lcnMoZW1pdHRlcjEpO1xuICAgKiAgIGVtaXR0ZXIyLmVtaXQoJ2V2ZW50MScpOyAvLyBlbWl0dGVyMiBoYXMgZXZlbnQxXG4gICAqICAgZW1pdHRlcjIuZW1pdCgnZXZlbnQyJyk7IC8vIGVtaXR0ZXIyIGhhcyBldmVudDJcbiAgICovXG4gIGFkZExpc3RlbmVyczogZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGxpc3RlbmVycykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGlmIHBhcmFtZXRlciBpcyBhbiBTZXF1ZW50aWFsRXhlY3V0b3Igb2JqZWN0XG4gICAgaWYgKGxpc3RlbmVycy5fZXZlbnRzKSBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuX2V2ZW50cztcblxuICAgIEFXUy51dGlsLmVhY2gobGlzdGVuZXJzLCBmdW5jdGlvbihldmVudCwgY2FsbGJhY2tzKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrcyA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2tzID0gW2NhbGxiYWNrc107XG4gICAgICBBV1MudXRpbC5hcnJheUVhY2goY2FsbGJhY2tzLCBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBzZWxmLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgd2l0aCB7b259IGFuZCBzYXZlcyB0aGUgY2FsbGJhY2sgaGFuZGxlIGZ1bmN0aW9uXG4gICAqIGFzIGEgcHJvcGVydHkgb24gdGhlIGVtaXR0ZXIgb2JqZWN0IHVzaW5nIGEgZ2l2ZW4gYG5hbWVgLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgcHJvcGVydHkgbmFtZSB0byBzZXQgb24gdGhpcyBvYmplY3QgY29udGFpbmluZ1xuICAgKiAgIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBoYW5kbGUgc28gdGhhdCB0aGUgbGlzdGVuZXIgY2FuIGJlIHJlbW92ZWQgaW5cbiAgICogICB0aGUgZnV0dXJlLlxuICAgKiBAcGFyYW0gKHNlZSBvbilcbiAgICogQHJldHVybiAoc2VlIG9uKVxuICAgKiBAZXhhbXBsZSBBZGRpbmcgYSBuYW1lZCBsaXN0ZW5lciBEQVRBX0NBTExCQUNLXG4gICAqICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oKSB7IGRvU29tZXRoaW5nKCk7IH07XG4gICAqICAgZW1pdHRlci5hZGROYW1lZExpc3RlbmVyKCdEQVRBX0NBTExCQUNLJywgJ2RhdGEnLCBsaXN0ZW5lcik7XG4gICAqXG4gICAqICAgLy8gdGhlIGZvbGxvd2luZyBwcmludHM6IHRydWVcbiAgICogICBjb25zb2xlLmxvZyhlbWl0dGVyLkRBVEFfQ0FMTEJBQ0sgPT0gbGlzdGVuZXIpO1xuICAgKi9cbiAgYWRkTmFtZWRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkTmFtZWRMaXN0ZW5lcihuYW1lLCBldmVudE5hbWUsIGNhbGxiYWNrLCB0b0hlYWQpIHtcbiAgICB0aGlzW25hbWVdID0gY2FsbGJhY2s7XG4gICAgdGhpcy5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrLCB0b0hlYWQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkZE5hbWVkQXN5bmNMaXN0ZW5lcjogZnVuY3Rpb24gYWRkTmFtZWRBc3luY0xpc3RlbmVyKG5hbWUsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIHRvSGVhZCkge1xuICAgIGNhbGxiYWNrLl9pc0FzeW5jID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5hZGROYW1lZExpc3RlbmVyKG5hbWUsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIHRvSGVhZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gYWRkIGEgc2V0IG9mIG5hbWVkIGxpc3RlbmVycyB1c2luZ1xuICAgKiB7YWRkTmFtZWRMaXN0ZW5lcn0uIFRoZSBjYWxsYmFjayBjb250YWlucyBhIHBhcmFtZXRlclxuICAgKiB3aXRoIGEgaGFuZGxlIHRvIHRoZSBgYWRkTmFtZWRMaXN0ZW5lcmAgbWV0aG9kLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oYWRkKVxuICAgKiAgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgaW4gb3JkZXIgdG8gcHJvdmlkZVxuICAgKiAgIHRoZSBgYWRkYCBmdW5jdGlvbiB0byB0aGUgYmxvY2suIFRoaXMgc2ltcGxpZmllcyB0aGUgYWRkaXRpb24gb2ZcbiAgICogICBhIGxhcmdlIGdyb3VwIG9mIG5hbWVkIGxpc3RlbmVycy5cbiAgICogICBAcGFyYW0gYWRkIFtGdW5jdGlvbl0gdGhlIHthZGROYW1lZExpc3RlbmVyfSBmdW5jdGlvbiB0byBjYWxsXG4gICAqICAgICB3aGVuIHJlZ2lzdGVyaW5nIGxpc3RlbmVycy5cbiAgICogQGV4YW1wbGUgQWRkaW5nIGEgc2V0IG9mIG5hbWVkIGxpc3RlbmVyc1xuICAgKiAgIGVtaXR0ZXIuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAqICAgICBhZGQoJ0RBVEFfQ0FMTEJBQ0snLCAnZGF0YScsIGZ1bmN0aW9uKCkgeyAuLi4gfSk7XG4gICAqICAgICBhZGQoJ09USEVSJywgJ290aGVyRXZlbnQnLCBmdW5jdGlvbigpIHsgLi4uIH0pO1xuICAgKiAgICAgYWRkKCdMQVNUJywgJ2xhc3RFdmVudCcsIGZ1bmN0aW9uKCkgeyAuLi4gfSk7XG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgLy8gdGhlc2UgcHJvcGVydGllcyBhcmUgbm93IHNldDpcbiAgICogICBlbWl0dGVyLkRBVEFfQ0FMTEJBQ0s7XG4gICAqICAgZW1pdHRlci5PVEhFUjtcbiAgICogICBlbWl0dGVyLkxBU1Q7XG4gICAqL1xuICBhZGROYW1lZExpc3RlbmVyczogZnVuY3Rpb24gYWRkTmFtZWRMaXN0ZW5lcnMoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgY2FsbGJhY2soXG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5hZGROYW1lZExpc3RlbmVyLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuYWRkTmFtZWRBc3luY0xpc3RlbmVyLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbi8qKlxuICoge29ufSBpcyB0aGUgcHJlZmVyZWQgbWV0aG9kLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TZXF1ZW50aWFsRXhlY3V0b3IucHJvdG90eXBlLmFkZExpc3RlbmVyID0gQVdTLlNlcXVlbnRpYWxFeGVjdXRvci5wcm90b3R5cGUub247XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNlcXVlbnRpYWxFeGVjdXRvcjtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBBcGkgPSByZXF1aXJlKCcuL21vZGVsL2FwaScpO1xudmFyIHJlZ2lvbkNvbmZpZyA9IHJlcXVpcmUoJy4vcmVnaW9uX2NvbmZpZycpO1xuXG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG52YXIgY2xpZW50Q291bnQgPSAwO1xuXG4vKipcbiAqIFRoZSBzZXJ2aWNlIGNsYXNzIHJlcHJlc2VudGluZyBhbiBBV1Mgc2VydmljZS5cbiAqXG4gKiBAY2xhc3NfYWJzdHJhY3QgVGhpcyBjbGFzcyBpcyBhbiBhYnN0cmFjdCBjbGFzcy5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBhcGlWZXJzaW9uc1xuICogICBAcmV0dXJuIFtBcnJheTxTdHJpbmc+XSB0aGUgbGlzdCBvZiBBUEkgdmVyc2lvbnMgc3VwcG9ydGVkIGJ5IHRoaXMgc2VydmljZS5cbiAqICAgQHJlYWRvbmx5XG4gKi9cbkFXUy5TZXJ2aWNlID0gaW5oZXJpdCh7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgc2VydmljZSBvYmplY3Qgd2l0aCBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSBjb25maWcgW21hcF0gYSBtYXAgb2YgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gU2VydmljZShjb25maWcpIHtcbiAgICBpZiAoIXRoaXMubG9hZFNlcnZpY2VDbGFzcykge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgICdTZXJ2aWNlIG11c3QgYmUgY29uc3RydWN0ZWQgd2l0aCBgbmV3XFwnIG9wZXJhdG9yJyk7XG4gICAgfVxuICAgIHZhciBTZXJ2aWNlQ2xhc3MgPSB0aGlzLmxvYWRTZXJ2aWNlQ2xhc3MoY29uZmlnIHx8IHt9KTtcbiAgICBpZiAoU2VydmljZUNsYXNzKSB7XG4gICAgICB2YXIgb3JpZ2luYWxDb25maWcgPSBBV1MudXRpbC5jb3B5KGNvbmZpZyk7XG4gICAgICB2YXIgc3ZjID0gbmV3IFNlcnZpY2VDbGFzcyhjb25maWcpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN2YywgJ19vcmlnaW5hbENvbmZpZycsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG9yaWdpbmFsQ29uZmlnOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHN2Yy5fY2xpZW50SWQgPSArK2NsaWVudENvdW50O1xuICAgICAgcmV0dXJuIHN2YztcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsaXplKGNvbmZpZyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShjb25maWcpIHtcbiAgICB2YXIgc3ZjQ29uZmlnID0gQVdTLmNvbmZpZ1t0aGlzLnNlcnZpY2VJZGVudGlmaWVyXTtcbiAgICB0aGlzLmNvbmZpZyA9IG5ldyBBV1MuQ29uZmlnKEFXUy5jb25maWcpO1xuICAgIGlmIChzdmNDb25maWcpIHRoaXMuY29uZmlnLnVwZGF0ZShzdmNDb25maWcsIHRydWUpO1xuICAgIGlmIChjb25maWcpIHRoaXMuY29uZmlnLnVwZGF0ZShjb25maWcsIHRydWUpO1xuXG4gICAgdGhpcy52YWxpZGF0ZVNlcnZpY2UoKTtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmVuZHBvaW50KSByZWdpb25Db25maWcuY29uZmlndXJlRW5kcG9pbnQodGhpcyk7XG5cbiAgICB0aGlzLmNvbmZpZy5lbmRwb2ludCA9IHRoaXMuZW5kcG9pbnRGcm9tVGVtcGxhdGUodGhpcy5jb25maWcuZW5kcG9pbnQpO1xuICAgIHRoaXMuc2V0RW5kcG9pbnQodGhpcy5jb25maWcuZW5kcG9pbnQpO1xuICAgIC8vZW5hYmxlIGF0dGFjaGluZyBsaXN0ZW5lcnMgdG8gc2VydmljZSBjbGllbnRcbiAgICBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yLmNhbGwodGhpcyk7XG4gICAgQVdTLlNlcnZpY2UuYWRkRGVmYXVsdE1vbml0b3JpbmdMaXN0ZW5lcnModGhpcyk7XG4gICAgaWYgKCh0aGlzLmNvbmZpZy5jbGllbnRTaWRlTW9uaXRvcmluZyB8fCBBV1MuU2VydmljZS5fY2xpZW50U2lkZU1vbml0b3JpbmcpICYmIHRoaXMucHVibGlzaGVyKSB7XG4gICAgICB2YXIgcHVibGlzaGVyID0gdGhpcy5wdWJsaXNoZXI7XG4gICAgICB0aGlzLmFkZE5hbWVkTGlzdGVuZXIoJ1BVQkxJU0hfQVBJX0NBTEwnLCAnYXBpQ2FsbCcsIGZ1bmN0aW9uIFBVQkxJU0hfQVBJX0NBTEwoZXZlbnQpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtwdWJsaXNoZXIuZXZlbnRIYW5kbGVyKGV2ZW50KTt9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hZGROYW1lZExpc3RlbmVyKCdQVUJMSVNIX0FQSV9BVFRFTVBUJywgJ2FwaUNhbGxBdHRlbXB0JywgZnVuY3Rpb24gUFVCTElTSF9BUElfQVRURU1QVChldmVudCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge3B1Ymxpc2hlci5ldmVudEhhbmRsZXIoZXZlbnQpO30pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHZhbGlkYXRlU2VydmljZTogZnVuY3Rpb24gdmFsaWRhdGVTZXJ2aWNlKCkge1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxvYWRTZXJ2aWNlQ2xhc3M6IGZ1bmN0aW9uIGxvYWRTZXJ2aWNlQ2xhc3Moc2VydmljZUNvbmZpZykge1xuICAgIHZhciBjb25maWcgPSBzZXJ2aWNlQ29uZmlnO1xuICAgIGlmICghQVdTLnV0aWwuaXNFbXB0eSh0aGlzLmFwaSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnLmFwaUNvbmZpZykge1xuICAgICAgcmV0dXJuIEFXUy5TZXJ2aWNlLmRlZmluZVNlcnZpY2VBcGkodGhpcy5jb25zdHJ1Y3RvciwgY29uZmlnLmFwaUNvbmZpZyk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZyA9IG5ldyBBV1MuQ29uZmlnKEFXUy5jb25maWcpO1xuICAgICAgY29uZmlnLnVwZGF0ZShzZXJ2aWNlQ29uZmlnLCB0cnVlKTtcbiAgICAgIHZhciB2ZXJzaW9uID0gY29uZmlnLmFwaVZlcnNpb25zW3RoaXMuY29uc3RydWN0b3Iuc2VydmljZUlkZW50aWZpZXJdO1xuICAgICAgdmVyc2lvbiA9IHZlcnNpb24gfHwgY29uZmlnLmFwaVZlcnNpb247XG4gICAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3RTZXJ2aWNlQ2xhc3ModmVyc2lvbik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldExhdGVzdFNlcnZpY2VDbGFzczogZnVuY3Rpb24gZ2V0TGF0ZXN0U2VydmljZUNsYXNzKHZlcnNpb24pIHtcbiAgICB2ZXJzaW9uID0gdGhpcy5nZXRMYXRlc3RTZXJ2aWNlVmVyc2lvbih2ZXJzaW9uKTtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlc1t2ZXJzaW9uXSA9PT0gbnVsbCkge1xuICAgICAgQVdTLlNlcnZpY2UuZGVmaW5lU2VydmljZUFwaSh0aGlzLmNvbnN0cnVjdG9yLCB2ZXJzaW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlc1t2ZXJzaW9uXTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRMYXRlc3RTZXJ2aWNlVmVyc2lvbjogZnVuY3Rpb24gZ2V0TGF0ZXN0U2VydmljZVZlcnNpb24odmVyc2lvbikge1xuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlcyB8fCB0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzZXJ2aWNlcyBkZWZpbmVkIG9uICcgK1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3Iuc2VydmljZUlkZW50aWZpZXIpO1xuICAgIH1cblxuICAgIGlmICghdmVyc2lvbikge1xuICAgICAgdmVyc2lvbiA9ICdsYXRlc3QnO1xuICAgIH0gZWxzZSBpZiAoQVdTLnV0aWwuaXNUeXBlKHZlcnNpb24sIERhdGUpKSB7XG4gICAgICB2ZXJzaW9uID0gQVdTLnV0aWwuZGF0ZS5pc284NjAxKHZlcnNpb24pLnNwbGl0KCdUJylbMF07XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eSh0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VzLCB2ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VzKS5zb3J0KCk7XG4gICAgdmFyIHNlbGVjdGVkVmVyc2lvbiA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIC8vIHZlcnNpb25zIHRoYXQgZW5kIGluIFwiKlwiIGFyZSBub3QgYXZhaWxhYmxlIG9uIGRpc2sgYW5kIGNhbiBiZVxuICAgICAgLy8gc2tpcHBlZCwgc28gZG8gbm90IGNob29zZSB0aGVzZSBhcyBzZWxlY3RlZFZlcnNpb25zXG4gICAgICBpZiAoa2V5c1tpXVtrZXlzW2ldLmxlbmd0aCAtIDFdICE9PSAnKicpIHtcbiAgICAgICAgc2VsZWN0ZWRWZXJzaW9uID0ga2V5c1tpXTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXlzW2ldLnN1YnN0cigwLCAxMCkgPD0gdmVyc2lvbikge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWRWZXJzaW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgJyArIHRoaXMuY29uc3RydWN0b3Iuc2VydmljZUlkZW50aWZpZXIgK1xuICAgICAgICAgICAgICAgICAgICAnIEFQSSB0byBzYXRpc2Z5IHZlcnNpb24gY29uc3RyYWludCBgJyArIHZlcnNpb24gKyAnXFwnJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYXBpOiB7fSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBkZWZhdWx0UmV0cnlDb3VudDogMyxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjdXN0b21pemVSZXF1ZXN0czogZnVuY3Rpb24gY3VzdG9taXplUmVxdWVzdHMoY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmN1c3RvbVJlcXVlc3RIYW5kbGVyID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0SGFuZGxlciA9IGNhbGxiYWNrO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2FsbGJhY2sgdHlwZSBcXCcnICsgdHlwZW9mIGNhbGxiYWNrICsgJ1xcJyBwcm92aWRlZCBpbiBjdXN0b21pemVSZXF1ZXN0cycpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbHMgYW4gb3BlcmF0aW9uIG9uIGEgc2VydmljZSB3aXRoIHRoZSBnaXZlbiBpbnB1dCBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gb3BlcmF0aW9uIFtTdHJpbmddIHRoZSBuYW1lIG9mIHRoZSBvcGVyYXRpb24gdG8gY2FsbCBvbiB0aGUgc2VydmljZS5cbiAgICogQHBhcmFtIHBhcmFtcyBbbWFwXSBhIG1hcCBvZiBpbnB1dCBvcHRpb25zIGZvciB0aGUgb3BlcmF0aW9uXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGRhdGEpXG4gICAqICAgSWYgYSBjYWxsYmFjayBpcyBzdXBwbGllZCwgaXQgaXMgY2FsbGVkIHdoZW4gYSByZXNwb25zZSBpcyByZXR1cm5lZFxuICAgKiAgIGZyb20gdGhlIHNlcnZpY2UuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgcmVxdWVzdC5cbiAgICogICAgIFNldCB0byBgbnVsbGAgaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bC5cbiAgICogICBAcGFyYW0gZGF0YSBbT2JqZWN0XSB0aGUgZGUtc2VyaWFsaXplZCBkYXRhIHJldHVybmVkIGZyb21cbiAgICogICAgIHRoZSByZXF1ZXN0LiBTZXQgdG8gYG51bGxgIGlmIGEgcmVxdWVzdCBlcnJvciBvY2N1cnMuXG4gICAqL1xuICBtYWtlUmVxdWVzdDogZnVuY3Rpb24gbWFrZVJlcXVlc3Qob3BlcmF0aW9uLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgICAgcGFyYW1zID0gbnVsbDtcbiAgICB9XG5cbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgaWYgKHRoaXMuY29uZmlnLnBhcmFtcykgeyAvLyBjb3B5IG9ubHkgdG9wbGV2ZWwgYm91bmQgcGFyYW1zXG4gICAgICB2YXIgcnVsZXMgPSB0aGlzLmFwaS5vcGVyYXRpb25zW29wZXJhdGlvbl07XG4gICAgICBpZiAocnVsZXMpIHtcbiAgICAgICAgcGFyYW1zID0gQVdTLnV0aWwuY29weShwYXJhbXMpO1xuICAgICAgICBBV1MudXRpbC5lYWNoKHRoaXMuY29uZmlnLnBhcmFtcywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChydWxlcy5pbnB1dC5tZW1iZXJzW2tleV0pIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXNba2V5XSA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtc1trZXldID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBBV1MuUmVxdWVzdCh0aGlzLCBvcGVyYXRpb24sIHBhcmFtcyk7XG4gICAgdGhpcy5hZGRBbGxSZXF1ZXN0TGlzdGVuZXJzKHJlcXVlc3QpO1xuICAgIHRoaXMuYXR0YWNoTW9uaXRvcmluZ0VtaXR0ZXIocmVxdWVzdCk7XG4gICAgaWYgKGNhbGxiYWNrKSByZXF1ZXN0LnNlbmQoY2FsbGJhY2spO1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxscyBhbiBvcGVyYXRpb24gb24gYSBzZXJ2aWNlIHdpdGggdGhlIGdpdmVuIGlucHV0IHBhcmFtZXRlcnMsIHdpdGhvdXRcbiAgICogYW55IGF1dGhlbnRpY2F0aW9uIGRhdGEuIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBmb3IgXCJwdWJsaWNcIiBBUEkgb3BlcmF0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIG9wZXJhdGlvbiBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgb3BlcmF0aW9uIHRvIGNhbGwgb24gdGhlIHNlcnZpY2UuXG4gICAqIEBwYXJhbSBwYXJhbXMgW21hcF0gYSBtYXAgb2YgaW5wdXQgb3B0aW9ucyBmb3IgdGhlIG9wZXJhdGlvblxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBkYXRhKVxuICAgKiAgIElmIGEgY2FsbGJhY2sgaXMgc3VwcGxpZWQsIGl0IGlzIGNhbGxlZCB3aGVuIGEgcmVzcG9uc2UgaXMgcmV0dXJuZWRcbiAgICogICBmcm9tIHRoZSBzZXJ2aWNlLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHJldHVybmVkIGZyb20gdGhlIHJlcXVlc3QuXG4gICAqICAgICBTZXQgdG8gYG51bGxgIGlmIHRoZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuXG4gICAqICAgQHBhcmFtIGRhdGEgW09iamVjdF0gdGhlIGRlLXNlcmlhbGl6ZWQgZGF0YSByZXR1cm5lZCBmcm9tXG4gICAqICAgICB0aGUgcmVxdWVzdC4gU2V0IHRvIGBudWxsYCBpZiBhIHJlcXVlc3QgZXJyb3Igb2NjdXJzLlxuICAgKi9cbiAgbWFrZVVuYXV0aGVudGljYXRlZFJlcXVlc3Q6IGZ1bmN0aW9uIG1ha2VVbmF1dGhlbnRpY2F0ZWRSZXF1ZXN0KG9wZXJhdGlvbiwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgIHBhcmFtcyA9IHt9O1xuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gdGhpcy5tYWtlUmVxdWVzdChvcGVyYXRpb24sIHBhcmFtcykudG9VbmF1dGhlbnRpY2F0ZWQoKTtcbiAgICByZXR1cm4gY2FsbGJhY2sgPyByZXF1ZXN0LnNlbmQoY2FsbGJhY2spIDogcmVxdWVzdDtcbiAgfSxcblxuICAvKipcbiAgICogV2FpdHMgZm9yIGEgZ2l2ZW4gc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHN0YXRlIFtTdHJpbmddIHRoZSBzdGF0ZSBvbiB0aGUgc2VydmljZSB0byB3YWl0IGZvclxuICAgKiBAcGFyYW0gcGFyYW1zIFttYXBdIGEgbWFwIG9mIHBhcmFtZXRlcnMgdG8gcGFzcyB3aXRoIGVhY2ggcmVxdWVzdFxuICAgKiBAb3B0aW9uIHBhcmFtcyAkd2FpdGVyIFttYXBdIGEgbWFwIG9mIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHdhaXRlclxuICAgKiBAb3B0aW9uIHBhcmFtcyAkd2FpdGVyLmRlbGF5IFtOdW1iZXJdIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB0byB3YWl0IGJldHdlZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0c1xuICAgKiBAb3B0aW9uIHBhcmFtcyAkd2FpdGVyLm1heEF0dGVtcHRzIFtOdW1iZXJdIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZXF1ZXN0c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHNlbmQgd2hpbGUgd2FpdGluZ1xuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBkYXRhKVxuICAgKiAgIElmIGEgY2FsbGJhY2sgaXMgc3VwcGxpZWQsIGl0IGlzIGNhbGxlZCB3aGVuIGEgcmVzcG9uc2UgaXMgcmV0dXJuZWRcbiAgICogICBmcm9tIHRoZSBzZXJ2aWNlLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHJldHVybmVkIGZyb20gdGhlIHJlcXVlc3QuXG4gICAqICAgICBTZXQgdG8gYG51bGxgIGlmIHRoZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuXG4gICAqICAgQHBhcmFtIGRhdGEgW09iamVjdF0gdGhlIGRlLXNlcmlhbGl6ZWQgZGF0YSByZXR1cm5lZCBmcm9tXG4gICAqICAgICB0aGUgcmVxdWVzdC4gU2V0IHRvIGBudWxsYCBpZiBhIHJlcXVlc3QgZXJyb3Igb2NjdXJzLlxuICAgKi9cbiAgd2FpdEZvcjogZnVuY3Rpb24gd2FpdEZvcihzdGF0ZSwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgIHZhciB3YWl0ZXIgPSBuZXcgQVdTLlJlc291cmNlV2FpdGVyKHRoaXMsIHN0YXRlKTtcbiAgICByZXR1cm4gd2FpdGVyLndhaXQocGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYWRkQWxsUmVxdWVzdExpc3RlbmVyczogZnVuY3Rpb24gYWRkQWxsUmVxdWVzdExpc3RlbmVycyhyZXF1ZXN0KSB7XG4gICAgdmFyIGxpc3QgPSBbQVdTLmV2ZW50cywgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUsIHRoaXMuc2VydmljZUludGVyZmFjZSgpLFxuICAgICAgICAgICAgICAgIEFXUy5FdmVudExpc3RlbmVycy5Db3JlUG9zdF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXSkgcmVxdWVzdC5hZGRMaXN0ZW5lcnMobGlzdFtpXSk7XG4gICAgfVxuXG4gICAgLy8gZGlzYWJsZSBwYXJhbWV0ZXIgdmFsaWRhdGlvblxuICAgIGlmICghdGhpcy5jb25maWcucGFyYW1WYWxpZGF0aW9uKSB7XG4gICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCd2YWxpZGF0ZScsXG4gICAgICAgIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlZBTElEQVRFX1BBUkFNRVRFUlMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbmZpZy5sb2dnZXIpIHsgLy8gYWRkIGxvZ2dpbmcgZXZlbnRzXG4gICAgICByZXF1ZXN0LmFkZExpc3RlbmVycyhBV1MuRXZlbnRMaXN0ZW5lcnMuTG9nZ2VyKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldHVwUmVxdWVzdExpc3RlbmVycyhyZXF1ZXN0KTtcbiAgICAvLyBjYWxsIHByb3RvdHlwZSdzIGN1c3RvbVJlcXVlc3RIYW5kbGVyXG4gICAgaWYgKHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jdXN0b21SZXF1ZXN0SGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY3VzdG9tUmVxdWVzdEhhbmRsZXIocmVxdWVzdCk7XG4gICAgfVxuICAgIC8vIGNhbGwgaW5zdGFuY2UncyBjdXN0b21SZXF1ZXN0SGFuZGxlclxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ2N1c3RvbVJlcXVlc3RIYW5kbGVyJykgJiYgdHlwZW9mIHRoaXMuY3VzdG9tUmVxdWVzdEhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdEhhbmRsZXIocmVxdWVzdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFdmVudCByZWNvcmRpbmcgbWV0cmljcyBmb3IgYSB3aG9sZSBBUEkgY2FsbC5cbiAgICogQHJldHVybnMge29iamVjdH0gYSBzdWJzZXQgb2YgYXBpIGNhbGwgbWV0cmljc1xuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFwaUNhbGxFdmVudDogZnVuY3Rpb24gYXBpQ2FsbEV2ZW50KHJlcXVlc3QpIHtcbiAgICB2YXIgYXBpID0gcmVxdWVzdC5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXTtcbiAgICB2YXIgbW9uaXRvcmluZ0V2ZW50ID0ge1xuICAgICAgVHlwZTogJ0FwaUNhbGwnLFxuICAgICAgQXBpOiBhcGkgPyBhcGkubmFtZSA6IHJlcXVlc3Qub3BlcmF0aW9uLFxuICAgICAgVmVyc2lvbjogMSxcbiAgICAgIFNlcnZpY2U6IHJlcXVlc3Quc2VydmljZS5hcGkuc2VydmljZUlkIHx8IHJlcXVlc3Quc2VydmljZS5hcGkuZW5kcG9pbnRQcmVmaXgsXG4gICAgICBSZWdpb246IHJlcXVlc3QuaHR0cFJlcXVlc3QucmVnaW9uLFxuICAgICAgTWF4UmV0cmllc0V4Y2VlZGVkOiAwLFxuICAgICAgVXNlckFnZW50OiByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmdldFVzZXJBZ2VudCgpLFxuICAgIH07XG4gICAgdmFyIHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICBpZiAocmVzcG9uc2UuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUpIHtcbiAgICAgIG1vbml0b3JpbmdFdmVudC5GaW5hbEh0dHBTdGF0dXNDb2RlID0gcmVzcG9uc2UuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG4gICAgICB2YXIgc3RhdHVzQ29kZSA9IHJlc3BvbnNlLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgaWYgKHN0YXR1c0NvZGUgPiAyOTkpIHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUpIG1vbml0b3JpbmdFdmVudC5GaW5hbEF3c0V4Y2VwdGlvbiA9IGVycm9yLmNvZGU7XG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlKSBtb25pdG9yaW5nRXZlbnQuRmluYWxBd3NFeGNlcHRpb25NZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlIHx8IGVycm9yLm5hbWUpIG1vbml0b3JpbmdFdmVudC5GaW5hbFNka0V4Y2VwdGlvbiA9IGVycm9yLmNvZGUgfHwgZXJyb3IubmFtZTtcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIG1vbml0b3JpbmdFdmVudC5GaW5hbFNka0V4Y2VwdGlvbk1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbW9uaXRvcmluZ0V2ZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBFdmVudCByZWNvcmRpbmcgbWV0cmljcyBmb3IgYW4gQVBJIGNhbGwgYXR0ZW1wdC5cbiAgICogQHJldHVybnMge29iamVjdH0gYSBzdWJzZXQgb2YgYXBpIGNhbGwgYXR0ZW1wdCBtZXRyaWNzXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYXBpQXR0ZW1wdEV2ZW50OiBmdW5jdGlvbiBhcGlBdHRlbXB0RXZlbnQocmVxdWVzdCkge1xuICAgIHZhciBhcGkgPSByZXF1ZXN0LnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dO1xuICAgIHZhciBtb25pdG9yaW5nRXZlbnQgPSB7XG4gICAgICBUeXBlOiAnQXBpQ2FsbEF0dGVtcHQnLFxuICAgICAgQXBpOiBhcGkgPyBhcGkubmFtZSA6IHJlcXVlc3Qub3BlcmF0aW9uLFxuICAgICAgVmVyc2lvbjogMSxcbiAgICAgIFNlcnZpY2U6IHJlcXVlc3Quc2VydmljZS5hcGkuc2VydmljZUlkIHx8IHJlcXVlc3Quc2VydmljZS5hcGkuZW5kcG9pbnRQcmVmaXgsXG4gICAgICBGcWRuOiByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmVuZHBvaW50Lmhvc3RuYW1lLFxuICAgICAgVXNlckFnZW50OiByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmdldFVzZXJBZ2VudCgpLFxuICAgIH07XG4gICAgdmFyIHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICBpZiAocmVzcG9uc2UuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUpIHtcbiAgICAgIG1vbml0b3JpbmdFdmVudC5IdHRwU3RhdHVzQ29kZSA9IHJlc3BvbnNlLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAhcmVxdWVzdC5fdW5BdXRoZW50aWNhdGVkICYmXG4gICAgICByZXF1ZXN0LnNlcnZpY2UuY29uZmlnLmNyZWRlbnRpYWxzICYmXG4gICAgICByZXF1ZXN0LnNlcnZpY2UuY29uZmlnLmNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkXG4gICAgKSB7XG4gICAgICBtb25pdG9yaW5nRXZlbnQuQWNjZXNzS2V5ID0gcmVxdWVzdC5zZXJ2aWNlLmNvbmZpZy5jcmVkZW50aWFscy5hY2Nlc3NLZXlJZDtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5odHRwUmVzcG9uc2UuaGVhZGVycykgcmV0dXJuIG1vbml0b3JpbmdFdmVudDtcbiAgICBpZiAocmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzWyd4LWFtei1zZWN1cml0eS10b2tlbiddKSB7XG4gICAgICBtb25pdG9yaW5nRXZlbnQuU2Vzc2lvblRva2VuID0gcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzWyd4LWFtei1zZWN1cml0eS10b2tlbiddO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3gtYW16bi1yZXF1ZXN0aWQnXSkge1xuICAgICAgbW9uaXRvcmluZ0V2ZW50LlhBbXpuUmVxdWVzdElkID0gcmVzcG9uc2UuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3gtYW16bi1yZXF1ZXN0aWQnXTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmh0dHBSZXNwb25zZS5oZWFkZXJzWyd4LWFtei1yZXF1ZXN0LWlkJ10pIHtcbiAgICAgIG1vbml0b3JpbmdFdmVudC5YQW16UmVxdWVzdElkID0gcmVzcG9uc2UuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3gtYW16LXJlcXVlc3QtaWQnXTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmh0dHBSZXNwb25zZS5oZWFkZXJzWyd4LWFtei1pZC0yJ10pIHtcbiAgICAgIG1vbml0b3JpbmdFdmVudC5YQW16SWQyID0gcmVzcG9uc2UuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3gtYW16LWlkLTInXTtcbiAgICB9XG4gICAgcmV0dXJuIG1vbml0b3JpbmdFdmVudDtcbiAgfSxcblxuICAvKipcbiAgICogQWRkIG1ldHJpY3Mgb2YgZmFpbGVkIHJlcXVlc3QuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYXR0ZW1wdEZhaWxFdmVudDogZnVuY3Rpb24gYXR0ZW1wdEZhaWxFdmVudChyZXF1ZXN0KSB7XG4gICAgdmFyIG1vbml0b3JpbmdFdmVudCA9IHRoaXMuYXBpQXR0ZW1wdEV2ZW50KHJlcXVlc3QpO1xuICAgIHZhciByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgdmFyIGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG4gICAgaWYgKHJlc3BvbnNlLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlID4gMjk5ICkge1xuICAgICAgaWYgKGVycm9yLmNvZGUpIG1vbml0b3JpbmdFdmVudC5Bd3NFeGNlcHRpb24gPSBlcnJvci5jb2RlO1xuICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIG1vbml0b3JpbmdFdmVudC5Bd3NFeGNlcHRpb25NZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVycm9yLmNvZGUgfHwgZXJyb3IubmFtZSkgbW9uaXRvcmluZ0V2ZW50LlNka0V4Y2VwdGlvbiA9IGVycm9yLmNvZGUgfHwgZXJyb3IubmFtZTtcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlKSBtb25pdG9yaW5nRXZlbnQuU2RrRXhjZXB0aW9uTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBtb25pdG9yaW5nRXZlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEF0dGFjaCBsaXN0ZW5lcnMgdG8gcmVxdWVzdCBvYmplY3QgdG8gZmV0Y2ggbWV0cmljcyBvZiBlYWNoIHJlcXVlc3RcbiAgICogYW5kIGVtaXQgZGF0YSBvYmplY3QgdGhyb3VnaCBcXCdBcGlDYWxsXFwnIGFuZCBcXCdBcGlDYWxsQXR0ZW1wdFxcJyBldmVudHMuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYXR0YWNoTW9uaXRvcmluZ0VtaXR0ZXI6IGZ1bmN0aW9uIGF0dGFjaE1vbml0b3JpbmdFbWl0dGVyKHJlcXVlc3QpIHtcbiAgICB2YXIgYXR0ZW1wdFRpbWVzdGFtcDsgLy90aW1lc3RhbXAgbWFya2luZyB0aGUgYmVnaW5uaW5nIG9mIGEgcmVxdWVzdCBhdHRlbXB0XG4gICAgdmFyIGF0dGVtcHRTdGFydFJlYWxUaW1lOyAvL1N0YXJ0IHRpbWUgb2YgcmVxdWVzdCBhdHRlbXB0LiBVc2VkIHRvIGNhbGN1bGF0aW5nIGF0dGVtcHRMYXRlbmN5XG4gICAgdmFyIGF0dGVtcHRMYXRlbmN5OyAvL2xhdGVuY3kgZnJvbSByZXF1ZXN0IHNlbnQgb3V0IHRvIGh0dHAgcmVzcG9uc2UgcmVhY2hpbmcgU0RLXG4gICAgdmFyIGNhbGxTdGFydFJlYWxUaW1lOyAvL1N0YXJ0IHRpbWUgb2YgQVBJIGNhbGwuIFVzZWQgdG8gY2FsY3VsYXRpbmcgQVBJIGNhbGwgbGF0ZW5jeVxuICAgIHZhciBhdHRlbXB0Q291bnQgPSAwOyAvL3JlcXVlc3QucmV0cnlDb3VudCBpcyBub3QgcmVsaWFibGUgaGVyZVxuICAgIHZhciByZWdpb247IC8vcmVnaW9uIGNhY2hlIHJlZ2lvbiBmb3IgZWFjaCBhdHRlbXB0IHNpbmNlIGl0IGNhbiBiZSB1cGRhdGVkIGluIHBsYXNlIChlLmcuIHMzKVxuICAgIHZhciBjYWxsVGltZXN0YW1wOyAvL3RpbWVzdGFtcCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNyZWF0ZWRcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFkZFRvSGVhZCA9IHRydWU7XG5cbiAgICByZXF1ZXN0Lm9uKCd2YWxpZGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxTdGFydFJlYWxUaW1lID0gQVdTLnV0aWwucmVhbENsb2NrLm5vdygpO1xuICAgICAgY2FsbFRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgfSwgYWRkVG9IZWFkKTtcbiAgICByZXF1ZXN0Lm9uKCdzaWduJywgZnVuY3Rpb24gKCkge1xuICAgICAgYXR0ZW1wdFN0YXJ0UmVhbFRpbWUgPSBBV1MudXRpbC5yZWFsQ2xvY2subm93KCk7XG4gICAgICBhdHRlbXB0VGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgIHJlZ2lvbiA9IHJlcXVlc3QuaHR0cFJlcXVlc3QucmVnaW9uO1xuICAgICAgYXR0ZW1wdENvdW50Kys7XG4gICAgfSwgYWRkVG9IZWFkKTtcbiAgICByZXF1ZXN0Lm9uKCd2YWxpZGF0ZVJlc3BvbnNlJywgZnVuY3Rpb24oKSB7XG4gICAgICBhdHRlbXB0TGF0ZW5jeSA9IE1hdGgucm91bmQoQVdTLnV0aWwucmVhbENsb2NrLm5vdygpIC0gYXR0ZW1wdFN0YXJ0UmVhbFRpbWUpO1xuICAgIH0pO1xuICAgIHJlcXVlc3QuYWRkTmFtZWRMaXN0ZW5lcignQVBJX0NBTExfQVRURU1QVCcsICdzdWNjZXNzJywgZnVuY3Rpb24gQVBJX0NBTExfQVRURU1QVCgpIHtcbiAgICAgIHZhciBhcGlBdHRlbXB0RXZlbnQgPSBzZWxmLmFwaUF0dGVtcHRFdmVudChyZXF1ZXN0KTtcbiAgICAgIGFwaUF0dGVtcHRFdmVudC5UaW1lc3RhbXAgPSBhdHRlbXB0VGltZXN0YW1wO1xuICAgICAgYXBpQXR0ZW1wdEV2ZW50LkF0dGVtcHRMYXRlbmN5ID0gYXR0ZW1wdExhdGVuY3kgPj0gMCA/IGF0dGVtcHRMYXRlbmN5IDogMDtcbiAgICAgIGFwaUF0dGVtcHRFdmVudC5SZWdpb24gPSByZWdpb247XG4gICAgICBzZWxmLmVtaXQoJ2FwaUNhbGxBdHRlbXB0JywgW2FwaUF0dGVtcHRFdmVudF0pO1xuICAgIH0pO1xuICAgIHJlcXVlc3QuYWRkTmFtZWRMaXN0ZW5lcignQVBJX0NBTExfQVRURU1QVF9SRVRSWScsICdyZXRyeScsIGZ1bmN0aW9uIEFQSV9DQUxMX0FUVEVNUFRfUkVUUlkoKSB7XG4gICAgICB2YXIgYXBpQXR0ZW1wdEV2ZW50ID0gc2VsZi5hdHRlbXB0RmFpbEV2ZW50KHJlcXVlc3QpO1xuICAgICAgYXBpQXR0ZW1wdEV2ZW50LlRpbWVzdGFtcCA9IGF0dGVtcHRUaW1lc3RhbXA7XG4gICAgICAvL2F0dGVtcHRMYXRlbmN5IG1heSBub3QgYmUgYXZhaWxhYmxlIGlmIGZhaWwgYmVmb3JlIHJlc3BvbnNlXG4gICAgICBhdHRlbXB0TGF0ZW5jeSA9IGF0dGVtcHRMYXRlbmN5IHx8XG4gICAgICAgIE1hdGgucm91bmQoQVdTLnV0aWwucmVhbENsb2NrLm5vdygpIC0gYXR0ZW1wdFN0YXJ0UmVhbFRpbWUpO1xuICAgICAgYXBpQXR0ZW1wdEV2ZW50LkF0dGVtcHRMYXRlbmN5ID0gYXR0ZW1wdExhdGVuY3kgPj0gMCA/IGF0dGVtcHRMYXRlbmN5IDogMDtcbiAgICAgIGFwaUF0dGVtcHRFdmVudC5SZWdpb24gPSByZWdpb247XG4gICAgICBzZWxmLmVtaXQoJ2FwaUNhbGxBdHRlbXB0JywgW2FwaUF0dGVtcHRFdmVudF0pO1xuICAgIH0pO1xuICAgIHJlcXVlc3QuYWRkTmFtZWRMaXN0ZW5lcignQVBJX0NBTEwnLCAnY29tcGxldGUnLCBmdW5jdGlvbiBBUElfQ0FMTCgpIHtcbiAgICAgIHZhciBhcGlDYWxsRXZlbnQgPSBzZWxmLmFwaUNhbGxFdmVudChyZXF1ZXN0KTtcbiAgICAgIGFwaUNhbGxFdmVudC5BdHRlbXB0Q291bnQgPSBhdHRlbXB0Q291bnQ7XG4gICAgICBpZiAoYXBpQ2FsbEV2ZW50LkF0dGVtcHRDb3VudCA8PSAwKSByZXR1cm47XG4gICAgICBhcGlDYWxsRXZlbnQuVGltZXN0YW1wID0gY2FsbFRpbWVzdGFtcDtcbiAgICAgIHZhciBsYXRlbmN5ID0gTWF0aC5yb3VuZChBV1MudXRpbC5yZWFsQ2xvY2subm93KCkgLSBjYWxsU3RhcnRSZWFsVGltZSk7XG4gICAgICBhcGlDYWxsRXZlbnQuTGF0ZW5jeSA9IGxhdGVuY3kgPj0gMCA/IGxhdGVuY3kgOiAwO1xuICAgICAgdmFyIHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHJlc3BvbnNlLnJldHJ5Q291bnQgPT09ICdudW1iZXInICYmXG4gICAgICAgIHR5cGVvZiByZXNwb25zZS5tYXhSZXRyaWVzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAocmVzcG9uc2UucmV0cnlDb3VudCA+PSByZXNwb25zZS5tYXhSZXRyaWVzKVxuICAgICAgKSB7XG4gICAgICAgIGFwaUNhbGxFdmVudC5NYXhSZXRyaWVzRXhjZWVkZWQgPSAxO1xuICAgICAgfVxuICAgICAgc2VsZi5lbWl0KCdhcGlDYWxsJywgW2FwaUNhbGxFdmVudF0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBzZXR1cCBhbnkgY3VzdG9tIHJlcXVlc3QgbGlzdGVuZXJzIGZvciBlYWNoXG4gICAqIG5ldyByZXF1ZXN0IHRvIHRoZSBzZXJ2aWNlLlxuICAgKlxuICAgKiBAbWV0aG9kX2Fic3RyYWN0IFRoaXMgaXMgYW4gYWJzdHJhY3QgbWV0aG9kLlxuICAgKi9cbiAgc2V0dXBSZXF1ZXN0TGlzdGVuZXJzOiBmdW5jdGlvbiBzZXR1cFJlcXVlc3RMaXN0ZW5lcnMocmVxdWVzdCkge1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaWduZXIgY2xhc3MgZm9yIGEgZ2l2ZW4gcmVxdWVzdFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldFNpZ25lckNsYXNzOiBmdW5jdGlvbiBnZXRTaWduZXJDbGFzcyhyZXF1ZXN0KSB7XG4gICAgdmFyIHZlcnNpb247XG4gICAgLy8gZ2V0IG9wZXJhdGlvbiBhdXRodHlwZSBpZiBwcmVzZW50XG4gICAgdmFyIG9wZXJhdGlvbiA9IG51bGw7XG4gICAgdmFyIGF1dGh0eXBlID0gJyc7XG4gICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgIHZhciBvcGVyYXRpb25zID0gcmVxdWVzdC5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zIHx8IHt9O1xuICAgICAgb3BlcmF0aW9uID0gb3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl0gfHwgbnVsbDtcbiAgICAgIGF1dGh0eXBlID0gb3BlcmF0aW9uID8gb3BlcmF0aW9uLmF1dGh0eXBlIDogJyc7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZy5zaWduYXR1cmVWZXJzaW9uKSB7XG4gICAgICB2ZXJzaW9uID0gdGhpcy5jb25maWcuc2lnbmF0dXJlVmVyc2lvbjtcbiAgICB9IGVsc2UgaWYgKGF1dGh0eXBlID09PSAndjQnIHx8IGF1dGh0eXBlID09PSAndjQtdW5zaWduZWQtYm9keScpIHtcbiAgICAgIHZlcnNpb24gPSAndjQnO1xuICAgIH0gZWxzZSB7XG4gICAgICB2ZXJzaW9uID0gdGhpcy5hcGkuc2lnbmF0dXJlVmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIEFXUy5TaWduZXJzLlJlcXVlc3RTaWduZXIuZ2V0VmVyc2lvbih2ZXJzaW9uKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzZXJ2aWNlSW50ZXJmYWNlOiBmdW5jdGlvbiBzZXJ2aWNlSW50ZXJmYWNlKCkge1xuICAgIHN3aXRjaCAodGhpcy5hcGkucHJvdG9jb2wpIHtcbiAgICAgIGNhc2UgJ2VjMic6IHJldHVybiBBV1MuRXZlbnRMaXN0ZW5lcnMuUXVlcnk7XG4gICAgICBjYXNlICdxdWVyeSc6IHJldHVybiBBV1MuRXZlbnRMaXN0ZW5lcnMuUXVlcnk7XG4gICAgICBjYXNlICdqc29uJzogcmV0dXJuIEFXUy5FdmVudExpc3RlbmVycy5Kc29uO1xuICAgICAgY2FzZSAncmVzdC1qc29uJzogcmV0dXJuIEFXUy5FdmVudExpc3RlbmVycy5SZXN0SnNvbjtcbiAgICAgIGNhc2UgJ3Jlc3QteG1sJzogcmV0dXJuIEFXUy5FdmVudExpc3RlbmVycy5SZXN0WG1sO1xuICAgIH1cbiAgICBpZiAodGhpcy5hcGkucHJvdG9jb2wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGBwcm90b2NvbFxcJyAnICtcbiAgICAgICAgdGhpcy5hcGkucHJvdG9jb2wgKyAnIGluIEFQSSBjb25maWcnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlOiBmdW5jdGlvbiBzdWNjZXNzZnVsUmVzcG9uc2UocmVzcCkge1xuICAgIHJldHVybiByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlIDwgMzAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIb3cgbWFueSB0aW1lcyBhIGZhaWxlZCByZXF1ZXN0IHNob3VsZCBiZSByZXRyaWVkIGJlZm9yZSBnaXZpbmcgdXAuXG4gICAqIHRoZSBkZWZhdWx0UmV0cnlDb3VudCBjYW4gYmUgb3ZlcnJpZGVuIGJ5IHNlcnZpY2UgY2xhc3Nlcy5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBudW1SZXRyaWVzOiBmdW5jdGlvbiBudW1SZXRyaWVzKCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5tYXhSZXRyaWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5tYXhSZXRyaWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZhdWx0UmV0cnlDb3VudDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcmV0cnlEZWxheXM6IGZ1bmN0aW9uIHJldHJ5RGVsYXlzKHJldHJ5Q291bnQsIGVycikge1xuICAgIHJldHVybiBBV1MudXRpbC5jYWxjdWxhdGVSZXRyeURlbGF5KHJldHJ5Q291bnQsIHRoaXMuY29uZmlnLnJldHJ5RGVsYXlPcHRpb25zLCBlcnIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHJldHJ5YWJsZUVycm9yOiBmdW5jdGlvbiByZXRyeWFibGVFcnJvcihlcnJvcikge1xuICAgIGlmICh0aGlzLnRpbWVvdXRFcnJvcihlcnJvcikpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLm5ldHdvcmtpbmdFcnJvcihlcnJvcikpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLmV4cGlyZWRDcmVkZW50aWFsc0Vycm9yKGVycm9yKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMudGhyb3R0bGVkRXJyb3IoZXJyb3IpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXJyb3Iuc3RhdHVzQ29kZSA+PSA1MDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBuZXR3b3JraW5nRXJyb3I6IGZ1bmN0aW9uIG5ldHdvcmtpbmdFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5jb2RlID09PSAnTmV0d29ya2luZ0Vycm9yJztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB0aW1lb3V0RXJyb3I6IGZ1bmN0aW9uIHRpbWVvdXRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5jb2RlID09PSAnVGltZW91dEVycm9yJztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBleHBpcmVkQ3JlZGVudGlhbHNFcnJvcjogZnVuY3Rpb24gZXhwaXJlZENyZWRlbnRpYWxzRXJyb3IoZXJyb3IpIHtcbiAgICAvLyBUT0RPIDogdGhpcyBvbmx5IGhhbmRsZXMgKm9uZSogb2YgdGhlIGV4cGlyZWQgY3JlZGVudGlhbCBjb2Rlc1xuICAgIHJldHVybiAoZXJyb3IuY29kZSA9PT0gJ0V4cGlyZWRUb2tlbkV4Y2VwdGlvbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNsb2NrU2tld0Vycm9yOiBmdW5jdGlvbiBjbG9ja1NrZXdFcnJvcihlcnJvcikge1xuICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgY2FzZSAnUmVxdWVzdFRpbWVUb29Ta2V3ZWQnOlxuICAgICAgY2FzZSAnUmVxdWVzdEV4cGlyZWQnOlxuICAgICAgY2FzZSAnSW52YWxpZFNpZ25hdHVyZUV4Y2VwdGlvbic6XG4gICAgICBjYXNlICdTaWduYXR1cmVEb2VzTm90TWF0Y2gnOlxuICAgICAgY2FzZSAnQXV0aEZhaWx1cmUnOlxuICAgICAgY2FzZSAnUmVxdWVzdEluVGhlRnV0dXJlJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldFNrZXdDb3JyZWN0ZWREYXRlOiBmdW5jdGlvbiBnZXRTa2V3Q29ycmVjdGVkRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5ub3coKSArIHRoaXMuY29uZmlnLnN5c3RlbUNsb2NrT2Zmc2V0KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhcHBseUNsb2NrT2Zmc2V0OiBmdW5jdGlvbiBhcHBseUNsb2NrT2Zmc2V0KG5ld1NlcnZlclRpbWUpIHtcbiAgICBpZiAobmV3U2VydmVyVGltZSkge1xuICAgICAgdGhpcy5jb25maWcuc3lzdGVtQ2xvY2tPZmZzZXQgPSBuZXdTZXJ2ZXJUaW1lIC0gRGF0ZS5ub3coKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaXNDbG9ja1NrZXdlZDogZnVuY3Rpb24gaXNDbG9ja1NrZXdlZChuZXdTZXJ2ZXJUaW1lKSB7XG4gICAgaWYgKG5ld1NlcnZlclRpbWUpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLmdldFNrZXdDb3JyZWN0ZWREYXRlKCkuZ2V0VGltZSgpIC0gbmV3U2VydmVyVGltZSkgPj0gMzAwMDAwO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB0aHJvdHRsZWRFcnJvcjogZnVuY3Rpb24gdGhyb3R0bGVkRXJyb3IoZXJyb3IpIHtcbiAgICAvLyB0aGlzIGxvZ2ljIHZhcmllcyBiZXR3ZWVuIHNlcnZpY2VzXG4gICAgaWYgKGVycm9yLnN0YXR1c0NvZGUgPT09IDQyOSkgcmV0dXJuIHRydWU7XG4gICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgICBjYXNlICdQcm92aXNpb25lZFRocm91Z2hwdXRFeGNlZWRlZEV4Y2VwdGlvbic6XG4gICAgICBjYXNlICdUaHJvdHRsaW5nJzpcbiAgICAgIGNhc2UgJ1Rocm90dGxpbmdFeGNlcHRpb24nOlxuICAgICAgY2FzZSAnUmVxdWVzdExpbWl0RXhjZWVkZWQnOlxuICAgICAgY2FzZSAnUmVxdWVzdFRocm90dGxlZCc6XG4gICAgICBjYXNlICdSZXF1ZXN0VGhyb3R0bGVkRXhjZXB0aW9uJzpcbiAgICAgIGNhc2UgJ1Rvb01hbnlSZXF1ZXN0c0V4Y2VwdGlvbic6XG4gICAgICBjYXNlICdUcmFuc2FjdGlvbkluUHJvZ3Jlc3NFeGNlcHRpb24nOiAvL2R5bmFtb2RiXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBlbmRwb2ludEZyb21UZW1wbGF0ZTogZnVuY3Rpb24gZW5kcG9pbnRGcm9tVGVtcGxhdGUoZW5kcG9pbnQpIHtcbiAgICBpZiAodHlwZW9mIGVuZHBvaW50ICE9PSAnc3RyaW5nJykgcmV0dXJuIGVuZHBvaW50O1xuXG4gICAgdmFyIGUgPSBlbmRwb2ludDtcbiAgICBlID0gZS5yZXBsYWNlKC9cXHtzZXJ2aWNlXFx9L2csIHRoaXMuYXBpLmVuZHBvaW50UHJlZml4KTtcbiAgICBlID0gZS5yZXBsYWNlKC9cXHtyZWdpb25cXH0vZywgdGhpcy5jb25maWcucmVnaW9uKTtcbiAgICBlID0gZS5yZXBsYWNlKC9cXHtzY2hlbWVcXH0vZywgdGhpcy5jb25maWcuc3NsRW5hYmxlZCA/ICdodHRwcycgOiAnaHR0cCcpO1xuICAgIHJldHVybiBlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNldEVuZHBvaW50OiBmdW5jdGlvbiBzZXRFbmRwb2ludChlbmRwb2ludCkge1xuICAgIHRoaXMuZW5kcG9pbnQgPSBuZXcgQVdTLkVuZHBvaW50KGVuZHBvaW50LCB0aGlzLmNvbmZpZyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcGFnaW5hdGlvbkNvbmZpZzogZnVuY3Rpb24gcGFnaW5hdGlvbkNvbmZpZyhvcGVyYXRpb24sIHRocm93RXhjZXB0aW9uKSB7XG4gICAgdmFyIHBhZ2luYXRvciA9IHRoaXMuYXBpLm9wZXJhdGlvbnNbb3BlcmF0aW9uXS5wYWdpbmF0b3I7XG4gICAgaWYgKCFwYWdpbmF0b3IpIHtcbiAgICAgIGlmICh0aHJvd0V4Y2VwdGlvbikge1xuICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcigpO1xuICAgICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihlLCAnTm8gcGFnaW5hdGlvbiBjb25maWd1cmF0aW9uIGZvciAnICsgb3BlcmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBwYWdpbmF0b3I7XG4gIH1cbn0pO1xuXG5BV1MudXRpbC51cGRhdGUoQVdTLlNlcnZpY2UsIHtcblxuICAvKipcbiAgICogQWRkcyBvbmUgbWV0aG9kIGZvciBlYWNoIG9wZXJhdGlvbiBkZXNjcmliZWQgaW4gdGhlIGFwaSBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZGVmaW5lTWV0aG9kczogZnVuY3Rpb24gZGVmaW5lTWV0aG9kcyhzdmMpIHtcbiAgICBBV1MudXRpbC5lYWNoKHN2Yy5wcm90b3R5cGUuYXBpLm9wZXJhdGlvbnMsIGZ1bmN0aW9uIGl0ZXJhdG9yKG1ldGhvZCkge1xuICAgICAgaWYgKHN2Yy5wcm90b3R5cGVbbWV0aG9kXSkgcmV0dXJuO1xuICAgICAgdmFyIG9wZXJhdGlvbiA9IHN2Yy5wcm90b3R5cGUuYXBpLm9wZXJhdGlvbnNbbWV0aG9kXTtcbiAgICAgIGlmIChvcGVyYXRpb24uYXV0aHR5cGUgPT09ICdub25lJykge1xuICAgICAgICBzdmMucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VVbmF1dGhlbnRpY2F0ZWRSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdmMucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBuZXcgU2VydmljZSBjbGFzcyB1c2luZyBhIHNlcnZpY2UgaWRlbnRpZmllciBhbmQgbGlzdCBvZiB2ZXJzaW9uc1xuICAgKiBpbmNsdWRpbmcgYW4gb3B0aW9uYWwgc2V0IG9mIGZlYXR1cmVzIChmdW5jdGlvbnMpIHRvIGFwcGx5IHRvIHRoZSBjbGFzc1xuICAgKiBwcm90b3R5cGUuXG4gICAqXG4gICAqIEBwYXJhbSBzZXJ2aWNlSWRlbnRpZmllciBbU3RyaW5nXSB0aGUgaWRlbnRpZmllciBmb3IgdGhlIHNlcnZpY2VcbiAgICogQHBhcmFtIHZlcnNpb25zIFtBcnJheTxTdHJpbmc+XSBhIGxpc3Qgb2YgdmVyc2lvbnMgdGhhdCB3b3JrIHdpdGggdGhpc1xuICAgKiAgIHNlcnZpY2VcbiAgICogQHBhcmFtIGZlYXR1cmVzIFtPYmplY3RdIGFuIG9iamVjdCB0byBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZVxuICAgKiBAcmV0dXJuIFtDbGFzczxTZXJ2aWNlPl0gdGhlIHNlcnZpY2UgY2xhc3MgZGVmaW5lZCBieSB0aGlzIGZ1bmN0aW9uLlxuICAgKi9cbiAgZGVmaW5lU2VydmljZTogZnVuY3Rpb24gZGVmaW5lU2VydmljZShzZXJ2aWNlSWRlbnRpZmllciwgdmVyc2lvbnMsIGZlYXR1cmVzKSB7XG4gICAgQVdTLlNlcnZpY2UuX3NlcnZpY2VNYXBbc2VydmljZUlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmVyc2lvbnMpKSB7XG4gICAgICBmZWF0dXJlcyA9IHZlcnNpb25zO1xuICAgICAgdmVyc2lvbnMgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgc3ZjID0gaW5oZXJpdChBV1MuU2VydmljZSwgZmVhdHVyZXMgfHwge30pO1xuXG4gICAgaWYgKHR5cGVvZiBzZXJ2aWNlSWRlbnRpZmllciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIEFXUy5TZXJ2aWNlLmFkZFZlcnNpb25zKHN2YywgdmVyc2lvbnMpO1xuXG4gICAgICB2YXIgaWRlbnRpZmllciA9IHN2Yy5zZXJ2aWNlSWRlbnRpZmllciB8fCBzZXJ2aWNlSWRlbnRpZmllcjtcbiAgICAgIHN2Yy5zZXJ2aWNlSWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG4gICAgfSBlbHNlIHsgLy8gZGVmaW5lU2VydmljZSBjYWxsZWQgd2l0aCBhbiBBUElcbiAgICAgIHN2Yy5wcm90b3R5cGUuYXBpID0gc2VydmljZUlkZW50aWZpZXI7XG4gICAgICBBV1MuU2VydmljZS5kZWZpbmVNZXRob2RzKHN2Yyk7XG4gICAgfVxuICAgIEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IuY2FsbCh0aGlzLnByb3RvdHlwZSk7XG4gICAgLy91dGlsLmNsaWVudFNpZGVNb25pdG9yaW5nIGlzIG9ubHkgYXZhaWxhYmxlIGluIG5vZGVcbiAgICBpZiAoIXRoaXMucHJvdG90eXBlLnB1Ymxpc2hlciAmJiBBV1MudXRpbC5jbGllbnRTaWRlTW9uaXRvcmluZykge1xuICAgICAgdmFyIFB1Ymxpc2hlciA9IEFXUy51dGlsLmNsaWVudFNpZGVNb25pdG9yaW5nLlB1Ymxpc2hlcjtcbiAgICAgIHZhciBjb25maWdQcm92aWRlciA9IEFXUy51dGlsLmNsaWVudFNpZGVNb25pdG9yaW5nLmNvbmZpZ1Byb3ZpZGVyO1xuICAgICAgdmFyIHB1Ymxpc2hlckNvbmZpZyA9IGNvbmZpZ1Byb3ZpZGVyKCk7XG4gICAgICB0aGlzLnByb3RvdHlwZS5wdWJsaXNoZXIgPSBuZXcgUHVibGlzaGVyKHB1Ymxpc2hlckNvbmZpZyk7XG4gICAgICBpZiAocHVibGlzaGVyQ29uZmlnLmVuYWJsZWQpIHtcbiAgICAgICAgLy9pZiBjc20gaXMgZW5hYmxlZCBpbiBlbnZpcm9ubWVudCwgU0RLIHNob3VsZCBzZW5kIGFsbCBtZXRyaWNzXG4gICAgICAgIEFXUy5TZXJ2aWNlLl9jbGllbnRTaWRlTW9uaXRvcmluZyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IuY2FsbChzdmMucHJvdG90eXBlKTtcbiAgICBBV1MuU2VydmljZS5hZGREZWZhdWx0TW9uaXRvcmluZ0xpc3RlbmVycyhzdmMucHJvdG90eXBlKTtcbiAgICByZXR1cm4gc3ZjO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkZFZlcnNpb25zOiBmdW5jdGlvbiBhZGRWZXJzaW9ucyhzdmMsIHZlcnNpb25zKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZlcnNpb25zKSkgdmVyc2lvbnMgPSBbdmVyc2lvbnNdO1xuXG4gICAgc3ZjLnNlcnZpY2VzID0gc3ZjLnNlcnZpY2VzIHx8IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVyc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdmMuc2VydmljZXNbdmVyc2lvbnNbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3ZjLnNlcnZpY2VzW3ZlcnNpb25zW2ldXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3ZjLmFwaVZlcnNpb25zID0gT2JqZWN0LmtleXMoc3ZjLnNlcnZpY2VzKS5zb3J0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZGVmaW5lU2VydmljZUFwaTogZnVuY3Rpb24gZGVmaW5lU2VydmljZUFwaShzdXBlcmNsYXNzLCB2ZXJzaW9uLCBhcGlDb25maWcpIHtcbiAgICB2YXIgc3ZjID0gaW5oZXJpdChzdXBlcmNsYXNzLCB7XG4gICAgICBzZXJ2aWNlSWRlbnRpZmllcjogc3VwZXJjbGFzcy5zZXJ2aWNlSWRlbnRpZmllclxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gc2V0QXBpKGFwaSkge1xuICAgICAgaWYgKGFwaS5pc0FwaSkge1xuICAgICAgICBzdmMucHJvdG90eXBlLmFwaSA9IGFwaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN2Yy5wcm90b3R5cGUuYXBpID0gbmV3IEFwaShhcGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChhcGlDb25maWcpIHtcbiAgICAgICAgc2V0QXBpKGFwaUNvbmZpZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldEFwaShBV1MuYXBpTG9hZGVyKHN1cGVyY2xhc3Muc2VydmljZUlkZW50aWZpZXIsIHZlcnNpb24pKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IoZXJyLCB7XG4gICAgICAgICAgICBtZXNzYWdlOiAnQ291bGQgbm90IGZpbmQgQVBJIGNvbmZpZ3VyYXRpb24gJyArXG4gICAgICAgICAgICAgIHN1cGVyY2xhc3Muc2VydmljZUlkZW50aWZpZXIgKyAnLScgKyB2ZXJzaW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN1cGVyY2xhc3Muc2VydmljZXMsIHZlcnNpb24pKSB7XG4gICAgICAgIHN1cGVyY2xhc3MuYXBpVmVyc2lvbnMgPSBzdXBlcmNsYXNzLmFwaVZlcnNpb25zLmNvbmNhdCh2ZXJzaW9uKS5zb3J0KCk7XG4gICAgICB9XG4gICAgICBzdXBlcmNsYXNzLnNlcnZpY2VzW3ZlcnNpb25dID0gc3ZjO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRBcGkodmVyc2lvbik7XG4gICAgfVxuXG4gICAgQVdTLlNlcnZpY2UuZGVmaW5lTWV0aG9kcyhzdmMpO1xuICAgIHJldHVybiBzdmM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaGFzU2VydmljZTogZnVuY3Rpb24oaWRlbnRpZmllcikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQVdTLlNlcnZpY2UuX3NlcnZpY2VNYXAsIGlkZW50aWZpZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gYXR0YWNoT24gYXR0YWNoIGRlZmF1bHQgbW9uaXRvcmluZyBsaXN0ZW5lcnMgdG8gb2JqZWN0XG4gICAqXG4gICAqIEVhY2ggbW9uaXRvcmluZyBldmVudCBzaG91bGQgYmUgZW1pdHRlZCBmcm9tIHNlcnZpY2UgY2xpZW50IHRvIHNlcnZpY2UgY29uc3RydWN0b3IgcHJvdG90eXBlIGFuZCB0aGVuXG4gICAqIHRvIGdsb2JhbCBzZXJ2aWNlIHByb3RvdHlwZSBsaWtlIGJ1YmJsaW5nIHVwLiBUaGVzZSBkZWZhdWx0IG1vbml0b3JpbmcgZXZlbnRzIGxpc3RlbmVyIHdpbGwgdHJhbnNmZXJcbiAgICogdGhlIG1vbml0b3JpbmcgZXZlbnRzIHRvIHRoZSB1cHBlciBsYXllci5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhZGREZWZhdWx0TW9uaXRvcmluZ0xpc3RlbmVyczogZnVuY3Rpb24gYWRkRGVmYXVsdE1vbml0b3JpbmdMaXN0ZW5lcnMoYXR0YWNoT24pIHtcbiAgICBhdHRhY2hPbi5hZGROYW1lZExpc3RlbmVyKCdNT05JVE9SX0VWRU5UU19CVUJCTEUnLCAnYXBpQ2FsbEF0dGVtcHQnLCBmdW5jdGlvbiBFVkVOVFNfQlVCQkxFKGV2ZW50KSB7XG4gICAgICB2YXIgYmFzZUNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGF0dGFjaE9uKTtcbiAgICAgIGlmIChiYXNlQ2xhc3MuX2V2ZW50cykgYmFzZUNsYXNzLmVtaXQoJ2FwaUNhbGxBdHRlbXB0JywgW2V2ZW50XSk7XG4gICAgfSk7XG4gICAgYXR0YWNoT24uYWRkTmFtZWRMaXN0ZW5lcignQ0FMTF9FVkVOVFNfQlVCQkxFJywgJ2FwaUNhbGwnLCBmdW5jdGlvbiBDQUxMX0VWRU5UU19CVUJCTEUoZXZlbnQpIHtcbiAgICAgIHZhciBiYXNlQ2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXR0YWNoT24pO1xuICAgICAgaWYgKGJhc2VDbGFzcy5fZXZlbnRzKSBiYXNlQ2xhc3MuZW1pdCgnYXBpQ2FsbCcsIFtldmVudF0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIF9zZXJ2aWNlTWFwOiB7fVxufSk7XG5cbkFXUy51dGlsLm1peGluKEFXUy5TZXJ2aWNlLCBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuU2VydmljZTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbkFXUy51dGlsLnVwZGF0ZShBV1MuQ29nbml0b0lkZW50aXR5LnByb3RvdHlwZSwge1xuICBnZXRPcGVuSWRUb2tlbjogZnVuY3Rpb24gZ2V0T3BlbklkVG9rZW4ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLm1ha2VVbmF1dGhlbnRpY2F0ZWRSZXF1ZXN0KCdnZXRPcGVuSWRUb2tlbicsIHBhcmFtcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIGdldElkOiBmdW5jdGlvbiBnZXRJZChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubWFrZVVuYXV0aGVudGljYXRlZFJlcXVlc3QoJ2dldElkJywgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eTogZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eShwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubWFrZVVuYXV0aGVudGljYXRlZFJlcXVlc3QoJ2dldENyZWRlbnRpYWxzRm9ySWRlbnRpdHknLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfVxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIHY0Q3JlZGVudGlhbHMgPSByZXF1aXJlKCcuLi9zaWduZXJzL3Y0X2NyZWRlbnRpYWxzJyk7XG52YXIgcmVzb2x2ZVJlZ2lvbmFsRW5kcG9pbnRzRmxhZyA9IHJlcXVpcmUoJy4uL2NvbmZpZ19yZWdpb25hbF9lbmRwb2ludCcpO1xudmFyIHJlZ2lvblV0aWwgPSByZXF1aXJlKCcuLi9yZWdpb25fY29uZmlnJyk7XG5cbi8vIFB1bGwgaW4gbWFuYWdlZCB1cGxvYWQgZXh0ZW5zaW9uXG5yZXF1aXJlKCcuLi9zMy9tYW5hZ2VkX3VwbG9hZCcpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgb3BlcmF0aW9uc1dpdGgyMDBTdGF0dXNDb2RlRXJyb3IgPSB7XG4gICdjb21wbGV0ZU11bHRpcGFydFVwbG9hZCc6IHRydWUsXG4gICdjb3B5T2JqZWN0JzogdHJ1ZSxcbiAgJ3VwbG9hZFBhcnRDb3B5JzogdHJ1ZVxufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuIHZhciByZWdpb25SZWRpcmVjdEVycm9yQ29kZXMgPSBbXG4gICdBdXRob3JpemF0aW9uSGVhZGVyTWFsZm9ybWVkJywgLy8gbm9uLWhlYWQgb3BlcmF0aW9ucyBvbiB2aXJ0dWFsLWhvc3RlZCBnbG9iYWwgYnVja2V0IGVuZHBvaW50c1xuICAnQmFkUmVxdWVzdCcsIC8vIGhlYWQgb3BlcmF0aW9ucyBvbiB2aXJ0dWFsLWhvc3RlZCBnbG9iYWwgYnVja2V0IGVuZHBvaW50c1xuICAnUGVybWFuZW50UmVkaXJlY3QnLCAvLyBub24taGVhZCBvcGVyYXRpb25zIG9uIHBhdGgtc3R5bGUgb3IgcmVnaW9uYWwgZW5kcG9pbnRzXG4gIDMwMSAvLyBoZWFkIG9wZXJhdGlvbnMgb24gcGF0aC1zdHlsZSBvciByZWdpb25hbCBlbmRwb2ludHNcbiBdO1xuXG5BV1MudXRpbC51cGRhdGUoQVdTLlMzLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRTaWduYXR1cmVWZXJzaW9uOiBmdW5jdGlvbiBnZXRTaWduYXR1cmVWZXJzaW9uKHJlcXVlc3QpIHtcbiAgICB2YXIgZGVmYXVsdEFwaVZlcnNpb24gPSB0aGlzLmFwaS5zaWduYXR1cmVWZXJzaW9uO1xuICAgIHZhciB1c2VyRGVmaW5lZFZlcnNpb24gPSB0aGlzLl9vcmlnaW5hbENvbmZpZyA/IHRoaXMuX29yaWdpbmFsQ29uZmlnLnNpZ25hdHVyZVZlcnNpb24gOiBudWxsO1xuICAgIHZhciByZWdpb25EZWZpbmVkVmVyc2lvbiA9IHRoaXMuY29uZmlnLnNpZ25hdHVyZVZlcnNpb247XG4gICAgdmFyIGlzUHJlc2lnbmVkID0gcmVxdWVzdCA/IHJlcXVlc3QuaXNQcmVzaWduZWQoKSA6IGZhbHNlO1xuICAgIC8qXG4gICAgICAxKSBVc2VyIGRlZmluZWQgdmVyc2lvbiBzcGVjaWZpZWQ6XG4gICAgICAgIGEpIGFsd2F5cyByZXR1cm4gdXNlciBkZWZpbmVkIHZlcnNpb25cbiAgICAgIDIpIE5vIHVzZXIgZGVmaW5lZCB2ZXJzaW9uIHNwZWNpZmllZDpcbiAgICAgICAgYSkgZGVmYXVsdCB0byBsb3dlc3QgdmVyc2lvbiB0aGUgcmVnaW9uIHN1cHBvcnRzXG4gICAgICAgIGIpIElmIHVzaW5nIHByZXNpZ25lZCB1cmxzLCBkZWZhdWx0IHRvIGxvd2VzdCB2ZXJzaW9uIHRoZSByZWdpb24gc3VwcG9ydHNcbiAgICAqL1xuICAgIGlmICh1c2VyRGVmaW5lZFZlcnNpb24pIHtcbiAgICAgIHVzZXJEZWZpbmVkVmVyc2lvbiA9IHVzZXJEZWZpbmVkVmVyc2lvbiA9PT0gJ3YyJyA/ICdzMycgOiB1c2VyRGVmaW5lZFZlcnNpb247XG4gICAgICByZXR1cm4gdXNlckRlZmluZWRWZXJzaW9uO1xuICAgIH1cbiAgICBpZiAoaXNQcmVzaWduZWQgIT09IHRydWUpIHtcbiAgICAgIGRlZmF1bHRBcGlWZXJzaW9uID0gJ3Y0JztcbiAgICB9IGVsc2UgaWYgKHJlZ2lvbkRlZmluZWRWZXJzaW9uKSB7XG4gICAgICBkZWZhdWx0QXBpVmVyc2lvbiA9IHJlZ2lvbkRlZmluZWRWZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdEFwaVZlcnNpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U2lnbmVyQ2xhc3M6IGZ1bmN0aW9uIGdldFNpZ25lckNsYXNzKHJlcXVlc3QpIHtcbiAgICB2YXIgc2lnbmF0dXJlVmVyc2lvbiA9IHRoaXMuZ2V0U2lnbmF0dXJlVmVyc2lvbihyZXF1ZXN0KTtcbiAgICByZXR1cm4gQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lci5nZXRWZXJzaW9uKHNpZ25hdHVyZVZlcnNpb24pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHZhbGlkYXRlU2VydmljZTogZnVuY3Rpb24gdmFsaWRhdGVTZXJ2aWNlKCkge1xuICAgIHZhciBtc2c7XG4gICAgdmFyIG1lc3NhZ2VzID0gW107XG5cbiAgICAvLyBkZWZhdWx0IHRvIHVzLWVhc3QtMSB3aGVuIG5vIHJlZ2lvbiBpcyBwcm92aWRlZFxuICAgIGlmICghdGhpcy5jb25maWcucmVnaW9uKSB0aGlzLmNvbmZpZy5yZWdpb24gPSAndXMtZWFzdC0xJztcblxuICAgIGlmICghdGhpcy5jb25maWcuZW5kcG9pbnQgJiYgdGhpcy5jb25maWcuczNCdWNrZXRFbmRwb2ludCkge1xuICAgICAgbWVzc2FnZXMucHVzaCgnQW4gZW5kcG9pbnQgbXVzdCBiZSBwcm92aWRlZCB3aGVuIGNvbmZpZ3VyaW5nICcgK1xuICAgICAgICAgICAgICAgICAgICAnYHMzQnVja2V0RW5kcG9pbnRgIHRvIHRydWUuJyk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIG1zZyA9IG1lc3NhZ2VzWzBdO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZXMubGVuZ3RoID4gMSkge1xuICAgICAgbXNnID0gJ011bHRpcGxlIGNvbmZpZ3VyYXRpb24gZXJyb3JzOlxcbicgKyBtZXNzYWdlcy5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgaWYgKG1zZykge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgIHtuYW1lOiAnSW52YWxpZEVuZHBvaW50JywgbWVzc2FnZTogbXNnfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNob3VsZERpc2FibGVCb2R5U2lnbmluZzogZnVuY3Rpb24gc2hvdWxkRGlzYWJsZUJvZHlTaWduaW5nKHJlcXVlc3QpIHtcbiAgICB2YXIgc2lnbmVyQ2xhc3MgPSB0aGlzLmdldFNpZ25lckNsYXNzKCk7XG4gICAgaWYgKHRoaXMuY29uZmlnLnMzRGlzYWJsZUJvZHlTaWduaW5nID09PSB0cnVlICYmIHNpZ25lckNsYXNzID09PSBBV1MuU2lnbmVycy5WNFxuICAgICAgICAmJiByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmVuZHBvaW50LnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzZXR1cFJlcXVlc3RMaXN0ZW5lcnM6IGZ1bmN0aW9uIHNldHVwUmVxdWVzdExpc3RlbmVycyhyZXF1ZXN0KSB7XG4gICAgdmFyIHByZXBlbmRMaXN0ZW5lciA9IHRydWU7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcigndmFsaWRhdGUnLCB0aGlzLnZhbGlkYXRlU2NoZW1lKTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCd2YWxpZGF0ZScsIHRoaXMudmFsaWRhdGVCdWNrZXROYW1lLCBwcmVwZW5kTGlzdGVuZXIpO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ3ZhbGlkYXRlJywgdGhpcy5vcHRJblVzRWFzdDFSZWdpb25hbEVuZHBvaW50LCBwcmVwZW5kTGlzdGVuZXIpO1xuXG4gICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLFxuICAgICAgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfUkVHSU9OKTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdidWlsZCcsIHRoaXMuYWRkQ29udGVudFR5cGUpO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2J1aWxkJywgdGhpcy5jb21wdXRlQ29udGVudE1kNSk7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcignYnVpbGQnLCB0aGlzLmNvbXB1dGVTc2VDdXN0b21lcktleU1kNSk7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcignYnVpbGQnLCB0aGlzLnBvcHVsYXRlVVJJKTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdhZnRlckJ1aWxkJywgdGhpcy5hZGRFeHBlY3QxMDBDb250aW51ZSk7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcignZXh0cmFjdEVycm9yJywgdGhpcy5leHRyYWN0RXJyb3IpO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2V4dHJhY3REYXRhJywgQVdTLnV0aWwuaG9pc3RQYXlsb2FkTWVtYmVyKTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdleHRyYWN0RGF0YScsIHRoaXMuZXh0cmFjdERhdGEpO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2JlZm9yZVByZXNpZ24nLCB0aGlzLnByZXBhcmVTaWduZWRVcmwpO1xuICAgIGlmICh0aGlzLnNob3VsZERpc2FibGVCb2R5U2lnbmluZyhyZXF1ZXN0KSkgIHtcbiAgICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ2FmdGVyQnVpbGQnLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5DT01QVVRFX1NIQTI1Nik7XG4gICAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdhZnRlckJ1aWxkJywgdGhpcy5kaXNhYmxlQm9keVNpZ25pbmcpO1xuICAgIH1cbiAgICAvL2RlYWwgd2l0aCBBUk5zIHN1cHBsaWVkIHRvIEJ1Y2tldFxuICAgIGlmICh0aGlzLmlzQWNjZXNzUG9pbnRBcHBsaWNhYmxlKHJlcXVlc3QpKSB7XG4gICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCd2YWxpZGF0ZScsIHRoaXMudmFsaWRhdGVCdWNrZXROYW1lKTtcbiAgICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ3ZhbGlkYXRlJywgdGhpcy52YWxpZGF0ZUFjY2Vzc1BvaW50QXJuLCBwcmVwZW5kTGlzdGVuZXIpO1xuICAgICAgcmVxdWVzdC5hZGRMaXN0ZW5lcigndmFsaWRhdGUnLCB0aGlzLnZhbGlkYXRlQXJuUmVnaW9uKTtcbiAgICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ2J1aWxkJywgdGhpcy5wb3B1bGF0ZVVSSSk7XG4gICAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdidWlsZCcsIHRoaXMucG9wdWxhdGVVcmlGcm9tQWNjZXNzUG9pbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvL2xpc3RlbmVycyByZWdhcmRpbmcgcmVnaW9uIGluZmVyZW5jZVxuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ3ZhbGlkYXRlJywgdGhpcy52YWxpZGF0ZUJ1Y2tldEVuZHBvaW50KTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCd2YWxpZGF0ZScsIHRoaXMuY29ycmVjdEJ1Y2tldFJlZ2lvbkZyb21DYWNoZSk7XG4gICAgcmVxdWVzdC5vbkFzeW5jKCdleHRyYWN0RXJyb3InLCB0aGlzLnJlcXVlc3RCdWNrZXRSZWdpb24pO1xuICAgIGlmIChBV1MudXRpbC5pc0Jyb3dzZXIoKSkge1xuICAgICAgcmVxdWVzdC5vbkFzeW5jKCdyZXRyeScsIHRoaXMucmVxUmVnaW9uRm9yTmV0d29ya2luZ0Vycm9yKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdmFsaWRhdGVTY2hlbWU6IGZ1bmN0aW9uKHJlcSkge1xuICAgIHZhciBwYXJhbXMgPSByZXEucGFyYW1zLFxuICAgICAgICBzY2hlbWUgPSByZXEuaHR0cFJlcXVlc3QuZW5kcG9pbnQucHJvdG9jb2wsXG4gICAgICAgIHNlbnNpdGl2ZSA9IHBhcmFtcy5TU0VDdXN0b21lcktleSB8fCBwYXJhbXMuQ29weVNvdXJjZVNTRUN1c3RvbWVyS2V5O1xuICAgIGlmIChzZW5zaXRpdmUgJiYgc2NoZW1lICE9PSAnaHR0cHM6Jykge1xuICAgICAgdmFyIG1zZyA9ICdDYW5ub3Qgc2VuZCBTU0Uga2V5cyBvdmVyIEhUVFAuIFNldCBcXCdzc2xFbmFibGVkXFwnJyArXG4gICAgICAgICd0byBcXCd0cnVlXFwnIGluIHlvdXIgY29uZmlndXJhdGlvbic7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgeyBjb2RlOiAnQ29uZmlnRXJyb3InLCBtZXNzYWdlOiBtc2cgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHZhbGlkYXRlQnVja2V0RW5kcG9pbnQ6IGZ1bmN0aW9uKHJlcSkge1xuICAgIGlmICghcmVxLnBhcmFtcy5CdWNrZXQgJiYgcmVxLnNlcnZpY2UuY29uZmlnLnMzQnVja2V0RW5kcG9pbnQpIHtcbiAgICAgIHZhciBtc2cgPSAnQ2Fubm90IHNlbmQgcmVxdWVzdHMgdG8gcm9vdCBBUEkgd2l0aCBgczNCdWNrZXRFbmRwb2ludGAgc2V0Lic7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgeyBjb2RlOiAnQ29uZmlnRXJyb3InLCBtZXNzYWdlOiBtc2cgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGlzQWNjZXNzUG9pbnRBcHBsaWNhYmxlOiBmdW5jdGlvbiBoYXNCdWNrZXRJblBhcmFtcyhyZXEpIHtcbiAgICB2YXIgaW5wdXRTaGFwZSA9IChyZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXSB8fCB7fSkuaW5wdXQgfHwge307XG4gICAgdmFyIGlucHV0TWVtYmVycyA9IGlucHV0U2hhcGUubWVtYmVycyB8fCB7fTtcbiAgICBpZiAoXG4gICAgICByZXEub3BlcmF0aW9uID09PSAnY3JlYXRlQnVja2V0JyB8fFxuICAgICAgIXJlcS5wYXJhbXMuQnVja2V0IHx8XG4gICAgICAhaW5wdXRNZW1iZXJzLkJ1Y2tldFxuICAgICkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghQVdTLnV0aWwuQVJOLnZhbGlkYXRlKHJlcS5wYXJhbXMuQnVja2V0KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBBUk4gc3VwcGxpZWQgaW4gQnVja2V0IHBhcmFtZXRlciBpcyBhIHZhbGlkIGFjY2VzcyBwb2ludCBBUk5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB2YWxpZGF0ZUFjY2Vzc1BvaW50QXJuOiBmdW5jdGlvbiB2YWxpZGF0ZUFjY2Vzc1BvaW50QXJuKHJlcSkge1xuICAgIHZhciBwYXJzZWRBcm4gPSBBV1MudXRpbC5BUk4ucGFyc2UocmVxLnBhcmFtcy5CdWNrZXQpO1xuICAgIC8vYXZvaWQgZHVwbGljYXRlZCBwYXJzaW5nIGluIHRoZSBmdXR1cmVcbiAgICByZXEuX3BhcnNlZEFjY2Vzc1BvaW50QXJuID0gcGFyc2VkQXJuO1xuICAgIHZhciBwYXJzZWRBcm4gPSByZXEuX3BhcnNlZEFjY2Vzc1BvaW50QXJuO1xuICAgIGlmIChwYXJzZWRBcm4uc2VydmljZSAhPT0gJ3MzJykge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWRBY2Nlc3NQb2ludEFSTicsXG4gICAgICAgIG1lc3NhZ2U6ICdleHBlY3QgXFwnczNcXCcgaW4gYWNjZXNzIHBvaW50IEFSTiBzZXJ2aWNlIGNvbXBvbmVudCdcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIXBhcnNlZEFybi5yZWdpb24pIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkQWNjZXNzUG9pbnRBUk4nLFxuICAgICAgICBtZXNzYWdlOiAnQWNjZXNzIHBvaW50IEFSTiByZWdpb24gaXMgZW1wdHknXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgcGFyc2VkQXJuLnJlc291cmNlLmluZGV4T2YoJ2FjY2Vzc3BvaW50OicpICE9PSAwICYmXG4gICAgICBwYXJzZWRBcm4ucmVzb3VyY2UuaW5kZXhPZignYWNjZXNzcG9pbnQvJykgIT09IDBcbiAgICApIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkQWNjZXNzUG9pbnRBUk4nLFxuICAgICAgICBtZXNzYWdlOiAnQWNjZXNzIHBvaW50IEFSTiByZXNvdXJjZSBzaG91bGQgYmVnaW4gd2l0aCBcXCdhY2Nlc3Nwb2ludC9cXCcnXG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGRlbGltaXRlciA9IHBhcnNlZEFybi5yZXNvdXJjZVsnYWNjZXNzcG9pbnQnLmxlbmd0aF07IC8vY2FuIGJlICc6JyBvciAnLydcbiAgICBpZiAocGFyc2VkQXJuLnJlc291cmNlLnNwbGl0KGRlbGltaXRlcikubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnSW52YWxpZEFjY2Vzc1BvaW50QVJOJyxcbiAgICAgICAgbWVzc2FnZTogJ1RvbyBtYW55IHJlc291cmNlIHBhcmFtZXRlcnMgaW4gYWNjZXNzIHBvaW50IEFSTidcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgYWNjZXNzUG9pbnQgPSBwYXJzZWRBcm4ucmVzb3VyY2Uuc3BsaXQoZGVsaW1pdGVyKVsxXTtcbiAgICB2YXIgYWNjZXNzUG9pbnRQcmVmaXggPSBhY2Nlc3NQb2ludCArICctJyArIHBhcnNlZEFybi5hY2NvdW50SWQ7XG4gICAgaWYgKCFyZXEuc2VydmljZS5pc0Ruc0NvbXBhdGlibGUoYWNjZXNzUG9pbnRQcmVmaXgpIHx8IGFjY2Vzc1BvaW50UHJlZml4Lm1hdGNoKC9cXC4vKSkge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWRBY2Nlc3NQb2ludEFSTicsXG4gICAgICAgIG1lc3NhZ2U6ICdBY2Nlc3MgcG9pbnQgQVJOIGlzIG5vdCBETlMgY29tcGF0aWJsZS4gR290ICcgKyBhY2Nlc3NQb2ludFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vc2V0IHBhcnNlZCB2YWxpZCBhY2Nlc3MgcG9pbnRcbiAgICByZXEuX3BhcnNlZEFjY2Vzc1BvaW50QXJuLmFjY2Vzc1BvaW50ID0gYWNjZXNzUG9pbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdmFsaWRhdGVBcm5SZWdpb246IGZ1bmN0aW9uIHZhbGlkYXRlQXJuUmVnaW9uKHJlcSkge1xuICAgIHZhciB1c2VBcm5SZWdpb24gPSByZXEuc2VydmljZS5sb2FkVXNlQXJuUmVnaW9uQ29uZmlnKHJlcSk7XG4gICAgdmFyIHJlZ2lvbkZyb21Bcm4gPSByZXEuX3BhcnNlZEFjY2Vzc1BvaW50QXJuLnJlZ2lvbjtcbiAgICB2YXIgY2xpZW50UmVnaW9uID0gcmVxLnNlcnZpY2UuY29uZmlnLnJlZ2lvbjtcbiAgICBpZiAoXG4gICAgICBjbGllbnRSZWdpb24uaW5kZXhPZignZmlwcycpID49IDAgfHxcbiAgICAgIHJlZ2lvbkZyb21Bcm4uaW5kZXhPZignZmlwcycpID49IDBcbiAgICApIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkQ29uZmlndXJhdGlvbicsXG4gICAgICAgIG1lc3NhZ2U6ICdBY2Nlc3MgcG9pbnQgZW5kcG9pbnQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBGSVBTIHJlZ2lvbidcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIXVzZUFyblJlZ2lvbiAmJiByZWdpb25Gcm9tQXJuICE9PSBjbGllbnRSZWdpb24pIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkQ29uZmlndXJhdGlvbicsXG4gICAgICAgIG1lc3NhZ2U6ICdDb25maWd1cmVkIHJlZ2lvbiBjb25mbGljdHMgd2l0aCBhY2Nlc3MgcG9pbnQgcmVnaW9uJ1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHVzZUFyblJlZ2lvbiAmJlxuICAgICAgcmVnaW9uVXRpbC5nZXRFbmRwb2ludFN1ZmZpeChyZWdpb25Gcm9tQXJuKSAhPT0gcmVnaW9uVXRpbC5nZXRFbmRwb2ludFN1ZmZpeChjbGllbnRSZWdpb24pXG4gICAgKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnSW52YWxpZENvbmZpZ3VyYXRpb24nLFxuICAgICAgICBtZXNzYWdlOiAnQ29uZmlndXJlZCByZWdpb24gYW5kIGFjY2VzcyBwb2ludCByZWdpb24gbm90IGluIHNhbWUgcGFydGl0aW9uJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChyZXEuc2VydmljZS5jb25maWcudXNlQWNjZWxlcmF0ZUVuZHBvaW50KSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnSW52YWxpZENvbmZpZ3VyYXRpb24nLFxuICAgICAgICBtZXNzYWdlOiAndXNlQWNjZWxlcmF0ZUVuZHBvaW50IGNvbmZpZyBpcyBub3Qgc3VwcG9ydGVkIHdpdGggYWNjZXNzIHBvaW50IEFSTidcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkVXNlQXJuUmVnaW9uQ29uZmlnOiBmdW5jdGlvbiBsb2FkVXNlQXJuUmVnaW9uQ29uZmlnKHJlcSkge1xuICAgIHZhciBlbnZOYW1lID0gJ0FXU19TM19VU0VfQVJOX1JFR0lPTic7XG4gICAgdmFyIGNvbmZpZ05hbWUgPSAnczNfdXNlX2Fybl9yZWdpb24nO1xuICAgIHZhciB1c2VBcm5SZWdpb24gPSB0cnVlO1xuICAgIHZhciBvcmlnaW5hbENvbmZpZyA9IHJlcS5zZXJ2aWNlLl9vcmlnaW5hbENvbmZpZyB8fCB7fTtcbiAgICBpZiAocmVxLnNlcnZpY2UuY29uZmlnLnMzVXNlQXJuUmVnaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZXEuc2VydmljZS5jb25maWcuczNVc2VBcm5SZWdpb247XG4gICAgfSBlbHNlIGlmIChvcmlnaW5hbENvbmZpZy5zM1VzZUFyblJlZ2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1c2VBcm5SZWdpb24gPSBvcmlnaW5hbENvbmZpZy5zM1VzZUFyblJlZ2lvbiA9PT0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKEFXUy51dGlsLmlzTm9kZSgpKSB7XG4gICAgICAvL2xvYWQgZnJvbSBlbnZpcm9ubWVudGFsIHZhcmlhYmxlIEFXU19VU0VfQVJOX1JFR0lPTlxuICAgICAgaWYgKHByb2Nlc3MuZW52W2Vudk5hbWVdKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHByb2Nlc3MuZW52W2Vudk5hbWVdLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoWydmYWxzZScsICd0cnVlJ10uaW5kZXhPZih2YWx1ZSkgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgICAgIGNvZGU6ICdJbnZhbGlkQ29uZmlndXJhdGlvbicsXG4gICAgICAgICAgICBtZXNzYWdlOiBlbnZOYW1lICsgJyBvbmx5IGFjY2VwdHMgdHJ1ZSBvciBmYWxzZS4gR290ICcgKyBwcm9jZXNzLmVudltlbnZOYW1lXSxcbiAgICAgICAgICAgIHJldHJ5YWJsZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB1c2VBcm5SZWdpb24gPSB2YWx1ZSA9PT0gJ3RydWUnO1xuICAgICAgfSBlbHNlIHsgIC8vbG9hZCBmcm9tIHNoYXJlZCBjb25maWcgcHJvcGVydHkgdXNlX2Fybl9yZWdpb25cbiAgICAgICAgdmFyIHByb2ZpbGVzID0ge307XG4gICAgICAgIHZhciBwcm9maWxlID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcHJvZmlsZXMgPSBBV1MudXRpbC5nZXRQcm9maWxlc0Zyb21TaGFyZWRDb25maWcoQVdTLnV0aWwuaW5pTG9hZGVyKTtcbiAgICAgICAgICBwcm9maWxlID0gcHJvZmlsZXNbcHJvY2Vzcy5lbnYuQVdTX1BST0ZJTEUgfHwgQVdTLnV0aWwuZGVmYXVsdFByb2ZpbGVdO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICBpZiAocHJvZmlsZVtjb25maWdOYW1lXSkge1xuICAgICAgICAgIGlmIChbJ2ZhbHNlJywgJ3RydWUnXS5pbmRleE9mKHByb2ZpbGVbY29uZmlnTmFtZV0udHJpbSgpLnRvTG93ZXJDYXNlKCkpIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgICAgICAgY29kZTogJ0ludmFsaWRDb25maWd1cmF0aW9uJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogY29uZmlnTmFtZSArICcgb25seSBhY2NlcHRzIHRydWUgb3IgZmFsc2UuIEdvdCAnICsgcHJvZmlsZVtjb25maWdOYW1lXSxcbiAgICAgICAgICAgICAgcmV0cnlhYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVzZUFyblJlZ2lvbiA9IHByb2ZpbGVbY29uZmlnTmFtZV0udHJpbSgpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXEuc2VydmljZS5jb25maWcuczNVc2VBcm5SZWdpb24gPSB1c2VBcm5SZWdpb247XG4gICAgcmV0dXJuIHVzZUFyblJlZ2lvbjtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB2YWxpZGF0ZUJ1Y2tldE5hbWU6IGZ1bmN0aW9uIHZhbGlkYXRlQnVja2V0TmFtZShyZXEpIHtcbiAgICB2YXIgc2VydmljZSA9IHJlcS5zZXJ2aWNlO1xuICAgIHZhciBzaWduYXR1cmVWZXJzaW9uID0gc2VydmljZS5nZXRTaWduYXR1cmVWZXJzaW9uKHJlcSk7XG4gICAgdmFyIGJ1Y2tldCA9IHJlcS5wYXJhbXMgJiYgcmVxLnBhcmFtcy5CdWNrZXQ7XG4gICAgdmFyIGtleSA9IHJlcS5wYXJhbXMgJiYgcmVxLnBhcmFtcy5LZXk7XG4gICAgdmFyIHNsYXNoSW5kZXggPSBidWNrZXQgJiYgYnVja2V0LmluZGV4T2YoJy8nKTtcbiAgICBpZiAoYnVja2V0ICYmIHNsYXNoSW5kZXggPj0gMCkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIHNsYXNoSW5kZXggPiAwKSB7XG4gICAgICAgIHJlcS5wYXJhbXMgPSBBV1MudXRpbC5jb3B5KHJlcS5wYXJhbXMpO1xuICAgICAgICAvLyBOZWVkIHRvIGluY2x1ZGUgdHJhaWxpbmcgc2xhc2ggdG8gbWF0Y2ggc2lndjIgYmVoYXZpb3JcbiAgICAgICAgdmFyIHByZWZpeCA9IGJ1Y2tldC5zdWJzdHIoc2xhc2hJbmRleCArIDEpIHx8ICcnO1xuICAgICAgICByZXEucGFyYW1zLktleSA9IHByZWZpeCArICcvJyArIGtleTtcbiAgICAgICAgcmVxLnBhcmFtcy5CdWNrZXQgPSBidWNrZXQuc3Vic3RyKDAsIHNsYXNoSW5kZXgpO1xuICAgICAgfSBlbHNlIGlmIChzaWduYXR1cmVWZXJzaW9uID09PSAndjQnKSB7XG4gICAgICAgIHZhciBtc2cgPSAnQnVja2V0IG5hbWVzIGNhbm5vdCBjb250YWluIGZvcndhcmQgc2xhc2hlcy4gQnVja2V0OiAnICsgYnVja2V0O1xuICAgICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgICB7IGNvZGU6ICdJbnZhbGlkQnVja2V0JywgbWVzc2FnZTogbXNnIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpc1ZhbGlkQWNjZWxlcmF0ZU9wZXJhdGlvbjogZnVuY3Rpb24gaXNWYWxpZEFjY2VsZXJhdGVPcGVyYXRpb24ob3BlcmF0aW9uKSB7XG4gICAgdmFyIGludmFsaWRPcGVyYXRpb25zID0gW1xuICAgICAgJ2NyZWF0ZUJ1Y2tldCcsXG4gICAgICAnZGVsZXRlQnVja2V0JyxcbiAgICAgICdsaXN0QnVja2V0cydcbiAgICBdO1xuICAgIHJldHVybiBpbnZhbGlkT3BlcmF0aW9ucy5pbmRleE9mKG9wZXJhdGlvbikgPT09IC0xO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaGVuIHVzLWVhc3QtMSByZWdpb24gZW5kcG9pbnQgY29uZmlndXJhdGlvbiBpcyBzZXQsIGluIHN0ZWFkIG9mIHNlbmRpbmcgcmVxdWVzdCB0b1xuICAgKiBnbG9iYWwgZW5kcG9pbnQoZS5nLiAnczMuYW1hem9uYXdzLmNvbScpLCB3ZSB3aWxsIHNlbmQgcmVxdWVzdCB0b1xuICAgKiAnczMudXMtZWFzdC0xLmFtYXpvbmF3cy5jb20nLlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG9wdEluVXNFYXN0MVJlZ2lvbmFsRW5kcG9pbnQ6IGZ1bmN0aW9uIG9wdEluVXNFYXN0MVJlZ2lvbmFsRW5kcG9pbnQocmVxKSB7XG4gICAgdmFyIHNlcnZpY2UgPSByZXEuc2VydmljZTtcbiAgICB2YXIgY29uZmlnID0gc2VydmljZS5jb25maWc7XG4gICAgY29uZmlnLnMzVXNFYXN0MVJlZ2lvbmFsRW5kcG9pbnQgPSByZXNvbHZlUmVnaW9uYWxFbmRwb2ludHNGbGFnKHNlcnZpY2UuX29yaWdpbmFsQ29uZmlnLCB7XG4gICAgICBlbnY6ICdBV1NfUzNfVVNfRUFTVF8xX1JFR0lPTkFMX0VORFBPSU5UJyxcbiAgICAgIHNoYXJlZENvbmZpZzogJ3MzX3VzX2Vhc3RfMV9yZWdpb25hbF9lbmRwb2ludCcsXG4gICAgICBjbGllbnRDb25maWc6ICdzM1VzRWFzdDFSZWdpb25hbEVuZHBvaW50J1xuICAgIH0pO1xuICAgIGlmIChcbiAgICAgICEoc2VydmljZS5fb3JpZ2luYWxDb25maWcgfHwge30pLmVuZHBvaW50ICYmXG4gICAgICByZXEuaHR0cFJlcXVlc3QucmVnaW9uID09PSAndXMtZWFzdC0xJyAmJlxuICAgICAgY29uZmlnLnMzVXNFYXN0MVJlZ2lvbmFsRW5kcG9pbnQgPT09ICdyZWdpb25hbCcgJiZcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5lbmRwb2ludC5ob3N0bmFtZS5pbmRleE9mKCdzMy5hbWF6b25hd3MuY29tJykgPj0gMFxuICAgICkge1xuICAgICAgdmFyIGluc2VydFBvaW50ID0gY29uZmlnLmVuZHBvaW50LmluZGV4T2YoJy5hbWF6b25hd3MuY29tJyk7XG4gICAgICByZWdpb25hbEVuZHBvaW50ID0gY29uZmlnLmVuZHBvaW50LnN1YnN0cmluZygwLCBpbnNlcnRQb2ludCkgK1xuICAgICAgICAnLnVzLWVhc3QtMScgKyBjb25maWcuZW5kcG9pbnQuc3Vic3RyaW5nKGluc2VydFBvaW50KTtcbiAgICAgIHJlcS5odHRwUmVxdWVzdC51cGRhdGVFbmRwb2ludChyZWdpb25hbEVuZHBvaW50KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFMzIHByZWZlcnMgZG5zLWNvbXBhdGlibGUgYnVja2V0IG5hbWVzIHRvIGJlIG1vdmVkIGZyb20gdGhlIHVyaSBwYXRoXG4gICAqIHRvIHRoZSBob3N0bmFtZSBhcyBhIHN1Yi1kb21haW4uICBUaGlzIGlzIG5vdCBwb3NzaWJsZSwgZXZlbiBmb3IgZG5zLWNvbXBhdFxuICAgKiBidWNrZXRzIHdoZW4gdXNpbmcgU1NMIGFuZCB0aGUgYnVja2V0IG5hbWUgY29udGFpbnMgYSBkb3QgKCcuJykuICBUaGVcbiAgICogc3NsIHdpbGRjYXJkIGNlcnRpZmljYXRlIGlzIG9ubHkgMS1sZXZlbCBkZWVwLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHBvcHVsYXRlVVJJOiBmdW5jdGlvbiBwb3B1bGF0ZVVSSShyZXEpIHtcbiAgICB2YXIgaHR0cFJlcXVlc3QgPSByZXEuaHR0cFJlcXVlc3Q7XG4gICAgdmFyIGIgPSByZXEucGFyYW1zLkJ1Y2tldDtcbiAgICB2YXIgc2VydmljZSA9IHJlcS5zZXJ2aWNlO1xuICAgIHZhciBlbmRwb2ludCA9IGh0dHBSZXF1ZXN0LmVuZHBvaW50O1xuICAgIGlmIChiKSB7XG4gICAgICBpZiAoIXNlcnZpY2UucGF0aFN0eWxlQnVja2V0TmFtZShiKSkge1xuICAgICAgICBpZiAoc2VydmljZS5jb25maWcudXNlQWNjZWxlcmF0ZUVuZHBvaW50ICYmIHNlcnZpY2UuaXNWYWxpZEFjY2VsZXJhdGVPcGVyYXRpb24ocmVxLm9wZXJhdGlvbikpIHtcbiAgICAgICAgICBpZiAoc2VydmljZS5jb25maWcudXNlRHVhbHN0YWNrKSB7XG4gICAgICAgICAgICBlbmRwb2ludC5ob3N0bmFtZSA9IGIgKyAnLnMzLWFjY2VsZXJhdGUuZHVhbHN0YWNrLmFtYXpvbmF3cy5jb20nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmRwb2ludC5ob3N0bmFtZSA9IGIgKyAnLnMzLWFjY2VsZXJhdGUuYW1hem9uYXdzLmNvbSc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFzZXJ2aWNlLmNvbmZpZy5zM0J1Y2tldEVuZHBvaW50KSB7XG4gICAgICAgICAgZW5kcG9pbnQuaG9zdG5hbWUgPVxuICAgICAgICAgICAgYiArICcuJyArIGVuZHBvaW50Lmhvc3RuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvcnQgPSBlbmRwb2ludC5wb3J0O1xuICAgICAgICBpZiAocG9ydCAhPT0gODAgJiYgcG9ydCAhPT0gNDQzKSB7XG4gICAgICAgICAgZW5kcG9pbnQuaG9zdCA9IGVuZHBvaW50Lmhvc3RuYW1lICsgJzonICtcbiAgICAgICAgICAgIGVuZHBvaW50LnBvcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kcG9pbnQuaG9zdCA9IGVuZHBvaW50Lmhvc3RuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaHR0cFJlcXVlc3QudmlydHVhbEhvc3RlZEJ1Y2tldCA9IGI7IC8vIG5lZWRlZCBmb3Igc2lnbmluZyB0aGUgcmVxdWVzdFxuICAgICAgICBzZXJ2aWNlLnJlbW92ZVZpcnR1YWxIb3N0ZWRCdWNrZXRGcm9tUGF0aChyZXEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVGFrZXMgdGhlIGJ1Y2tldCBuYW1lIG91dCBvZiB0aGUgcGF0aCBpZiBidWNrZXQgaXMgdmlydHVhbC1ob3N0ZWRcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICByZW1vdmVWaXJ0dWFsSG9zdGVkQnVja2V0RnJvbVBhdGg6IGZ1bmN0aW9uIHJlbW92ZVZpcnR1YWxIb3N0ZWRCdWNrZXRGcm9tUGF0aChyZXEpIHtcbiAgICB2YXIgaHR0cFJlcXVlc3QgPSByZXEuaHR0cFJlcXVlc3Q7XG4gICAgdmFyIGJ1Y2tldCA9IGh0dHBSZXF1ZXN0LnZpcnR1YWxIb3N0ZWRCdWNrZXQ7XG4gICAgaWYgKGJ1Y2tldCAmJiBodHRwUmVxdWVzdC5wYXRoKSB7XG4gICAgICBpZiAocmVxLnBhcmFtcyAmJiByZXEucGFyYW1zLktleSkge1xuICAgICAgICB2YXIgZW5jb2RlZFMzS2V5ID0gJy8nICsgQVdTLnV0aWwudXJpRXNjYXBlUGF0aChyZXEucGFyYW1zLktleSk7XG4gICAgICAgIGlmIChodHRwUmVxdWVzdC5wYXRoLmluZGV4T2YoZW5jb2RlZFMzS2V5KSA9PT0gMCAmJiAoaHR0cFJlcXVlc3QucGF0aC5sZW5ndGggPT09IGVuY29kZWRTM0tleS5sZW5ndGggfHwgaHR0cFJlcXVlc3QucGF0aFtlbmNvZGVkUzNLZXkubGVuZ3RoXSA9PT0gJz8nKSkge1xuICAgICAgICAgIC8vcGF0aCBvbmx5IGNvbnRhaW5zIGtleSBvciBwYXRoIGNvbnRhaW5zIG9ubHkga2V5IGFuZCBxdWVyeXN0cmluZ1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaHR0cFJlcXVlc3QucGF0aCA9IGh0dHBSZXF1ZXN0LnBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCcvJyArIGJ1Y2tldCksICcnKTtcbiAgICAgIGlmIChodHRwUmVxdWVzdC5wYXRoWzBdICE9PSAnLycpIHtcbiAgICAgICAgaHR0cFJlcXVlc3QucGF0aCA9ICcvJyArIGh0dHBSZXF1ZXN0LnBhdGg7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBXaGVuIHVzZXIgc3VwcGx5IGFuIGFjY2VzcyBwb2ludCBBUk4gaW4gdGhlIEJ1Y2tldCBwYXJhbWV0ZXIsIHdlIG5lZWQgdG9cbiAgICogcG9wdWxhdGUgdGhlIFVSSSBhY2NvcmRpbmcgdG8gdGhlIEFSTi5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwb3B1bGF0ZVVyaUZyb21BY2Nlc3NQb2ludDogZnVuY3Rpb24gcG9wdWxhdGVVcmlGcm9tQWNjZXNzUG9pbnQocmVxKSB7XG4gICAgaWYgKHJlcS5zZXJ2aWNlLl9vcmlnaW5hbENvbmZpZy5lbmRwb2ludCkge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWRDb25maWd1cmF0aW9uJyxcbiAgICAgICAgbWVzc2FnZTogJ0N1c3RvbSBlbmRwb2ludCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGFjY2VzcyBwb2ludCBBUk4nXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHJlcS5zZXJ2aWNlLmNvbmZpZy5zM0ZvcmNlUGF0aFN0eWxlKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnSW52YWxpZENvbmZpZ3VyYXRpb24nLFxuICAgICAgICBtZXNzYWdlOiAnQ2Fubm90IGNvbnN0cnVjdCBwYXRoLXN0eWxlIGVuZHBvaW50IHdpdGggYWNjZXNzIHBvaW50J1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBhY2Nlc3NQb2ludEFybiA9IHJlcS5fcGFyc2VkQWNjZXNzUG9pbnRBcm47XG4gICAgdmFyIHNlcnZpY2VOYW1lID0gcmVxLnNlcnZpY2UuY29uZmlnLnVzZUR1YWxzdGFjayA/XG4gICAgICAnczMtYWNjZXNzcG9pbnQuZHVhbHN0YWNrJzpcbiAgICAgICdzMy1hY2Nlc3Nwb2ludCc7XG4gICAgdmFyIGVuZHBvaW50ID0gcmVxLmh0dHBSZXF1ZXN0LmVuZHBvaW50O1xuICAgIHZhciBkbnNTdWZmaXggPSByZWdpb25VdGlsLmdldEVuZHBvaW50U3VmZml4KGFjY2Vzc1BvaW50QXJuLnJlZ2lvbik7XG4gICAgdmFyIHVzZUFyblJlZ2lvbiA9IHJlcS5zZXJ2aWNlLmNvbmZpZy5zM1VzZUFyblJlZ2lvbjtcbiAgICBlbmRwb2ludC5ob3N0bmFtZSA9IFtcbiAgICAgIGFjY2Vzc1BvaW50QXJuLmFjY2Vzc1BvaW50ICsgJy0nICsgYWNjZXNzUG9pbnRBcm4uYWNjb3VudElkLFxuICAgICAgc2VydmljZU5hbWUsXG4gICAgICB1c2VBcm5SZWdpb24gPyBhY2Nlc3NQb2ludEFybi5yZWdpb24gOiByZXEuc2VydmljZS5jb25maWcucmVnaW9uLFxuICAgICAgZG5zU3VmZml4XG4gICAgXS5qb2luKCcuJyk7XG4gICAgZW5kcG9pbnQuaG9zdCA9IGVuZHBvaW50Lmhvc3RuYW1lO1xuICAgIHZhciBlbmNvZGVkQXJuID0gQVdTLnV0aWwudXJpRXNjYXBlKHJlcS5wYXJhbXMuQnVja2V0KTtcbiAgICB2YXIgcGF0aCA9IHJlcS5odHRwUmVxdWVzdC5wYXRoO1xuICAgIC8vcmVtb3ZlIHRoZSBCdWNrZXQgdmFsdWUgZnJvbSBwYXRoXG4gICAgcmVxLmh0dHBSZXF1ZXN0LnBhdGggPSBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgnLycgKyBlbmNvZGVkQXJuKSwgJycpO1xuICAgIGlmIChyZXEuaHR0cFJlcXVlc3QucGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICByZXEuaHR0cFJlcXVlc3QucGF0aCA9ICcvJyArIHJlcS5odHRwUmVxdWVzdC5wYXRoO1xuICAgIH1cbiAgICByZXEuaHR0cFJlcXVlc3QucmVnaW9uID0gYWNjZXNzUG9pbnRBcm4ucmVnaW9uOyAvL3JlZ2lvbiB1c2VkIHRvIHNpZ25cbiAgfSxcblxuICAvKipcbiAgICogQWRkcyBFeHBlY3Q6IDEwMC1jb250aW51ZSBoZWFkZXIgaWYgcGF5bG9hZCBpcyBncmVhdGVyLW9yLWVxdWFsIDFNQlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkZEV4cGVjdDEwMENvbnRpbnVlOiBmdW5jdGlvbiBhZGRFeHBlY3QxMDBDb250aW51ZShyZXEpIHtcbiAgICB2YXIgbGVuID0gcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ107XG4gICAgaWYgKEFXUy51dGlsLmlzTm9kZSgpICYmIChsZW4gPj0gMTAyNCAqIDEwMjQgfHwgcmVxLnBhcmFtcy5Cb2R5IGluc3RhbmNlb2YgQVdTLnV0aWwuc3RyZWFtLlN0cmVhbSkpIHtcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydFeHBlY3QnXSA9ICcxMDAtY29udGludWUnO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWRkcyBhIGRlZmF1bHQgY29udGVudCB0eXBlIGlmIG5vbmUgaXMgc3VwcGxpZWQuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYWRkQ29udGVudFR5cGU6IGZ1bmN0aW9uIGFkZENvbnRlbnRUeXBlKHJlcSkge1xuICAgIHZhciBodHRwUmVxdWVzdCA9IHJlcS5odHRwUmVxdWVzdDtcbiAgICBpZiAoaHR0cFJlcXVlc3QubWV0aG9kID09PSAnR0VUJyB8fCBodHRwUmVxdWVzdC5tZXRob2QgPT09ICdIRUFEJykge1xuICAgICAgLy8gQ29udGVudC1UeXBlIGlzIG5vdCBzZXQgaW4gR0VUL0hFQUQgcmVxdWVzdHNcbiAgICAgIGRlbGV0ZSBodHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSB7IC8vIGFsd2F5cyBoYXZlIGEgQ29udGVudC1UeXBlXG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgIH1cblxuICAgIHZhciBjb250ZW50VHlwZSA9IGh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddO1xuICAgIGlmIChBV1MudXRpbC5pc0Jyb3dzZXIoKSkge1xuICAgICAgaWYgKHR5cGVvZiBodHRwUmVxdWVzdC5ib2R5ID09PSAnc3RyaW5nJyAmJiAhY29udGVudFR5cGUubWF0Y2goLztcXHMqY2hhcnNldD0vKSkge1xuICAgICAgICB2YXIgY2hhcnNldCA9ICc7IGNoYXJzZXQ9VVRGLTgnO1xuICAgICAgICBodHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSArPSBjaGFyc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlcGxhY2VGbiA9IGZ1bmN0aW9uKF8sIHByZWZpeCwgY2hhcnNldE5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICsgY2hhcnNldE5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBodHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9XG4gICAgICAgICAgY29udGVudFR5cGUucmVwbGFjZSgvKDtcXHMqY2hhcnNldD0pKC4rKSQvLCByZXBsYWNlRm4pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb21wdXRhYmxlQ2hlY2tzdW1PcGVyYXRpb25zOiB7XG4gICAgcHV0QnVja2V0Q29yczogdHJ1ZSxcbiAgICBwdXRCdWNrZXRMaWZlY3ljbGU6IHRydWUsXG4gICAgcHV0QnVja2V0TGlmZWN5Y2xlQ29uZmlndXJhdGlvbjogdHJ1ZSxcbiAgICBwdXRCdWNrZXRUYWdnaW5nOiB0cnVlLFxuICAgIGRlbGV0ZU9iamVjdHM6IHRydWUsXG4gICAgcHV0QnVja2V0UmVwbGljYXRpb246IHRydWUsXG4gICAgcHV0T2JqZWN0TGVnYWxIb2xkOiB0cnVlLFxuICAgIHB1dE9iamVjdFJldGVudGlvbjogdHJ1ZSxcbiAgICBwdXRPYmplY3RMb2NrQ29uZmlndXJhdGlvbjogdHJ1ZVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBjaGVja3N1bXMgc2hvdWxkIGJlIGNvbXB1dGVkIGZvciB0aGUgcmVxdWVzdC5cbiAgICogSWYgdGhlIHJlcXVlc3QgcmVxdWlyZXMgY2hlY2tzdW1zIHRvIGJlIGNvbXB1dGVkLCB0aGlzIHdpbGwgYWx3YXlzXG4gICAqIHJldHVybiB0cnVlLCBvdGhlcndpc2UgaXQgZGVwZW5kcyBvbiB3aGV0aGVyIHtBV1MuQ29uZmlnLmNvbXB1dGVDaGVja3N1bXN9XG4gICAqIGlzIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHJlcSBbQVdTLlJlcXVlc3RdIHRoZSByZXF1ZXN0IHRvIGNoZWNrIGFnYWluc3RcbiAgICogQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0byBjb21wdXRlIGNoZWNrc3VtcyBmb3IgYSByZXF1ZXN0LlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHdpbGxDb21wdXRlQ2hlY2tzdW1zOiBmdW5jdGlvbiB3aWxsQ29tcHV0ZUNoZWNrc3VtcyhyZXEpIHtcbiAgICBpZiAodGhpcy5jb21wdXRhYmxlQ2hlY2tzdW1PcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmNvbXB1dGVDaGVja3N1bXMpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIFRPRE86IGNvbXB1dGUgY2hlY2tzdW1zIGZvciBTdHJlYW0gb2JqZWN0c1xuICAgIGlmICghQVdTLnV0aWwuQnVmZmVyLmlzQnVmZmVyKHJlcS5odHRwUmVxdWVzdC5ib2R5KSAmJlxuICAgICAgICB0eXBlb2YgcmVxLmh0dHBSZXF1ZXN0LmJvZHkgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHJ1bGVzID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0uaW5wdXQubWVtYmVycztcblxuICAgIC8vIFNoYTI1NiBzaWduaW5nIGRpc2FibGVkLCBhbmQgbm90IGEgcHJlc2lnbmVkIHVybFxuICAgIGlmIChyZXEuc2VydmljZS5zaG91bGREaXNhYmxlQm9keVNpZ25pbmcocmVxKSAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzLCAncHJlc2lnbmVkLWV4cGlyZXMnKSkge1xuICAgICAgaWYgKHJ1bGVzLkNvbnRlbnRNRDUgJiYgIXJlcS5wYXJhbXMuQ29udGVudE1ENSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWNCBzaWduZXIgdXNlcyBTSEEyNTYgc2lnbmF0dXJlcyBzbyBvbmx5IGNvbXB1dGUgTUQ1IGlmIGl0IGlzIHJlcXVpcmVkXG4gICAgaWYgKHJlcS5zZXJ2aWNlLmdldFNpZ25lckNsYXNzKHJlcSkgPT09IEFXUy5TaWduZXJzLlY0KSB7XG4gICAgICBpZiAocnVsZXMuQ29udGVudE1ENSAmJiAhcnVsZXMuQ29udGVudE1ENS5yZXF1aXJlZCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChydWxlcy5Db250ZW50TUQ1ICYmICFyZXEucGFyYW1zLkNvbnRlbnRNRDUpIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBIGxpc3RlbmVyIHRoYXQgY29tcHV0ZXMgdGhlIENvbnRlbnQtTUQ1IGFuZCBzZXRzIGl0IGluIHRoZSBoZWFkZXIuXG4gICAqIEBzZWUgQVdTLlMzLndpbGxDb21wdXRlQ2hlY2tzdW1zXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29tcHV0ZUNvbnRlbnRNZDU6IGZ1bmN0aW9uIGNvbXB1dGVDb250ZW50TWQ1KHJlcSkge1xuICAgIGlmIChyZXEuc2VydmljZS53aWxsQ29tcHV0ZUNoZWNrc3VtcyhyZXEpKSB7XG4gICAgICB2YXIgbWQ1ID0gQVdTLnV0aWwuY3J5cHRvLm1kNShyZXEuaHR0cFJlcXVlc3QuYm9keSwgJ2Jhc2U2NCcpO1xuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtTUQ1J10gPSBtZDU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbXB1dGVTc2VDdXN0b21lcktleU1kNTogZnVuY3Rpb24gY29tcHV0ZVNzZUN1c3RvbWVyS2V5TWQ1KHJlcSkge1xuICAgIHZhciBrZXlzID0ge1xuICAgICAgU1NFQ3VzdG9tZXJLZXk6ICd4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDUnLFxuICAgICAgQ29weVNvdXJjZVNTRUN1c3RvbWVyS2V5OiAneC1hbXotY29weS1zb3VyY2Utc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1J1xuICAgIH07XG4gICAgQVdTLnV0aWwuZWFjaChrZXlzLCBmdW5jdGlvbihrZXksIGhlYWRlcikge1xuICAgICAgaWYgKHJlcS5wYXJhbXNba2V5XSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBBV1MudXRpbC5jcnlwdG8ubWQ1KHJlcS5wYXJhbXNba2V5XSwgJ2Jhc2U2NCcpO1xuICAgICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1toZWFkZXJdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYnVja2V0IG5hbWUgc2hvdWxkIGJlIGxlZnQgaW4gdGhlIFVSSSBwYXRoIGZvclxuICAgKiBhIHJlcXVlc3QgdG8gUzMuICBUaGlzIGZ1bmN0aW9uIHRha2VzIGludG8gYWNjb3VudCB0aGUgY3VycmVudFxuICAgKiBlbmRwb2ludCBwcm90b2NvbCAoZS5nLiBodHRwIG9yIGh0dHBzKS5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwYXRoU3R5bGVCdWNrZXROYW1lOiBmdW5jdGlvbiBwYXRoU3R5bGVCdWNrZXROYW1lKGJ1Y2tldE5hbWUpIHtcbiAgICAvLyB1c2VyIGNhbiBmb3JjZSBwYXRoIHN0eWxlIHJlcXVlc3RzIHZpYSB0aGUgY29uZmlndXJhdGlvblxuICAgIGlmICh0aGlzLmNvbmZpZy5zM0ZvcmNlUGF0aFN0eWxlKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5jb25maWcuczNCdWNrZXRFbmRwb2ludCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuaXNEbnNDb21wYXRpYmxlKGJ1Y2tldE5hbWUpKSB7XG4gICAgICByZXR1cm4gKHRoaXMuY29uZmlnLnNzbEVuYWJsZWQgJiYgYnVja2V0TmFtZS5tYXRjaCgvXFwuLykpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gbm90IGRucyBjb21wYXRpYmxlIG5hbWVzIG11c3QgYWx3YXlzIHVzZSBwYXRoIHN0eWxlXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGJ1Y2tldCBuYW1lIGlzIEROUyBjb21wYXRpYmxlLiAgQnVja2V0cyBjcmVhdGVkXG4gICAqIG91dHNpZGUgb2YgdGhlIGNsYXNzaWMgcmVnaW9uIE1VU1QgYmUgRE5TIGNvbXBhdGlibGUuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaXNEbnNDb21wYXRpYmxlOiBmdW5jdGlvbiBpc0Ruc0NvbXBhdGlibGUoYnVja2V0TmFtZSkge1xuICAgIHZhciBiID0gYnVja2V0TmFtZTtcbiAgICB2YXIgZG9tYWluID0gbmV3IFJlZ0V4cCgvXlthLXowLTldW2EtejAtOVxcLlxcLV17MSw2MX1bYS16MC05XSQvKTtcbiAgICB2YXIgaXBBZGRyZXNzID0gbmV3IFJlZ0V4cCgvKFxcZCtcXC4pezN9XFxkKy8pO1xuICAgIHZhciBkb3RzID0gbmV3IFJlZ0V4cCgvXFwuXFwuLyk7XG4gICAgcmV0dXJuIChiLm1hdGNoKGRvbWFpbikgJiYgIWIubWF0Y2goaXBBZGRyZXNzKSAmJiAhYi5tYXRjaChkb3RzKSkgPyB0cnVlIDogZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgcmVzcG9uc2UgY29udGFpbnMgYW4gZXJyb3JcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzdWNjZXNzZnVsUmVzcG9uc2U6IGZ1bmN0aW9uIHN1Y2Nlc3NmdWxSZXNwb25zZShyZXNwKSB7XG4gICAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgICB2YXIgaHR0cFJlc3BvbnNlID0gcmVzcC5odHRwUmVzcG9uc2U7XG4gICAgaWYgKG9wZXJhdGlvbnNXaXRoMjAwU3RhdHVzQ29kZUVycm9yW3JlcS5vcGVyYXRpb25dICYmXG4gICAgICAgIGh0dHBSZXNwb25zZS5ib2R5LnRvU3RyaW5nKCkubWF0Y2goJzxFcnJvcj4nKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUgPCAzMDA7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRoZSBlcnJvciBjYW4gYmUgcmV0cmllZFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHJldHJ5YWJsZUVycm9yOiBmdW5jdGlvbiByZXRyeWFibGVFcnJvcihlcnJvciwgcmVxdWVzdCkge1xuICAgIGlmIChvcGVyYXRpb25zV2l0aDIwMFN0YXR1c0NvZGVFcnJvcltyZXF1ZXN0Lm9wZXJhdGlvbl0gJiZcbiAgICAgICAgZXJyb3Iuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QuX3JlcXVlc3RSZWdpb25Gb3JCdWNrZXQgJiZcbiAgICAgICAgcmVxdWVzdC5zZXJ2aWNlLmJ1Y2tldFJlZ2lvbkNhY2hlW3JlcXVlc3QuX3JlcXVlc3RSZWdpb25Gb3JCdWNrZXRdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChlcnJvciAmJiBlcnJvci5jb2RlID09PSAnUmVxdWVzdFRpbWVvdXQnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGVycm9yICYmXG4gICAgICAgIHJlZ2lvblJlZGlyZWN0RXJyb3JDb2Rlcy5pbmRleE9mKGVycm9yLmNvZGUpICE9IC0xICYmXG4gICAgICAgIGVycm9yLnJlZ2lvbiAmJiBlcnJvci5yZWdpb24gIT0gcmVxdWVzdC5odHRwUmVxdWVzdC5yZWdpb24pIHtcbiAgICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QucmVnaW9uID0gZXJyb3IucmVnaW9uO1xuICAgICAgaWYgKGVycm9yLnN0YXR1c0NvZGUgPT09IDMwMSkge1xuICAgICAgICByZXF1ZXN0LnNlcnZpY2UudXBkYXRlUmVxQnVja2V0UmVnaW9uKHJlcXVlc3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfc3VwZXIgPSBBV1MuU2VydmljZS5wcm90b3R5cGUucmV0cnlhYmxlRXJyb3I7XG4gICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZXJyb3IsIHJlcXVlc3QpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyBodHRwUmVxdWVzdCB3aXRoIHJlZ2lvbi4gSWYgcmVnaW9uIGlzIG5vdCBwcm92aWRlZCwgdGhlblxuICAgKiB0aGUgaHR0cFJlcXVlc3Qgd2lsbCBiZSB1cGRhdGVkIGJhc2VkIG9uIGh0dHBSZXF1ZXN0LnJlZ2lvblxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVJlcUJ1Y2tldFJlZ2lvbjogZnVuY3Rpb24gdXBkYXRlUmVxQnVja2V0UmVnaW9uKHJlcXVlc3QsIHJlZ2lvbikge1xuICAgIHZhciBodHRwUmVxdWVzdCA9IHJlcXVlc3QuaHR0cFJlcXVlc3Q7XG4gICAgaWYgKHR5cGVvZiByZWdpb24gPT09ICdzdHJpbmcnICYmIHJlZ2lvbi5sZW5ndGgpIHtcbiAgICAgIGh0dHBSZXF1ZXN0LnJlZ2lvbiA9IHJlZ2lvbjtcbiAgICB9XG4gICAgaWYgKCFodHRwUmVxdWVzdC5lbmRwb2ludC5ob3N0Lm1hdGNoKC9zMyg/IS1hY2NlbGVyYXRlKS4qXFwuYW1hem9uYXdzXFwuY29tJC8pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzZXJ2aWNlID0gcmVxdWVzdC5zZXJ2aWNlO1xuICAgIHZhciBzM0NvbmZpZyA9IHNlcnZpY2UuY29uZmlnO1xuICAgIHZhciBzM0J1Y2tldEVuZHBvaW50ID0gczNDb25maWcuczNCdWNrZXRFbmRwb2ludDtcbiAgICBpZiAoczNCdWNrZXRFbmRwb2ludCkge1xuICAgICAgZGVsZXRlIHMzQ29uZmlnLnMzQnVja2V0RW5kcG9pbnQ7XG4gICAgfVxuICAgIHZhciBuZXdDb25maWcgPSBBV1MudXRpbC5jb3B5KHMzQ29uZmlnKTtcbiAgICBkZWxldGUgbmV3Q29uZmlnLmVuZHBvaW50O1xuICAgIG5ld0NvbmZpZy5yZWdpb24gPSBodHRwUmVxdWVzdC5yZWdpb247XG5cbiAgICBodHRwUmVxdWVzdC5lbmRwb2ludCA9IChuZXcgQVdTLlMzKG5ld0NvbmZpZykpLmVuZHBvaW50O1xuICAgIHNlcnZpY2UucG9wdWxhdGVVUkkocmVxdWVzdCk7XG4gICAgczNDb25maWcuczNCdWNrZXRFbmRwb2ludCA9IHMzQnVja2V0RW5kcG9pbnQ7XG4gICAgaHR0cFJlcXVlc3QuaGVhZGVycy5Ib3N0ID0gaHR0cFJlcXVlc3QuZW5kcG9pbnQuaG9zdDtcblxuICAgIGlmIChyZXF1ZXN0Ll9hc20uY3VycmVudFN0YXRlID09PSAndmFsaWRhdGUnKSB7XG4gICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdidWlsZCcsIHNlcnZpY2UucG9wdWxhdGVVUkkpO1xuICAgICAgcmVxdWVzdC5hZGRMaXN0ZW5lcignYnVpbGQnLCBzZXJ2aWNlLnJlbW92ZVZpcnR1YWxIb3N0ZWRCdWNrZXRGcm9tUGF0aCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIHNwZWNpYWxpemVkIHBhcnNlciBmb3IgZ2V0QnVja2V0TG9jYXRpb24gLS0gYWxsIG90aGVyXG4gICAqIG9wZXJhdGlvbnMgYXJlIHBhcnNlZCBieSB0aGUgc3VwZXIgY2xhc3MuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZXh0cmFjdERhdGE6IGZ1bmN0aW9uIGV4dHJhY3REYXRhKHJlc3ApIHtcbiAgICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICAgIGlmIChyZXEub3BlcmF0aW9uID09PSAnZ2V0QnVja2V0TG9jYXRpb24nKSB7XG4gICAgICB2YXIgbWF0Y2ggPSByZXNwLmh0dHBSZXNwb25zZS5ib2R5LnRvU3RyaW5nKCkubWF0Y2goLz4oLispPFxcL0xvY2F0aW9uLyk7XG4gICAgICBkZWxldGUgcmVzcC5kYXRhWydfJ107XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmVzcC5kYXRhLkxvY2F0aW9uQ29uc3RyYWludCA9IG1hdGNoWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzcC5kYXRhLkxvY2F0aW9uQ29uc3RyYWludCA9ICcnO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYnVja2V0ID0gcmVxLnBhcmFtcy5CdWNrZXQgfHwgbnVsbDtcbiAgICBpZiAocmVxLm9wZXJhdGlvbiA9PT0gJ2RlbGV0ZUJ1Y2tldCcgJiYgdHlwZW9mIGJ1Y2tldCA9PT0gJ3N0cmluZycgJiYgIXJlc3AuZXJyb3IpIHtcbiAgICAgIHJlcS5zZXJ2aWNlLmNsZWFyQnVja2V0UmVnaW9uQ2FjaGUoYnVja2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGhlYWRlcnMgPSByZXNwLmh0dHBSZXNwb25zZS5oZWFkZXJzIHx8IHt9O1xuICAgICAgdmFyIHJlZ2lvbiA9IGhlYWRlcnNbJ3gtYW16LWJ1Y2tldC1yZWdpb24nXSB8fCBudWxsO1xuICAgICAgaWYgKCFyZWdpb24gJiYgcmVxLm9wZXJhdGlvbiA9PT0gJ2NyZWF0ZUJ1Y2tldCcgJiYgIXJlc3AuZXJyb3IpIHtcbiAgICAgICAgdmFyIGNyZWF0ZUJ1Y2tldENvbmZpZ3VyYXRpb24gPSByZXEucGFyYW1zLkNyZWF0ZUJ1Y2tldENvbmZpZ3VyYXRpb247XG4gICAgICAgIGlmICghY3JlYXRlQnVja2V0Q29uZmlndXJhdGlvbikge1xuICAgICAgICAgIHJlZ2lvbiA9ICd1cy1lYXN0LTEnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyZWF0ZUJ1Y2tldENvbmZpZ3VyYXRpb24uTG9jYXRpb25Db25zdHJhaW50ID09PSAnRVUnKSB7XG4gICAgICAgICAgcmVnaW9uID0gJ2V1LXdlc3QtMSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVnaW9uID0gY3JlYXRlQnVja2V0Q29uZmlndXJhdGlvbi5Mb2NhdGlvbkNvbnN0cmFpbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZWdpb24pIHtcbiAgICAgICAgICBpZiAoYnVja2V0ICYmIHJlZ2lvbiAhPT0gcmVxLnNlcnZpY2UuYnVja2V0UmVnaW9uQ2FjaGVbYnVja2V0XSkge1xuICAgICAgICAgICAgcmVxLnNlcnZpY2UuYnVja2V0UmVnaW9uQ2FjaGVbYnVja2V0XSA9IHJlZ2lvbjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlcS5zZXJ2aWNlLmV4dHJhY3RSZXF1ZXN0SWRzKHJlc3ApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyBhbiBlcnJvciBvYmplY3QgZnJvbSB0aGUgaHR0cCByZXNwb25zZS5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBleHRyYWN0RXJyb3I6IGZ1bmN0aW9uIGV4dHJhY3RFcnJvcihyZXNwKSB7XG4gICAgdmFyIGNvZGVzID0ge1xuICAgICAgMzA0OiAnTm90TW9kaWZpZWQnLFxuICAgICAgNDAzOiAnRm9yYmlkZGVuJyxcbiAgICAgIDQwMDogJ0JhZFJlcXVlc3QnLFxuICAgICAgNDA0OiAnTm90Rm91bmQnXG4gICAgfTtcblxuICAgIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gICAgdmFyIGNvZGUgPSByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgIHZhciBib2R5ID0gcmVzcC5odHRwUmVzcG9uc2UuYm9keSB8fCAnJztcblxuICAgIHZhciBoZWFkZXJzID0gcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVycyB8fCB7fTtcbiAgICB2YXIgcmVnaW9uID0gaGVhZGVyc1sneC1hbXotYnVja2V0LXJlZ2lvbiddIHx8IG51bGw7XG4gICAgdmFyIGJ1Y2tldCA9IHJlcS5wYXJhbXMuQnVja2V0IHx8IG51bGw7XG4gICAgdmFyIGJ1Y2tldFJlZ2lvbkNhY2hlID0gcmVxLnNlcnZpY2UuYnVja2V0UmVnaW9uQ2FjaGU7XG4gICAgaWYgKHJlZ2lvbiAmJiBidWNrZXQgJiYgcmVnaW9uICE9PSBidWNrZXRSZWdpb25DYWNoZVtidWNrZXRdKSB7XG4gICAgICBidWNrZXRSZWdpb25DYWNoZVtidWNrZXRdID0gcmVnaW9uO1xuICAgIH1cblxuICAgIHZhciBjYWNoZWRSZWdpb247XG4gICAgaWYgKGNvZGVzW2NvZGVdICYmIGJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoYnVja2V0ICYmICFyZWdpb24pIHtcbiAgICAgICAgY2FjaGVkUmVnaW9uID0gYnVja2V0UmVnaW9uQ2FjaGVbYnVja2V0XSB8fCBudWxsO1xuICAgICAgICBpZiAoY2FjaGVkUmVnaW9uICE9PSByZXEuaHR0cFJlcXVlc3QucmVnaW9uKSB7XG4gICAgICAgICAgcmVnaW9uID0gY2FjaGVkUmVnaW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXNwLmVycm9yID0gQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogY29kZXNbY29kZV0sXG4gICAgICAgIG1lc3NhZ2U6IG51bGwsXG4gICAgICAgIHJlZ2lvbjogcmVnaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhdGEgPSBuZXcgQVdTLlhNTC5QYXJzZXIoKS5wYXJzZShib2R5LnRvU3RyaW5nKCkpO1xuXG4gICAgICBpZiAoZGF0YS5SZWdpb24gJiYgIXJlZ2lvbikge1xuICAgICAgICByZWdpb24gPSBkYXRhLlJlZ2lvbjtcbiAgICAgICAgaWYgKGJ1Y2tldCAmJiByZWdpb24gIT09IGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0pIHtcbiAgICAgICAgICBidWNrZXRSZWdpb25DYWNoZVtidWNrZXRdID0gcmVnaW9uO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGJ1Y2tldCAmJiAhcmVnaW9uICYmICFkYXRhLlJlZ2lvbikge1xuICAgICAgICBjYWNoZWRSZWdpb24gPSBidWNrZXRSZWdpb25DYWNoZVtidWNrZXRdIHx8IG51bGw7XG4gICAgICAgIGlmIChjYWNoZWRSZWdpb24gIT09IHJlcS5odHRwUmVxdWVzdC5yZWdpb24pIHtcbiAgICAgICAgICByZWdpb24gPSBjYWNoZWRSZWdpb247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzcC5lcnJvciA9IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6IGRhdGEuQ29kZSB8fCBjb2RlLFxuICAgICAgICBtZXNzYWdlOiBkYXRhLk1lc3NhZ2UgfHwgbnVsbCxcbiAgICAgICAgcmVnaW9uOiByZWdpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXEuc2VydmljZS5leHRyYWN0UmVxdWVzdElkcyhyZXNwKTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgcmVnaW9uIHdhcyBub3Qgb2J0YWluZWQgc3luY2hyb25vdXNseSwgdGhlbiBzZW5kIGFzeW5jIHJlcXVlc3RcbiAgICogdG8gZ2V0IGJ1Y2tldCByZWdpb24gZm9yIGVycm9ycyByZXN1bHRpbmcgZnJvbSB3cm9uZyByZWdpb24uXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcmVxdWVzdEJ1Y2tldFJlZ2lvbjogZnVuY3Rpb24gcmVxdWVzdEJ1Y2tldFJlZ2lvbihyZXNwLCBkb25lKSB7XG4gICAgdmFyIGVycm9yID0gcmVzcC5lcnJvcjtcbiAgICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICAgIHZhciBidWNrZXQgPSByZXEucGFyYW1zLkJ1Y2tldCB8fCBudWxsO1xuXG4gICAgaWYgKCFlcnJvciB8fCAhYnVja2V0IHx8IGVycm9yLnJlZ2lvbiB8fCByZXEub3BlcmF0aW9uID09PSAnbGlzdE9iamVjdHMnIHx8XG4gICAgICAgIChBV1MudXRpbC5pc05vZGUoKSAmJiByZXEub3BlcmF0aW9uID09PSAnaGVhZEJ1Y2tldCcpIHx8XG4gICAgICAgIChlcnJvci5zdGF0dXNDb2RlID09PSA0MDAgJiYgcmVxLm9wZXJhdGlvbiAhPT0gJ2hlYWRPYmplY3QnKSB8fFxuICAgICAgICByZWdpb25SZWRpcmVjdEVycm9yQ29kZXMuaW5kZXhPZihlcnJvci5jb2RlKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuICAgIHZhciByZXFPcGVyYXRpb24gPSBBV1MudXRpbC5pc05vZGUoKSA/ICdoZWFkQnVja2V0JyA6ICdsaXN0T2JqZWN0cyc7XG4gICAgdmFyIHJlcVBhcmFtcyA9IHtCdWNrZXQ6IGJ1Y2tldH07XG4gICAgaWYgKHJlcU9wZXJhdGlvbiA9PT0gJ2xpc3RPYmplY3RzJykgcmVxUGFyYW1zLk1heEtleXMgPSAwO1xuICAgIHZhciByZWdpb25SZXEgPSByZXEuc2VydmljZVtyZXFPcGVyYXRpb25dKHJlcVBhcmFtcyk7XG4gICAgcmVnaW9uUmVxLl9yZXF1ZXN0UmVnaW9uRm9yQnVja2V0ID0gYnVja2V0O1xuICAgIHJlZ2lvblJlcS5zZW5kKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlZ2lvbiA9IHJlcS5zZXJ2aWNlLmJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gfHwgbnVsbDtcbiAgICAgIGVycm9yLnJlZ2lvbiA9IHJlZ2lvbjtcbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgfSxcblxuICAgLyoqXG4gICAqIEZvciBicm93c2VyIG9ubHkuIElmIE5ldHdvcmtpbmdFcnJvciByZWNlaXZlZCwgd2lsbCBhdHRlbXB0IHRvIG9idGFpblxuICAgKiB0aGUgYnVja2V0IHJlZ2lvbi5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICAgcmVxUmVnaW9uRm9yTmV0d29ya2luZ0Vycm9yOiBmdW5jdGlvbiByZXFSZWdpb25Gb3JOZXR3b3JraW5nRXJyb3IocmVzcCwgZG9uZSkge1xuICAgIGlmICghQVdTLnV0aWwuaXNCcm93c2VyKCkpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuICAgIHZhciBlcnJvciA9IHJlc3AuZXJyb3I7XG4gICAgdmFyIHJlcXVlc3QgPSByZXNwLnJlcXVlc3Q7XG4gICAgdmFyIGJ1Y2tldCA9IHJlcXVlc3QucGFyYW1zLkJ1Y2tldDtcbiAgICBpZiAoIWVycm9yIHx8IGVycm9yLmNvZGUgIT09ICdOZXR3b3JraW5nRXJyb3InIHx8ICFidWNrZXQgfHxcbiAgICAgICAgcmVxdWVzdC5odHRwUmVxdWVzdC5yZWdpb24gPT09ICd1cy1lYXN0LTEnKSB7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cbiAgICB2YXIgc2VydmljZSA9IHJlcXVlc3Quc2VydmljZTtcbiAgICB2YXIgYnVja2V0UmVnaW9uQ2FjaGUgPSBzZXJ2aWNlLmJ1Y2tldFJlZ2lvbkNhY2hlO1xuICAgIHZhciBjYWNoZWRSZWdpb24gPSBidWNrZXRSZWdpb25DYWNoZVtidWNrZXRdIHx8IG51bGw7XG5cbiAgICBpZiAoY2FjaGVkUmVnaW9uICYmIGNhY2hlZFJlZ2lvbiAhPT0gcmVxdWVzdC5odHRwUmVxdWVzdC5yZWdpb24pIHtcbiAgICAgIHNlcnZpY2UudXBkYXRlUmVxQnVja2V0UmVnaW9uKHJlcXVlc3QsIGNhY2hlZFJlZ2lvbik7XG4gICAgICBkb25lKCk7XG4gICAgfSBlbHNlIGlmICghc2VydmljZS5pc0Ruc0NvbXBhdGlibGUoYnVja2V0KSkge1xuICAgICAgc2VydmljZS51cGRhdGVSZXFCdWNrZXRSZWdpb24ocmVxdWVzdCwgJ3VzLWVhc3QtMScpO1xuICAgICAgaWYgKGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gIT09ICd1cy1lYXN0LTEnKSB7XG4gICAgICAgIGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gPSAndXMtZWFzdC0xJztcbiAgICAgIH1cbiAgICAgIGRvbmUoKTtcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QuaHR0cFJlcXVlc3QudmlydHVhbEhvc3RlZEJ1Y2tldCkge1xuICAgICAgdmFyIGdldFJlZ2lvblJlcSA9IHNlcnZpY2UubGlzdE9iamVjdHMoe0J1Y2tldDogYnVja2V0LCBNYXhLZXlzOiAwfSk7XG4gICAgICBzZXJ2aWNlLnVwZGF0ZVJlcUJ1Y2tldFJlZ2lvbihnZXRSZWdpb25SZXEsICd1cy1lYXN0LTEnKTtcbiAgICAgIGdldFJlZ2lvblJlcS5fcmVxdWVzdFJlZ2lvbkZvckJ1Y2tldCA9IGJ1Y2tldDtcblxuICAgICAgZ2V0UmVnaW9uUmVxLnNlbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWdpb24gPSBzZXJ2aWNlLmJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gfHwgbnVsbDtcbiAgICAgICAgaWYgKHJlZ2lvbiAmJiByZWdpb24gIT09IHJlcXVlc3QuaHR0cFJlcXVlc3QucmVnaW9uKSB7XG4gICAgICAgICAgc2VydmljZS51cGRhdGVSZXFCdWNrZXRSZWdpb24ocmVxdWVzdCwgcmVnaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRE5TLWNvbXBhdGlibGUgcGF0aC1zdHlsZVxuICAgICAgLy8gKHMzRm9yY2VQYXRoU3R5bGUgb3IgYnVja2V0IG5hbWUgd2l0aCBkb3Qgb3ZlciBodHRwcylcbiAgICAgIC8vIENhbm5vdCBvYnRhaW4gcmVnaW9uIGluZm9ybWF0aW9uIGZvciB0aGlzIGNhc2VcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gICB9LFxuXG4gIC8qKlxuICAgKiBDYWNoZSBmb3IgYnVja2V0IHJlZ2lvbi5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICAgYnVja2V0UmVnaW9uQ2FjaGU6IHt9LFxuXG4gIC8qKlxuICAgKiBDbGVhcnMgYnVja2V0IHJlZ2lvbiBjYWNoZS5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICAgY2xlYXJCdWNrZXRSZWdpb25DYWNoZTogZnVuY3Rpb24oYnVja2V0cykge1xuICAgIHZhciBidWNrZXRSZWdpb25DYWNoZSA9IHRoaXMuYnVja2V0UmVnaW9uQ2FjaGU7XG4gICAgaWYgKCFidWNrZXRzKSB7XG4gICAgICBidWNrZXRzID0gT2JqZWN0LmtleXMoYnVja2V0UmVnaW9uQ2FjaGUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJ1Y2tldHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWNrZXRzID0gW2J1Y2tldHNdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Y2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlbGV0ZSBidWNrZXRSZWdpb25DYWNoZVtidWNrZXRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Y2tldFJlZ2lvbkNhY2hlO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBDb3JyZWN0cyByZXF1ZXN0IHJlZ2lvbiBpZiBidWNrZXQncyBjYWNoZWQgcmVnaW9uIGlzIGRpZmZlcmVudFxuICAgICpcbiAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICovXG4gIGNvcnJlY3RCdWNrZXRSZWdpb25Gcm9tQ2FjaGU6IGZ1bmN0aW9uIGNvcnJlY3RCdWNrZXRSZWdpb25Gcm9tQ2FjaGUocmVxKSB7XG4gICAgdmFyIGJ1Y2tldCA9IHJlcS5wYXJhbXMuQnVja2V0IHx8IG51bGw7XG4gICAgaWYgKGJ1Y2tldCkge1xuICAgICAgdmFyIHNlcnZpY2UgPSByZXEuc2VydmljZTtcbiAgICAgIHZhciByZXF1ZXN0UmVnaW9uID0gcmVxLmh0dHBSZXF1ZXN0LnJlZ2lvbjtcbiAgICAgIHZhciBjYWNoZWRSZWdpb24gPSBzZXJ2aWNlLmJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF07XG4gICAgICBpZiAoY2FjaGVkUmVnaW9uICYmIGNhY2hlZFJlZ2lvbiAhPT0gcmVxdWVzdFJlZ2lvbikge1xuICAgICAgICBzZXJ2aWNlLnVwZGF0ZVJlcUJ1Y2tldFJlZ2lvbihyZXEsIGNhY2hlZFJlZ2lvbik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyBTMyBzcGVjaWZpYyByZXF1ZXN0IGlkcyBmcm9tIHRoZSBodHRwIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGV4dHJhY3RSZXF1ZXN0SWRzOiBmdW5jdGlvbiBleHRyYWN0UmVxdWVzdElkcyhyZXNwKSB7XG4gICAgdmFyIGV4dGVuZGVkUmVxdWVzdElkID0gcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVycyA/IHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3gtYW16LWlkLTInXSA6IG51bGw7XG4gICAgdmFyIGNmSWQgPSByZXNwLmh0dHBSZXNwb25zZS5oZWFkZXJzID8gcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXotY2YtaWQnXSA6IG51bGw7XG4gICAgcmVzcC5leHRlbmRlZFJlcXVlc3RJZCA9IGV4dGVuZGVkUmVxdWVzdElkO1xuICAgIHJlc3AuY2ZJZCA9IGNmSWQ7XG5cbiAgICBpZiAocmVzcC5lcnJvcikge1xuICAgICAgcmVzcC5lcnJvci5yZXF1ZXN0SWQgPSByZXNwLnJlcXVlc3RJZCB8fCBudWxsO1xuICAgICAgcmVzcC5lcnJvci5leHRlbmRlZFJlcXVlc3RJZCA9IGV4dGVuZGVkUmVxdWVzdElkO1xuICAgICAgcmVzcC5lcnJvci5jZklkID0gY2ZJZDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHByZS1zaWduZWQgVVJMIGZvciBhIGdpdmVuIG9wZXJhdGlvbiBuYW1lLlxuICAgKlxuICAgKiBAbm90ZSBZb3UgbXVzdCBlbnN1cmUgdGhhdCB5b3UgaGF2ZSBzdGF0aWMgb3IgcHJldmlvdXNseSByZXNvbHZlZFxuICAgKiAgIGNyZWRlbnRpYWxzIGlmIHlvdSBjYWxsIHRoaXMgbWV0aG9kIHN5bmNocm9ub3VzbHkgKHdpdGggbm8gY2FsbGJhY2spLFxuICAgKiAgIG90aGVyd2lzZSBpdCBtYXkgbm90IHByb3Blcmx5IHNpZ24gdGhlIHJlcXVlc3QuIElmIHlvdSBjYW5ub3QgZ3VhcmFudGVlXG4gICAqICAgdGhpcyAoeW91IGFyZSB1c2luZyBhbiBhc3luY2hyb25vdXMgY3JlZGVudGlhbCBwcm92aWRlciwgaS5lLiwgRUMyXG4gICAqICAgSUFNIHJvbGVzKSwgeW91IHNob3VsZCBhbHdheXMgY2FsbCB0aGlzIG1ldGhvZCB3aXRoIGFuIGFzeW5jaHJvbm91c1xuICAgKiAgIGNhbGxiYWNrLlxuICAgKiBAbm90ZSBOb3QgYWxsIG9wZXJhdGlvbiBwYXJhbWV0ZXJzIGFyZSBzdXBwb3J0ZWQgd2hlbiB1c2luZyBwcmUtc2lnbmVkXG4gICAqICAgVVJMcy4gQ2VydGFpbiBwYXJhbWV0ZXJzLCBzdWNoIGFzIGBTU0VDdXN0b21lcktleWAsIGBBQ0xgLCBgRXhwaXJlc2AsXG4gICAqICAgYENvbnRlbnRMZW5ndGhgLCBvciBgVGFnZ2luZ2AgbXVzdCBiZSBwcm92aWRlZCBhcyBoZWFkZXJzIHdoZW4gc2VuZGluZyBhXG4gICAqICAgcmVxdWVzdC4gSWYgeW91IGFyZSB1c2luZyBwcmUtc2lnbmVkIFVSTHMgdG8gdXBsb2FkIGZyb20gYSBicm93c2VyIGFuZFxuICAgKiAgIG5lZWQgdG8gdXNlIHRoZXNlIGZpZWxkcywgc2VlIHtjcmVhdGVQcmVzaWduZWRQb3N0fS5cbiAgICogQG5vdGUgVGhlIGRlZmF1bHQgc2lnbmVyIGFsbG93cyBhbHRlcmluZyB0aGUgcmVxdWVzdCBieSBhZGRpbmcgY29ycmVzcG9uZGluZ1xuICAgKiAgIGhlYWRlcnMgdG8gc2V0IHNvbWUgcGFyYW1ldGVycyAoZS5nLiBSYW5nZSkgYW5kIHRoZXNlIGFkZGVkIHBhcmFtZXRlcnNcbiAgICogICB3b24ndCBiZSBzaWduZWQuIFlvdSBtdXN0IHVzZSBzaWduYXR1cmVWZXJzaW9uIHY0IHRvIHRvIGluY2x1ZGUgdGhlc2VcbiAgICogICBwYXJhbWV0ZXJzIGluIHRoZSBzaWduZWQgcG9ydGlvbiBvZiB0aGUgVVJMIGFuZCBlbmZvcmNlIGV4YWN0IG1hdGNoaW5nXG4gICAqICAgYmV0d2VlbiBoZWFkZXJzIGFuZCBzaWduZWQgcGFyYW1zIGluIHRoZSBVUkwuXG4gICAqIEBub3RlIFRoaXMgb3BlcmF0aW9uIGNhbm5vdCBiZSB1c2VkIHdpdGggYSBwcm9taXNlLiBTZWUgbm90ZSBhYm92ZSByZWdhcmRpbmdcbiAgICogICBhc3luY2hyb25vdXMgY3JlZGVudGlhbHMgYW5kIHVzZSB3aXRoIGEgY2FsbGJhY2suXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG9wZXJhdGlvbiB0byBjYWxsXG4gICAqIEBwYXJhbSBwYXJhbXMgW21hcF0gcGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSBvcGVyYXRpb24uIFNlZSB0aGUgZ2l2ZW5cbiAgICogICBvcGVyYXRpb24gZm9yIHRoZSBleHBlY3RlZCBvcGVyYXRpb24gcGFyYW1ldGVycy4gSW4gYWRkaXRpb24sIHlvdSBjYW5cbiAgICogICBhbHNvIHBhc3MgdGhlIFwiRXhwaXJlc1wiIHBhcmFtZXRlciB0byBpbmZvcm0gUzMgaG93IGxvbmcgdGhlIFVSTCBzaG91bGRcbiAgICogICB3b3JrIGZvci5cbiAgICogQG9wdGlvbiBwYXJhbXMgRXhwaXJlcyBbSW50ZWdlcl0gKDkwMCkgdGhlIG51bWJlciBvZiBzZWNvbmRzIHRvIGV4cGlyZVxuICAgKiAgIHRoZSBwcmUtc2lnbmVkIFVSTCBvcGVyYXRpb24gaW4uIERlZmF1bHRzIHRvIDE1IG1pbnV0ZXMuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBbRnVuY3Rpb25dIGlmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQsIHRoaXMgZnVuY3Rpb24gd2lsbFxuICAgKiAgIHBhc3MgdGhlIFVSTCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciAoYWZ0ZXIgdGhlIGVycm9yIHBhcmFtZXRlcikgdG9cbiAgICogICB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4gW1N0cmluZ10gaWYgY2FsbGVkIHN5bmNocm9ub3VzbHkgKHdpdGggbm8gY2FsbGJhY2spLCByZXR1cm5zIHRoZVxuICAgKiAgIHNpZ25lZCBVUkwuXG4gICAqIEByZXR1cm4gW251bGxdIG5vdGhpbmcgaXMgcmV0dXJuZWQgaWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZC5cbiAgICogQGV4YW1wbGUgUHJlLXNpZ25pbmcgYSBnZXRPYmplY3Qgb3BlcmF0aW9uIChzeW5jaHJvbm91c2x5KVxuICAgKiAgIHZhciBwYXJhbXMgPSB7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5J307XG4gICAqICAgdmFyIHVybCA9IHMzLmdldFNpZ25lZFVybCgnZ2V0T2JqZWN0JywgcGFyYW1zKTtcbiAgICogICBjb25zb2xlLmxvZygnVGhlIFVSTCBpcycsIHVybCk7XG4gICAqIEBleGFtcGxlIFByZS1zaWduaW5nIGEgcHV0T2JqZWN0IChhc3luY2hyb25vdXNseSlcbiAgICogICB2YXIgcGFyYW1zID0ge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleSd9O1xuICAgKiAgIHMzLmdldFNpZ25lZFVybCgncHV0T2JqZWN0JywgcGFyYW1zLCBmdW5jdGlvbiAoZXJyLCB1cmwpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKCdUaGUgVVJMIGlzJywgdXJsKTtcbiAgICogICB9KTtcbiAgICogQGV4YW1wbGUgUHJlLXNpZ25pbmcgYSBwdXRPYmplY3Qgb3BlcmF0aW9uIHdpdGggYSBzcGVjaWZpYyBwYXlsb2FkXG4gICAqICAgdmFyIHBhcmFtcyA9IHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLCBCb2R5OiAnYm9keSd9O1xuICAgKiAgIHZhciB1cmwgPSBzMy5nZXRTaWduZWRVcmwoJ3B1dE9iamVjdCcsIHBhcmFtcyk7XG4gICAqICAgY29uc29sZS5sb2coJ1RoZSBVUkwgaXMnLCB1cmwpO1xuICAgKiBAZXhhbXBsZSBQYXNzaW5nIGluIGEgMS1taW51dGUgZXhwaXJ5IHRpbWUgZm9yIGEgcHJlLXNpZ25lZCBVUkxcbiAgICogICB2YXIgcGFyYW1zID0ge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsIEV4cGlyZXM6IDYwfTtcbiAgICogICB2YXIgdXJsID0gczMuZ2V0U2lnbmVkVXJsKCdnZXRPYmplY3QnLCBwYXJhbXMpO1xuICAgKiAgIGNvbnNvbGUubG9nKCdUaGUgVVJMIGlzJywgdXJsKTsgLy8gZXhwaXJlcyBpbiA2MCBzZWNvbmRzXG4gICAqL1xuICBnZXRTaWduZWRVcmw6IGZ1bmN0aW9uIGdldFNpZ25lZFVybChvcGVyYXRpb24sIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBwYXJhbXMgPSBBV1MudXRpbC5jb3B5KHBhcmFtcyB8fCB7fSk7XG4gICAgdmFyIGV4cGlyZXMgPSBwYXJhbXMuRXhwaXJlcyB8fCA5MDA7XG5cbiAgICBpZiAodHlwZW9mIGV4cGlyZXMgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgeyBjb2RlOiAnSW52YWxpZFBhcmFtZXRlckV4Y2VwdGlvbicsIG1lc3NhZ2U6ICdUaGUgZXhwaXJhdGlvbiBtdXN0IGJlIGEgbnVtYmVyLCByZWNlaXZlZCAnICsgdHlwZW9mIGV4cGlyZXMgfSk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHBhcmFtcy5FeHBpcmVzOyAvLyB3ZSBjYW4ndCB2YWxpZGF0ZSB0aGlzXG4gICAgdmFyIHJlcXVlc3QgPSB0aGlzLm1ha2VSZXF1ZXN0KG9wZXJhdGlvbiwgcGFyYW1zKTtcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgQVdTLnV0aWwuZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlcXVlc3QucHJlc2lnbihleHBpcmVzLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlcXVlc3QucHJlc2lnbihleHBpcmVzLCBjYWxsYmFjayk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAIW1ldGhvZCAgZ2V0U2lnbmVkVXJsUHJvbWlzZSgpXG4gICAqICAgUmV0dXJucyBhICd0aGVuYWJsZScgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCBhIHByZS1zaWduZWQgVVJMXG4gICAqICAgZm9yIGEgZ2l2ZW4gb3BlcmF0aW9uIG5hbWUuXG4gICAqXG4gICAqICAgVHdvIGNhbGxiYWNrcyBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIGB0aGVuYCBtZXRob2Qgb24gdGhlIHJldHVybmVkIHByb21pc2UuXG4gICAqICAgVGhlIGZpcnN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgYW5kIHRoZSBzZWNvbmRcbiAgICogICBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICBAbm90ZSBOb3QgYWxsIG9wZXJhdGlvbiBwYXJhbWV0ZXJzIGFyZSBzdXBwb3J0ZWQgd2hlbiB1c2luZyBwcmUtc2lnbmVkXG4gICAqICAgICAgVVJMcy4gQ2VydGFpbiBwYXJhbWV0ZXJzLCBzdWNoIGFzIGBTU0VDdXN0b21lcktleWAsIGBBQ0xgLCBgRXhwaXJlc2AsXG4gICAqICAgICAgYENvbnRlbnRMZW5ndGhgLCBvciBgVGFnZ2luZ2AgbXVzdCBiZSBwcm92aWRlZCBhcyBoZWFkZXJzIHdoZW4gc2VuZGluZyBhXG4gICAqICAgICAgcmVxdWVzdC4gSWYgeW91IGFyZSB1c2luZyBwcmUtc2lnbmVkIFVSTHMgdG8gdXBsb2FkIGZyb20gYSBicm93c2VyIGFuZFxuICAgKiAgICAgIG5lZWQgdG8gdXNlIHRoZXNlIGZpZWxkcywgc2VlIHtjcmVhdGVQcmVzaWduZWRQb3N0fS5cbiAgICogICBAcGFyYW0gb3BlcmF0aW9uIFtTdHJpbmddIHRoZSBuYW1lIG9mIHRoZSBvcGVyYXRpb24gdG8gY2FsbFxuICAgKiAgIEBwYXJhbSBwYXJhbXMgW21hcF0gcGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSBvcGVyYXRpb24uIFNlZSB0aGUgZ2l2ZW5cbiAgICogICAgICBvcGVyYXRpb24gZm9yIHRoZSBleHBlY3RlZCBvcGVyYXRpb24gcGFyYW1ldGVycy4gSW4gYWRkaXRpb24sIHlvdSBjYW5cbiAgICogICAgICBhbHNvIHBhc3MgdGhlIFwiRXhwaXJlc1wiIHBhcmFtZXRlciB0byBpbmZvcm0gUzMgaG93IGxvbmcgdGhlIFVSTCBzaG91bGRcbiAgICogICAgICB3b3JrIGZvci5cbiAgICogICBAb3B0aW9uIHBhcmFtcyBFeHBpcmVzIFtJbnRlZ2VyXSAoOTAwKSB0aGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gZXhwaXJlXG4gICAqICAgICAgdGhlIHByZS1zaWduZWQgVVJMIG9wZXJhdGlvbiBpbi4gRGVmYXVsdHMgdG8gMTUgbWludXRlcy5cbiAgICogICBAY2FsbGJhY2sgZnVsZmlsbGVkQ2FsbGJhY2sgZnVuY3Rpb24odXJsKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbiAgICogICAgIEBwYXJhbSB1cmwgW1N0cmluZ10gdGhlIHNpZ25lZCB1cmxcbiAgICogICBAY2FsbGJhY2sgcmVqZWN0ZWRDYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogICBAcmV0dXJuIFtQcm9taXNlXSBBIHByb21pc2UgdGhhdCByZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgYHJlZnJlc2hgIGNhbGwuXG4gICAqICAgQGV4YW1wbGUgUHJlLXNpZ25pbmcgYSBnZXRPYmplY3Qgb3BlcmF0aW9uXG4gICAqICAgICAgdmFyIHBhcmFtcyA9IHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknfTtcbiAgICogICAgICB2YXIgcHJvbWlzZSA9IHMzLmdldFNpZ25lZFVybFByb21pc2UoJ2dldE9iamVjdCcsIHBhcmFtcyk7XG4gICAqICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHVybCkge1xuICAgKiAgICAgICAgY29uc29sZS5sb2coJ1RoZSBVUkwgaXMnLCB1cmwpO1xuICAgKiAgICAgIH0sIGZ1bmN0aW9uKGVycikgeyAuLi4gfSk7XG4gICAqICAgQGV4YW1wbGUgUHJlLXNpZ25pbmcgYSBwdXRPYmplY3Qgb3BlcmF0aW9uIHdpdGggYSBzcGVjaWZpYyBwYXlsb2FkXG4gICAqICAgICAgdmFyIHBhcmFtcyA9IHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLCBCb2R5OiAnYm9keSd9O1xuICAgKiAgICAgIHZhciBwcm9taXNlID0gczMuZ2V0U2lnbmVkVXJsUHJvbWlzZSgncHV0T2JqZWN0JywgcGFyYW1zKTtcbiAgICogICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odXJsKSB7XG4gICAqICAgICAgICBjb25zb2xlLmxvZygnVGhlIFVSTCBpcycsIHVybCk7XG4gICAqICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7IC4uLiB9KTtcbiAgICogICBAZXhhbXBsZSBQYXNzaW5nIGluIGEgMS1taW51dGUgZXhwaXJ5IHRpbWUgZm9yIGEgcHJlLXNpZ25lZCBVUkxcbiAgICogICAgICB2YXIgcGFyYW1zID0ge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsIEV4cGlyZXM6IDYwfTtcbiAgICogICAgICB2YXIgcHJvbWlzZSA9IHMzLmdldFNpZ25lZFVybFByb21pc2UoJ2dldE9iamVjdCcsIHBhcmFtcyk7XG4gICAqICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHVybCkge1xuICAgKiAgICAgICAgY29uc29sZS5sb2coJ1RoZSBVUkwgaXMnLCB1cmwpO1xuICAgKiAgICAgIH0sIGZ1bmN0aW9uKGVycikgeyAuLi4gfSk7XG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZXQgYSBwcmUtc2lnbmVkIFBPU1QgcG9saWN5IHRvIHN1cHBvcnQgdXBsb2FkaW5nIHRvIFMzIGRpcmVjdGx5IGZyb20gYW5cbiAgICogSFRNTCBmb3JtLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIFttYXBdXG4gICAqIEBvcHRpb24gcGFyYW1zIEJ1Y2tldCBbU3RyaW5nXSAgICAgVGhlIGJ1Y2tldCB0byB3aGljaCB0aGUgcG9zdCBzaG91bGQgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRlZFxuICAgKiBAb3B0aW9uIHBhcmFtcyBFeHBpcmVzIFtJbnRlZ2VyXSAgICgzNjAwKSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgZm9yIHdoaWNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHByZXNpZ25lZCBwb2xpY3kgc2hvdWxkIGJlIHZhbGlkLlxuICAgKiBAb3B0aW9uIHBhcmFtcyBDb25kaXRpb25zIFtBcnJheV0gIEFuIGFycmF5IG9mIGNvbmRpdGlvbnMgdGhhdCBtdXN0IGJlIG1ldFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciB0aGUgcHJlc2lnbmVkIHBvbGljeSB0byBhbGxvdyB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWQuIFRoaXMgY2FuIGluY2x1ZGUgcmVxdWlyZWQgdGFncyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgYWNjZXB0ZWQgcmFuZ2UgZm9yIGNvbnRlbnQgbGVuZ3RocyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldGMuXG4gICAqIEBzZWUgaHR0cDovL2RvY3MuYXdzLmFtYXpvbi5jb20vQW1hem9uUzMvbGF0ZXN0L0FQSS9zaWd2NC1IVFRQUE9TVENvbnN0cnVjdFBvbGljeS5odG1sXG4gICAqIEBvcHRpb24gcGFyYW1zIEZpZWxkcyBbbWFwXSAgICAgICAgRmllbGRzIHRvIGluY2x1ZGUgaW4gdGhlIGZvcm0uIEFsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyBwYXNzZWQgaW4gYXMgZmllbGRzIHdpbGwgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduZWQgYXMgZXhhY3QgbWF0Y2ggY29uZGl0aW9ucy5cbiAgICogQHBhcmFtIGNhbGxiYWNrIFtGdW5jdGlvbl1cbiAgICpcbiAgICogQG5vdGUgQWxsIGZpZWxkcyBwYXNzZWQgaW4gd2hlbiBjcmVhdGluZyBwcmVzaWduZWQgcG9zdCBkYXRhIHdpbGwgYmUgc2lnbmVkXG4gICAqICAgYXMgZXhhY3QgbWF0Y2ggY29uZGl0aW9ucy4gQW55IGZpZWxkcyB0aGF0IHdpbGwgYmUgaW50ZXJwb2xhdGVkIGJ5IFMzXG4gICAqICAgbXVzdCBiZSBhZGRlZCB0byB0aGUgZmllbGRzIGhhc2ggYWZ0ZXIgc2lnbmluZywgYW5kIGFuIGFwcHJvcHJpYXRlXG4gICAqICAgY29uZGl0aW9uIGZvciBzdWNoIGZpZWxkcyBtdXN0IGJlIGV4cGxpY2l0bHkgYWRkZWQgdG8gdGhlIENvbmRpdGlvbnNcbiAgICogICBhcnJheSBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBiZWZvcmUgc2lnbmluZy5cbiAgICpcbiAgICogQGV4YW1wbGUgUHJlc2lnaW5nIHBvc3QgZGF0YSB3aXRoIGEga25vd24ga2V5XG4gICAqICAgdmFyIHBhcmFtcyA9IHtcbiAgICogICAgIEJ1Y2tldDogJ2J1Y2tldCcsXG4gICAqICAgICBGaWVsZHM6IHtcbiAgICogICAgICAga2V5OiAna2V5J1xuICAgKiAgICAgfVxuICAgKiAgIH07XG4gICAqICAgczMuY3JlYXRlUHJlc2lnbmVkUG9zdChwYXJhbXMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICAgaWYgKGVycikge1xuICAgKiAgICAgICBjb25zb2xlLmVycm9yKCdQcmVzaWduaW5nIHBvc3QgZGF0YSBlbmNvdW50ZXJlZCBhbiBlcnJvcicsIGVycik7XG4gICAqICAgICB9IGVsc2Uge1xuICAgKiAgICAgICBjb25zb2xlLmxvZygnVGhlIHBvc3QgZGF0YSBpcycsIGRhdGEpO1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZSBQcmVzaWduaW5nIHBvc3QgZGF0YSB3aXRoIGFuIGludGVycG9sYXRlZCBrZXlcbiAgICogICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICAgQnVja2V0OiAnYnVja2V0JyxcbiAgICogICAgIENvbmRpdGlvbnM6IFtcbiAgICogICAgICAgWydzdGFydHMtd2l0aCcsICcka2V5JywgJ3BhdGgvdG8vdXBsb2Fkcy8nXVxuICAgKiAgICAgXVxuICAgKiAgIH07XG4gICAqICAgczMuY3JlYXRlUHJlc2lnbmVkUG9zdChwYXJhbXMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICAgaWYgKGVycikge1xuICAgKiAgICAgICBjb25zb2xlLmVycm9yKCdQcmVzaWduaW5nIHBvc3QgZGF0YSBlbmNvdW50ZXJlZCBhbiBlcnJvcicsIGVycik7XG4gICAqICAgICB9IGVsc2Uge1xuICAgKiAgICAgICBkYXRhLkZpZWxkcy5rZXkgPSAncGF0aC90by91cGxvYWRzLyR7ZmlsZW5hbWV9JztcbiAgICogICAgICAgY29uc29sZS5sb2coJ1RoZSBwb3N0IGRhdGEgaXMnLCBkYXRhKTtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQG5vdGUgWW91IG11c3QgZW5zdXJlIHRoYXQgeW91IGhhdmUgc3RhdGljIG9yIHByZXZpb3VzbHkgcmVzb2x2ZWRcbiAgICogICBjcmVkZW50aWFscyBpZiB5b3UgY2FsbCB0aGlzIG1ldGhvZCBzeW5jaHJvbm91c2x5ICh3aXRoIG5vIGNhbGxiYWNrKSxcbiAgICogICBvdGhlcndpc2UgaXQgbWF5IG5vdCBwcm9wZXJseSBzaWduIHRoZSByZXF1ZXN0LiBJZiB5b3UgY2Fubm90IGd1YXJhbnRlZVxuICAgKiAgIHRoaXMgKHlvdSBhcmUgdXNpbmcgYW4gYXN5bmNocm9ub3VzIGNyZWRlbnRpYWwgcHJvdmlkZXIsIGkuZS4sIEVDMlxuICAgKiAgIElBTSByb2xlcyksIHlvdSBzaG91bGQgYWx3YXlzIGNhbGwgdGhpcyBtZXRob2Qgd2l0aCBhbiBhc3luY2hyb25vdXNcbiAgICogICBjYWxsYmFjay5cbiAgICpcbiAgICogQHJldHVybiBbbWFwXSAgSWYgY2FsbGVkIHN5bmNocm9ub3VzbHkgKHdpdGggbm8gY2FsbGJhY2spLCByZXR1cm5zIGEgaGFzaFxuICAgKiAgICAgICAgICAgICAgICB3aXRoIHRoZSB1cmwgdG8gc2V0IGFzIHRoZSBmb3JtIGFjdGlvbiBhbmQgYSBoYXNoIG9mIGZpZWxkc1xuICAgKiAgICAgICAgICAgICAgICB0byBpbmNsdWRlIGluIHRoZSBmb3JtLlxuICAgKiBAcmV0dXJuIFtudWxsXSBOb3RoaW5nIGlzIHJldHVybmVkIGlmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbiAoZXJyLCBkYXRhKVxuICAgKiAgQHBhcmFtIGVyciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgcG9saWN5IHNpZ25lclxuICAgKiAgQHBhcmFtIGRhdGEgW21hcF0gVGhlIGRhdGEgbmVjZXNzYXJ5IHRvIGNvbnN0cnVjdCBhbiBIVE1MIGZvcm1cbiAgICogIEBwYXJhbSBkYXRhLnVybCBbU3RyaW5nXSBUaGUgVVJMIHRvIHVzZSBhcyB0aGUgYWN0aW9uIG9mIHRoZSBmb3JtXG4gICAqICBAcGFyYW0gZGF0YS5maWVsZHMgW21hcF0gQSBoYXNoIG9mIGZpZWxkcyB0aGF0IG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybSBmb3IgdGhlIHVwbG9hZCB0byBzdWNjZWVkLiBUaGlzIGhhc2ggd2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGUgdGhlIHNpZ25lZCBQT1NUIHBvbGljeSwgeW91ciBhY2Nlc3Mga2V5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgSUQgYW5kIHNlY3VyaXR5IHRva2VuIChpZiBwcmVzZW50KSwgZXRjLiBUaGVzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heSBiZSBzYWZlbHkgaW5jbHVkZWQgYXMgaW5wdXQgZWxlbWVudHMgb2YgdHlwZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICdoaWRkZW4uJ1xuICAgKi9cbiAgY3JlYXRlUHJlc2lnbmVkUG9zdDogZnVuY3Rpb24gY3JlYXRlUHJlc2lnbmVkUG9zdChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicgJiYgY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICBwYXJhbXMgPSBudWxsO1xuICAgIH1cblxuICAgIHBhcmFtcyA9IEFXUy51dGlsLmNvcHkocGFyYW1zIHx8IHt9KTtcbiAgICB2YXIgYm91bmRQYXJhbXMgPSB0aGlzLmNvbmZpZy5wYXJhbXMgfHwge307XG4gICAgdmFyIGJ1Y2tldCA9IHBhcmFtcy5CdWNrZXQgfHwgYm91bmRQYXJhbXMuQnVja2V0LFxuICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgIGVuZHBvaW50ID0gQVdTLnV0aWwuY29weSh0aGlzLmVuZHBvaW50KTtcbiAgICBpZiAoIWNvbmZpZy5zM0J1Y2tldEVuZHBvaW50KSB7XG4gICAgICBlbmRwb2ludC5wYXRobmFtZSA9ICcvJyArIGJ1Y2tldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5hbGl6ZVBvc3QoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IEFXUy51dGlsLnVybEZvcm1hdChlbmRwb2ludCksXG4gICAgICAgIGZpZWxkczogc2VsZi5wcmVwYXJlUG9zdEZpZWxkcyhcbiAgICAgICAgICBjb25maWcuY3JlZGVudGlhbHMsXG4gICAgICAgICAgY29uZmlnLnJlZ2lvbixcbiAgICAgICAgICBidWNrZXQsXG4gICAgICAgICAgcGFyYW1zLkZpZWxkcyxcbiAgICAgICAgICBwYXJhbXMuQ29uZGl0aW9ucyxcbiAgICAgICAgICBwYXJhbXMuRXhwaXJlc1xuICAgICAgICApXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY29uZmlnLmdldENyZWRlbnRpYWxzKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCBmaW5hbGl6ZVBvc3QoKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZpbmFsaXplUG9zdCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwcmVwYXJlUG9zdEZpZWxkczogZnVuY3Rpb24gcHJlcGFyZVBvc3RGaWVsZHMoXG4gICAgY3JlZGVudGlhbHMsXG4gICAgcmVnaW9uLFxuICAgIGJ1Y2tldCxcbiAgICBmaWVsZHMsXG4gICAgY29uZGl0aW9ucyxcbiAgICBleHBpcmVzSW5TZWNvbmRzXG4gICkge1xuICAgIHZhciBub3cgPSB0aGlzLmdldFNrZXdDb3JyZWN0ZWREYXRlKCk7XG4gICAgaWYgKCFjcmVkZW50aWFscyB8fCAhcmVnaW9uIHx8ICFidWNrZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNyZWF0ZSBhIFBPU1Qgb2JqZWN0IHBvbGljeSB3aXRob3V0IGEgYnVja2V0LCdcbiAgICAgICAgKyAnIHJlZ2lvbiwgYW5kIGNyZWRlbnRpYWxzJyk7XG4gICAgfVxuICAgIGZpZWxkcyA9IEFXUy51dGlsLmNvcHkoZmllbGRzIHx8IHt9KTtcbiAgICBjb25kaXRpb25zID0gKGNvbmRpdGlvbnMgfHwgW10pLnNsaWNlKDApO1xuICAgIGV4cGlyZXNJblNlY29uZHMgPSBleHBpcmVzSW5TZWNvbmRzIHx8IDM2MDA7XG5cbiAgICB2YXIgc2lnbmluZ0RhdGUgPSBBV1MudXRpbC5kYXRlLmlzbzg2MDEobm93KS5yZXBsYWNlKC9bOlxcLV18XFwuXFxkezN9L2csICcnKTtcbiAgICB2YXIgc2hvcnREYXRlID0gc2lnbmluZ0RhdGUuc3Vic3RyKDAsIDgpO1xuICAgIHZhciBzY29wZSA9IHY0Q3JlZGVudGlhbHMuY3JlYXRlU2NvcGUoc2hvcnREYXRlLCByZWdpb24sICdzMycpO1xuICAgIHZhciBjcmVkZW50aWFsID0gY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgKyAnLycgKyBzY29wZTtcblxuICAgIGZpZWxkc1snYnVja2V0J10gPSBidWNrZXQ7XG4gICAgZmllbGRzWydYLUFtei1BbGdvcml0aG0nXSA9ICdBV1M0LUhNQUMtU0hBMjU2JztcbiAgICBmaWVsZHNbJ1gtQW16LUNyZWRlbnRpYWwnXSA9IGNyZWRlbnRpYWw7XG4gICAgZmllbGRzWydYLUFtei1EYXRlJ10gPSBzaWduaW5nRGF0ZTtcbiAgICBpZiAoY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuKSB7XG4gICAgICBmaWVsZHNbJ1gtQW16LVNlY3VyaXR5LVRva2VuJ10gPSBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW47XG4gICAgfVxuICAgIGZvciAodmFyIGZpZWxkIGluIGZpZWxkcykge1xuICAgICAgaWYgKGZpZWxkcy5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHt9O1xuICAgICAgICBjb25kaXRpb25bZmllbGRdID0gZmllbGRzW2ZpZWxkXTtcbiAgICAgICAgY29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmllbGRzLlBvbGljeSA9IHRoaXMucHJlcGFyZVBvc3RQb2xpY3koXG4gICAgICBuZXcgRGF0ZShub3cudmFsdWVPZigpICsgZXhwaXJlc0luU2Vjb25kcyAqIDEwMDApLFxuICAgICAgY29uZGl0aW9uc1xuICAgICk7XG4gICAgZmllbGRzWydYLUFtei1TaWduYXR1cmUnXSA9IEFXUy51dGlsLmNyeXB0by5obWFjKFxuICAgICAgdjRDcmVkZW50aWFscy5nZXRTaWduaW5nS2V5KGNyZWRlbnRpYWxzLCBzaG9ydERhdGUsIHJlZ2lvbiwgJ3MzJywgdHJ1ZSksXG4gICAgICBmaWVsZHMuUG9saWN5LFxuICAgICAgJ2hleCdcbiAgICApO1xuXG4gICAgcmV0dXJuIGZpZWxkcztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwcmVwYXJlUG9zdFBvbGljeTogZnVuY3Rpb24gcHJlcGFyZVBvc3RQb2xpY3koZXhwaXJhdGlvbiwgY29uZGl0aW9ucykge1xuICAgIHJldHVybiBBV1MudXRpbC5iYXNlNjQuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGV4cGlyYXRpb246IEFXUy51dGlsLmRhdGUuaXNvODYwMShleHBpcmF0aW9uKSxcbiAgICAgIGNvbmRpdGlvbnM6IGNvbmRpdGlvbnNcbiAgICB9KSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcHJlcGFyZVNpZ25lZFVybDogZnVuY3Rpb24gcHJlcGFyZVNpZ25lZFVybChyZXF1ZXN0KSB7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcigndmFsaWRhdGUnLCByZXF1ZXN0LnNlcnZpY2Uubm9QcmVzaWduZWRDb250ZW50TGVuZ3RoKTtcbiAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdidWlsZCcsIHJlcXVlc3Quc2VydmljZS5hZGRDb250ZW50VHlwZSk7XG4gICAgaWYgKCFyZXF1ZXN0LnBhcmFtcy5Cb2R5KSB7XG4gICAgICAvLyBubyBDb250ZW50LU1ENS9TSEEtMjU2IGlmIGJvZHkgaXMgbm90IHByb3ZpZGVkXG4gICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdidWlsZCcsIHJlcXVlc3Quc2VydmljZS5jb21wdXRlQ29udGVudE1kNSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2FmdGVyQnVpbGQnLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5DT01QVVRFX1NIQTI1Nik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQHBhcmFtIHJlcXVlc3RcbiAgICovXG4gIGRpc2FibGVCb2R5U2lnbmluZzogZnVuY3Rpb24gZGlzYWJsZUJvZHlTaWduaW5nKHJlcXVlc3QpIHtcbiAgICB2YXIgaGVhZGVycyA9IHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVycztcbiAgICAvLyBBZGQgdGhlIGhlYWRlciB0byBhbnl0aGluZyB0aGF0IGlzbid0IGEgcHJlc2lnbmVkIHVybCwgdW5sZXNzIHRoYXQgcHJlc2lnbmVkIHVybCBoYWQgYSBib2R5IGRlZmluZWRcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoZWFkZXJzLCAncHJlc2lnbmVkLWV4cGlyZXMnKSkge1xuICAgICAgaGVhZGVyc1snWC1BbXotQ29udGVudC1TaGEyNTYnXSA9ICdVTlNJR05FRC1QQVlMT0FEJztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbm9QcmVzaWduZWRDb250ZW50TGVuZ3RoOiBmdW5jdGlvbiBub1ByZXNpZ25lZENvbnRlbnRMZW5ndGgocmVxdWVzdCkge1xuICAgIGlmIChyZXF1ZXN0LnBhcmFtcy5Db250ZW50TGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7Y29kZTogJ1VuZXhwZWN0ZWRQYXJhbWV0ZXInLFxuICAgICAgICBtZXNzYWdlOiAnQ29udGVudExlbmd0aCBpcyBub3Qgc3VwcG9ydGVkIGluIHByZS1zaWduZWQgVVJMcy4nfSk7XG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZUJ1Y2tldDogZnVuY3Rpb24gY3JlYXRlQnVja2V0KHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAvLyBXaGVuIGNyZWF0aW5nIGEgYnVja2V0ICpvdXRzaWRlKiB0aGUgY2xhc3NpYyByZWdpb24sIHRoZSBsb2NhdGlvblxuICAgIC8vIGNvbnN0cmFpbnQgbXVzdCBiZSBzZXQgZm9yIHRoZSBidWNrZXQgYW5kIGl0IG11c3QgbWF0Y2ggdGhlIGVuZHBvaW50LlxuICAgIC8vIFRoaXMgY2h1bmsgb2YgY29kZSB3aWxsIHNldCB0aGUgbG9jYXRpb24gY29uc3RyYWludCBwYXJhbSBiYXNlZFxuICAgIC8vIG9uIHRoZSByZWdpb24gKHdoZW4gcG9zc2libGUpLCBidXQgaXQgd2lsbCBub3Qgb3ZlcnJpZGUgYSBwYXNzZWQtaW5cbiAgICAvLyBsb2NhdGlvbiBjb25zdHJhaW50LlxuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nIHx8ICFwYXJhbXMpIHtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgcGFyYW1zO1xuICAgICAgcGFyYW1zID0ge307XG4gICAgfVxuICAgIHZhciBob3N0bmFtZSA9IHRoaXMuZW5kcG9pbnQuaG9zdG5hbWU7XG4gICAgaWYgKGhvc3RuYW1lICE9PSB0aGlzLmFwaS5nbG9iYWxFbmRwb2ludCAmJiAhcGFyYW1zLkNyZWF0ZUJ1Y2tldENvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHBhcmFtcy5DcmVhdGVCdWNrZXRDb25maWd1cmF0aW9uID0geyBMb2NhdGlvbkNvbnN0cmFpbnQ6IHRoaXMuY29uZmlnLnJlZ2lvbiB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdCgnY3JlYXRlQnVja2V0JywgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBzZWUgQVdTLlMzLk1hbmFnZWRVcGxvYWRcbiAgICogQG92ZXJsb2FkIHVwbG9hZChwYXJhbXMgPSB7fSwgW29wdGlvbnNdLCBbY2FsbGJhY2tdKVxuICAgKiAgIFVwbG9hZHMgYW4gYXJiaXRyYXJpbHkgc2l6ZWQgYnVmZmVyLCBibG9iLCBvciBzdHJlYW0sIHVzaW5nIGludGVsbGlnZW50XG4gICAqICAgY29uY3VycmVudCBoYW5kbGluZyBvZiBwYXJ0cyBpZiB0aGUgcGF5bG9hZCBpcyBsYXJnZSBlbm91Z2guIFlvdSBjYW5cbiAgICogICBjb25maWd1cmUgdGhlIGNvbmN1cnJlbnQgcXVldWUgc2l6ZSBieSBzZXR0aW5nIGBvcHRpb25zYC4gTm90ZSB0aGF0IHRoaXNcbiAgICogICBpcyB0aGUgb25seSBvcGVyYXRpb24gZm9yIHdoaWNoIHRoZSBTREsgY2FuIHJldHJ5IHJlcXVlc3RzIHdpdGggc3RyZWFtXG4gICAqICAgYm9kaWVzLlxuICAgKlxuICAgKiAgIEBwYXJhbSAoc2VlIEFXUy5TMy5wdXRPYmplY3QpXG4gICAqICAgQG9wdGlvbiAoc2VlIEFXUy5TMy5NYW5hZ2VkVXBsb2FkLmNvbnN0cnVjdG9yKVxuICAgKiAgIEByZXR1cm4gW0FXUy5TMy5NYW5hZ2VkVXBsb2FkXSB0aGUgbWFuYWdlZCB1cGxvYWQgb2JqZWN0IHRoYXQgY2FuIGNhbGxcbiAgICogICAgIGBzZW5kKClgIG9yIHRyYWNrIHByb2dyZXNzLlxuICAgKiAgIEBleGFtcGxlIFVwbG9hZGluZyBhIHN0cmVhbSBvYmplY3RcbiAgICogICAgIHZhciBwYXJhbXMgPSB7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5JywgQm9keTogc3RyZWFtfTtcbiAgICogICAgIHMzLnVwbG9hZChwYXJhbXMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICAgICBjb25zb2xlLmxvZyhlcnIsIGRhdGEpO1xuICAgKiAgICAgfSk7XG4gICAqICAgQGV4YW1wbGUgVXBsb2FkaW5nIGEgc3RyZWFtIHdpdGggY29uY3VycmVuY3kgb2YgMSBhbmQgcGFydFNpemUgb2YgMTBtYlxuICAgKiAgICAgdmFyIHBhcmFtcyA9IHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLCBCb2R5OiBzdHJlYW19O1xuICAgKiAgICAgdmFyIG9wdGlvbnMgPSB7cGFydFNpemU6IDEwICogMTAyNCAqIDEwMjQsIHF1ZXVlU2l6ZTogMX07XG4gICAqICAgICBzMy51cGxvYWQocGFyYW1zLCBvcHRpb25zLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICogICAgICAgY29uc29sZS5sb2coZXJyLCBkYXRhKTtcbiAgICogICAgIH0pO1xuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBkYXRhKVxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBhbiBlcnJvciBvciBudWxsIGlmIG5vIGVycm9yIG9jY3VycmVkLlxuICAgKiAgIEBwYXJhbSBkYXRhIFttYXBdIFRoZSByZXNwb25zZSBkYXRhIGZyb20gdGhlIHN1Y2Nlc3NmdWwgdXBsb2FkOlxuICAgKiAgIEBwYXJhbSBkYXRhLkxvY2F0aW9uIFtTdHJpbmddIHRoZSBVUkwgb2YgdGhlIHVwbG9hZGVkIG9iamVjdFxuICAgKiAgIEBwYXJhbSBkYXRhLkVUYWcgW1N0cmluZ10gdGhlIEVUYWcgb2YgdGhlIHVwbG9hZGVkIG9iamVjdFxuICAgKiAgIEBwYXJhbSBkYXRhLkJ1Y2tldCBbU3RyaW5nXSAgdGhlIGJ1Y2tldCB0byB3aGljaCB0aGUgb2JqZWN0IHdhcyB1cGxvYWRlZFxuICAgKiAgIEBwYXJhbSBkYXRhLktleSBbU3RyaW5nXSB0aGUga2V5IHRvIHdoaWNoIHRoZSBvYmplY3Qgd2FzIHVwbG9hZGVkXG4gICAqL1xuICB1cGxvYWQ6IGZ1bmN0aW9uIHVwbG9hZChwYXJhbXMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nICYmIGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMgPSBBV1MudXRpbC5tZXJnZShvcHRpb25zIHx8IHt9LCB7c2VydmljZTogdGhpcywgcGFyYW1zOiBwYXJhbXN9KTtcblxuICAgIHZhciB1cGxvYWRlciA9IG5ldyBBV1MuUzMuTWFuYWdlZFVwbG9hZChvcHRpb25zKTtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB1cGxvYWRlci5zZW5kKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdXBsb2FkZXI7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuUzMuYWRkUHJvbWlzZXNUb0NsYXNzID0gZnVuY3Rpb24gYWRkUHJvbWlzZXNUb0NsYXNzKFByb21pc2VEZXBlbmRlbmN5KSB7XG4gIHRoaXMucHJvdG90eXBlLmdldFNpZ25lZFVybFByb21pc2UgPSBBV1MudXRpbC5wcm9taXNpZnlNZXRob2QoJ2dldFNpZ25lZFVybCcsIFByb21pc2VEZXBlbmRlbmN5KTtcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TMy5kZWxldGVQcm9taXNlc0Zyb21DbGFzcyA9IGZ1bmN0aW9uIGRlbGV0ZVByb21pc2VzRnJvbUNsYXNzKCkge1xuICBkZWxldGUgdGhpcy5wcm90b3R5cGUuZ2V0U2lnbmVkVXJsUHJvbWlzZTtcbn07XG5cbkFXUy51dGlsLmFkZFByb21pc2VzKEFXUy5TMyk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIHJlc29sdmVSZWdpb25hbEVuZHBvaW50c0ZsYWcgPSByZXF1aXJlKCcuLi9jb25maWdfcmVnaW9uYWxfZW5kcG9pbnQnKTtcbnZhciBFTlZfUkVHSU9OQUxfRU5EUE9JTlRfRU5BQkxFRCA9ICdBV1NfU1RTX1JFR0lPTkFMX0VORFBPSU5UUyc7XG52YXIgQ09ORklHX1JFR0lPTkFMX0VORFBPSU5UX0VOQUJMRUQgPSAnc3RzX3JlZ2lvbmFsX2VuZHBvaW50cyc7XG5cbkFXUy51dGlsLnVwZGF0ZShBV1MuU1RTLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogQG92ZXJsb2FkIGNyZWRlbnRpYWxzRnJvbShkYXRhLCBjcmVkZW50aWFscyA9IG51bGwpXG4gICAqICAgQ3JlYXRlcyBhIGNyZWRlbnRpYWxzIG9iamVjdCBmcm9tIFNUUyByZXNwb25zZSBkYXRhIGNvbnRhaW5pbmdcbiAgICogICBjcmVkZW50aWFscyBpbmZvcm1hdGlvbi4gVXNlZnVsIGZvciBxdWlja2x5IHNldHRpbmcgQVdTIGNyZWRlbnRpYWxzLlxuICAgKlxuICAgKiAgIEBub3RlIFRoaXMgaXMgYSBsb3ctbGV2ZWwgdXRpbGl0eSBmdW5jdGlvbi4gSWYgeW91IHdhbnQgdG8gbG9hZCB0ZW1wb3JhcnlcbiAgICogICAgIGNyZWRlbnRpYWxzIGludG8geW91ciBwcm9jZXNzIGZvciBzdWJzZXF1ZW50IHJlcXVlc3RzIHRvIEFXUyByZXNvdXJjZXMsXG4gICAqICAgICB5b3Ugc2hvdWxkIHVzZSB7QVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzfSBpbnN0ZWFkLlxuICAgKiAgIEBwYXJhbSBkYXRhIFttYXBdIGRhdGEgcmV0cmlldmVkIGZyb20gYSBjYWxsIHRvIHtnZXRGZWRlcmF0ZWRUb2tlbn0sXG4gICAqICAgICB7Z2V0U2Vzc2lvblRva2VufSwge2Fzc3VtZVJvbGV9LCBvciB7YXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0uXG4gICAqICAgQHBhcmFtIGNyZWRlbnRpYWxzIFtBV1MuQ3JlZGVudGlhbHNdIGFuIG9wdGlvbmFsIGNyZWRlbnRpYWxzIG9iamVjdCB0b1xuICAgKiAgICAgZmlsbCBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG9iamVjdC4gVXNlZnVsIHdoZW4gbW9kaWZ5aW5nIGFuXG4gICAqICAgICBleGlzdGluZyBjcmVkZW50aWFscyBvYmplY3QgZnJvbSBhIHJlZnJlc2ggY2FsbC5cbiAgICogICBAcmV0dXJuIFtBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHNdIHRoZSBzZXQgb2YgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzXG4gICAqICAgICBsb2FkZWQgZnJvbSBhIHJhdyBTVFMgb3BlcmF0aW9uIHJlc3BvbnNlLlxuICAgKiAgIEBleGFtcGxlIFVzaW5nIGNyZWRlbnRpYWxzRnJvbSB0byBsb2FkIGdsb2JhbCBBV1MgY3JlZGVudGlhbHNcbiAgICogICAgIHZhciBzdHMgPSBuZXcgQVdTLlNUUygpO1xuICAgKiAgICAgc3RzLmdldFNlc3Npb25Ub2tlbihmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAqICAgICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKFwiRXJyb3IgZ2V0dGluZyBjcmVkZW50aWFsc1wiKTtcbiAgICogICAgICAgZWxzZSB7XG4gICAqICAgICAgICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IHN0cy5jcmVkZW50aWFsc0Zyb20oZGF0YSk7XG4gICAqICAgICAgIH1cbiAgICogICAgIH0pO1xuICAgKiAgIEBzZWUgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzXG4gICAqL1xuICBjcmVkZW50aWFsc0Zyb206IGZ1bmN0aW9uIGNyZWRlbnRpYWxzRnJvbShkYXRhLCBjcmVkZW50aWFscykge1xuICAgIGlmICghZGF0YSkgcmV0dXJuIG51bGw7XG4gICAgaWYgKCFjcmVkZW50aWFscykgY3JlZGVudGlhbHMgPSBuZXcgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzKCk7XG4gICAgY3JlZGVudGlhbHMuZXhwaXJlZCA9IGZhbHNlO1xuICAgIGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkID0gZGF0YS5DcmVkZW50aWFscy5BY2Nlc3NLZXlJZDtcbiAgICBjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXkgPSBkYXRhLkNyZWRlbnRpYWxzLlNlY3JldEFjY2Vzc0tleTtcbiAgICBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4gPSBkYXRhLkNyZWRlbnRpYWxzLlNlc3Npb25Ub2tlbjtcbiAgICBjcmVkZW50aWFscy5leHBpcmVUaW1lID0gZGF0YS5DcmVkZW50aWFscy5FeHBpcmF0aW9uO1xuICAgIHJldHVybiBjcmVkZW50aWFscztcbiAgfSxcblxuICBhc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5OiBmdW5jdGlvbiBhc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5KHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5tYWtlVW5hdXRoZW50aWNhdGVkUmVxdWVzdCgnYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eScsIHBhcmFtcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIGFzc3VtZVJvbGVXaXRoU0FNTDogZnVuY3Rpb24gYXNzdW1lUm9sZVdpdGhTQU1MKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5tYWtlVW5hdXRoZW50aWNhdGVkUmVxdWVzdCgnYXNzdW1lUm9sZVdpdGhTQU1MJywgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2V0dXBSZXF1ZXN0TGlzdGVuZXJzOiBmdW5jdGlvbiBzZXR1cFJlcXVlc3RMaXN0ZW5lcnMocmVxdWVzdCkge1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ3ZhbGlkYXRlJywgdGhpcy5vcHRJblJlZ2lvbmFsRW5kcG9pbnQsIHRydWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG9wdEluUmVnaW9uYWxFbmRwb2ludDogZnVuY3Rpb24gb3B0SW5SZWdpb25hbEVuZHBvaW50KHJlcSkge1xuICAgIHZhciBzZXJ2aWNlID0gcmVxLnNlcnZpY2U7XG4gICAgdmFyIGNvbmZpZyA9IHNlcnZpY2UuY29uZmlnO1xuICAgIGNvbmZpZy5zdHNSZWdpb25hbEVuZHBvaW50cyA9IHJlc29sdmVSZWdpb25hbEVuZHBvaW50c0ZsYWcoc2VydmljZS5fb3JpZ2luYWxDb25maWcsIHtcbiAgICAgIGVudjogRU5WX1JFR0lPTkFMX0VORFBPSU5UX0VOQUJMRUQsXG4gICAgICBzaGFyZWRDb25maWc6IENPTkZJR19SRUdJT05BTF9FTkRQT0lOVF9FTkFCTEVELFxuICAgICAgY2xpZW50Q29uZmlnOiAnc3RzUmVnaW9uYWxFbmRwb2ludHMnXG4gICAgfSk7XG4gICAgaWYgKFxuICAgICAgY29uZmlnLnN0c1JlZ2lvbmFsRW5kcG9pbnRzID09PSAncmVnaW9uYWwnICYmXG4gICAgICBzZXJ2aWNlLmlzR2xvYmFsRW5kcG9pbnRcbiAgICApIHtcbiAgICAgIC8vY2xpZW50IHdpbGwgdGhyb3cgaWYgcmVnaW9uIGlzIG5vdCBzdXBwbGllZDsgcmVxdWVzdCB3aWxsIGJlIHNpZ25lZCB3aXRoIHNwZWNpZmllZCByZWdpb25cbiAgICAgIGlmICghY29uZmlnLnJlZ2lvbikge1xuICAgICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgICB7Y29kZTogJ0NvbmZpZ0Vycm9yJywgbWVzc2FnZTogJ01pc3NpbmcgcmVnaW9uIGluIGNvbmZpZyd9KTtcbiAgICAgIH1cbiAgICAgIHZhciBpbnNlcnRQb2ludCA9IGNvbmZpZy5lbmRwb2ludC5pbmRleE9mKCcuYW1hem9uYXdzLmNvbScpO1xuICAgICAgdmFyIHJlZ2lvbmFsRW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnQuc3Vic3RyaW5nKDAsIGluc2VydFBvaW50KSArXG4gICAgICAgICcuJyArIGNvbmZpZy5yZWdpb24gKyBjb25maWcuZW5kcG9pbnQuc3Vic3RyaW5nKGluc2VydFBvaW50KTtcbiAgICAgIHJlcS5odHRwUmVxdWVzdC51cGRhdGVFbmRwb2ludChyZWdpb25hbEVuZHBvaW50KTtcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5yZWdpb24gPSBjb25maWcucmVnaW9uO1xuICAgIH1cbiAgfVxuXG59KTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciBleHBpcmVzSGVhZGVyID0gJ3ByZXNpZ25lZC1leHBpcmVzJztcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2lnbmVkVXJsQnVpbGRlcihyZXF1ZXN0KSB7XG4gIHZhciBleHBpcmVzID0gcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzW2V4cGlyZXNIZWFkZXJdO1xuICB2YXIgc2lnbmVyQ2xhc3MgPSByZXF1ZXN0LnNlcnZpY2UuZ2V0U2lnbmVyQ2xhc3MocmVxdWVzdCk7XG5cbiAgZGVsZXRlIHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1snVXNlci1BZ2VudCddO1xuICBkZWxldGUgcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzWydYLUFtei1Vc2VyLUFnZW50J107XG5cbiAgaWYgKHNpZ25lckNsYXNzID09PSBBV1MuU2lnbmVycy5WNCkge1xuICAgIGlmIChleHBpcmVzID4gNjA0ODAwKSB7IC8vIG9uZSB3ZWVrIGV4cGlyeSBpcyBpbnZhbGlkXG4gICAgICB2YXIgbWVzc2FnZSA9ICdQcmVzaWduaW5nIGRvZXMgbm90IHN1cHBvcnQgZXhwaXJ5IHRpbWUgZ3JlYXRlciAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3RoYW4gYSB3ZWVrIHdpdGggU2lnVjQgc2lnbmluZy4nO1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWRFeHBpcnlUaW1lJywgbWVzc2FnZTogbWVzc2FnZSwgcmV0cnlhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1tleHBpcmVzSGVhZGVyXSA9IGV4cGlyZXM7XG4gIH0gZWxzZSBpZiAoc2lnbmVyQ2xhc3MgPT09IEFXUy5TaWduZXJzLlMzKSB7XG4gICAgdmFyIG5vdyA9IHJlcXVlc3Quc2VydmljZSA/IHJlcXVlc3Quc2VydmljZS5nZXRTa2V3Q29ycmVjdGVkRGF0ZSgpIDogQVdTLnV0aWwuZGF0ZS5nZXREYXRlKCk7XG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzW2V4cGlyZXNIZWFkZXJdID0gcGFyc2VJbnQoXG4gICAgICBBV1MudXRpbC5kYXRlLnVuaXhUaW1lc3RhbXAobm93KSArIGV4cGlyZXMsIDEwKS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICBtZXNzYWdlOiAnUHJlc2lnbmluZyBvbmx5IHN1cHBvcnRzIFMzIG9yIFNpZ1Y0IHNpZ25pbmcuJyxcbiAgICAgIGNvZGU6ICdVbnN1cHBvcnRlZFNpZ25lcicsIHJldHJ5YWJsZTogZmFsc2VcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzaWduZWRVcmxTaWduZXIocmVxdWVzdCkge1xuICB2YXIgZW5kcG9pbnQgPSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmVuZHBvaW50O1xuICB2YXIgcGFyc2VkVXJsID0gQVdTLnV0aWwudXJsUGFyc2UocmVxdWVzdC5odHRwUmVxdWVzdC5wYXRoKTtcbiAgdmFyIHF1ZXJ5UGFyYW1zID0ge307XG5cbiAgaWYgKHBhcnNlZFVybC5zZWFyY2gpIHtcbiAgICBxdWVyeVBhcmFtcyA9IEFXUy51dGlsLnF1ZXJ5U3RyaW5nUGFyc2UocGFyc2VkVXJsLnNlYXJjaC5zdWJzdHIoMSkpO1xuICB9XG5cbiAgdmFyIGF1dGggPSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXS5zcGxpdCgnICcpO1xuICBpZiAoYXV0aFswXSA9PT0gJ0FXUycpIHtcbiAgICBhdXRoID0gYXV0aFsxXS5zcGxpdCgnOicpO1xuICAgIHF1ZXJ5UGFyYW1zWydBV1NBY2Nlc3NLZXlJZCddID0gYXV0aFswXTtcbiAgICBxdWVyeVBhcmFtc1snU2lnbmF0dXJlJ10gPSBhdXRoWzFdO1xuXG4gICAgQVdTLnV0aWwuZWFjaChyZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5ID09PSBleHBpcmVzSGVhZGVyKSBrZXkgPSAnRXhwaXJlcyc7XG4gICAgICBpZiAoa2V5LmluZGV4T2YoJ3gtYW16LW1ldGEtJykgPT09IDApIHtcbiAgICAgICAgLy8gRGVsZXRlIGV4aXN0aW5nLCBwb3RlbnRpYWxseSBub3Qgbm9ybWFsaXplZCBrZXlcbiAgICAgICAgZGVsZXRlIHF1ZXJ5UGFyYW1zW2tleV07XG4gICAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgICAgcXVlcnlQYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIGRlbGV0ZSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbZXhwaXJlc0hlYWRlcl07XG4gICAgZGVsZXRlIHF1ZXJ5UGFyYW1zWydBdXRob3JpemF0aW9uJ107XG4gICAgZGVsZXRlIHF1ZXJ5UGFyYW1zWydIb3N0J107XG4gIH0gZWxzZSBpZiAoYXV0aFswXSA9PT0gJ0FXUzQtSE1BQy1TSEEyNTYnKSB7IC8vIFNpZ1Y0IHNpZ25pbmdcbiAgICBhdXRoLnNoaWZ0KCk7XG4gICAgdmFyIHJlc3QgPSBhdXRoLmpvaW4oJyAnKTtcbiAgICB2YXIgc2lnbmF0dXJlID0gcmVzdC5tYXRjaCgvU2lnbmF0dXJlPSguKj8pKD86LHxcXHN8XFxyP1xcbnwkKS8pWzFdO1xuICAgIHF1ZXJ5UGFyYW1zWydYLUFtei1TaWduYXR1cmUnXSA9IHNpZ25hdHVyZTtcbiAgICBkZWxldGUgcXVlcnlQYXJhbXNbJ0V4cGlyZXMnXTtcbiAgfVxuXG4gIC8vIGJ1aWxkIFVSTFxuICBlbmRwb2ludC5wYXRobmFtZSA9IHBhcnNlZFVybC5wYXRobmFtZTtcbiAgZW5kcG9pbnQuc2VhcmNoID0gQVdTLnV0aWwucXVlcnlQYXJhbXNUb1N0cmluZyhxdWVyeVBhcmFtcyk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TaWduZXJzLlByZXNpZ24gPSBpbmhlcml0KHtcbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2lnbjogZnVuY3Rpb24gc2lnbihyZXF1ZXN0LCBleHBpcmVUaW1lLCBjYWxsYmFjaykge1xuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1tleHBpcmVzSGVhZGVyXSA9IGV4cGlyZVRpbWUgfHwgMzYwMDtcbiAgICByZXF1ZXN0Lm9uKCdidWlsZCcsIHNpZ25lZFVybEJ1aWxkZXIpO1xuICAgIHJlcXVlc3Qub24oJ3NpZ24nLCBzaWduZWRVcmxTaWduZXIpO1xuICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ2FmdGVyQnVpbGQnLFxuICAgICAgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuU0VUX0NPTlRFTlRfTEVOR1RIKTtcbiAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdhZnRlckJ1aWxkJyxcbiAgICAgIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLkNPTVBVVEVfU0hBMjU2KTtcblxuICAgIHJlcXVlc3QuZW1pdCgnYmVmb3JlUHJlc2lnbicsIFtyZXF1ZXN0XSk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHJlcXVlc3QuYnVpbGQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNlLmVycm9yKSBjYWxsYmFjayh0aGlzLnJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgQVdTLnV0aWwudXJsRm9ybWF0KHJlcXVlc3QuaHR0cFJlcXVlc3QuZW5kcG9pbnQpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3QuYnVpbGQoKTtcbiAgICAgIGlmIChyZXF1ZXN0LnJlc3BvbnNlLmVycm9yKSB0aHJvdyByZXF1ZXN0LnJlc3BvbnNlLmVycm9yO1xuICAgICAgcmV0dXJuIEFXUy51dGlsLnVybEZvcm1hdChyZXF1ZXN0Lmh0dHBSZXF1ZXN0LmVuZHBvaW50KTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5TaWduZXJzLlByZXNpZ247XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TaWduZXJzLlJlcXVlc3RTaWduZXIgPSBpbmhlcml0KHtcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFJlcXVlc3RTaWduZXIocmVxdWVzdCkge1xuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIH0sXG5cbiAgc2V0U2VydmljZUNsaWVudElkOiBmdW5jdGlvbiBzZXRTZXJ2aWNlQ2xpZW50SWQoaWQpIHtcbiAgICB0aGlzLnNlcnZpY2VDbGllbnRJZCA9IGlkO1xuICB9LFxuXG4gIGdldFNlcnZpY2VDbGllbnRJZDogZnVuY3Rpb24gZ2V0U2VydmljZUNsaWVudElkKCkge1xuICAgIHJldHVybiB0aGlzLnNlcnZpY2VDbGllbnRJZDtcbiAgfVxufSk7XG5cbkFXUy5TaWduZXJzLlJlcXVlc3RTaWduZXIuZ2V0VmVyc2lvbiA9IGZ1bmN0aW9uIGdldFZlcnNpb24odmVyc2lvbikge1xuICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICBjYXNlICd2Mic6IHJldHVybiBBV1MuU2lnbmVycy5WMjtcbiAgICBjYXNlICd2Myc6IHJldHVybiBBV1MuU2lnbmVycy5WMztcbiAgICBjYXNlICdzM3Y0JzogcmV0dXJuIEFXUy5TaWduZXJzLlY0O1xuICAgIGNhc2UgJ3Y0JzogcmV0dXJuIEFXUy5TaWduZXJzLlY0O1xuICAgIGNhc2UgJ3MzJzogcmV0dXJuIEFXUy5TaWduZXJzLlMzO1xuICAgIGNhc2UgJ3YzaHR0cHMnOiByZXR1cm4gQVdTLlNpZ25lcnMuVjNIdHRwcztcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gc2lnbmluZyB2ZXJzaW9uICcgKyB2ZXJzaW9uKTtcbn07XG5cbnJlcXVpcmUoJy4vdjInKTtcbnJlcXVpcmUoJy4vdjMnKTtcbnJlcXVpcmUoJy4vdjNodHRwcycpO1xucmVxdWlyZSgnLi92NCcpO1xucmVxdWlyZSgnLi9zMycpO1xucmVxdWlyZSgnLi9wcmVzaWduJyk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuU2lnbmVycy5TMyA9IGluaGVyaXQoQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lciwge1xuICAvKipcbiAgICogV2hlbiBidWlsZGluZyB0aGUgc3RyaW5nVG9TaWduLCB0aGVzZSBzdWIgcmVzb3VyY2UgcGFyYW1zIHNob3VsZCBiZVxuICAgKiBwYXJ0IG9mIHRoZSBjYW5vbmljYWwgcmVzb3VyY2Ugc3RyaW5nIHdpdGggdGhlaXIgTk9OLWRlY29kZWQgdmFsdWVzXG4gICAqL1xuICBzdWJSZXNvdXJjZXM6IHtcbiAgICAnYWNsJzogMSxcbiAgICAnYWNjZWxlcmF0ZSc6IDEsXG4gICAgJ2FuYWx5dGljcyc6IDEsXG4gICAgJ2NvcnMnOiAxLFxuICAgICdsaWZlY3ljbGUnOiAxLFxuICAgICdkZWxldGUnOiAxLFxuICAgICdpbnZlbnRvcnknOiAxLFxuICAgICdsb2NhdGlvbic6IDEsXG4gICAgJ2xvZ2dpbmcnOiAxLFxuICAgICdtZXRyaWNzJzogMSxcbiAgICAnbm90aWZpY2F0aW9uJzogMSxcbiAgICAncGFydE51bWJlcic6IDEsXG4gICAgJ3BvbGljeSc6IDEsXG4gICAgJ3JlcXVlc3RQYXltZW50JzogMSxcbiAgICAncmVwbGljYXRpb24nOiAxLFxuICAgICdyZXN0b3JlJzogMSxcbiAgICAndGFnZ2luZyc6IDEsXG4gICAgJ3RvcnJlbnQnOiAxLFxuICAgICd1cGxvYWRJZCc6IDEsXG4gICAgJ3VwbG9hZHMnOiAxLFxuICAgICd2ZXJzaW9uSWQnOiAxLFxuICAgICd2ZXJzaW9uaW5nJzogMSxcbiAgICAndmVyc2lvbnMnOiAxLFxuICAgICd3ZWJzaXRlJzogMVxuICB9LFxuXG4gIC8vIHdoZW4gYnVpbGRpbmcgdGhlIHN0cmluZ1RvU2lnbiwgdGhlc2UgcXVlcnlzdHJpbmcgcGFyYW1zIHNob3VsZCBiZVxuICAvLyBwYXJ0IG9mIHRoZSBjYW5vbmljYWwgcmVzb3VyY2Ugc3RyaW5nIHdpdGggdGhlaXIgTk9OLWVuY29kZWQgdmFsdWVzXG4gIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICdyZXNwb25zZS1jb250ZW50LXR5cGUnOiAxLFxuICAgICdyZXNwb25zZS1jb250ZW50LWxhbmd1YWdlJzogMSxcbiAgICAncmVzcG9uc2UtZXhwaXJlcyc6IDEsXG4gICAgJ3Jlc3BvbnNlLWNhY2hlLWNvbnRyb2wnOiAxLFxuICAgICdyZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uJzogMSxcbiAgICAncmVzcG9uc2UtY29udGVudC1lbmNvZGluZyc6IDFcbiAgfSxcblxuICBhZGRBdXRob3JpemF0aW9uOiBmdW5jdGlvbiBhZGRBdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRlKSB7XG4gICAgaWYgKCF0aGlzLnJlcXVlc3QuaGVhZGVyc1sncHJlc2lnbmVkLWV4cGlyZXMnXSkge1xuICAgICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LURhdGUnXSA9IEFXUy51dGlsLmRhdGUucmZjODIyKGRhdGUpO1xuICAgIH1cblxuICAgIGlmIChjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4pIHtcbiAgICAgIC8vIHByZXNpZ25lZCBVUkxzIHJlcXVpcmUgdGhpcyBoZWFkZXIgdG8gYmUgbG93ZXJjYXNlZFxuICAgICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LXNlY3VyaXR5LXRva2VuJ10gPSBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW47XG4gICAgfVxuXG4gICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMuc2lnbihjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXksIHRoaXMuc3RyaW5nVG9TaWduKCkpO1xuICAgIHZhciBhdXRoID0gJ0FXUyAnICsgY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgKyAnOicgKyBzaWduYXR1cmU7XG5cbiAgICB0aGlzLnJlcXVlc3QuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYXV0aDtcbiAgfSxcblxuICBzdHJpbmdUb1NpZ246IGZ1bmN0aW9uIHN0cmluZ1RvU2lnbigpIHtcbiAgICB2YXIgciA9IHRoaXMucmVxdWVzdDtcblxuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHBhcnRzLnB1c2goci5tZXRob2QpO1xuICAgIHBhcnRzLnB1c2goci5oZWFkZXJzWydDb250ZW50LU1ENSddIHx8ICcnKTtcbiAgICBwYXJ0cy5wdXNoKHIuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gfHwgJycpO1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgXCJEYXRlXCIgaGVhZGVyLCBidXQgd2UgdXNlIFgtQW16LURhdGUuXG4gICAgLy8gVGhlIFMzIHNpZ25pbmcgbWVjaGFuaXNtIHJlcXVpcmVzIHVzIHRvIHBhc3MgYW4gZW1wdHlcbiAgICAvLyBzdHJpbmcgZm9yIHRoaXMgRGF0ZSBoZWFkZXIgcmVnYXJkbGVzcy5cbiAgICBwYXJ0cy5wdXNoKHIuaGVhZGVyc1sncHJlc2lnbmVkLWV4cGlyZXMnXSB8fCAnJyk7XG5cbiAgICB2YXIgaGVhZGVycyA9IHRoaXMuY2Fub25pY2FsaXplZEFtekhlYWRlcnMoKTtcbiAgICBpZiAoaGVhZGVycykgcGFydHMucHVzaChoZWFkZXJzKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuY2Fub25pY2FsaXplZFJlc291cmNlKCkpO1xuXG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJ1xcbicpO1xuXG4gIH0sXG5cbiAgY2Fub25pY2FsaXplZEFtekhlYWRlcnM6IGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZWRBbXpIZWFkZXJzKCkge1xuXG4gICAgdmFyIGFtekhlYWRlcnMgPSBbXTtcblxuICAgIEFXUy51dGlsLmVhY2godGhpcy5yZXF1ZXN0LmhlYWRlcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAobmFtZS5tYXRjaCgvXngtYW16LS9pKSlcbiAgICAgICAgYW16SGVhZGVycy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuXG4gICAgYW16SGVhZGVycy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS50b0xvd2VyQ2FzZSgpIDwgYi50b0xvd2VyQ2FzZSgpID8gLTEgOiAxO1xuICAgIH0pO1xuXG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgQVdTLnV0aWwuYXJyYXlFYWNoLmNhbGwodGhpcywgYW16SGVhZGVycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHBhcnRzLnB1c2gobmFtZS50b0xvd2VyQ2FzZSgpICsgJzonICsgU3RyaW5nKHRoaXMucmVxdWVzdC5oZWFkZXJzW25hbWVdKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcGFydHMuam9pbignXFxuJyk7XG5cbiAgfSxcblxuICBjYW5vbmljYWxpemVkUmVzb3VyY2U6IGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZWRSZXNvdXJjZSgpIHtcblxuICAgIHZhciByID0gdGhpcy5yZXF1ZXN0O1xuXG4gICAgdmFyIHBhcnRzID0gci5wYXRoLnNwbGl0KCc/Jyk7XG4gICAgdmFyIHBhdGggPSBwYXJ0c1swXTtcbiAgICB2YXIgcXVlcnlzdHJpbmcgPSBwYXJ0c1sxXTtcblxuICAgIHZhciByZXNvdXJjZSA9ICcnO1xuXG4gICAgaWYgKHIudmlydHVhbEhvc3RlZEJ1Y2tldClcbiAgICAgIHJlc291cmNlICs9ICcvJyArIHIudmlydHVhbEhvc3RlZEJ1Y2tldDtcblxuICAgIHJlc291cmNlICs9IHBhdGg7XG5cbiAgICBpZiAocXVlcnlzdHJpbmcpIHtcblxuICAgICAgLy8gY29sbGVjdCBhIGxpc3Qgb2Ygc3ViIHJlc291cmNlcyBhbmQgcXVlcnkgcGFyYW1zIHRoYXQgbmVlZCB0byBiZSBzaWduZWRcbiAgICAgIHZhciByZXNvdXJjZXMgPSBbXTtcblxuICAgICAgQVdTLnV0aWwuYXJyYXlFYWNoLmNhbGwodGhpcywgcXVlcnlzdHJpbmcuc3BsaXQoJyYnKSwgZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIHZhciBuYW1lID0gcGFyYW0uc3BsaXQoJz0nKVswXTtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyYW0uc3BsaXQoJz0nKVsxXTtcbiAgICAgICAgaWYgKHRoaXMuc3ViUmVzb3VyY2VzW25hbWVdIHx8IHRoaXMucmVzcG9uc2VIZWFkZXJzW25hbWVdKSB7XG4gICAgICAgICAgdmFyIHN1YnJlc291cmNlID0geyBuYW1lOiBuYW1lIH07XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1YlJlc291cmNlc1tuYW1lXSkge1xuICAgICAgICAgICAgICBzdWJyZXNvdXJjZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3VicmVzb3VyY2UudmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvdXJjZXMucHVzaChzdWJyZXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXNvdXJjZXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5uYW1lIDwgYi5uYW1lID8gLTEgOiAxOyB9KTtcblxuICAgICAgaWYgKHJlc291cmNlcy5sZW5ndGgpIHtcblxuICAgICAgICBxdWVyeXN0cmluZyA9IFtdO1xuICAgICAgICBBV1MudXRpbC5hcnJheUVhY2gocmVzb3VyY2VzLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgaWYgKHJlcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBxdWVyeXN0cmluZy5wdXNoKHJlcy5uYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcXVlcnlzdHJpbmcucHVzaChyZXMubmFtZSArICc9JyArIHJlcy52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXNvdXJjZSArPSAnPycgKyBxdWVyeXN0cmluZy5qb2luKCcmJyk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzb3VyY2U7XG5cbiAgfSxcblxuICBzaWduOiBmdW5jdGlvbiBzaWduKHNlY3JldCwgc3RyaW5nKSB7XG4gICAgcmV0dXJuIEFXUy51dGlsLmNyeXB0by5obWFjKHNlY3JldCwgc3RyaW5nLCAnYmFzZTY0JywgJ3NoYTEnKTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNpZ25lcnMuUzM7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuU2lnbmVycy5WMiA9IGluaGVyaXQoQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lciwge1xuICBhZGRBdXRob3JpemF0aW9uOiBmdW5jdGlvbiBhZGRBdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRlKSB7XG5cbiAgICBpZiAoIWRhdGUpIGRhdGUgPSBBV1MudXRpbC5kYXRlLmdldERhdGUoKTtcblxuICAgIHZhciByID0gdGhpcy5yZXF1ZXN0O1xuXG4gICAgci5wYXJhbXMuVGltZXN0YW1wID0gQVdTLnV0aWwuZGF0ZS5pc284NjAxKGRhdGUpO1xuICAgIHIucGFyYW1zLlNpZ25hdHVyZVZlcnNpb24gPSAnMic7XG4gICAgci5wYXJhbXMuU2lnbmF0dXJlTWV0aG9kID0gJ0htYWNTSEEyNTYnO1xuICAgIHIucGFyYW1zLkFXU0FjY2Vzc0tleUlkID0gY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQ7XG5cbiAgICBpZiAoY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuKSB7XG4gICAgICByLnBhcmFtcy5TZWN1cml0eVRva2VuID0gY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuO1xuICAgIH1cblxuICAgIGRlbGV0ZSByLnBhcmFtcy5TaWduYXR1cmU7IC8vIGRlbGV0ZSBvbGQgU2lnbmF0dXJlIGZvciByZS1zaWduaW5nXG4gICAgci5wYXJhbXMuU2lnbmF0dXJlID0gdGhpcy5zaWduYXR1cmUoY3JlZGVudGlhbHMpO1xuXG4gICAgci5ib2R5ID0gQVdTLnV0aWwucXVlcnlQYXJhbXNUb1N0cmluZyhyLnBhcmFtcyk7XG4gICAgci5oZWFkZXJzWydDb250ZW50LUxlbmd0aCddID0gci5ib2R5Lmxlbmd0aDtcbiAgfSxcblxuICBzaWduYXR1cmU6IGZ1bmN0aW9uIHNpZ25hdHVyZShjcmVkZW50aWFscykge1xuICAgIHJldHVybiBBV1MudXRpbC5jcnlwdG8uaG1hYyhjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXksIHRoaXMuc3RyaW5nVG9TaWduKCksICdiYXNlNjQnKTtcbiAgfSxcblxuICBzdHJpbmdUb1NpZ246IGZ1bmN0aW9uIHN0cmluZ1RvU2lnbigpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMucmVxdWVzdC5tZXRob2QpO1xuICAgIHBhcnRzLnB1c2godGhpcy5yZXF1ZXN0LmVuZHBvaW50Lmhvc3QudG9Mb3dlckNhc2UoKSk7XG4gICAgcGFydHMucHVzaCh0aGlzLnJlcXVlc3QucGF0aG5hbWUoKSk7XG4gICAgcGFydHMucHVzaChBV1MudXRpbC5xdWVyeVBhcmFtc1RvU3RyaW5nKHRoaXMucmVxdWVzdC5wYXJhbXMpKTtcbiAgICByZXR1cm4gcGFydHMuam9pbignXFxuJyk7XG4gIH1cblxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNpZ25lcnMuVjI7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuU2lnbmVycy5WMyA9IGluaGVyaXQoQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lciwge1xuICBhZGRBdXRob3JpemF0aW9uOiBmdW5jdGlvbiBhZGRBdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRlKSB7XG5cbiAgICB2YXIgZGF0ZXRpbWUgPSBBV1MudXRpbC5kYXRlLnJmYzgyMihkYXRlKTtcblxuICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWydYLUFtei1EYXRlJ10gPSBkYXRldGltZTtcblxuICAgIGlmIChjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4pIHtcbiAgICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWyd4LWFtei1zZWN1cml0eS10b2tlbiddID0gY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuO1xuICAgIH1cblxuICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWydYLUFtem4tQXV0aG9yaXphdGlvbiddID1cbiAgICAgIHRoaXMuYXV0aG9yaXphdGlvbihjcmVkZW50aWFscywgZGF0ZXRpbWUpO1xuXG4gIH0sXG5cbiAgYXV0aG9yaXphdGlvbjogZnVuY3Rpb24gYXV0aG9yaXphdGlvbihjcmVkZW50aWFscykge1xuICAgIHJldHVybiAnQVdTMyAnICtcbiAgICAgICdBV1NBY2Nlc3NLZXlJZD0nICsgY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgKyAnLCcgK1xuICAgICAgJ0FsZ29yaXRobT1IbWFjU0hBMjU2LCcgK1xuICAgICAgJ1NpZ25lZEhlYWRlcnM9JyArIHRoaXMuc2lnbmVkSGVhZGVycygpICsgJywnICtcbiAgICAgICdTaWduYXR1cmU9JyArIHRoaXMuc2lnbmF0dXJlKGNyZWRlbnRpYWxzKTtcbiAgfSxcblxuICBzaWduZWRIZWFkZXJzOiBmdW5jdGlvbiBzaWduZWRIZWFkZXJzKCkge1xuICAgIHZhciBoZWFkZXJzID0gW107XG4gICAgQVdTLnV0aWwuYXJyYXlFYWNoKHRoaXMuaGVhZGVyc1RvU2lnbigpLCBmdW5jdGlvbiBpdGVyYXRvcihoKSB7XG4gICAgICBoZWFkZXJzLnB1c2goaC50b0xvd2VyQ2FzZSgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVycy5zb3J0KCkuam9pbignOycpO1xuICB9LFxuXG4gIGNhbm9uaWNhbEhlYWRlcnM6IGZ1bmN0aW9uIGNhbm9uaWNhbEhlYWRlcnMoKSB7XG4gICAgdmFyIGhlYWRlcnMgPSB0aGlzLnJlcXVlc3QuaGVhZGVycztcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBBV1MudXRpbC5hcnJheUVhY2godGhpcy5oZWFkZXJzVG9TaWduKCksIGZ1bmN0aW9uIGl0ZXJhdG9yKGgpIHtcbiAgICAgIHBhcnRzLnB1c2goaC50b0xvd2VyQ2FzZSgpLnRyaW0oKSArICc6JyArIFN0cmluZyhoZWFkZXJzW2hdKS50cmltKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJ0cy5zb3J0KCkuam9pbignXFxuJykgKyAnXFxuJztcbiAgfSxcblxuICBoZWFkZXJzVG9TaWduOiBmdW5jdGlvbiBoZWFkZXJzVG9TaWduKCkge1xuICAgIHZhciBoZWFkZXJzID0gW107XG4gICAgQVdTLnV0aWwuZWFjaCh0aGlzLnJlcXVlc3QuaGVhZGVycywgZnVuY3Rpb24gaXRlcmF0b3Ioaykge1xuICAgICAgaWYgKGsgPT09ICdIb3N0JyB8fCBrID09PSAnQ29udGVudC1FbmNvZGluZycgfHwgay5tYXRjaCgvXlgtQW16L2kpKSB7XG4gICAgICAgIGhlYWRlcnMucHVzaChrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfSxcblxuICBzaWduYXR1cmU6IGZ1bmN0aW9uIHNpZ25hdHVyZShjcmVkZW50aWFscykge1xuICAgIHJldHVybiBBV1MudXRpbC5jcnlwdG8uaG1hYyhjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXksIHRoaXMuc3RyaW5nVG9TaWduKCksICdiYXNlNjQnKTtcbiAgfSxcblxuICBzdHJpbmdUb1NpZ246IGZ1bmN0aW9uIHN0cmluZ1RvU2lnbigpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMucmVxdWVzdC5tZXRob2QpO1xuICAgIHBhcnRzLnB1c2goJy8nKTtcbiAgICBwYXJ0cy5wdXNoKCcnKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuY2Fub25pY2FsSGVhZGVycygpKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMucmVxdWVzdC5ib2R5KTtcbiAgICByZXR1cm4gQVdTLnV0aWwuY3J5cHRvLnNoYTI1NihwYXJ0cy5qb2luKCdcXG4nKSk7XG4gIH1cblxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNpZ25lcnMuVjM7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xuXG5yZXF1aXJlKCcuL3YzJyk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TaWduZXJzLlYzSHR0cHMgPSBpbmhlcml0KEFXUy5TaWduZXJzLlYzLCB7XG4gIGF1dGhvcml6YXRpb246IGZ1bmN0aW9uIGF1dGhvcml6YXRpb24oY3JlZGVudGlhbHMpIHtcbiAgICByZXR1cm4gJ0FXUzMtSFRUUFMgJyArXG4gICAgICAnQVdTQWNjZXNzS2V5SWQ9JyArIGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkICsgJywnICtcbiAgICAgICdBbGdvcml0aG09SG1hY1NIQTI1NiwnICtcbiAgICAgICdTaWduYXR1cmU9JyArIHRoaXMuc2lnbmF0dXJlKGNyZWRlbnRpYWxzKTtcbiAgfSxcblxuICBzdHJpbmdUb1NpZ246IGZ1bmN0aW9uIHN0cmluZ1RvU2lnbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LURhdGUnXTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNpZ25lcnMuVjNIdHRwcztcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgdjRDcmVkZW50aWFscyA9IHJlcXVpcmUoJy4vdjRfY3JlZGVudGlhbHMnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIGV4cGlyZXNIZWFkZXIgPSAncHJlc2lnbmVkLWV4cGlyZXMnO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuU2lnbmVycy5WNCA9IGluaGVyaXQoQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lciwge1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gVjQocmVxdWVzdCwgc2VydmljZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBBV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyLmNhbGwodGhpcywgcmVxdWVzdCk7XG4gICAgdGhpcy5zZXJ2aWNlTmFtZSA9IHNlcnZpY2VOYW1lO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuc2lnbmF0dXJlQ2FjaGUgPSB0eXBlb2Ygb3B0aW9ucy5zaWduYXR1cmVDYWNoZSA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zaWduYXR1cmVDYWNoZSA6IHRydWU7XG4gICAgdGhpcy5vcGVyYXRpb24gPSBvcHRpb25zLm9wZXJhdGlvbjtcbiAgICB0aGlzLnNpZ25hdHVyZVZlcnNpb24gPSBvcHRpb25zLnNpZ25hdHVyZVZlcnNpb247XG4gIH0sXG5cbiAgYWxnb3JpdGhtOiAnQVdTNC1ITUFDLVNIQTI1NicsXG5cbiAgYWRkQXV0aG9yaXphdGlvbjogZnVuY3Rpb24gYWRkQXV0aG9yaXphdGlvbihjcmVkZW50aWFscywgZGF0ZSkge1xuICAgIHZhciBkYXRldGltZSA9IEFXUy51dGlsLmRhdGUuaXNvODYwMShkYXRlKS5yZXBsYWNlKC9bOlxcLV18XFwuXFxkezN9L2csICcnKTtcblxuICAgIGlmICh0aGlzLmlzUHJlc2lnbmVkKCkpIHtcbiAgICAgIHRoaXMudXBkYXRlRm9yUHJlc2lnbmVkKGNyZWRlbnRpYWxzLCBkYXRldGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkSGVhZGVycyhjcmVkZW50aWFscywgZGF0ZXRpbWUpO1xuICAgIH1cblxuICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPVxuICAgICAgdGhpcy5hdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRldGltZSk7XG4gIH0sXG5cbiAgYWRkSGVhZGVyczogZnVuY3Rpb24gYWRkSGVhZGVycyhjcmVkZW50aWFscywgZGF0ZXRpbWUpIHtcbiAgICB0aGlzLnJlcXVlc3QuaGVhZGVyc1snWC1BbXotRGF0ZSddID0gZGF0ZXRpbWU7XG4gICAgaWYgKGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbikge1xuICAgICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LXNlY3VyaXR5LXRva2VuJ10gPSBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW47XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZUZvclByZXNpZ25lZDogZnVuY3Rpb24gdXBkYXRlRm9yUHJlc2lnbmVkKGNyZWRlbnRpYWxzLCBkYXRldGltZSkge1xuICAgIHZhciBjcmVkU3RyaW5nID0gdGhpcy5jcmVkZW50aWFsU3RyaW5nKGRhdGV0aW1lKTtcbiAgICB2YXIgcXMgPSB7XG4gICAgICAnWC1BbXotRGF0ZSc6IGRhdGV0aW1lLFxuICAgICAgJ1gtQW16LUFsZ29yaXRobSc6IHRoaXMuYWxnb3JpdGhtLFxuICAgICAgJ1gtQW16LUNyZWRlbnRpYWwnOiBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZCArICcvJyArIGNyZWRTdHJpbmcsXG4gICAgICAnWC1BbXotRXhwaXJlcyc6IHRoaXMucmVxdWVzdC5oZWFkZXJzW2V4cGlyZXNIZWFkZXJdLFxuICAgICAgJ1gtQW16LVNpZ25lZEhlYWRlcnMnOiB0aGlzLnNpZ25lZEhlYWRlcnMoKVxuICAgIH07XG5cbiAgICBpZiAoY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuKSB7XG4gICAgICBxc1snWC1BbXotU2VjdXJpdHktVG9rZW4nXSA9IGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSB7XG4gICAgICBxc1snQ29udGVudC1UeXBlJ10gPSB0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG4gICAgfVxuICAgIGlmICh0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1NRDUnXSkge1xuICAgICAgcXNbJ0NvbnRlbnQtTUQ1J10gPSB0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1NRDUnXTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVxdWVzdC5oZWFkZXJzWydDYWNoZS1Db250cm9sJ10pIHtcbiAgICAgIHFzWydDYWNoZS1Db250cm9sJ10gPSB0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ2FjaGUtQ29udHJvbCddO1xuICAgIH1cblxuICAgIC8vIG5lZWQgdG8gcHVsbCBpbiBhbnkgb3RoZXIgWC1BbXotKiBoZWFkZXJzXG4gICAgQVdTLnV0aWwuZWFjaC5jYWxsKHRoaXMsIHRoaXMucmVxdWVzdC5oZWFkZXJzLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5ID09PSBleHBpcmVzSGVhZGVyKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5pc1NpZ25hYmxlSGVhZGVyKGtleSkpIHtcbiAgICAgICAgdmFyIGxvd2VyS2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIE1ldGFkYXRhIHNob3VsZCBiZSBub3JtYWxpemVkXG4gICAgICAgIGlmIChsb3dlcktleS5pbmRleE9mKCd4LWFtei1tZXRhLScpID09PSAwKSB7XG4gICAgICAgICAgcXNbbG93ZXJLZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAobG93ZXJLZXkuaW5kZXhPZigneC1hbXotJykgPT09IDApIHtcbiAgICAgICAgICBxc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBzZXAgPSB0aGlzLnJlcXVlc3QucGF0aC5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JztcbiAgICB0aGlzLnJlcXVlc3QucGF0aCArPSBzZXAgKyBBV1MudXRpbC5xdWVyeVBhcmFtc1RvU3RyaW5nKHFzKTtcbiAgfSxcblxuICBhdXRob3JpemF0aW9uOiBmdW5jdGlvbiBhdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRldGltZSkge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHZhciBjcmVkU3RyaW5nID0gdGhpcy5jcmVkZW50aWFsU3RyaW5nKGRhdGV0aW1lKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuYWxnb3JpdGhtICsgJyBDcmVkZW50aWFsPScgK1xuICAgICAgY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgKyAnLycgKyBjcmVkU3RyaW5nKTtcbiAgICBwYXJ0cy5wdXNoKCdTaWduZWRIZWFkZXJzPScgKyB0aGlzLnNpZ25lZEhlYWRlcnMoKSk7XG4gICAgcGFydHMucHVzaCgnU2lnbmF0dXJlPScgKyB0aGlzLnNpZ25hdHVyZShjcmVkZW50aWFscywgZGF0ZXRpbWUpKTtcbiAgICByZXR1cm4gcGFydHMuam9pbignLCAnKTtcbiAgfSxcblxuICBzaWduYXR1cmU6IGZ1bmN0aW9uIHNpZ25hdHVyZShjcmVkZW50aWFscywgZGF0ZXRpbWUpIHtcbiAgICB2YXIgc2lnbmluZ0tleSA9IHY0Q3JlZGVudGlhbHMuZ2V0U2lnbmluZ0tleShcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgZGF0ZXRpbWUuc3Vic3RyKDAsIDgpLFxuICAgICAgdGhpcy5yZXF1ZXN0LnJlZ2lvbixcbiAgICAgIHRoaXMuc2VydmljZU5hbWUsXG4gICAgICB0aGlzLnNpZ25hdHVyZUNhY2hlXG4gICAgKTtcbiAgICByZXR1cm4gQVdTLnV0aWwuY3J5cHRvLmhtYWMoc2lnbmluZ0tleSwgdGhpcy5zdHJpbmdUb1NpZ24oZGF0ZXRpbWUpLCAnaGV4Jyk7XG4gIH0sXG5cbiAgc3RyaW5nVG9TaWduOiBmdW5jdGlvbiBzdHJpbmdUb1NpZ24oZGF0ZXRpbWUpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBwYXJ0cy5wdXNoKCdBV1M0LUhNQUMtU0hBMjU2Jyk7XG4gICAgcGFydHMucHVzaChkYXRldGltZSk7XG4gICAgcGFydHMucHVzaCh0aGlzLmNyZWRlbnRpYWxTdHJpbmcoZGF0ZXRpbWUpKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuaGV4RW5jb2RlZEhhc2godGhpcy5jYW5vbmljYWxTdHJpbmcoKSkpO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcbiAgfSxcblxuICBjYW5vbmljYWxTdHJpbmc6IGZ1bmN0aW9uIGNhbm9uaWNhbFN0cmluZygpIHtcbiAgICB2YXIgcGFydHMgPSBbXSwgcGF0aG5hbWUgPSB0aGlzLnJlcXVlc3QucGF0aG5hbWUoKTtcbiAgICBpZiAodGhpcy5zZXJ2aWNlTmFtZSAhPT0gJ3MzJyAmJiB0aGlzLnNpZ25hdHVyZVZlcnNpb24gIT09ICdzM3Y0JykgcGF0aG5hbWUgPSBBV1MudXRpbC51cmlFc2NhcGVQYXRoKHBhdGhuYW1lKTtcblxuICAgIHBhcnRzLnB1c2godGhpcy5yZXF1ZXN0Lm1ldGhvZCk7XG4gICAgcGFydHMucHVzaChwYXRobmFtZSk7XG4gICAgcGFydHMucHVzaCh0aGlzLnJlcXVlc3Quc2VhcmNoKCkpO1xuICAgIHBhcnRzLnB1c2godGhpcy5jYW5vbmljYWxIZWFkZXJzKCkgKyAnXFxuJyk7XG4gICAgcGFydHMucHVzaCh0aGlzLnNpZ25lZEhlYWRlcnMoKSk7XG4gICAgcGFydHMucHVzaCh0aGlzLmhleEVuY29kZWRCb2R5SGFzaCgpKTtcbiAgICByZXR1cm4gcGFydHMuam9pbignXFxuJyk7XG4gIH0sXG5cbiAgY2Fub25pY2FsSGVhZGVyczogZnVuY3Rpb24gY2Fub25pY2FsSGVhZGVycygpIHtcbiAgICB2YXIgaGVhZGVycyA9IFtdO1xuICAgIEFXUy51dGlsLmVhY2guY2FsbCh0aGlzLCB0aGlzLnJlcXVlc3QuaGVhZGVycywgZnVuY3Rpb24gKGtleSwgaXRlbSkge1xuICAgICAgaGVhZGVycy5wdXNoKFtrZXksIGl0ZW1dKTtcbiAgICB9KTtcbiAgICBoZWFkZXJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhWzBdLnRvTG93ZXJDYXNlKCkgPCBiWzBdLnRvTG93ZXJDYXNlKCkgPyAtMSA6IDE7XG4gICAgfSk7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgQVdTLnV0aWwuYXJyYXlFYWNoLmNhbGwodGhpcywgaGVhZGVycywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBrZXkgPSBpdGVtWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodGhpcy5pc1NpZ25hYmxlSGVhZGVyKGtleSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXRlbVsxXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCdIZWFkZXIgJyArIGtleSArICcgY29udGFpbnMgaW52YWxpZCB2YWx1ZScpLCB7XG4gICAgICAgICAgICBjb2RlOiAnSW52YWxpZEhlYWRlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGtleSArICc6JyArXG4gICAgICAgICAgdGhpcy5jYW5vbmljYWxIZWFkZXJWYWx1ZXModmFsdWUudG9TdHJpbmcoKSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcbiAgfSxcblxuICBjYW5vbmljYWxIZWFkZXJWYWx1ZXM6IGZ1bmN0aW9uIGNhbm9uaWNhbEhlYWRlclZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLnJlcGxhY2UoL1xccysvZywgJyAnKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gIH0sXG5cbiAgc2lnbmVkSGVhZGVyczogZnVuY3Rpb24gc2lnbmVkSGVhZGVycygpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIEFXUy51dGlsLmVhY2guY2FsbCh0aGlzLCB0aGlzLnJlcXVlc3QuaGVhZGVycywgZnVuY3Rpb24gKGtleSkge1xuICAgICAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodGhpcy5pc1NpZ25hYmxlSGVhZGVyKGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIH0pO1xuICAgIHJldHVybiBrZXlzLnNvcnQoKS5qb2luKCc7Jyk7XG4gIH0sXG5cbiAgY3JlZGVudGlhbFN0cmluZzogZnVuY3Rpb24gY3JlZGVudGlhbFN0cmluZyhkYXRldGltZSkge1xuICAgIHJldHVybiB2NENyZWRlbnRpYWxzLmNyZWF0ZVNjb3BlKFxuICAgICAgZGF0ZXRpbWUuc3Vic3RyKDAsIDgpLFxuICAgICAgdGhpcy5yZXF1ZXN0LnJlZ2lvbixcbiAgICAgIHRoaXMuc2VydmljZU5hbWVcbiAgICApO1xuICB9LFxuXG4gIGhleEVuY29kZWRIYXNoOiBmdW5jdGlvbiBoYXNoKHN0cmluZykge1xuICAgIHJldHVybiBBV1MudXRpbC5jcnlwdG8uc2hhMjU2KHN0cmluZywgJ2hleCcpO1xuICB9LFxuXG4gIGhleEVuY29kZWRCb2R5SGFzaDogZnVuY3Rpb24gaGV4RW5jb2RlZEJvZHlIYXNoKCkge1xuICAgIHZhciByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0O1xuICAgIGlmICh0aGlzLmlzUHJlc2lnbmVkKCkgJiYgdGhpcy5zZXJ2aWNlTmFtZSA9PT0gJ3MzJyAmJiAhcmVxdWVzdC5ib2R5KSB7XG4gICAgICByZXR1cm4gJ1VOU0lHTkVELVBBWUxPQUQnO1xuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5oZWFkZXJzWydYLUFtei1Db250ZW50LVNoYTI1NiddKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdC5oZWFkZXJzWydYLUFtei1Db250ZW50LVNoYTI1NiddO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5oZXhFbmNvZGVkSGFzaCh0aGlzLnJlcXVlc3QuYm9keSB8fCAnJyk7XG4gICAgfVxuICB9LFxuXG4gIHVuc2lnbmFibGVIZWFkZXJzOiBbXG4gICAgJ2F1dGhvcml6YXRpb24nLFxuICAgICdjb250ZW50LXR5cGUnLFxuICAgICdjb250ZW50LWxlbmd0aCcsXG4gICAgJ3VzZXItYWdlbnQnLFxuICAgIGV4cGlyZXNIZWFkZXIsXG4gICAgJ2V4cGVjdCcsXG4gICAgJ3gtYW16bi10cmFjZS1pZCdcbiAgXSxcblxuICBpc1NpZ25hYmxlSGVhZGVyOiBmdW5jdGlvbiBpc1NpZ25hYmxlSGVhZGVyKGtleSkge1xuICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd4LWFtei0nKSA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHRoaXMudW5zaWduYWJsZUhlYWRlcnMuaW5kZXhPZihrZXkpIDwgMDtcbiAgfSxcblxuICBpc1ByZXNpZ25lZDogZnVuY3Rpb24gaXNQcmVzaWduZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdC5oZWFkZXJzW2V4cGlyZXNIZWFkZXJdID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5TaWduZXJzLlY0O1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIGNhY2hlZFNlY3JldCA9IHt9O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgY2FjaGVRdWV1ZSA9IFtdO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgbWF4Q2FjaGVFbnRyaWVzID0gNTA7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciB2NElkZW50aWZpZXIgPSAnYXdzNF9yZXF1ZXN0JztcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIGRhdGUgW1N0cmluZ11cbiAgICogQHBhcmFtIHJlZ2lvbiBbU3RyaW5nXVxuICAgKiBAcGFyYW0gc2VydmljZU5hbWUgW1N0cmluZ11cbiAgICogQHJldHVybiBbU3RyaW5nXVxuICAgKi9cbiAgY3JlYXRlU2NvcGU6IGZ1bmN0aW9uIGNyZWF0ZVNjb3BlKGRhdGUsIHJlZ2lvbiwgc2VydmljZU5hbWUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgZGF0ZS5zdWJzdHIoMCwgOCksXG4gICAgICByZWdpb24sXG4gICAgICBzZXJ2aWNlTmFtZSxcbiAgICAgIHY0SWRlbnRpZmllclxuICAgIF0uam9pbignLycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIGNyZWRlbnRpYWxzIFtDcmVkZW50aWFsc11cbiAgICogQHBhcmFtIGRhdGUgW1N0cmluZ11cbiAgICogQHBhcmFtIHJlZ2lvbiBbU3RyaW5nXVxuICAgKiBAcGFyYW0gc2VydmljZSBbU3RyaW5nXVxuICAgKiBAcGFyYW0gc2hvdWxkQ2FjaGUgW0Jvb2xlYW5dXG4gICAqIEByZXR1cm4gW1N0cmluZ11cbiAgICovXG4gIGdldFNpZ25pbmdLZXk6IGZ1bmN0aW9uIGdldFNpZ25pbmdLZXkoXG4gICAgY3JlZGVudGlhbHMsXG4gICAgZGF0ZSxcbiAgICByZWdpb24sXG4gICAgc2VydmljZSxcbiAgICBzaG91bGRDYWNoZVxuICApIHtcbiAgICB2YXIgY3JlZHNJZGVudGlmaWVyID0gQVdTLnV0aWwuY3J5cHRvXG4gICAgICAuaG1hYyhjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXksIGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkLCAnYmFzZTY0Jyk7XG4gICAgdmFyIGNhY2hlS2V5ID0gW2NyZWRzSWRlbnRpZmllciwgZGF0ZSwgcmVnaW9uLCBzZXJ2aWNlXS5qb2luKCdfJyk7XG4gICAgc2hvdWxkQ2FjaGUgPSBzaG91bGRDYWNoZSAhPT0gZmFsc2U7XG4gICAgaWYgKHNob3VsZENhY2hlICYmIChjYWNoZUtleSBpbiBjYWNoZWRTZWNyZXQpKSB7XG4gICAgICByZXR1cm4gY2FjaGVkU2VjcmV0W2NhY2hlS2V5XTtcbiAgICB9XG5cbiAgICB2YXIga0RhdGUgPSBBV1MudXRpbC5jcnlwdG8uaG1hYyhcbiAgICAgICdBV1M0JyArIGNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSxcbiAgICAgIGRhdGUsXG4gICAgICAnYnVmZmVyJ1xuICAgICk7XG4gICAgdmFyIGtSZWdpb24gPSBBV1MudXRpbC5jcnlwdG8uaG1hYyhrRGF0ZSwgcmVnaW9uLCAnYnVmZmVyJyk7XG4gICAgdmFyIGtTZXJ2aWNlID0gQVdTLnV0aWwuY3J5cHRvLmhtYWMoa1JlZ2lvbiwgc2VydmljZSwgJ2J1ZmZlcicpO1xuXG4gICAgdmFyIHNpZ25pbmdLZXkgPSBBV1MudXRpbC5jcnlwdG8uaG1hYyhrU2VydmljZSwgdjRJZGVudGlmaWVyLCAnYnVmZmVyJyk7XG4gICAgaWYgKHNob3VsZENhY2hlKSB7XG4gICAgICBjYWNoZWRTZWNyZXRbY2FjaGVLZXldID0gc2lnbmluZ0tleTtcbiAgICAgIGNhY2hlUXVldWUucHVzaChjYWNoZUtleSk7XG4gICAgICBpZiAoY2FjaGVRdWV1ZS5sZW5ndGggPiBtYXhDYWNoZUVudHJpZXMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBvbGRlc3QgZW50cnkgKG5vdCB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZClcbiAgICAgICAgZGVsZXRlIGNhY2hlZFNlY3JldFtjYWNoZVF1ZXVlLnNoaWZ0KCldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaWduaW5nS2V5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICpcbiAgICogRW1wdGllcyB0aGUgZGVyaXZlZCBzaWduaW5nIGtleSBjYWNoZS4gTWFkZSBhdmFpbGFibGUgZm9yIHRlc3RpbmcgcHVycG9zZXNcbiAgICogb25seS5cbiAgICovXG4gIGVtcHR5Q2FjaGU6IGZ1bmN0aW9uIGVtcHR5Q2FjaGUoKSB7XG4gICAgY2FjaGVkU2VjcmV0ID0ge307XG4gICAgY2FjaGVRdWV1ZSA9IFtdO1xuICB9XG59O1xuIiwiZnVuY3Rpb24gQWNjZXB0b3JTdGF0ZU1hY2hpbmUoc3RhdGVzLCBzdGF0ZSkge1xuICB0aGlzLmN1cnJlbnRTdGF0ZSA9IHN0YXRlIHx8IG51bGw7XG4gIHRoaXMuc3RhdGVzID0gc3RhdGVzIHx8IHt9O1xufVxuXG5BY2NlcHRvclN0YXRlTWFjaGluZS5wcm90b3R5cGUucnVuVG8gPSBmdW5jdGlvbiBydW5UbyhmaW5hbFN0YXRlLCBkb25lLCBiaW5kT2JqZWN0LCBpbnB1dEVycm9yKSB7XG4gIGlmICh0eXBlb2YgZmluYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlucHV0RXJyb3IgPSBiaW5kT2JqZWN0OyBiaW5kT2JqZWN0ID0gZG9uZTtcbiAgICBkb25lID0gZmluYWxTdGF0ZTsgZmluYWxTdGF0ZSA9IG51bGw7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHNlbGYuc3RhdGVzW3NlbGYuY3VycmVudFN0YXRlXTtcbiAgc3RhdGUuZm4uY2FsbChiaW5kT2JqZWN0IHx8IHNlbGYsIGlucHV0RXJyb3IsIGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChzdGF0ZS5mYWlsKSBzZWxmLmN1cnJlbnRTdGF0ZSA9IHN0YXRlLmZhaWw7XG4gICAgICBlbHNlIHJldHVybiBkb25lID8gZG9uZS5jYWxsKGJpbmRPYmplY3QsIGVycikgOiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuYWNjZXB0KSBzZWxmLmN1cnJlbnRTdGF0ZSA9IHN0YXRlLmFjY2VwdDtcbiAgICAgIGVsc2UgcmV0dXJuIGRvbmUgPyBkb25lLmNhbGwoYmluZE9iamVjdCkgOiBudWxsO1xuICAgIH1cbiAgICBpZiAoc2VsZi5jdXJyZW50U3RhdGUgPT09IGZpbmFsU3RhdGUpIHtcbiAgICAgIHJldHVybiBkb25lID8gZG9uZS5jYWxsKGJpbmRPYmplY3QsIGVycikgOiBudWxsO1xuICAgIH1cblxuICAgIHNlbGYucnVuVG8oZmluYWxTdGF0ZSwgZG9uZSwgYmluZE9iamVjdCwgZXJyKTtcbiAgfSk7XG59O1xuXG5BY2NlcHRvclN0YXRlTWFjaGluZS5wcm90b3R5cGUuYWRkU3RhdGUgPSBmdW5jdGlvbiBhZGRTdGF0ZShuYW1lLCBhY2NlcHRTdGF0ZSwgZmFpbFN0YXRlLCBmbikge1xuICBpZiAodHlwZW9mIGFjY2VwdFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBhY2NlcHRTdGF0ZTsgYWNjZXB0U3RhdGUgPSBudWxsOyBmYWlsU3RhdGUgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBmYWlsU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IGZhaWxTdGF0ZTsgZmFpbFN0YXRlID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdGhpcy5jdXJyZW50U3RhdGUpIHRoaXMuY3VycmVudFN0YXRlID0gbmFtZTtcbiAgdGhpcy5zdGF0ZXNbbmFtZV0gPSB7IGFjY2VwdDogYWNjZXB0U3RhdGUsIGZhaWw6IGZhaWxTdGF0ZSwgZm46IGZuIH07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBY2NlcHRvclN0YXRlTWFjaGluZTtcbiIsIi8qIGVzbGludCBndWFyZC1mb3ItaW46MCAqL1xudmFyIEFXUztcblxuLyoqXG4gKiBBIHNldCBvZiB1dGlsaXR5IG1ldGhvZHMgZm9yIHVzZSB3aXRoIHRoZSBBV1MgU0RLLlxuICpcbiAqIEAhYXR0cmlidXRlIGFib3J0XG4gKiAgIFJldHVybiB0aGlzIHZhbHVlIGZyb20gYW4gaXRlcmF0b3IgZnVuY3Rpb24ge2VhY2h9IG9yIHthcnJheUVhY2h9XG4gKiAgIHRvIGJyZWFrIG91dCBvZiB0aGUgaXRlcmF0aW9uLlxuICogICBAZXhhbXBsZSBCcmVha2luZyBvdXQgb2YgYW4gaXRlcmF0b3IgZnVuY3Rpb25cbiAqICAgICBBV1MudXRpbC5lYWNoKHthOiAxLCBiOiAyLCBjOiAzfSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICogICAgICAgaWYgKGtleSA9PSAnYicpIHJldHVybiBBV1MudXRpbC5hYm9ydDtcbiAqICAgICB9KTtcbiAqICAgQHNlZSBlYWNoXG4gKiAgIEBzZWUgYXJyYXlFYWNoXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIHV0aWwgPSB7XG4gIGVudmlyb25tZW50OiAnbm9kZWpzJyxcbiAgZW5naW5lOiBmdW5jdGlvbiBlbmdpbmUoKSB7XG4gICAgaWYgKHV0aWwuaXNCcm93c2VyKCkgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZW5naW5lID0gcHJvY2Vzcy5wbGF0Zm9ybSArICcvJyArIHByb2Nlc3MudmVyc2lvbjtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5BV1NfRVhFQ1VUSU9OX0VOVikge1xuICAgICAgICBlbmdpbmUgKz0gJyBleGVjLWVudi8nICsgcHJvY2Vzcy5lbnYuQVdTX0VYRUNVVElPTl9FTlY7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5naW5lO1xuICAgIH1cbiAgfSxcblxuICB1c2VyQWdlbnQ6IGZ1bmN0aW9uIHVzZXJBZ2VudCgpIHtcbiAgICB2YXIgbmFtZSA9IHV0aWwuZW52aXJvbm1lbnQ7XG4gICAgdmFyIGFnZW50ID0gJ2F3cy1zZGstJyArIG5hbWUgKyAnLycgKyByZXF1aXJlKCcuL2NvcmUnKS5WRVJTSU9OO1xuICAgIGlmIChuYW1lID09PSAnbm9kZWpzJykgYWdlbnQgKz0gJyAnICsgdXRpbC5lbmdpbmUoKTtcbiAgICByZXR1cm4gYWdlbnQ7XG4gIH0sXG5cbiAgdXJpRXNjYXBlOiBmdW5jdGlvbiB1cmlFc2NhcGUoc3RyaW5nKSB7XG4gICAgdmFyIG91dHB1dCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpO1xuICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOV8uflxcLSVdKy9nLCBlc2NhcGUpO1xuXG4gICAgLy8gQVdTIHBlcmNlbnQtZW5jb2RlcyBzb21lIGV4dHJhIG5vbi1zdGFuZGFyZCBjaGFyYWN0ZXJzIGluIGEgVVJJXG4gICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1sqXS9nLCBmdW5jdGlvbihjaCkge1xuICAgICAgcmV0dXJuICclJyArIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LFxuXG4gIHVyaUVzY2FwZVBhdGg6IGZ1bmN0aW9uIHVyaUVzY2FwZVBhdGgoc3RyaW5nKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgdXRpbC5hcnJheUVhY2goc3RyaW5nLnNwbGl0KCcvJyksIGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICBwYXJ0cy5wdXNoKHV0aWwudXJpRXNjYXBlKHBhcnQpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFydHMuam9pbignLycpO1xuICB9LFxuXG4gIHVybFBhcnNlOiBmdW5jdGlvbiB1cmxQYXJzZSh1cmwpIHtcbiAgICByZXR1cm4gdXRpbC51cmwucGFyc2UodXJsKTtcbiAgfSxcblxuICB1cmxGb3JtYXQ6IGZ1bmN0aW9uIHVybEZvcm1hdCh1cmwpIHtcbiAgICByZXR1cm4gdXRpbC51cmwuZm9ybWF0KHVybCk7XG4gIH0sXG5cbiAgcXVlcnlTdHJpbmdQYXJzZTogZnVuY3Rpb24gcXVlcnlTdHJpbmdQYXJzZShxcykge1xuICAgIHJldHVybiB1dGlsLnF1ZXJ5c3RyaW5nLnBhcnNlKHFzKTtcbiAgfSxcblxuICBxdWVyeVBhcmFtc1RvU3RyaW5nOiBmdW5jdGlvbiBxdWVyeVBhcmFtc1RvU3RyaW5nKHBhcmFtcykge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHZhciBlc2NhcGUgPSB1dGlsLnVyaUVzY2FwZTtcbiAgICB2YXIgc29ydGVkS2V5cyA9IE9iamVjdC5rZXlzKHBhcmFtcykuc29ydCgpO1xuXG4gICAgdXRpbC5hcnJheUVhY2goc29ydGVkS2V5cywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW25hbWVdO1xuICAgICAgdmFyIGVuYW1lID0gZXNjYXBlKG5hbWUpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVuYW1lICsgJz0nO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhciB2YWxzID0gW107XG4gICAgICAgIHV0aWwuYXJyYXlFYWNoKHZhbHVlLCBmdW5jdGlvbihpdGVtKSB7IHZhbHMucHVzaChlc2NhcGUoaXRlbSkpOyB9KTtcbiAgICAgICAgcmVzdWx0ID0gZW5hbWUgKyAnPScgKyB2YWxzLnNvcnQoKS5qb2luKCcmJyArIGVuYW1lICsgJz0nKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQgPSBlbmFtZSArICc9JyArIGVzY2FwZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpdGVtcy5wdXNoKHJlc3VsdCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaXRlbXMuam9pbignJicpO1xuICB9LFxuXG4gIHJlYWRGaWxlU3luYzogZnVuY3Rpb24gcmVhZEZpbGVTeW5jKHBhdGgpIHtcbiAgICBpZiAodXRpbC5pc0Jyb3dzZXIoKSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ2ZzJykucmVhZEZpbGVTeW5jKHBhdGgsICd1dGYtOCcpO1xuICB9LFxuXG4gIGJhc2U2NDoge1xuICAgIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlNjQoc3RyaW5nKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBiYXNlNjQgZW5jb2RlIG51bWJlciAnICsgc3RyaW5nKSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyaW5nID09PSBudWxsIHx8IHR5cGVvZiBzdHJpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgYnVmID0gdXRpbC5idWZmZXIudG9CdWZmZXIoc3RyaW5nKTtcbiAgICAgIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH0sXG5cbiAgICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZTY0KHN0cmluZykge1xuICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IHV0aWwuZXJyb3IobmV3IEVycm9yKCdDYW5ub3QgYmFzZTY0IGRlY29kZSBudW1iZXIgJyArIHN0cmluZykpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmluZyA9PT0gbnVsbCB8fCB0eXBlb2Ygc3RyaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHV0aWwuYnVmZmVyLnRvQnVmZmVyKHN0cmluZywgJ2Jhc2U2NCcpO1xuICAgIH1cblxuICB9LFxuXG4gIGJ1ZmZlcjoge1xuICAgIC8qKlxuICAgICAqIEJ1ZmZlciBjb25zdHJ1Y3RvciBmb3IgTm9kZSBidWZmZXIgYW5kIGJ1ZmZlciBwb2xseWZpbGxcbiAgICAgKi9cbiAgICB0b0J1ZmZlcjogZnVuY3Rpb24oZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIHV0aWwuQnVmZmVyLmZyb20gPT09ICdmdW5jdGlvbicgJiYgdXRpbC5CdWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tKSA/XG4gICAgICAgIHV0aWwuQnVmZmVyLmZyb20oZGF0YSwgZW5jb2RpbmcpIDogbmV3IHV0aWwuQnVmZmVyKGRhdGEsIGVuY29kaW5nKTtcbiAgICB9LFxuXG4gICAgYWxsb2M6IGZ1bmN0aW9uKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gICAgICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2l6ZSBwYXNzZWQgdG8gYWxsb2MgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdXRpbC5CdWZmZXIuYWxsb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuQnVmZmVyLmFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBidWYgPSBuZXcgdXRpbC5CdWZmZXIoc2l6ZSk7XG4gICAgICAgIGlmIChmaWxsICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGJ1Zi5maWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYnVmLmZpbGwoZmlsbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0b1N0cmVhbTogZnVuY3Rpb24gdG9TdHJlYW0oYnVmZmVyKSB7XG4gICAgICBpZiAoIXV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIGJ1ZmZlciA9ICB1dGlsLmJ1ZmZlci50b0J1ZmZlcihidWZmZXIpO1xuXG4gICAgICB2YXIgcmVhZGFibGUgPSBuZXcgKHV0aWwuc3RyZWFtLlJlYWRhYmxlKSgpO1xuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICByZWFkYWJsZS5fcmVhZCA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgaWYgKHBvcyA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm4gcmVhZGFibGUucHVzaChudWxsKTtcblxuICAgICAgICB2YXIgZW5kID0gcG9zICsgc2l6ZTtcbiAgICAgICAgaWYgKGVuZCA+IGJ1ZmZlci5sZW5ndGgpIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIHJlYWRhYmxlLnB1c2goYnVmZmVyLnNsaWNlKHBvcywgZW5kKSk7XG4gICAgICAgIHBvcyA9IGVuZDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZWFkYWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uY2F0ZW5hdGVzIGEgbGlzdCBvZiBCdWZmZXIgb2JqZWN0cy5cbiAgICAgKi9cbiAgICBjb25jYXQ6IGZ1bmN0aW9uKGJ1ZmZlcnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSAwLFxuICAgICAgICAgIG9mZnNldCA9IDAsXG4gICAgICAgICAgYnVmZmVyID0gbnVsbCwgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoICs9IGJ1ZmZlcnNbaV0ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBidWZmZXIgPSB1dGlsLmJ1ZmZlci5hbGxvYyhsZW5ndGgpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBidWZmZXJzW2ldLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gYnVmZmVyc1tpXS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICB9LFxuXG4gIHN0cmluZzoge1xuICAgIGJ5dGVMZW5ndGg6IGZ1bmN0aW9uIGJ5dGVMZW5ndGgoc3RyaW5nKSB7XG4gICAgICBpZiAoc3RyaW5nID09PSBudWxsIHx8IHN0cmluZyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJykgc3RyaW5nID0gdXRpbC5idWZmZXIudG9CdWZmZXIoc3RyaW5nKTtcblxuICAgICAgaWYgKHR5cGVvZiBzdHJpbmcuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyaW5nLmxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdHJpbmcuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zaXplO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyaW5nLnBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCdmcycpLmxzdGF0U3luYyhzdHJpbmcucGF0aCkuc2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHV0aWwuZXJyb3IobmV3IEVycm9yKCdDYW5ub3QgZGV0ZXJtaW5lIGxlbmd0aCBvZiAnICsgc3RyaW5nKSxcbiAgICAgICAgICB7IG9iamVjdDogc3RyaW5nIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cHBlckZpcnN0OiBmdW5jdGlvbiB1cHBlckZpcnN0KHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZ1swXS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnN1YnN0cigxKTtcbiAgICB9LFxuXG4gICAgbG93ZXJGaXJzdDogZnVuY3Rpb24gbG93ZXJGaXJzdChzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmdbMF0udG9Mb3dlckNhc2UoKSArIHN0cmluZy5zdWJzdHIoMSk7XG4gICAgfVxuICB9LFxuXG4gIGluaToge1xuICAgIHBhcnNlOiBmdW5jdGlvbiBzdHJpbmcoaW5pKSB7XG4gICAgICB2YXIgY3VycmVudFNlY3Rpb24sIG1hcCA9IHt9O1xuICAgICAgdXRpbC5hcnJheUVhY2goaW5pLnNwbGl0KC9cXHI/XFxuLyksIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgbGluZSA9IGxpbmUuc3BsaXQoLyhefFxccylbOyNdLylbMF07IC8vIHJlbW92ZSBjb21tZW50c1xuICAgICAgICB2YXIgc2VjdGlvbiA9IGxpbmUubWF0Y2goL15cXHMqXFxbKFteXFxbXFxdXSspXFxdXFxzKiQvKTtcbiAgICAgICAgaWYgKHNlY3Rpb24pIHtcbiAgICAgICAgICBjdXJyZW50U2VjdGlvbiA9IHNlY3Rpb25bMV07XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFNlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IGxpbmUubWF0Y2goL15cXHMqKC4rPylcXHMqPVxccyooLis/KVxccyokLyk7XG4gICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIG1hcFtjdXJyZW50U2VjdGlvbl0gPSBtYXBbY3VycmVudFNlY3Rpb25dIHx8IHt9O1xuICAgICAgICAgICAgbWFwW2N1cnJlbnRTZWN0aW9uXVtpdGVtWzFdXSA9IGl0ZW1bMl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gIH0sXG5cbiAgZm46IHtcbiAgICBub29wOiBmdW5jdGlvbigpIHt9LFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoZXJyKSB7IGlmIChlcnIpIHRocm93IGVycjsgfSxcblxuICAgIC8qKlxuICAgICAqIFR1cm4gYSBzeW5jaHJvbm91cyBmdW5jdGlvbiBpbnRvIGFzIFwiYXN5bmNcIiBmdW5jdGlvbiBieSBtYWtpbmcgaXQgY2FsbFxuICAgICAqIGEgY2FsbGJhY2suIFRoZSB1bmRlcmx5aW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFsbCBidXQgdGhlIGxhc3QgYXJndW1lbnQsXG4gICAgICogd2hpY2ggaXMgdHJlYXRlZCBhcyB0aGUgY2FsbGJhY2suIFRoZSBjYWxsYmFjayBpcyBwYXNzZWQgcGFzc2VkIGEgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBvZiBudWxsIG9uIHN1Y2Nlc3MgdG8gbWltaWNrIHN0YW5kYXJkIG5vZGUgY2FsbGJhY2tzLlxuICAgICAqL1xuICAgIG1ha2VBc3luYzogZnVuY3Rpb24gbWFrZUFzeW5jKGZuLCBleHBlY3RlZEFyZ3MpIHtcbiAgICAgIGlmIChleHBlY3RlZEFyZ3MgJiYgZXhwZWN0ZWRBcmdzIDw9IGZuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGF0ZSBhbmQgdGltZSB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAgICovXG4gIGRhdGU6IHtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gW0RhdGVdIHRoZSBjdXJyZW50IEphdmFTY3JpcHQgZGF0ZSBvYmplY3QuIFNpbmNlIGFsbFxuICAgICAqICAgQVdTIHNlcnZpY2VzIHJlbHkgb24gdGhpcyBkYXRlIG9iamVjdCwgeW91IGNhbiBvdmVycmlkZVxuICAgICAqICAgdGhpcyBmdW5jdGlvbiB0byBwcm92aWRlIGEgc3BlY2lhbCB0aW1lIHZhbHVlIHRvIEFXUyBzZXJ2aWNlXG4gICAgICogICByZXF1ZXN0cy5cbiAgICAgKi9cbiAgICBnZXREYXRlOiBmdW5jdGlvbiBnZXREYXRlKCkge1xuICAgICAgaWYgKCFBV1MpIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xuICAgICAgaWYgKEFXUy5jb25maWcuc3lzdGVtQ2xvY2tPZmZzZXQpIHsgLy8gdXNlIG9mZnNldCB3aGVuIG5vbi16ZXJvXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShuZXcgRGF0ZSgpLmdldFRpbWUoKSArIEFXUy5jb25maWcuc3lzdGVtQ2xvY2tPZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gW1N0cmluZ10gdGhlIGRhdGUgaW4gSVNPLTg2MDEgZm9ybWF0XG4gICAgICovXG4gICAgaXNvODYwMTogZnVuY3Rpb24gaXNvODYwMShkYXRlKSB7XG4gICAgICBpZiAoZGF0ZSA9PT0gdW5kZWZpbmVkKSB7IGRhdGUgPSB1dGlsLmRhdGUuZ2V0RGF0ZSgpOyB9XG4gICAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1xcLlxcZHszfVokLywgJ1onKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBbU3RyaW5nXSB0aGUgZGF0ZSBpbiBSRkMgODIyIGZvcm1hdFxuICAgICAqL1xuICAgIHJmYzgyMjogZnVuY3Rpb24gcmZjODIyKGRhdGUpIHtcbiAgICAgIGlmIChkYXRlID09PSB1bmRlZmluZWQpIHsgZGF0ZSA9IHV0aWwuZGF0ZS5nZXREYXRlKCk7IH1cbiAgICAgIHJldHVybiBkYXRlLnRvVVRDU3RyaW5nKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gW0ludGVnZXJdIHRoZSBVTklYIHRpbWVzdGFtcCB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgdGltZVxuICAgICAqL1xuICAgIHVuaXhUaW1lc3RhbXA6IGZ1bmN0aW9uIHVuaXhUaW1lc3RhbXAoZGF0ZSkge1xuICAgICAgaWYgKGRhdGUgPT09IHVuZGVmaW5lZCkgeyBkYXRlID0gdXRpbC5kYXRlLmdldERhdGUoKTsgfVxuICAgICAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIC8gMTAwMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIFtTdHJpbmcsbnVtYmVyLERhdGVdIGRhdGVcbiAgICAgKiBAcmV0dXJuIFtEYXRlXVxuICAgICAqL1xuICAgIGZyb206IGZ1bmN0aW9uIGZvcm1hdChkYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIGRhdGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlICogMTAwMCk7IC8vIHVuaXggdGltZXN0YW1wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgRGF0ZSBvciBkYXRlLWxpa2UgdmFsdWUsIHRoaXMgZnVuY3Rpb24gZm9ybWF0cyB0aGVcbiAgICAgKiBkYXRlIGludG8gYSBzdHJpbmcgb2YgdGhlIHJlcXVlc3RlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gW1N0cmluZyxudW1iZXIsRGF0ZV0gZGF0ZVxuICAgICAqIEBwYXJhbSBbU3RyaW5nXSBmb3JtYXR0ZXIgVmFsaWQgZm9ybWF0cyBhcmU6XG4gICAgICMgICAqICdpc284NjAxJ1xuICAgICAjICAgKiAncmZjODIyJ1xuICAgICAjICAgKiAndW5peFRpbWVzdGFtcCdcbiAgICAgKiBAcmV0dXJuIFtTdHJpbmddXG4gICAgICovXG4gICAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQoZGF0ZSwgZm9ybWF0dGVyKSB7XG4gICAgICBpZiAoIWZvcm1hdHRlcikgZm9ybWF0dGVyID0gJ2lzbzg2MDEnO1xuICAgICAgcmV0dXJuIHV0aWwuZGF0ZVtmb3JtYXR0ZXJdKHV0aWwuZGF0ZS5mcm9tKGRhdGUpKTtcbiAgICB9LFxuXG4gICAgcGFyc2VUaW1lc3RhbXA6IGZ1bmN0aW9uIHBhcnNlVGltZXN0YW1wKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgeyAvLyB1bml4IHRpbWVzdGFtcCAobnVtYmVyKVxuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUgKiAxMDAwKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUubWF0Y2goL15cXGQrJC8pKSB7IC8vIHVuaXggdGltZXN0YW1wXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSAqIDEwMDApO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5tYXRjaCgvXlxcZHs0fS8pKSB7IC8vIGlzbzg2MDFcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUubWF0Y2goL15cXHd7M30sLykpIHsgLy8gcmZjODIyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB1dGlsLmVycm9yKFxuICAgICAgICAgIG5ldyBFcnJvcigndW5oYW5kbGVkIHRpbWVzdGFtcCBmb3JtYXQ6ICcgKyB2YWx1ZSksXG4gICAgICAgICAge2NvZGU6ICdUaW1lc3RhbXBQYXJzZXJFcnJvcid9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSxcblxuICBjcnlwdG86IHtcbiAgICBjcmMzMlRhYmxlOiBbXG4gICAgIDB4MDAwMDAwMDAsIDB4NzcwNzMwOTYsIDB4RUUwRTYxMkMsIDB4OTkwOTUxQkEsIDB4MDc2REM0MTksXG4gICAgIDB4NzA2QUY0OEYsIDB4RTk2M0E1MzUsIDB4OUU2NDk1QTMsIDB4MEVEQjg4MzIsIDB4NzlEQ0I4QTQsXG4gICAgIDB4RTBENUU5MUUsIDB4OTdEMkQ5ODgsIDB4MDlCNjRDMkIsIDB4N0VCMTdDQkQsIDB4RTdCODJEMDcsXG4gICAgIDB4OTBCRjFEOTEsIDB4MURCNzEwNjQsIDB4NkFCMDIwRjIsIDB4RjNCOTcxNDgsIDB4ODRCRTQxREUsXG4gICAgIDB4MUFEQUQ0N0QsIDB4NkREREU0RUIsIDB4RjRENEI1NTEsIDB4ODNEMzg1QzcsIDB4MTM2Qzk4NTYsXG4gICAgIDB4NjQ2QkE4QzAsIDB4RkQ2MkY5N0EsIDB4OEE2NUM5RUMsIDB4MTQwMTVDNEYsIDB4NjMwNjZDRDksXG4gICAgIDB4RkEwRjNENjMsIDB4OEQwODBERjUsIDB4M0I2RTIwQzgsIDB4NEM2OTEwNUUsIDB4RDU2MDQxRTQsXG4gICAgIDB4QTI2NzcxNzIsIDB4M0MwM0U0RDEsIDB4NEIwNEQ0NDcsIDB4RDIwRDg1RkQsIDB4QTUwQUI1NkIsXG4gICAgIDB4MzVCNUE4RkEsIDB4NDJCMjk4NkMsIDB4REJCQkM5RDYsIDB4QUNCQ0Y5NDAsIDB4MzJEODZDRTMsXG4gICAgIDB4NDVERjVDNzUsIDB4RENENjBEQ0YsIDB4QUJEMTNENTksIDB4MjZEOTMwQUMsIDB4NTFERTAwM0EsXG4gICAgIDB4QzhENzUxODAsIDB4QkZEMDYxMTYsIDB4MjFCNEY0QjUsIDB4NTZCM0M0MjMsIDB4Q0ZCQTk1OTksXG4gICAgIDB4QjhCREE1MEYsIDB4MjgwMkI4OUUsIDB4NUYwNTg4MDgsIDB4QzYwQ0Q5QjIsIDB4QjEwQkU5MjQsXG4gICAgIDB4MkY2RjdDODcsIDB4NTg2ODRDMTEsIDB4QzE2MTFEQUIsIDB4QjY2NjJEM0QsIDB4NzZEQzQxOTAsXG4gICAgIDB4MDFEQjcxMDYsIDB4OThEMjIwQkMsIDB4RUZENTEwMkEsIDB4NzFCMTg1ODksIDB4MDZCNkI1MUYsXG4gICAgIDB4OUZCRkU0QTUsIDB4RThCOEQ0MzMsIDB4NzgwN0M5QTIsIDB4MEYwMEY5MzQsIDB4OTYwOUE4OEUsXG4gICAgIDB4RTEwRTk4MTgsIDB4N0Y2QTBEQkIsIDB4MDg2RDNEMkQsIDB4OTE2NDZDOTcsIDB4RTY2MzVDMDEsXG4gICAgIDB4NkI2QjUxRjQsIDB4MUM2QzYxNjIsIDB4ODU2NTMwRDgsIDB4RjI2MjAwNEUsIDB4NkMwNjk1RUQsXG4gICAgIDB4MUIwMUE1N0IsIDB4ODIwOEY0QzEsIDB4RjUwRkM0NTcsIDB4NjVCMEQ5QzYsIDB4MTJCN0U5NTAsXG4gICAgIDB4OEJCRUI4RUEsIDB4RkNCOTg4N0MsIDB4NjJERDFEREYsIDB4MTVEQTJENDksIDB4OENEMzdDRjMsXG4gICAgIDB4RkJENDRDNjUsIDB4NERCMjYxNTgsIDB4M0FCNTUxQ0UsIDB4QTNCQzAwNzQsIDB4RDRCQjMwRTIsXG4gICAgIDB4NEFERkE1NDEsIDB4M0REODk1RDcsIDB4QTREMUM0NkQsIDB4RDNENkY0RkIsIDB4NDM2OUU5NkEsXG4gICAgIDB4MzQ2RUQ5RkMsIDB4QUQ2Nzg4NDYsIDB4REE2MEI4RDAsIDB4NDQwNDJENzMsIDB4MzMwMzFERTUsXG4gICAgIDB4QUEwQTRDNUYsIDB4REQwRDdDQzksIDB4NTAwNTcxM0MsIDB4MjcwMjQxQUEsIDB4QkUwQjEwMTAsXG4gICAgIDB4QzkwQzIwODYsIDB4NTc2OEI1MjUsIDB4MjA2Rjg1QjMsIDB4Qjk2NkQ0MDksIDB4Q0U2MUU0OUYsXG4gICAgIDB4NUVERUY5MEUsIDB4MjlEOUM5OTgsIDB4QjBEMDk4MjIsIDB4QzdEN0E4QjQsIDB4NTlCMzNEMTcsXG4gICAgIDB4MkVCNDBEODEsIDB4QjdCRDVDM0IsIDB4QzBCQTZDQUQsIDB4RURCODgzMjAsIDB4OUFCRkIzQjYsXG4gICAgIDB4MDNCNkUyMEMsIDB4NzRCMUQyOUEsIDB4RUFENTQ3MzksIDB4OUREMjc3QUYsIDB4MDREQjI2MTUsXG4gICAgIDB4NzNEQzE2ODMsIDB4RTM2MzBCMTIsIDB4OTQ2NDNCODQsIDB4MEQ2RDZBM0UsIDB4N0E2QTVBQTgsXG4gICAgIDB4RTQwRUNGMEIsIDB4OTMwOUZGOUQsIDB4MEEwMEFFMjcsIDB4N0QwNzlFQjEsIDB4RjAwRjkzNDQsXG4gICAgIDB4ODcwOEEzRDIsIDB4MUUwMUYyNjgsIDB4NjkwNkMyRkUsIDB4Rjc2MjU3NUQsIDB4ODA2NTY3Q0IsXG4gICAgIDB4MTk2QzM2NzEsIDB4NkU2QjA2RTcsIDB4RkVENDFCNzYsIDB4ODlEMzJCRTAsIDB4MTBEQTdBNUEsXG4gICAgIDB4NjdERDRBQ0MsIDB4RjlCOURGNkYsIDB4OEVCRUVGRjksIDB4MTdCN0JFNDMsIDB4NjBCMDhFRDUsXG4gICAgIDB4RDZENkEzRTgsIDB4QTFEMTkzN0UsIDB4MzhEOEMyQzQsIDB4NEZERkYyNTIsIDB4RDFCQjY3RjEsXG4gICAgIDB4QTZCQzU3NjcsIDB4M0ZCNTA2REQsIDB4NDhCMjM2NEIsIDB4RDgwRDJCREEsIDB4QUYwQTFCNEMsXG4gICAgIDB4MzYwMzRBRjYsIDB4NDEwNDdBNjAsIDB4REY2MEVGQzMsIDB4QTg2N0RGNTUsIDB4MzE2RThFRUYsXG4gICAgIDB4NDY2OUJFNzksIDB4Q0I2MUIzOEMsIDB4QkM2NjgzMUEsIDB4MjU2RkQyQTAsIDB4NTI2OEUyMzYsXG4gICAgIDB4Q0MwQzc3OTUsIDB4QkIwQjQ3MDMsIDB4MjIwMjE2QjksIDB4NTUwNTI2MkYsIDB4QzVCQTNCQkUsXG4gICAgIDB4QjJCRDBCMjgsIDB4MkJCNDVBOTIsIDB4NUNCMzZBMDQsIDB4QzJEN0ZGQTcsIDB4QjVEMENGMzEsXG4gICAgIDB4MkNEOTlFOEIsIDB4NUJERUFFMUQsIDB4OUI2NEMyQjAsIDB4RUM2M0YyMjYsIDB4NzU2QUEzOUMsXG4gICAgIDB4MDI2RDkzMEEsIDB4OUMwOTA2QTksIDB4RUIwRTM2M0YsIDB4NzIwNzY3ODUsIDB4MDUwMDU3MTMsXG4gICAgIDB4OTVCRjRBODIsIDB4RTJCODdBMTQsIDB4N0JCMTJCQUUsIDB4MENCNjFCMzgsIDB4OTJEMjhFOUIsXG4gICAgIDB4RTVENUJFMEQsIDB4N0NEQ0VGQjcsIDB4MEJEQkRGMjEsIDB4ODZEM0QyRDQsIDB4RjFENEUyNDIsXG4gICAgIDB4NjhEREIzRjgsIDB4MUZEQTgzNkUsIDB4ODFCRTE2Q0QsIDB4RjZCOTI2NUIsIDB4NkZCMDc3RTEsXG4gICAgIDB4MThCNzQ3NzcsIDB4ODgwODVBRTYsIDB4RkYwRjZBNzAsIDB4NjYwNjNCQ0EsIDB4MTEwMTBCNUMsXG4gICAgIDB4OEY2NTlFRkYsIDB4Rjg2MkFFNjksIDB4NjE2QkZGRDMsIDB4MTY2Q0NGNDUsIDB4QTAwQUUyNzgsXG4gICAgIDB4RDcwREQyRUUsIDB4NEUwNDgzNTQsIDB4MzkwM0IzQzIsIDB4QTc2NzI2NjEsIDB4RDA2MDE2RjcsXG4gICAgIDB4NDk2OTQ3NEQsIDB4M0U2RTc3REIsIDB4QUVEMTZBNEEsIDB4RDlENjVBREMsIDB4NDBERjBCNjYsXG4gICAgIDB4MzdEODNCRjAsIDB4QTlCQ0FFNTMsIDB4REVCQjlFQzUsIDB4NDdCMkNGN0YsIDB4MzBCNUZGRTksXG4gICAgIDB4QkRCREYyMUMsIDB4Q0FCQUMyOEEsIDB4NTNCMzkzMzAsIDB4MjRCNEEzQTYsIDB4QkFEMDM2MDUsXG4gICAgIDB4Q0RENzA2OTMsIDB4NTRERTU3MjksIDB4MjNEOTY3QkYsIDB4QjM2NjdBMkUsIDB4QzQ2MTRBQjgsXG4gICAgIDB4NUQ2ODFCMDIsIDB4MkE2RjJCOTQsIDB4QjQwQkJFMzcsIDB4QzMwQzhFQTEsIDB4NUEwNURGMUIsXG4gICAgIDB4MkQwMkVGOERdLFxuXG4gICAgY3JjMzI6IGZ1bmN0aW9uIGNyYzMyKGRhdGEpIHtcbiAgICAgIHZhciB0YmwgPSB1dGlsLmNyeXB0by5jcmMzMlRhYmxlO1xuICAgICAgdmFyIGNyYyA9IDAgXiAtMTtcblxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBkYXRhID0gdXRpbC5idWZmZXIudG9CdWZmZXIoZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IGRhdGEucmVhZFVJbnQ4KGkpO1xuICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRibFsoY3JjIF4gY29kZSkgJiAweEZGXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoY3JjIF4gLTEpID4+PiAwO1xuICAgIH0sXG5cbiAgICBobWFjOiBmdW5jdGlvbiBobWFjKGtleSwgc3RyaW5nLCBkaWdlc3QsIGZuKSB7XG4gICAgICBpZiAoIWRpZ2VzdCkgZGlnZXN0ID0gJ2JpbmFyeSc7XG4gICAgICBpZiAoZGlnZXN0ID09PSAnYnVmZmVyJykgeyBkaWdlc3QgPSB1bmRlZmluZWQ7IH1cbiAgICAgIGlmICghZm4pIGZuID0gJ3NoYTI1Nic7XG4gICAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycpIHN0cmluZyA9IHV0aWwuYnVmZmVyLnRvQnVmZmVyKHN0cmluZyk7XG4gICAgICByZXR1cm4gdXRpbC5jcnlwdG8ubGliLmNyZWF0ZUhtYWMoZm4sIGtleSkudXBkYXRlKHN0cmluZykuZGlnZXN0KGRpZ2VzdCk7XG4gICAgfSxcblxuICAgIG1kNTogZnVuY3Rpb24gbWQ1KGRhdGEsIGRpZ2VzdCwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB1dGlsLmNyeXB0by5oYXNoKCdtZDUnLCBkYXRhLCBkaWdlc3QsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgc2hhMjU2OiBmdW5jdGlvbiBzaGEyNTYoZGF0YSwgZGlnZXN0LCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHV0aWwuY3J5cHRvLmhhc2goJ3NoYTI1NicsIGRhdGEsIGRpZ2VzdCwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICBoYXNoOiBmdW5jdGlvbihhbGdvcml0aG0sIGRhdGEsIGRpZ2VzdCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBoYXNoID0gdXRpbC5jcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0pO1xuICAgICAgaWYgKCFkaWdlc3QpIHsgZGlnZXN0ID0gJ2JpbmFyeSc7IH1cbiAgICAgIGlmIChkaWdlc3QgPT09ICdidWZmZXInKSB7IGRpZ2VzdCA9IHVuZGVmaW5lZDsgfVxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgZGF0YSA9IHV0aWwuYnVmZmVyLnRvQnVmZmVyKGRhdGEpO1xuICAgICAgdmFyIHNsaWNlRm4gPSB1dGlsLmFycmF5U2xpY2VGbihkYXRhKTtcbiAgICAgIHZhciBpc0J1ZmZlciA9IHV0aWwuQnVmZmVyLmlzQnVmZmVyKGRhdGEpO1xuICAgICAgLy9JZGVudGlmeWluZyBvYmplY3RzIHdpdGggYW4gQXJyYXlCdWZmZXIgYXMgYnVmZmVyc1xuICAgICAgaWYgKHV0aWwuaXNCcm93c2VyKCkgJiYgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhICYmIGRhdGEuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGlzQnVmZmVyID0gdHJ1ZTtcblxuICAgICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIHR5cGVvZiBkYXRhLm9uID09PSAnZnVuY3Rpb24nICYmICFpc0J1ZmZlcikge1xuICAgICAgICBkYXRhLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHsgaGFzaC51cGRhdGUoY2h1bmspOyB9KTtcbiAgICAgICAgZGF0YS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHsgY2FsbGJhY2soZXJyKTsgfSk7XG4gICAgICAgIGRhdGEub24oJ2VuZCcsIGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhudWxsLCBoYXNoLmRpZ2VzdChkaWdlc3QpKTsgfSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbGxiYWNrICYmIHNsaWNlRm4gJiYgIWlzQnVmZmVyICYmXG4gICAgICAgICAgICAgICAgIHR5cGVvZiBGaWxlUmVhZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyB0aGlzIG1pZ2h0IGJlIGEgRmlsZS9CbG9iXG4gICAgICAgIHZhciBpbmRleCA9IDAsIHNpemUgPSAxMDI0ICogNTEyO1xuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZWFkIGRhdGEuJykpO1xuICAgICAgICB9O1xuICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGJ1ZiA9IG5ldyB1dGlsLkJ1ZmZlcihuZXcgVWludDhBcnJheShyZWFkZXIucmVzdWx0KSk7XG4gICAgICAgICAgaGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgICBpbmRleCArPSBidWYubGVuZ3RoO1xuICAgICAgICAgIHJlYWRlci5fY29udGludWVSZWFkaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5fY29udGludWVSZWFkaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGluZGV4ID49IGRhdGEuc2l6ZSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgaGFzaC5kaWdlc3QoZGlnZXN0KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJhY2sgPSBpbmRleCArIHNpemU7XG4gICAgICAgICAgaWYgKGJhY2sgPiBkYXRhLnNpemUpIGJhY2sgPSBkYXRhLnNpemU7XG4gICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHNsaWNlRm4uY2FsbChkYXRhLCBpbmRleCwgYmFjaykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlYWRlci5fY29udGludWVSZWFkaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodXRpbC5pc0Jyb3dzZXIoKSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgIWlzQnVmZmVyKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyB1dGlsLkJ1ZmZlcihuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dCA9IGhhc2gudXBkYXRlKGRhdGEpLmRpZ2VzdChkaWdlc3QpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKG51bGwsIG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRvSGV4OiBmdW5jdGlvbiB0b0hleChkYXRhKSB7XG4gICAgICB2YXIgb3V0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2goKCcwJyArIGRhdGEuY2hhckNvZGVBdChpKS50b1N0cmluZygxNikpLnN1YnN0cigtMiwgMikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgY3JlYXRlSGFzaDogZnVuY3Rpb24gY3JlYXRlSGFzaChhbGdvcml0aG0pIHtcbiAgICAgIHJldHVybiB1dGlsLmNyeXB0by5saWIuY3JlYXRlSGFzaChhbGdvcml0aG0pO1xuICAgIH1cblxuICB9LFxuXG4gIC8qKiBAIWlnbm9yZSAqL1xuXG4gIC8qIEFib3J0IGNvbnN0YW50ICovXG4gIGFib3J0OiB7fSxcblxuICBlYWNoOiBmdW5jdGlvbiBlYWNoKG9iamVjdCwgaXRlckZ1bmN0aW9uKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgdmFyIHJldCA9IGl0ZXJGdW5jdGlvbi5jYWxsKHRoaXMsIGtleSwgb2JqZWN0W2tleV0pO1xuICAgICAgICBpZiAocmV0ID09PSB1dGlsLmFib3J0KSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYXJyYXlFYWNoOiBmdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJGdW5jdGlvbikge1xuICAgIGZvciAodmFyIGlkeCBpbiBhcnJheSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaWR4KSkge1xuICAgICAgICB2YXIgcmV0ID0gaXRlckZ1bmN0aW9uLmNhbGwodGhpcywgYXJyYXlbaWR4XSwgcGFyc2VJbnQoaWR4LCAxMCkpO1xuICAgICAgICBpZiAocmV0ID09PSB1dGlsLmFib3J0KSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqMSwgb2JqMikge1xuICAgIHV0aWwuZWFjaChvYmoyLCBmdW5jdGlvbiBpdGVyYXRvcihrZXksIGl0ZW0pIHtcbiAgICAgIG9iajFba2V5XSA9IGl0ZW07XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajE7XG4gIH0sXG5cbiAgbWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKG9iajEsIG9iajIpIHtcbiAgICByZXR1cm4gdXRpbC51cGRhdGUodXRpbC5jb3B5KG9iajEpLCBvYmoyKTtcbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiBjb3B5KG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB1bmRlZmluZWQpIHJldHVybiBvYmplY3Q7XG4gICAgdmFyIGR1cGUgPSB7fTtcbiAgICAvLyBqc2hpbnQgZm9yaW46ZmFsc2VcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBkdXBlW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGR1cGU7XG4gIH0sXG5cbiAgaXNFbXB0eTogZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgYXJyYXlTbGljZUZuOiBmdW5jdGlvbiBhcnJheVNsaWNlRm4ob2JqKSB7XG4gICAgdmFyIGZuID0gb2JqLnNsaWNlIHx8IG9iai53ZWJraXRTbGljZSB8fCBvYmoubW96U2xpY2U7XG4gICAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuIDogbnVsbDtcbiAgfSxcblxuICBpc1R5cGU6IGZ1bmN0aW9uIGlzVHlwZShvYmosIHR5cGUpIHtcbiAgICAvLyBoYW5kbGUgY3Jvc3MtXCJmcmFtZVwiIG9iamVjdHNcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHR5cGUgPSB1dGlsLnR5cGVOYW1lKHR5cGUpO1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgJyArIHR5cGUgKyAnXSc7XG4gIH0sXG5cbiAgdHlwZU5hbWU6IGZ1bmN0aW9uIHR5cGVOYW1lKHR5cGUpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGUsICduYW1lJykpIHJldHVybiB0eXBlLm5hbWU7XG4gICAgdmFyIHN0ciA9IHR5cGUudG9TdHJpbmcoKTtcbiAgICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goL15cXHMqZnVuY3Rpb24gKC4rKVxcKC8pO1xuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogc3RyO1xuICB9LFxuXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcihlcnIsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3JpZ2luYWxFcnJvciA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgZXJyLm1lc3NhZ2UgIT09ICcnKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnIHx8IChvcHRpb25zICYmIG9wdGlvbnMubWVzc2FnZSkpIHtcbiAgICAgICAgb3JpZ2luYWxFcnJvciA9IHV0aWwuY29weShlcnIpO1xuICAgICAgICBvcmlnaW5hbEVycm9yLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZSB8fCBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyLm1lc3NhZ2UgPSBvcHRpb25zO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgIHV0aWwudXBkYXRlKGVyciwgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5tZXNzYWdlKVxuICAgICAgICBlcnIubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICAgIGlmIChvcHRpb25zLmNvZGUgfHwgb3B0aW9ucy5uYW1lKVxuICAgICAgICBlcnIuY29kZSA9IG9wdGlvbnMuY29kZSB8fCBvcHRpb25zLm5hbWU7XG4gICAgICBpZiAob3B0aW9ucy5zdGFjaylcbiAgICAgICAgZXJyLnN0YWNrID0gb3B0aW9ucy5zdGFjaztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ25hbWUnLCB7d3JpdGFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAnbWVzc2FnZScsIHtlbnVtZXJhYmxlOiB0cnVlfSk7XG4gICAgfVxuXG4gICAgZXJyLm5hbWUgPSBvcHRpb25zICYmIG9wdGlvbnMubmFtZSB8fCBlcnIubmFtZSB8fCBlcnIuY29kZSB8fCAnRXJyb3InO1xuICAgIGVyci50aW1lID0gbmV3IERhdGUoKTtcblxuICAgIGlmIChvcmlnaW5hbEVycm9yKSBlcnIub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG5cbiAgICByZXR1cm4gZXJyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGluaGVyaXQ6IGZ1bmN0aW9uIGluaGVyaXQoa2xhc3MsIGZlYXR1cmVzKSB7XG4gICAgdmFyIG5ld09iamVjdCA9IG51bGw7XG4gICAgaWYgKGZlYXR1cmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZlYXR1cmVzID0ga2xhc3M7XG4gICAgICBrbGFzcyA9IE9iamVjdDtcbiAgICAgIG5ld09iamVjdCA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3RvciA9IGZ1bmN0aW9uIENvbnN0cnVjdG9yV3JhcHBlcigpIHt9O1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSBrbGFzcy5wcm90b3R5cGU7XG4gICAgICBuZXdPYmplY3QgPSBuZXcgY3RvcigpO1xuICAgIH1cblxuICAgIC8vIGNvbnN0cnVjdG9yIG5vdCBzdXBwbGllZCwgY3JlYXRlIHBhc3MtdGhyb3VnaCBjdG9yXG4gICAgaWYgKGZlYXR1cmVzLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgIGZlYXR1cmVzLmNvbnN0cnVjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChrbGFzcyAhPT0gT2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGtsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZmVhdHVyZXMuY29uc3RydWN0b3IucHJvdG90eXBlID0gbmV3T2JqZWN0O1xuICAgIHV0aWwudXBkYXRlKGZlYXR1cmVzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgZmVhdHVyZXMpO1xuICAgIGZlYXR1cmVzLmNvbnN0cnVjdG9yLl9fc3VwZXJfXyA9IGtsYXNzO1xuICAgIHJldHVybiBmZWF0dXJlcy5jb25zdHJ1Y3RvcjtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBtaXhpbjogZnVuY3Rpb24gbWl4aW4oKSB7XG4gICAgdmFyIGtsYXNzID0gYXJndW1lbnRzWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBqc2hpbnQgZm9yaW46ZmFsc2VcbiAgICAgIGZvciAodmFyIHByb3AgaW4gYXJndW1lbnRzW2ldLnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgZm4gPSBhcmd1bWVudHNbaV0ucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGtsYXNzLnByb3RvdHlwZVtwcm9wXSA9IGZuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrbGFzcztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBoaWRlUHJvcGVydGllczogZnVuY3Rpb24gaGlkZVByb3BlcnRpZXMob2JqLCBwcm9wcykge1xuICAgIGlmICh0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICB1dGlsLmFycmF5RWFjaChwcm9wcywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHByb3BlcnR5OiBmdW5jdGlvbiBwcm9wZXJ0eShvYmosIG5hbWUsIHZhbHVlLCBlbnVtZXJhYmxlLCBpc1ZhbHVlKSB7XG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBlbnVtZXJhYmxlICE9PSB1bmRlZmluZWQgPyBlbnVtZXJhYmxlIDogdHJ1ZVxuICAgIH07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNWYWx1ZSkge1xuICAgICAgb3B0cy5nZXQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvcHRzLnZhbHVlID0gdmFsdWU7IG9wdHMud3JpdGFibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIG9wdHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG1lbW9pemVkUHJvcGVydHk6IGZ1bmN0aW9uIG1lbW9pemVkUHJvcGVydHkob2JqLCBuYW1lLCBnZXQsIGVudW1lcmFibGUpIHtcbiAgICB2YXIgY2FjaGVkVmFsdWUgPSBudWxsO1xuXG4gICAgLy8gYnVpbGQgZW51bWVyYWJsZSBhdHRyaWJ1dGUgZm9yIGVhY2ggdmFsdWUgd2l0aCBsYXp5IGFjY2Vzc29yLlxuICAgIHV0aWwucHJvcGVydHkob2JqLCBuYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjYWNoZWRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBjYWNoZWRWYWx1ZSA9IGdldCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlZFZhbHVlO1xuICAgIH0sIGVudW1lcmFibGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUT0RPIFJlbW92ZSBpbiBtYWpvciB2ZXJzaW9uIHJldmlzaW9uXG4gICAqIFRoaXMgYmFja2ZpbGwgcG9wdWxhdGVzIHJlc3BvbnNlIGRhdGEgd2l0aG91dCB0aGVcbiAgICogdG9wLWxldmVsIHBheWxvYWQgbmFtZS5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBob2lzdFBheWxvYWRNZW1iZXI6IGZ1bmN0aW9uIGhvaXN0UGF5bG9hZE1lbWJlcihyZXNwKSB7XG4gICAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgICB2YXIgb3BlcmF0aW9uTmFtZSA9IHJlcS5vcGVyYXRpb247XG4gICAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW29wZXJhdGlvbk5hbWVdO1xuICAgIHZhciBvdXRwdXQgPSBvcGVyYXRpb24ub3V0cHV0O1xuICAgIGlmIChvdXRwdXQucGF5bG9hZCAmJiAhb3BlcmF0aW9uLmhhc0V2ZW50T3V0cHV0KSB7XG4gICAgICB2YXIgcGF5bG9hZE1lbWJlciA9IG91dHB1dC5tZW1iZXJzW291dHB1dC5wYXlsb2FkXTtcbiAgICAgIHZhciByZXNwb25zZVBheWxvYWQgPSByZXNwLmRhdGFbb3V0cHV0LnBheWxvYWRdO1xuICAgICAgaWYgKHBheWxvYWRNZW1iZXIudHlwZSA9PT0gJ3N0cnVjdHVyZScpIHtcbiAgICAgICAgdXRpbC5lYWNoKHJlc3BvbnNlUGF5bG9hZCwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHV0aWwucHJvcGVydHkocmVzcC5kYXRhLCBrZXksIHZhbHVlLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ29tcHV0ZSBTSEEtMjU2IGNoZWNrc3VtcyBvZiBzdHJlYW1zXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29tcHV0ZVNoYTI1NjogZnVuY3Rpb24gY29tcHV0ZVNoYTI1Nihib2R5LCBkb25lKSB7XG4gICAgaWYgKHV0aWwuaXNOb2RlKCkpIHtcbiAgICAgIHZhciBTdHJlYW0gPSB1dGlsLnN0cmVhbS5TdHJlYW07XG4gICAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgICAgaWYgKHR5cGVvZiBTdHJlYW0gPT09ICdmdW5jdGlvbicgJiYgYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkucGF0aCA9PT0gJ3N0cmluZycpIHsgLy8gYXNzdW1lIGZpbGUgb2JqZWN0XG4gICAgICAgICAgdmFyIHNldHRpbmdzID0ge307XG4gICAgICAgICAgaWYgKHR5cGVvZiBib2R5LnN0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgc2V0dGluZ3Muc3RhcnQgPSBib2R5LnN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGJvZHkuZW5kID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgc2V0dGluZ3MuZW5kID0gYm9keS5lbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvZHkgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGJvZHkucGF0aCwgc2V0dGluZ3MpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUT0RPIHN1cHBvcnQgb3RoZXIgc3RyZWFtIHR5cGVzXG4gICAgICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdOb24tZmlsZSBzdHJlYW0gb2JqZWN0cyBhcmUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdub3Qgc3VwcG9ydGVkIHdpdGggU2lnVjQnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlsLmNyeXB0by5zaGEyNTYoYm9keSwgJ2hleCcsIGZ1bmN0aW9uKGVyciwgc2hhKSB7XG4gICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICBlbHNlIGRvbmUobnVsbCwgc2hhKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpc0Nsb2NrU2tld2VkOiBmdW5jdGlvbiBpc0Nsb2NrU2tld2VkKHNlcnZlclRpbWUpIHtcbiAgICBpZiAoc2VydmVyVGltZSkge1xuICAgICAgdXRpbC5wcm9wZXJ0eShBV1MuY29uZmlnLCAnaXNDbG9ja1NrZXdlZCcsXG4gICAgICAgIE1hdGguYWJzKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc2VydmVyVGltZSkgPj0gMzAwMDAwLCBmYWxzZSk7XG4gICAgICByZXR1cm4gQVdTLmNvbmZpZy5pc0Nsb2NrU2tld2VkO1xuICAgIH1cbiAgfSxcblxuICBhcHBseUNsb2NrT2Zmc2V0OiBmdW5jdGlvbiBhcHBseUNsb2NrT2Zmc2V0KHNlcnZlclRpbWUpIHtcbiAgICBpZiAoc2VydmVyVGltZSlcbiAgICAgIEFXUy5jb25maWcuc3lzdGVtQ2xvY2tPZmZzZXQgPSBzZXJ2ZXJUaW1lIC0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZXh0cmFjdFJlcXVlc3RJZDogZnVuY3Rpb24gZXh0cmFjdFJlcXVlc3RJZChyZXNwKSB7XG4gICAgdmFyIHJlcXVlc3RJZCA9IHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3gtYW16LXJlcXVlc3QtaWQnXSB8fFxuICAgICAgICAgICAgICAgICAgICAgcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXpuLXJlcXVlc3RpZCddO1xuXG4gICAgaWYgKCFyZXF1ZXN0SWQgJiYgcmVzcC5kYXRhICYmIHJlc3AuZGF0YS5SZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICByZXF1ZXN0SWQgPSByZXNwLmRhdGEuUmVzcG9uc2VNZXRhZGF0YS5SZXF1ZXN0SWQ7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3RJZCkge1xuICAgICAgcmVzcC5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gICAgfVxuXG4gICAgaWYgKHJlc3AuZXJyb3IpIHtcbiAgICAgIHJlc3AuZXJyb3IucmVxdWVzdElkID0gcmVxdWVzdElkO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhZGRQcm9taXNlczogZnVuY3Rpb24gYWRkUHJvbWlzZXMoY29uc3RydWN0b3JzLCBQcm9taXNlRGVwZW5kZW5jeSkge1xuICAgIHZhciBkZWxldGVQcm9taXNlcyA9IGZhbHNlO1xuICAgIGlmIChQcm9taXNlRGVwZW5kZW5jeSA9PT0gdW5kZWZpbmVkICYmIEFXUyAmJiBBV1MuY29uZmlnKSB7XG4gICAgICBQcm9taXNlRGVwZW5kZW5jeSA9IEFXUy5jb25maWcuZ2V0UHJvbWlzZXNEZXBlbmRlbmN5KCk7XG4gICAgfVxuICAgIGlmIChQcm9taXNlRGVwZW5kZW5jeSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgUHJvbWlzZURlcGVuZGVuY3kgPSBQcm9taXNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIFByb21pc2VEZXBlbmRlbmN5ICE9PSAnZnVuY3Rpb24nKSBkZWxldGVQcm9taXNlcyA9IHRydWU7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbnN0cnVjdG9ycykpIGNvbnN0cnVjdG9ycyA9IFtjb25zdHJ1Y3RvcnNdO1xuXG4gICAgZm9yICh2YXIgaW5kID0gMDsgaW5kIDwgY29uc3RydWN0b3JzLmxlbmd0aDsgaW5kKyspIHtcbiAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yc1tpbmRdO1xuICAgICAgaWYgKGRlbGV0ZVByb21pc2VzKSB7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvci5kZWxldGVQcm9taXNlc0Zyb21DbGFzcykge1xuICAgICAgICAgIGNvbnN0cnVjdG9yLmRlbGV0ZVByb21pc2VzRnJvbUNsYXNzKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29uc3RydWN0b3IuYWRkUHJvbWlzZXNUb0NsYXNzKSB7XG4gICAgICAgIGNvbnN0cnVjdG9yLmFkZFByb21pc2VzVG9DbGFzcyhQcm9taXNlRGVwZW5kZW5jeSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJldHVybiBhIHByb21pc2Ugd2hvc2UgZmF0ZSBpcyBkZWNpZGVkIGJ5IHRoZVxuICAgKiBjYWxsYmFjayBiZWhhdmlvciBvZiB0aGUgZ2l2ZW4gbWV0aG9kIHdpdGggYG1ldGhvZE5hbWVgLiBUaGUgbWV0aG9kIHRvIGJlXG4gICAqIHByb21pc2lmaWVkIHNob3VsZCBjb25mb3JtIHRvIG5vZGUuanMgY29udmVudGlvbiBvZiBhY2NlcHRpbmcgYSBjYWxsYmFjayBhc1xuICAgKiBsYXN0IGFyZ3VtZW50IGFuZCBjYWxsaW5nIHRoYXQgY2FsbGJhY2sgd2l0aCBlcnJvciBhcyB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICogYW5kIHN1Y2Nlc3MgdmFsdWUgb24gdGhlIHNlY29uZCBhcmd1bWVudC5cbiAgICovXG4gIHByb21pc2lmeU1ldGhvZDogZnVuY3Rpb24gcHJvbWlzaWZ5TWV0aG9kKG1ldGhvZE5hbWUsIFByb21pc2VEZXBlbmRlbmN5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHByb21pc2UoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2VEZXBlbmRlbmN5KGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBhcmdzLnB1c2goZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2VsZlttZXRob2ROYW1lXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaXNEdWFsc3RhY2tBdmFpbGFibGU6IGZ1bmN0aW9uIGlzRHVhbHN0YWNrQXZhaWxhYmxlKHNlcnZpY2UpIHtcbiAgICBpZiAoIXNlcnZpY2UpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuLi9hcGlzL21ldGFkYXRhLmpzb24nKTtcbiAgICBpZiAodHlwZW9mIHNlcnZpY2UgIT09ICdzdHJpbmcnKSBzZXJ2aWNlID0gc2VydmljZS5zZXJ2aWNlSWRlbnRpZmllcjtcbiAgICBpZiAodHlwZW9mIHNlcnZpY2UgIT09ICdzdHJpbmcnIHx8ICFtZXRhZGF0YS5oYXNPd25Qcm9wZXJ0eShzZXJ2aWNlKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAhIW1ldGFkYXRhW3NlcnZpY2VdLmR1YWxzdGFja0F2YWlsYWJsZTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjYWxjdWxhdGVSZXRyeURlbGF5OiBmdW5jdGlvbiBjYWxjdWxhdGVSZXRyeURlbGF5KHJldHJ5Q291bnQsIHJldHJ5RGVsYXlPcHRpb25zLCBlcnIpIHtcbiAgICBpZiAoIXJldHJ5RGVsYXlPcHRpb25zKSByZXRyeURlbGF5T3B0aW9ucyA9IHt9O1xuICAgIHZhciBjdXN0b21CYWNrb2ZmID0gcmV0cnlEZWxheU9wdGlvbnMuY3VzdG9tQmFja29mZiB8fCBudWxsO1xuICAgIGlmICh0eXBlb2YgY3VzdG9tQmFja29mZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGN1c3RvbUJhY2tvZmYocmV0cnlDb3VudCwgZXJyKTtcbiAgICB9XG4gICAgdmFyIGJhc2UgPSB0eXBlb2YgcmV0cnlEZWxheU9wdGlvbnMuYmFzZSA9PT0gJ251bWJlcicgPyByZXRyeURlbGF5T3B0aW9ucy5iYXNlIDogMTAwO1xuICAgIHZhciBkZWxheSA9IE1hdGgucmFuZG9tKCkgKiAoTWF0aC5wb3coMiwgcmV0cnlDb3VudCkgKiBiYXNlKTtcbiAgICByZXR1cm4gZGVsYXk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlUmVxdWVzdFdpdGhSZXRyaWVzOiBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0V2l0aFJldHJpZXMoaHR0cFJlcXVlc3QsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgdmFyIGh0dHAgPSBBV1MuSHR0cENsaWVudC5nZXRJbnN0YW5jZSgpO1xuICAgIHZhciBodHRwT3B0aW9ucyA9IG9wdGlvbnMuaHR0cE9wdGlvbnMgfHwge307XG4gICAgdmFyIHJldHJ5Q291bnQgPSAwO1xuXG4gICAgdmFyIGVyckNhbGxiYWNrID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICB2YXIgbWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcyB8fCAwO1xuICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gJ1RpbWVvdXRFcnJvcicpIGVyci5yZXRyeWFibGUgPSB0cnVlO1xuICAgICAgdmFyIGRlbGF5ID0gdXRpbC5jYWxjdWxhdGVSZXRyeURlbGF5KHJldHJ5Q291bnQsIG9wdGlvbnMucmV0cnlEZWxheU9wdGlvbnMsIGVycik7XG4gICAgICBpZiAoZXJyICYmIGVyci5yZXRyeWFibGUgJiYgcmV0cnlDb3VudCA8IG1heFJldHJpZXMgJiYgZGVsYXkgPj0gMCkge1xuICAgICAgICByZXRyeUNvdW50Kys7XG4gICAgICAgIHNldFRpbWVvdXQoc2VuZFJlcXVlc3QsIGRlbGF5ICsgKGVyci5yZXRyeUFmdGVyIHx8IDApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzZW5kUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRhdGEgPSAnJztcbiAgICAgIGh0dHAuaGFuZGxlUmVxdWVzdChodHRwUmVxdWVzdCwgaHR0cE9wdGlvbnMsIGZ1bmN0aW9uKGh0dHBSZXNwb25zZSkge1xuICAgICAgICBodHRwUmVzcG9uc2Uub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykgeyBkYXRhICs9IGNodW5rLnRvU3RyaW5nKCk7IH0pO1xuICAgICAgICBodHRwUmVzcG9uc2Uub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBzdGF0dXNDb2RlID0gaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPCAzMDApIHtcbiAgICAgICAgICAgIGNiKG51bGwsIGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmV0cnlBZnRlciA9IHBhcnNlSW50KGh0dHBSZXNwb25zZS5oZWFkZXJzWydyZXRyeS1hZnRlciddLCAxMCkgKiAxMDAwIHx8IDA7XG4gICAgICAgICAgICB2YXIgZXJyID0gdXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgcmV0cnlhYmxlOiBzdGF0dXNDb2RlID49IDUwMCB8fCBzdGF0dXNDb2RlID09PSA0MjlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChyZXRyeUFmdGVyICYmIGVyci5yZXRyeWFibGUpIGVyci5yZXRyeUFmdGVyID0gcmV0cnlBZnRlcjtcbiAgICAgICAgICAgIGVyckNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIGVyckNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgQVdTLnV0aWwuZGVmZXIoc2VuZFJlcXVlc3QpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHV1aWQ6IHtcbiAgICB2NDogZnVuY3Rpb24gdXVpZFY0KCkge1xuICAgICAgcmV0dXJuIHJlcXVpcmUoJ3V1aWQnKS52NCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb252ZXJ0UGF5bG9hZFRvU3RyaW5nOiBmdW5jdGlvbiBjb252ZXJ0UGF5bG9hZFRvU3RyaW5nKHJlc3ApIHtcbiAgICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICAgIHZhciBvcGVyYXRpb24gPSByZXEub3BlcmF0aW9uO1xuICAgIHZhciBydWxlcyA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW29wZXJhdGlvbl0ub3V0cHV0IHx8IHt9O1xuICAgIGlmIChydWxlcy5wYXlsb2FkICYmIHJlc3AuZGF0YVtydWxlcy5wYXlsb2FkXSkge1xuICAgICAgcmVzcC5kYXRhW3J1bGVzLnBheWxvYWRdID0gcmVzcC5kYXRhW3J1bGVzLnBheWxvYWRdLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGRlZmVyOiBmdW5jdGlvbiBkZWZlcihjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldFJlcXVlc3RQYXlsb2FkU2hhcGU6IGZ1bmN0aW9uIGdldFJlcXVlc3RQYXlsb2FkU2hhcGUocmVxKSB7XG4gICAgdmFyIG9wZXJhdGlvbnMgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucztcbiAgICBpZiAoIW9wZXJhdGlvbnMpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdmFyIG9wZXJhdGlvbiA9IChvcGVyYXRpb25zIHx8IHt9KVtyZXEub3BlcmF0aW9uXTtcbiAgICBpZiAoIW9wZXJhdGlvbiB8fCAhb3BlcmF0aW9uLmlucHV0IHx8ICFvcGVyYXRpb24uaW5wdXQucGF5bG9hZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gb3BlcmF0aW9uLmlucHV0Lm1lbWJlcnNbb3BlcmF0aW9uLmlucHV0LnBheWxvYWRdO1xuICB9LFxuXG4gIGdldFByb2ZpbGVzRnJvbVNoYXJlZENvbmZpZzogZnVuY3Rpb24gZ2V0UHJvZmlsZXNGcm9tU2hhcmVkQ29uZmlnKGluaUxvYWRlciwgZmlsZW5hbWUpIHtcbiAgICB2YXIgcHJvZmlsZXMgPSB7fTtcbiAgICB2YXIgcHJvZmlsZXNGcm9tQ29uZmlnID0ge307XG4gICAgaWYgKHByb2Nlc3MuZW52W3V0aWwuY29uZmlnT3B0SW5FbnZdKSB7XG4gICAgICB2YXIgcHJvZmlsZXNGcm9tQ29uZmlnID0gaW5pTG9hZGVyLmxvYWRGcm9tKHtcbiAgICAgICAgaXNDb25maWc6IHRydWUsXG4gICAgICAgIGZpbGVuYW1lOiBwcm9jZXNzLmVudlt1dGlsLnNoYXJlZENvbmZpZ0ZpbGVFbnZdXG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHByb2ZpbGVzRnJvbUNyZWRzID0gaW5pTG9hZGVyLmxvYWRGcm9tKHtcbiAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZSB8fFxuICAgICAgICAocHJvY2Vzcy5lbnZbdXRpbC5jb25maWdPcHRJbkVudl0gJiYgcHJvY2Vzcy5lbnZbdXRpbC5zaGFyZWRDcmVkZW50aWFsc0ZpbGVFbnZdKVxuICAgIH0pO1xuICAgIGZvciAodmFyIGkgPSAwLCBwcm9maWxlTmFtZXMgPSBPYmplY3Qua2V5cyhwcm9maWxlc0Zyb21Db25maWcpOyBpIDwgcHJvZmlsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9maWxlc1twcm9maWxlTmFtZXNbaV1dID0gcHJvZmlsZXNGcm9tQ29uZmlnW3Byb2ZpbGVOYW1lc1tpXV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBwcm9maWxlTmFtZXMgPSBPYmplY3Qua2V5cyhwcm9maWxlc0Zyb21DcmVkcyk7IGkgPCBwcm9maWxlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb2ZpbGVzW3Byb2ZpbGVOYW1lc1tpXV0gPSBwcm9maWxlc0Zyb21DcmVkc1twcm9maWxlTmFtZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gcHJvZmlsZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgQVJOOiB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlQVJOKHN0cikge1xuICAgICAgcmV0dXJuIHN0ciAmJiBzdHIuaW5kZXhPZignYXJuOicpID09PSAwICYmIHN0ci5zcGxpdCgnOicpLmxlbmd0aCA+PSA2O1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlQVJOKGFybikge1xuICAgICAgdmFyIG1hdGNoZWQgPSBhcm4uc3BsaXQoJzonKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcnRpdGlvbjogbWF0Y2hlZFsxXSxcbiAgICAgICAgc2VydmljZTogbWF0Y2hlZFsyXSxcbiAgICAgICAgcmVnaW9uOiBtYXRjaGVkWzNdLFxuICAgICAgICBhY2NvdW50SWQ6IG1hdGNoZWRbNF0sXG4gICAgICAgIHJlc291cmNlOiBtYXRjaGVkLnNsaWNlKDUpLmpvaW4oJzonKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGJ1aWxkOiBmdW5jdGlvbiBidWlsZEFSTihhcm5PYmplY3QpIHtcbiAgICAgIGlmIChcbiAgICAgICAgYXJuT2JqZWN0LnNlcnZpY2UgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBhcm5PYmplY3QucmVnaW9uID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgYXJuT2JqZWN0LmFjY291bnRJZCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGFybk9iamVjdC5yZXNvdXJjZSA9PT0gdW5kZWZpbmVkXG4gICAgICApIHRocm93IHV0aWwuZXJyb3IobmV3IEVycm9yKCdJbnB1dCBBUk4gb2JqZWN0IGlzIGludmFsaWQnKSk7XG4gICAgICByZXR1cm4gJ2FybjonKyAoYXJuT2JqZWN0LnBhcnRpdGlvbiB8fCAnYXdzJykgKyAnOicgKyBhcm5PYmplY3Quc2VydmljZSArXG4gICAgICAgICc6JyArIGFybk9iamVjdC5yZWdpb24gKyAnOicgKyBhcm5PYmplY3QuYWNjb3VudElkICsgJzonICsgYXJuT2JqZWN0LnJlc291cmNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBkZWZhdWx0UHJvZmlsZTogJ2RlZmF1bHQnLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbmZpZ09wdEluRW52OiAnQVdTX1NES19MT0FEX0NPTkZJRycsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2hhcmVkQ3JlZGVudGlhbHNGaWxlRW52OiAnQVdTX1NIQVJFRF9DUkVERU5USUFMU19GSUxFJyxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzaGFyZWRDb25maWdGaWxlRW52OiAnQVdTX0NPTkZJR19GSUxFJyxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpbWRzRGlzYWJsZWRFbnY6ICdBV1NfRUMyX01FVEFEQVRBX0RJU0FCTEVEJ1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB1dGlsO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgU2hhcGUgPSByZXF1aXJlKCcuLi9tb2RlbC9zaGFwZScpO1xuXG5mdW5jdGlvbiBEb21YbWxQYXJzZXIoKSB7IH1cblxuRG9tWG1sUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHhtbCwgc2hhcGUpIHtcbiAgaWYgKHhtbC5yZXBsYWNlKC9eXFxzKy8sICcnKSA9PT0gJycpIHJldHVybiB7fTtcblxuICB2YXIgcmVzdWx0LCBlcnJvcjtcbiAgdHJ5IHtcbiAgICBpZiAod2luZG93LkRPTVBhcnNlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgcmVzdWx0ID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWwsICd0ZXh0L3htbCcpO1xuICAgICAgfSBjYXRjaCAoc3ludGF4RXJyb3IpIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoJ1BhcnNlIGVycm9yIGluIGRvY3VtZW50JyksXG4gICAgICAgICAge1xuICAgICAgICAgICAgb3JpZ2luYWxFcnJvcjogc3ludGF4RXJyb3IsXG4gICAgICAgICAgICBjb2RlOiAnWE1MUGFyc2VyRXJyb3InLFxuICAgICAgICAgICAgcmV0cnlhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQuZG9jdW1lbnRFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IHV0aWwuZXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgZW1wdHkgZG9jdW1lbnQuJyksXG4gICAgICAgICAge1xuICAgICAgICAgICAgY29kZTogJ1hNTFBhcnNlckVycm9yJyxcbiAgICAgICAgICAgIHJldHJ5YWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNFcnJvciA9IHJlc3VsdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgncGFyc2VyZXJyb3InKVswXTtcbiAgICAgIGlmIChpc0Vycm9yICYmIChpc0Vycm9yLnBhcmVudE5vZGUgPT09IHJlc3VsdCB8fFxuICAgICAgICAgIGlzRXJyb3IucGFyZW50Tm9kZS5ub2RlTmFtZSA9PT0gJ2JvZHknIHx8XG4gICAgICAgICAgaXNFcnJvci5wYXJlbnROb2RlLnBhcmVudE5vZGUgPT09IHJlc3VsdCB8fFxuICAgICAgICAgIGlzRXJyb3IucGFyZW50Tm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lID09PSAnYm9keScpKSB7XG4gICAgICAgIHZhciBlcnJvckVsZW1lbnQgPSBpc0Vycm9yLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkaXYnKVswXSB8fCBpc0Vycm9yO1xuICAgICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcihlcnJvckVsZW1lbnQudGV4dENvbnRlbnQgfHwgJ1BhcnNlciBlcnJvciBpbiBkb2N1bWVudCcpLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvZGU6ICdYTUxQYXJzZXJFcnJvcicsXG4gICAgICAgICAgICByZXRyeWFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XG4gICAgICByZXN1bHQgPSBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxET00nKTtcbiAgICAgIHJlc3VsdC5hc3luYyA9IGZhbHNlO1xuXG4gICAgICBpZiAoIXJlc3VsdC5sb2FkWE1MKHhtbCkpIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoJ1BhcnNlIGVycm9yIGluIGRvY3VtZW50JyksXG4gICAgICAgICAge1xuICAgICAgICAgICAgY29kZTogJ1hNTFBhcnNlckVycm9yJyxcbiAgICAgICAgICAgIHJldHJ5YWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBsb2FkIFhNTCBwYXJzZXInKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvciA9IGU7XG4gIH1cblxuICBpZiAocmVzdWx0ICYmIHJlc3VsdC5kb2N1bWVudEVsZW1lbnQgJiYgIWVycm9yKSB7XG4gICAgdmFyIGRhdGEgPSBwYXJzZVhtbChyZXN1bHQuZG9jdW1lbnRFbGVtZW50LCBzaGFwZSk7XG4gICAgdmFyIG1ldGFkYXRhID0gZ2V0RWxlbWVudEJ5VGFnTmFtZShyZXN1bHQuZG9jdW1lbnRFbGVtZW50LCAnUmVzcG9uc2VNZXRhZGF0YScpO1xuICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgZGF0YS5SZXNwb25zZU1ldGFkYXRhID0gcGFyc2VYbWwobWV0YWRhdGEsIHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gZWxzZSBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyB1dGlsLmVycm9yKGVycm9yIHx8IG5ldyBFcnJvcigpLCB7Y29kZTogJ1hNTFBhcnNlckVycm9yJywgcmV0cnlhYmxlOiB0cnVlfSk7XG4gIH0gZWxzZSB7IC8vIGVtcHR5IHhtbCBkb2N1bWVudFxuICAgIHJldHVybiB7fTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0RWxlbWVudEJ5VGFnTmFtZSh4bWwsIHRhZykge1xuICB2YXIgZWxlbWVudHMgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKTtcbiAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICBpZiAoZWxlbWVudHNbaV0ucGFyZW50Tm9kZSA9PT0geG1sKSB7XG4gICAgICByZXR1cm4gZWxlbWVudHNbaV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlWG1sKHhtbCwgc2hhcGUpIHtcbiAgaWYgKCFzaGFwZSkgc2hhcGUgPSB7fTtcbiAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgY2FzZSAnc3RydWN0dXJlJzogcmV0dXJuIHBhcnNlU3RydWN0dXJlKHhtbCwgc2hhcGUpO1xuICAgIGNhc2UgJ21hcCc6IHJldHVybiBwYXJzZU1hcCh4bWwsIHNoYXBlKTtcbiAgICBjYXNlICdsaXN0JzogcmV0dXJuIHBhcnNlTGlzdCh4bWwsIHNoYXBlKTtcbiAgICBjYXNlIHVuZGVmaW5lZDogY2FzZSBudWxsOiByZXR1cm4gcGFyc2VVbmtub3duKHhtbCk7XG4gICAgZGVmYXVsdDogcmV0dXJuIHBhcnNlU2NhbGFyKHhtbCwgc2hhcGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RydWN0dXJlKHhtbCwgc2hhcGUpIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgaWYgKHhtbCA9PT0gbnVsbCkgcmV0dXJuIGRhdGE7XG5cbiAgdXRpbC5lYWNoKHNoYXBlLm1lbWJlcnMsIGZ1bmN0aW9uKG1lbWJlck5hbWUsIG1lbWJlclNoYXBlKSB7XG4gICAgaWYgKG1lbWJlclNoYXBlLmlzWG1sQXR0cmlidXRlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHhtbC5hdHRyaWJ1dGVzLCBtZW1iZXJTaGFwZS5uYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB4bWwuYXR0cmlidXRlc1ttZW1iZXJTaGFwZS5uYW1lXS52YWx1ZTtcbiAgICAgICAgZGF0YVttZW1iZXJOYW1lXSA9IHBhcnNlWG1sKHt0ZXh0Q29udGVudDogdmFsdWV9LCBtZW1iZXJTaGFwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4bWxDaGlsZCA9IG1lbWJlclNoYXBlLmZsYXR0ZW5lZCA/IHhtbCA6XG4gICAgICAgIGdldEVsZW1lbnRCeVRhZ05hbWUoeG1sLCBtZW1iZXJTaGFwZS5uYW1lKTtcbiAgICAgIGlmICh4bWxDaGlsZCkge1xuICAgICAgICBkYXRhW21lbWJlck5hbWVdID0gcGFyc2VYbWwoeG1sQ2hpbGQsIG1lbWJlclNoYXBlKTtcbiAgICAgIH0gZWxzZSBpZiAoIW1lbWJlclNoYXBlLmZsYXR0ZW5lZCAmJiBtZW1iZXJTaGFwZS50eXBlID09PSAnbGlzdCcpIHtcbiAgICAgICAgZGF0YVttZW1iZXJOYW1lXSA9IG1lbWJlclNoYXBlLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1hcCh4bWwsIHNoYXBlKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciB4bWxLZXkgPSBzaGFwZS5rZXkubmFtZSB8fCAna2V5JztcbiAgdmFyIHhtbFZhbHVlID0gc2hhcGUudmFsdWUubmFtZSB8fCAndmFsdWUnO1xuICB2YXIgdGFnTmFtZSA9IHNoYXBlLmZsYXR0ZW5lZCA/IHNoYXBlLm5hbWUgOiAnZW50cnknO1xuXG4gIHZhciBjaGlsZCA9IHhtbC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgd2hpbGUgKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLm5vZGVOYW1lID09PSB0YWdOYW1lKSB7XG4gICAgICB2YXIga2V5ID0gZ2V0RWxlbWVudEJ5VGFnTmFtZShjaGlsZCwgeG1sS2V5KS50ZXh0Q29udGVudDtcbiAgICAgIHZhciB2YWx1ZSA9IGdldEVsZW1lbnRCeVRhZ05hbWUoY2hpbGQsIHhtbFZhbHVlKTtcbiAgICAgIGRhdGFba2V5XSA9IHBhcnNlWG1sKHZhbHVlLCBzaGFwZS52YWx1ZSk7XG4gICAgfVxuICAgIGNoaWxkID0gY2hpbGQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBwYXJzZUxpc3QoeG1sLCBzaGFwZSkge1xuICB2YXIgZGF0YSA9IFtdO1xuICB2YXIgdGFnTmFtZSA9IHNoYXBlLmZsYXR0ZW5lZCA/IHNoYXBlLm5hbWUgOiAoc2hhcGUubWVtYmVyLm5hbWUgfHwgJ21lbWJlcicpO1xuXG4gIHZhciBjaGlsZCA9IHhtbC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgd2hpbGUgKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLm5vZGVOYW1lID09PSB0YWdOYW1lKSB7XG4gICAgICBkYXRhLnB1c2gocGFyc2VYbWwoY2hpbGQsIHNoYXBlLm1lbWJlcikpO1xuICAgIH1cbiAgICBjaGlsZCA9IGNoaWxkLm5leHRFbGVtZW50U2libGluZztcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTY2FsYXIoeG1sLCBzaGFwZSkge1xuICBpZiAoeG1sLmdldEF0dHJpYnV0ZSkge1xuICAgIHZhciBlbmNvZGluZyA9IHhtbC5nZXRBdHRyaWJ1dGUoJ2VuY29kaW5nJyk7XG4gICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgICAgc2hhcGUgPSBuZXcgU2hhcGUuY3JlYXRlKHt0eXBlOiBlbmNvZGluZ30pO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0ZXh0ID0geG1sLnRleHRDb250ZW50O1xuICBpZiAodGV4dCA9PT0gJycpIHRleHQgPSBudWxsO1xuICBpZiAodHlwZW9mIHNoYXBlLnRvVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzaGFwZS50b1R5cGUodGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VVbmtub3duKHhtbCkge1xuICBpZiAoeG1sID09PSB1bmRlZmluZWQgfHwgeG1sID09PSBudWxsKSByZXR1cm4gJyc7XG5cbiAgLy8gZW1wdHkgb2JqZWN0XG4gIGlmICgheG1sLmZpcnN0RWxlbWVudENoaWxkKSB7XG4gICAgaWYgKHhtbC5wYXJlbnROb2RlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiB7fTtcbiAgICBpZiAoeG1sLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgZWxzZSByZXR1cm4geG1sLnRleHRDb250ZW50O1xuICB9XG5cbiAgLy8gb2JqZWN0LCBwYXJzZSBhcyBzdHJ1Y3R1cmVcbiAgdmFyIHNoYXBlID0ge3R5cGU6ICdzdHJ1Y3R1cmUnLCBtZW1iZXJzOiB7fX07XG4gIHZhciBjaGlsZCA9IHhtbC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgd2hpbGUgKGNoaWxkKSB7XG4gICAgdmFyIHRhZyA9IGNoaWxkLm5vZGVOYW1lO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2hhcGUubWVtYmVycywgdGFnKSkge1xuICAgICAgLy8gbXVsdGlwbGUgdGFncyBvZiB0aGUgc2FtZSBuYW1lIG1ha2VzIGl0IGEgbGlzdFxuICAgICAgc2hhcGUubWVtYmVyc1t0YWddLnR5cGUgPSAnbGlzdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYXBlLm1lbWJlcnNbdGFnXSA9IHtuYW1lOiB0YWd9O1xuICAgIH1cbiAgICBjaGlsZCA9IGNoaWxkLm5leHRFbGVtZW50U2libGluZztcbiAgfVxuICByZXR1cm4gcGFyc2VTdHJ1Y3R1cmUoeG1sLCBzaGFwZSk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gRG9tWG1sUGFyc2VyO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgWG1sTm9kZSA9IHJlcXVpcmUoJy4veG1sLW5vZGUnKS5YbWxOb2RlO1xudmFyIFhtbFRleHQgPSByZXF1aXJlKCcuL3htbC10ZXh0JykuWG1sVGV4dDtcblxuZnVuY3Rpb24gWG1sQnVpbGRlcigpIHsgfVxuXG5YbWxCdWlsZGVyLnByb3RvdHlwZS50b1hNTCA9IGZ1bmN0aW9uKHBhcmFtcywgc2hhcGUsIHJvb3RFbGVtZW50LCBub0VtcHR5KSB7XG4gIHZhciB4bWwgPSBuZXcgWG1sTm9kZShyb290RWxlbWVudCk7XG4gIGFwcGx5TmFtZXNwYWNlcyh4bWwsIHNoYXBlLCB0cnVlKTtcbiAgc2VyaWFsaXplKHhtbCwgcGFyYW1zLCBzaGFwZSk7XG4gIHJldHVybiB4bWwuY2hpbGRyZW4ubGVuZ3RoID4gMCB8fCBub0VtcHR5ID8geG1sLnRvU3RyaW5nKCkgOiAnJztcbn07XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZSh4bWwsIHZhbHVlLCBzaGFwZSkge1xuICBzd2l0Y2ggKHNoYXBlLnR5cGUpIHtcbiAgICBjYXNlICdzdHJ1Y3R1cmUnOiByZXR1cm4gc2VyaWFsaXplU3RydWN0dXJlKHhtbCwgdmFsdWUsIHNoYXBlKTtcbiAgICBjYXNlICdtYXAnOiByZXR1cm4gc2VyaWFsaXplTWFwKHhtbCwgdmFsdWUsIHNoYXBlKTtcbiAgICBjYXNlICdsaXN0JzogcmV0dXJuIHNlcmlhbGl6ZUxpc3QoeG1sLCB2YWx1ZSwgc2hhcGUpO1xuICAgIGRlZmF1bHQ6IHJldHVybiBzZXJpYWxpemVTY2FsYXIoeG1sLCB2YWx1ZSwgc2hhcGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVN0cnVjdHVyZSh4bWwsIHBhcmFtcywgc2hhcGUpIHtcbiAgdXRpbC5hcnJheUVhY2goc2hhcGUubWVtYmVyTmFtZXMsIGZ1bmN0aW9uKG1lbWJlck5hbWUpIHtcbiAgICB2YXIgbWVtYmVyU2hhcGUgPSBzaGFwZS5tZW1iZXJzW21lbWJlck5hbWVdO1xuICAgIGlmIChtZW1iZXJTaGFwZS5sb2NhdGlvbiAhPT0gJ2JvZHknKSByZXR1cm47XG5cbiAgICB2YXIgdmFsdWUgPSBwYXJhbXNbbWVtYmVyTmFtZV07XG4gICAgdmFyIG5hbWUgPSBtZW1iZXJTaGFwZS5uYW1lO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICBpZiAobWVtYmVyU2hhcGUuaXNYbWxBdHRyaWJ1dGUpIHtcbiAgICAgICAgeG1sLmFkZEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG1lbWJlclNoYXBlLmZsYXR0ZW5lZCkge1xuICAgICAgICBzZXJpYWxpemUoeG1sLCB2YWx1ZSwgbWVtYmVyU2hhcGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBuZXcgWG1sTm9kZShuYW1lKTtcbiAgICAgICAgeG1sLmFkZENoaWxkTm9kZShlbGVtZW50KTtcbiAgICAgICAgYXBwbHlOYW1lc3BhY2VzKGVsZW1lbnQsIG1lbWJlclNoYXBlKTtcbiAgICAgICAgc2VyaWFsaXplKGVsZW1lbnQsIHZhbHVlLCBtZW1iZXJTaGFwZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplTWFwKHhtbCwgbWFwLCBzaGFwZSkge1xuICB2YXIgeG1sS2V5ID0gc2hhcGUua2V5Lm5hbWUgfHwgJ2tleSc7XG4gIHZhciB4bWxWYWx1ZSA9IHNoYXBlLnZhbHVlLm5hbWUgfHwgJ3ZhbHVlJztcblxuICB1dGlsLmVhY2gobWFwLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gbmV3IFhtbE5vZGUoc2hhcGUuZmxhdHRlbmVkID8gc2hhcGUubmFtZSA6ICdlbnRyeScpO1xuICAgIHhtbC5hZGRDaGlsZE5vZGUoZW50cnkpO1xuXG4gICAgdmFyIGVudHJ5S2V5ID0gbmV3IFhtbE5vZGUoeG1sS2V5KTtcbiAgICB2YXIgZW50cnlWYWx1ZSA9IG5ldyBYbWxOb2RlKHhtbFZhbHVlKTtcbiAgICBlbnRyeS5hZGRDaGlsZE5vZGUoZW50cnlLZXkpO1xuICAgIGVudHJ5LmFkZENoaWxkTm9kZShlbnRyeVZhbHVlKTtcblxuICAgIHNlcmlhbGl6ZShlbnRyeUtleSwga2V5LCBzaGFwZS5rZXkpO1xuICAgIHNlcmlhbGl6ZShlbnRyeVZhbHVlLCB2YWx1ZSwgc2hhcGUudmFsdWUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplTGlzdCh4bWwsIGxpc3QsIHNoYXBlKSB7XG4gIGlmIChzaGFwZS5mbGF0dGVuZWQpIHtcbiAgICB1dGlsLmFycmF5RWFjaChsaXN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIG5hbWUgPSBzaGFwZS5tZW1iZXIubmFtZSB8fCBzaGFwZS5uYW1lO1xuICAgICAgdmFyIGVsZW1lbnQgPSBuZXcgWG1sTm9kZShuYW1lKTtcbiAgICAgIHhtbC5hZGRDaGlsZE5vZGUoZWxlbWVudCk7XG4gICAgICBzZXJpYWxpemUoZWxlbWVudCwgdmFsdWUsIHNoYXBlLm1lbWJlcik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdXRpbC5hcnJheUVhY2gobGlzdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBuYW1lID0gc2hhcGUubWVtYmVyLm5hbWUgfHwgJ21lbWJlcic7XG4gICAgICB2YXIgZWxlbWVudCA9IG5ldyBYbWxOb2RlKG5hbWUpO1xuICAgICAgeG1sLmFkZENoaWxkTm9kZShlbGVtZW50KTtcbiAgICAgIHNlcmlhbGl6ZShlbGVtZW50LCB2YWx1ZSwgc2hhcGUubWVtYmVyKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVTY2FsYXIoeG1sLCB2YWx1ZSwgc2hhcGUpIHtcbiAgeG1sLmFkZENoaWxkTm9kZShcbiAgICBuZXcgWG1sVGV4dChzaGFwZS50b1dpcmVGb3JtYXQodmFsdWUpKVxuICApO1xufVxuXG5mdW5jdGlvbiBhcHBseU5hbWVzcGFjZXMoeG1sLCBzaGFwZSwgaXNSb290KSB7XG4gIHZhciB1cmksIHByZWZpeCA9ICd4bWxucyc7XG4gIGlmIChzaGFwZS54bWxOYW1lc3BhY2VVcmkpIHtcbiAgICB1cmkgPSBzaGFwZS54bWxOYW1lc3BhY2VVcmk7XG4gICAgaWYgKHNoYXBlLnhtbE5hbWVzcGFjZVByZWZpeCkgcHJlZml4ICs9ICc6JyArIHNoYXBlLnhtbE5hbWVzcGFjZVByZWZpeDtcbiAgfSBlbHNlIGlmIChpc1Jvb3QgJiYgc2hhcGUuYXBpLnhtbE5hbWVzcGFjZVVyaSkge1xuICAgIHVyaSA9IHNoYXBlLmFwaS54bWxOYW1lc3BhY2VVcmk7XG4gIH1cblxuICBpZiAodXJpKSB4bWwuYWRkQXR0cmlidXRlKHByZWZpeCwgdXJpKTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBYbWxCdWlsZGVyO1xuIiwiLyoqXG4gKiBFc2NhcGVzIGNoYXJhY3RlcnMgdGhhdCBjYW4gbm90IGJlIGluIGFuIFhNTCBhdHRyaWJ1dGUuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUF0dHJpYnV0ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLycvZywgJyZhcG9zOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBlc2NhcGVBdHRyaWJ1dGU6IGVzY2FwZUF0dHJpYnV0ZVxufTtcbiIsIi8qKlxuICogRXNjYXBlcyBjaGFyYWN0ZXJzIHRoYXQgY2FuIG5vdCBiZSBpbiBhbiBYTUwgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlRWxlbWVudCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVzY2FwZUVsZW1lbnQ6IGVzY2FwZUVsZW1lbnRcbn07XG4iLCJ2YXIgZXNjYXBlQXR0cmlidXRlID0gcmVxdWlyZSgnLi9lc2NhcGUtYXR0cmlidXRlJykuZXNjYXBlQXR0cmlidXRlO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gWE1MIG5vZGUuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gWG1sTm9kZShuYW1lLCBjaGlsZHJlbikge1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7IGNoaWxkcmVuID0gW107IH1cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbn1cblhtbE5vZGUucHJvdG90eXBlLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xufTtcblhtbE5vZGUucHJvdG90eXBlLmFkZENoaWxkTm9kZSA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuWG1sTm9kZS5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuICAgIHJldHVybiB0aGlzO1xufTtcblhtbE5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNDaGlsZHJlbiA9IEJvb2xlYW4odGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIHZhciB4bWxUZXh0ID0gJzwnICsgdGhpcy5uYW1lO1xuICAgIC8vIGFkZCBhdHRyaWJ1dGVzXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGF0dHJpYnV0ZU5hbWVzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcyk7IGkgPCBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2ldO1xuICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGUgIT09ICd1bmRlZmluZWQnICYmIGF0dHJpYnV0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgeG1sVGV4dCArPSAnICcgKyBhdHRyaWJ1dGVOYW1lICsgJz1cXFwiJyArIGVzY2FwZUF0dHJpYnV0ZSgnJyArIGF0dHJpYnV0ZSkgKyAnXFxcIic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHhtbFRleHQgKz0gIWhhc0NoaWxkcmVuID8gJy8+JyA6ICc+JyArIHRoaXMuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvU3RyaW5nKCk7IH0pLmpvaW4oJycpICsgJzwvJyArIHRoaXMubmFtZSArICc+Jztcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFhtbE5vZGU6IFhtbE5vZGVcbn07XG4iLCJ2YXIgZXNjYXBlRWxlbWVudCA9IHJlcXVpcmUoJy4vZXNjYXBlLWVsZW1lbnQnKS5lc2NhcGVFbGVtZW50O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gWE1MIHRleHQgdmFsdWUuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gWG1sVGV4dCh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn1cblxuWG1sVGV4dC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGVzY2FwZUVsZW1lbnQoJycgKyB0aGlzLnZhbHVlKTtcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFhtbFRleHQ6IFhtbFRleHRcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMUlVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL0xSVVwiKTtcbnZhciBDQUNIRV9TSVpFID0gMTAwMDtcbi8qKlxuICogSW5zcGlyZWQgbm9kZS1scnUtY2FjaGVbaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWxydS1jYWNoZV1cbiAqL1xudmFyIEVuZHBvaW50Q2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW5kcG9pbnRDYWNoZShtYXhTaXplKSB7XG4gICAgICAgIGlmIChtYXhTaXplID09PSB2b2lkIDApIHsgbWF4U2l6ZSA9IENBQ0hFX1NJWkU7IH1cbiAgICAgICAgdGhpcy5tYXhTaXplID0gbWF4U2l6ZTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBMUlVfMS5MUlVDYWNoZShtYXhTaXplKTtcbiAgICB9XG4gICAgO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbmRwb2ludENhY2hlLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEVuZHBvaW50Q2FjaGUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIga2V5U3RyaW5nID0gdHlwZW9mIGtleSAhPT0gJ3N0cmluZycgPyBFbmRwb2ludENhY2hlLmdldEtleVN0cmluZyhrZXkpIDoga2V5O1xuICAgICAgICB2YXIgZW5kcG9pbnRSZWNvcmQgPSB0aGlzLnBvcHVsYXRlVmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLmNhY2hlLnB1dChrZXlTdHJpbmcsIGVuZHBvaW50UmVjb3JkKTtcbiAgICB9O1xuICAgIEVuZHBvaW50Q2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBrZXlTdHJpbmcgPSB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyA/IEVuZHBvaW50Q2FjaGUuZ2V0S2V5U3RyaW5nKGtleSkgOiBrZXk7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgcmVjb3JkcyA9IHRoaXMuY2FjaGUuZ2V0KGtleVN0cmluZyk7XG4gICAgICAgIGlmIChyZWNvcmRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gcmVjb3Jkc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLkV4cGlyZSA8IG5vdykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLnJlbW92ZShrZXlTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjb3JkcztcbiAgICB9O1xuICAgIEVuZHBvaW50Q2FjaGUuZ2V0S2V5U3RyaW5nID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgICAgICAgdmFyIGlkZW50aWZpZXJOYW1lcyA9IE9iamVjdC5rZXlzKGtleSkuc29ydCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkZW50aWZpZXJOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlkZW50aWZpZXJOYW1lID0gaWRlbnRpZmllck5hbWVzW2ldO1xuICAgICAgICAgICAgaWYgKGtleVtpZGVudGlmaWVyTmFtZV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlkZW50aWZpZXJzLnB1c2goa2V5W2lkZW50aWZpZXJOYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXJzLmpvaW4oJyAnKTtcbiAgICB9O1xuICAgIEVuZHBvaW50Q2FjaGUucHJvdG90eXBlLnBvcHVsYXRlVmFsdWUgPSBmdW5jdGlvbiAoZW5kcG9pbnRzKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gZW5kcG9pbnRzLm1hcChmdW5jdGlvbiAoZW5kcG9pbnQpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBBZGRyZXNzOiBlbmRwb2ludC5BZGRyZXNzIHx8ICcnLFxuICAgICAgICAgICAgRXhwaXJlOiBub3cgKyAoZW5kcG9pbnQuQ2FjaGVQZXJpb2RJbk1pbnV0ZXMgfHwgMSkgKiA2MCAqIDEwMDBcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgRW5kcG9pbnRDYWNoZS5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2FjaGUuZW1wdHkoKTtcbiAgICB9O1xuICAgIEVuZHBvaW50Q2FjaGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBrZXlTdHJpbmcgPSB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyA/IEVuZHBvaW50Q2FjaGUuZ2V0S2V5U3RyaW5nKGtleSkgOiBrZXk7XG4gICAgICAgIHRoaXMuY2FjaGUucmVtb3ZlKGtleVN0cmluZyk7XG4gICAgfTtcbiAgICByZXR1cm4gRW5kcG9pbnRDYWNoZTtcbn0oKSk7XG5leHBvcnRzLkVuZHBvaW50Q2FjaGUgPSBFbmRwb2ludENhY2hlOyIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExpbmtlZExpc3ROb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmtlZExpc3ROb2RlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIExpbmtlZExpc3ROb2RlO1xufSgpKTtcbnZhciBMUlVDYWNoZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMUlVDYWNoZShzaXplKSB7XG4gICAgICAgIHRoaXMubm9kZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInIHx8IHNpemUgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhY2hlIHNpemUgY2FuIG9ubHkgYmUgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaXplTGltaXQgPSBzaXplO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTFJVQ2FjaGUucHJvdG90eXBlLnByZXBlbmRUb0xpc3QgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGVhZGVyTm9kZSkge1xuICAgICAgICAgICAgdGhpcy50YWlsTm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlck5vZGUucHJldiA9IG5vZGU7XG4gICAgICAgICAgICBub2RlLm5leHQgPSB0aGlzLmhlYWRlck5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJOb2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5zaXplKys7XG4gICAgfTtcbiAgICBMUlVDYWNoZS5wcm90b3R5cGUucmVtb3ZlRnJvbVRhaWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy50YWlsTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMudGFpbE5vZGU7XG4gICAgICAgIHZhciBwcmV2Tm9kZSA9IG5vZGUucHJldjtcbiAgICAgICAgaWYgKHByZXZOb2RlKSB7XG4gICAgICAgICAgICBwcmV2Tm9kZS5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUucHJldiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50YWlsTm9kZSA9IHByZXZOb2RlO1xuICAgICAgICB0aGlzLnNpemUtLTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBMUlVDYWNoZS5wcm90b3R5cGUuZGV0YWNoRnJvbUxpc3QgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5oZWFkZXJOb2RlID09PSBub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlck5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGFpbE5vZGUgPT09IG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbE5vZGUgPSBub2RlLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucHJldikge1xuICAgICAgICAgICAgbm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubmV4dCkge1xuICAgICAgICAgICAgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICBub2RlLnByZXYgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2l6ZS0tO1xuICAgIH07XG4gICAgTFJVQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZU1hcFtrZXldKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZU1hcFtrZXldO1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hGcm9tTGlzdChub2RlKTtcbiAgICAgICAgICAgIHRoaXMucHJlcGVuZFRvTGlzdChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMUlVDYWNoZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAodGhpcy5ub2RlTWFwW2tleV0pIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlTWFwW2tleV07XG4gICAgICAgICAgICB0aGlzLmRldGFjaEZyb21MaXN0KG5vZGUpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubm9kZU1hcFtrZXldO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMUlVDYWNoZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZU1hcFtrZXldKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2l6ZSA9PT0gdGhpcy5zaXplTGltaXQpIHtcbiAgICAgICAgICAgIHZhciB0YWlsTm9kZSA9IHRoaXMucmVtb3ZlRnJvbVRhaWwoKTtcbiAgICAgICAgICAgIHZhciBrZXlfMSA9IHRhaWxOb2RlLmtleTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5vZGVNYXBba2V5XzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdOb2RlID0gbmV3IExpbmtlZExpc3ROb2RlKGtleSwgdmFsdWUpO1xuICAgICAgICB0aGlzLm5vZGVNYXBba2V5XSA9IG5ld05vZGU7XG4gICAgICAgIHRoaXMucHJlcGVuZFRvTGlzdChuZXdOb2RlKTtcbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm5vZGVNYXApO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVNYXBba2V5XTtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoRnJvbUxpc3Qobm9kZSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ub2RlTWFwW2tleV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBMUlVDYWNoZTtcbn0oKSk7XG5leHBvcnRzLkxSVUNhY2hlID0gTFJVQ2FjaGU7IiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpXG4gICAgPyBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIHZhciBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG52YXIgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICB2YXIgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICB2YXIgaTE2ID0gaSAqIDE2XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgb2JqZWN0Q3JlYXRlUG9seWZpbGxcbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgb2JqZWN0S2V5c1BvbHlmaWxsXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGZ1bmN0aW9uQmluZFBvbHlmaWxsXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX2V2ZW50cycpKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbnZhciBoYXNEZWZpbmVQcm9wZXJ0eTtcbnRyeSB7XG4gIHZhciBvID0ge307XG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCAneCcsIHsgdmFsdWU6IDAgfSk7XG4gIGhhc0RlZmluZVByb3BlcnR5ID0gby54ID09PSAwO1xufSBjYXRjaCAoZXJyKSB7IGhhc0RlZmluZVByb3BlcnR5ID0gZmFsc2UgfVxuaWYgKGhhc0RlZmluZVByb3BlcnR5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIGlucHV0IGlzIGEgcG9zaXRpdmUgbnVtYmVyICh3aG9zZSB2YWx1ZSBpcyB6ZXJvIG9yXG4gICAgICAvLyBncmVhdGVyIGFuZCBub3QgYSBOYU4pLlxuICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgYXJnICE9PSBhcmcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZGVmYXVsdE1heExpc3RlbmVyc1wiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gZGVmYXVsdE1heExpc3RlbmVycztcbn1cblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm5cIiBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbi8vIFRoZXNlIHN0YW5kYWxvbmUgZW1pdCogZnVuY3Rpb25zIGFyZSB1c2VkIHRvIG9wdGltaXplIGNhbGxpbmcgb2YgZXZlbnRcbi8vIGhhbmRsZXJzIGZvciBmYXN0IGNhc2VzIGJlY2F1c2UgZW1pdCgpIGl0c2VsZiBvZnRlbiBoYXMgYSB2YXJpYWJsZSBudW1iZXIgb2Zcbi8vIGFyZ3VtZW50cyBhbmQgY2FuIGJlIGRlb3B0aW1pemVkIGJlY2F1c2Ugb2YgdGhhdC4gVGhlc2UgZnVuY3Rpb25zIGFsd2F5cyBoYXZlXG4vLyB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCB0aHVzIGRvIG5vdCBnZXQgZGVvcHRpbWl6ZWQsIHNvIHRoZSBjb2RlXG4vLyBpbnNpZGUgdGhlbSBjYW4gZXhlY3V0ZSBmYXN0ZXIuXG5mdW5jdGlvbiBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJncykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgZXZlbnRzO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PSBudWxsKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoIWhhbmRsZXIpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBpc0ZuID0gdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbic7XG4gIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHN3aXRjaCAobGVuKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgY2FzZSAxOlxuICAgICAgZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgdGhpcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgZGVmYXVsdDpcbiAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmICghZXZlbnRzKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBpZiAoIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICAgIGlmIChtICYmIG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0pIHtcbiAgICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnIFwiJyArIFN0cmluZyh0eXBlKSArICdcIiBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0LicpO1xuICAgICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignJXM6ICVzJywgdy5uYW1lLCB3Lm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0pO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzJdKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IGJpbmQuY2FsbChvbmNlV3JhcHBlciwgc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmICghbGlzdClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKCFldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKCFldmVudHMpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoIWV2bGlzdGVuZXIpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdC5vd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKS5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpXG4gICAgbGlzdFtpXSA9IGxpc3Rba107XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb2JqZWN0Q3JlYXRlUG9seWZpbGwocHJvdG8pIHtcbiAgdmFyIEYgPSBmdW5jdGlvbigpIHt9O1xuICBGLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXR1cm4gbmV3IEY7XG59XG5mdW5jdGlvbiBvYmplY3RLZXlzUG9seWZpbGwob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGsgaW4gb2JqKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaykpIHtcbiAgICBrZXlzLnB1c2goayk7XG4gIH1cbiAgcmV0dXJuIGs7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkJpbmRQb2x5ZmlsbChjb250ZXh0KSB7XG4gIHZhciBmbiA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIihmdW5jdGlvbihleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgaWYgKG9iaiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICBpZiAob2JqICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpY3REZWVwRXF1YWwoZmlyc3QsIHNlY29uZCkge1xuICAgIC8vIENoZWNrIHRoZSBzY2FsYXIgY2FzZSBmaXJzdC5cbiAgICBpZiAoZmlyc3QgPT09IHNlY29uZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhleSBhcmUgdGhlIHNhbWUgdHlwZS5cbiAgICB2YXIgZmlyc3RUeXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZpcnN0KTtcbiAgICBpZiAoZmlyc3RUeXBlICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc2Vjb25kKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBXZSBrbm93IHRoYXQgZmlyc3QgYW5kIHNlY29uZCBoYXZlIHRoZSBzYW1lIHR5cGUgc28gd2UgY2FuIGp1c3QgY2hlY2sgdGhlXG4gICAgLy8gZmlyc3QgdHlwZSBmcm9tIG5vdyBvbi5cbiAgICBpZiAoaXNBcnJheShmaXJzdCkgPT09IHRydWUpIHtcbiAgICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgdGhleSdyZSBub3QgdGhlIHNhbWUgbGVuZ3RoO1xuICAgICAgaWYgKGZpcnN0Lmxlbmd0aCAhPT0gc2Vjb25kLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpY3REZWVwRXF1YWwoZmlyc3RbaV0sIHNlY29uZFtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGZpcnN0KSA9PT0gdHJ1ZSkge1xuICAgICAgLy8gQW4gb2JqZWN0IGlzIGVxdWFsIGlmIGl0IGhhcyB0aGUgc2FtZSBrZXkvdmFsdWUgcGFpcnMuXG4gICAgICB2YXIga2V5c1NlZW4gPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBmaXJzdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmaXJzdCwga2V5KSkge1xuICAgICAgICAgIGlmIChzdHJpY3REZWVwRXF1YWwoZmlyc3Rba2V5XSwgc2Vjb25kW2tleV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlzU2VlbltrZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTm93IGNoZWNrIHRoYXQgdGhlcmUgYXJlbid0IGFueSBrZXlzIGluIHNlY29uZCB0aGF0IHdlcmVuJ3RcbiAgICAgIC8vIGluIGZpcnN0LlxuICAgICAgZm9yICh2YXIga2V5MiBpbiBzZWNvbmQpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc2Vjb25kLCBrZXkyKSkge1xuICAgICAgICAgIGlmIChrZXlzU2VlbltrZXkyXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRmFsc2Uob2JqKSB7XG4gICAgLy8gRnJvbSB0aGUgc3BlYzpcbiAgICAvLyBBIGZhbHNlIHZhbHVlIGNvcnJlc3BvbmRzIHRvIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICAgIC8vIEVtcHR5IGxpc3RcbiAgICAvLyBFbXB0eSBvYmplY3RcbiAgICAvLyBFbXB0eSBzdHJpbmdcbiAgICAvLyBGYWxzZSBib29sZWFuXG4gICAgLy8gbnVsbCB2YWx1ZVxuXG4gICAgLy8gRmlyc3QgY2hlY2sgdGhlIHNjYWxhciB2YWx1ZXMuXG4gICAgaWYgKG9iaiA9PT0gXCJcIiB8fCBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbiBlbXB0eSBhcnJheS5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChvYmopKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbiBlbXB0eSBvYmplY3QuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhbnkga2V5cywgdGhlblxuICAgICAgICAgICAgLy8gdGhlIG9iamVjdCBpcyBub3QgZW1wdHkgc28gdGhlIG9iamVjdFxuICAgICAgICAgICAgLy8gaXMgbm90IGZhbHNlLlxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb2JqVmFsdWVzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXMucHVzaChvYmpba2V5c1tpXV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xuICAgICAgdmFyIG1lcmdlZCA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgICBtZXJnZWRba2V5XSA9IGFba2V5XTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleTIgaW4gYikge1xuICAgICAgICAgIG1lcmdlZFtrZXkyXSA9IGJba2V5Ml07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkO1xuICB9XG5cbiAgdmFyIHRyaW1MZWZ0O1xuICBpZiAodHlwZW9mIFN0cmluZy5wcm90b3R5cGUudHJpbUxlZnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRyaW1MZWZ0ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnRyaW1MZWZ0KCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0cmltTGVmdCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5tYXRjaCgvXlxccyooLiopLylbMV07XG4gICAgfTtcbiAgfVxuXG4gIC8vIFR5cGUgY29uc3RhbnRzIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9ucy5cbiAgdmFyIFRZUEVfTlVNQkVSID0gMDtcbiAgdmFyIFRZUEVfQU5ZID0gMTtcbiAgdmFyIFRZUEVfU1RSSU5HID0gMjtcbiAgdmFyIFRZUEVfQVJSQVkgPSAzO1xuICB2YXIgVFlQRV9PQkpFQ1QgPSA0O1xuICB2YXIgVFlQRV9CT09MRUFOID0gNTtcbiAgdmFyIFRZUEVfRVhQUkVGID0gNjtcbiAgdmFyIFRZUEVfTlVMTCA9IDc7XG4gIHZhciBUWVBFX0FSUkFZX05VTUJFUiA9IDg7XG4gIHZhciBUWVBFX0FSUkFZX1NUUklORyA9IDk7XG5cbiAgdmFyIFRPS19FT0YgPSBcIkVPRlwiO1xuICB2YXIgVE9LX1VOUVVPVEVESURFTlRJRklFUiA9IFwiVW5xdW90ZWRJZGVudGlmaWVyXCI7XG4gIHZhciBUT0tfUVVPVEVESURFTlRJRklFUiA9IFwiUXVvdGVkSWRlbnRpZmllclwiO1xuICB2YXIgVE9LX1JCUkFDS0VUID0gXCJSYnJhY2tldFwiO1xuICB2YXIgVE9LX1JQQVJFTiA9IFwiUnBhcmVuXCI7XG4gIHZhciBUT0tfQ09NTUEgPSBcIkNvbW1hXCI7XG4gIHZhciBUT0tfQ09MT04gPSBcIkNvbG9uXCI7XG4gIHZhciBUT0tfUkJSQUNFID0gXCJSYnJhY2VcIjtcbiAgdmFyIFRPS19OVU1CRVIgPSBcIk51bWJlclwiO1xuICB2YXIgVE9LX0NVUlJFTlQgPSBcIkN1cnJlbnRcIjtcbiAgdmFyIFRPS19FWFBSRUYgPSBcIkV4cHJlZlwiO1xuICB2YXIgVE9LX1BJUEUgPSBcIlBpcGVcIjtcbiAgdmFyIFRPS19PUiA9IFwiT3JcIjtcbiAgdmFyIFRPS19BTkQgPSBcIkFuZFwiO1xuICB2YXIgVE9LX0VRID0gXCJFUVwiO1xuICB2YXIgVE9LX0dUID0gXCJHVFwiO1xuICB2YXIgVE9LX0xUID0gXCJMVFwiO1xuICB2YXIgVE9LX0dURSA9IFwiR1RFXCI7XG4gIHZhciBUT0tfTFRFID0gXCJMVEVcIjtcbiAgdmFyIFRPS19ORSA9IFwiTkVcIjtcbiAgdmFyIFRPS19GTEFUVEVOID0gXCJGbGF0dGVuXCI7XG4gIHZhciBUT0tfU1RBUiA9IFwiU3RhclwiO1xuICB2YXIgVE9LX0ZJTFRFUiA9IFwiRmlsdGVyXCI7XG4gIHZhciBUT0tfRE9UID0gXCJEb3RcIjtcbiAgdmFyIFRPS19OT1QgPSBcIk5vdFwiO1xuICB2YXIgVE9LX0xCUkFDRSA9IFwiTGJyYWNlXCI7XG4gIHZhciBUT0tfTEJSQUNLRVQgPSBcIkxicmFja2V0XCI7XG4gIHZhciBUT0tfTFBBUkVOPSBcIkxwYXJlblwiO1xuICB2YXIgVE9LX0xJVEVSQUw9IFwiTGl0ZXJhbFwiO1xuXG4gIC8vIFRoZSBcIiZcIiwgXCJbXCIsIFwiPFwiLCBcIj5cIiB0b2tlbnNcbiAgLy8gYXJlIG5vdCBpbiBiYXNpY1Rva2VuIGJlY2F1c2VcbiAgLy8gdGhlcmUgYXJlIHR3byB0b2tlbiB2YXJpYW50c1xuICAvLyAoXCImJlwiLCBcIls/XCIsIFwiPD1cIiwgXCI+PVwiKS4gIFRoaXMgaXMgc3BlY2lhbGx5IGhhbmRsZWRcbiAgLy8gYmVsb3cuXG5cbiAgdmFyIGJhc2ljVG9rZW5zID0ge1xuICAgIFwiLlwiOiBUT0tfRE9ULFxuICAgIFwiKlwiOiBUT0tfU1RBUixcbiAgICBcIixcIjogVE9LX0NPTU1BLFxuICAgIFwiOlwiOiBUT0tfQ09MT04sXG4gICAgXCJ7XCI6IFRPS19MQlJBQ0UsXG4gICAgXCJ9XCI6IFRPS19SQlJBQ0UsXG4gICAgXCJdXCI6IFRPS19SQlJBQ0tFVCxcbiAgICBcIihcIjogVE9LX0xQQVJFTixcbiAgICBcIilcIjogVE9LX1JQQVJFTixcbiAgICBcIkBcIjogVE9LX0NVUlJFTlRcbiAgfTtcblxuICB2YXIgb3BlcmF0b3JTdGFydFRva2VuID0ge1xuICAgICAgXCI8XCI6IHRydWUsXG4gICAgICBcIj5cIjogdHJ1ZSxcbiAgICAgIFwiPVwiOiB0cnVlLFxuICAgICAgXCIhXCI6IHRydWVcbiAgfTtcblxuICB2YXIgc2tpcENoYXJzID0ge1xuICAgICAgXCIgXCI6IHRydWUsXG4gICAgICBcIlxcdFwiOiB0cnVlLFxuICAgICAgXCJcXG5cIjogdHJ1ZVxuICB9O1xuXG5cbiAgZnVuY3Rpb24gaXNBbHBoYShjaCkge1xuICAgICAgcmV0dXJuIChjaCA+PSBcImFcIiAmJiBjaCA8PSBcInpcIikgfHxcbiAgICAgICAgICAgICAoY2ggPj0gXCJBXCIgJiYgY2ggPD0gXCJaXCIpIHx8XG4gICAgICAgICAgICAgY2ggPT09IFwiX1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOdW0oY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPj0gXCIwXCIgJiYgY2ggPD0gXCI5XCIpIHx8XG4gICAgICAgICAgICAgY2ggPT09IFwiLVwiO1xuICB9XG4gIGZ1bmN0aW9uIGlzQWxwaGFOdW0oY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPj0gXCJhXCIgJiYgY2ggPD0gXCJ6XCIpIHx8XG4gICAgICAgICAgICAgKGNoID49IFwiQVwiICYmIGNoIDw9IFwiWlwiKSB8fFxuICAgICAgICAgICAgIChjaCA+PSBcIjBcIiAmJiBjaCA8PSBcIjlcIikgfHxcbiAgICAgICAgICAgICBjaCA9PT0gXCJfXCI7XG4gIH1cblxuICBmdW5jdGlvbiBMZXhlcigpIHtcbiAgfVxuICBMZXhlci5wcm90b3R5cGUgPSB7XG4gICAgICB0b2tlbml6ZTogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSAwO1xuICAgICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgICB2YXIgaWRlbnRpZmllcjtcbiAgICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnJlbnQgPCBzdHJlYW0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChpc0FscGhhKHN0cmVhbVt0aGlzLl9jdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSB0aGlzLl9jb25zdW1lVW5xdW90ZWRJZGVudGlmaWVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogVE9LX1VOUVVPVEVESURFTlRJRklFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChiYXNpY1Rva2Vuc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBiYXNpY1Rva2Vuc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0cmVhbVt0aGlzLl9jdXJyZW50XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLl9jdXJyZW50fSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOdW0oc3RyZWFtW3RoaXMuX2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLl9jb25zdW1lTnVtYmVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBpbmNyZW1lbnQgdGhpcy5fY3VycmVudC4gIFRoaXMgaGFwcGVuc1xuICAgICAgICAgICAgICAgICAgLy8gaW4gX2NvbnN1bWVMQnJhY2tldFxuICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLl9jb25zdW1lTEJyYWNrZXQoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiXFxcIlwiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gdGhpcy5fY29uc3VtZVF1b3RlZElkZW50aWZpZXIoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfUVVPVEVESURFTlRJRklFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gdGhpcy5fY29uc3VtZVJhd1N0cmluZ0xpdGVyYWwoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfTElURVJBTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiYFwiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHRoaXMuX2NvbnN1bWVMaXRlcmFsKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogVE9LX0xJVEVSQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxpdGVyYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3JTdGFydFRva2VuW3N0cmVhbVt0aGlzLl9jdXJyZW50XV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcy5fY29uc3VtZU9wZXJhdG9yKHN0cmVhbSkpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNraXBDaGFyc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCImXCIpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiJlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfQU5ELCB2YWx1ZTogXCImJlwiLCBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19FWFBSRUYsIHZhbHVlOiBcIiZcIiwgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcInxcIikge1xuICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19PUiwgdmFsdWU6IFwifHxcIiwgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfUElQRSwgdmFsdWU6IFwifFwiLCBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlVua25vd24gY2hhcmFjdGVyOlwiICsgc3RyZWFtW3RoaXMuX2N1cnJlbnRdKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIkxleGVyRXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZVVucXVvdGVkSWRlbnRpZmllcjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnJlbnQgPCBzdHJlYW0ubGVuZ3RoICYmIGlzQWxwaGFOdW0oc3RyZWFtW3RoaXMuX2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHJlYW0uc2xpY2Uoc3RhcnQsIHRoaXMuX2N1cnJlbnQpO1xuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVRdW90ZWRJZGVudGlmaWVyOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdICE9PSBcIlxcXCJcIiAmJiB0aGlzLl9jdXJyZW50IDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIFlvdSBjYW4gZXNjYXBlIGEgZG91YmxlIHF1b3RlIGFuZCB5b3UgY2FuIGVzY2FwZSBhbiBlc2NhcGUuXG4gICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVtjdXJyZW50XSA9PT0gXCJcXFxcXCIgJiYgKHN0cmVhbVtjdXJyZW50ICsgMV0gPT09IFwiXFxcXFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbVtjdXJyZW50ICsgMV0gPT09IFwiXFxcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudCArPSAyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyZWFtLnNsaWNlKHN0YXJ0LCB0aGlzLl9jdXJyZW50KSk7XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZVJhd1N0cmluZ0xpdGVyYWw6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHZhciBtYXhMZW5ndGggPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzdHJlYW1bdGhpcy5fY3VycmVudF0gIT09IFwiJ1wiICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gWW91IGNhbiBlc2NhcGUgYSBzaW5nbGUgcXVvdGUgYW5kIHlvdSBjYW4gZXNjYXBlIGFuIGVzY2FwZS5cbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW2N1cnJlbnRdID09PSBcIlxcXFxcIiAmJiAoc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJcXFxcXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCInXCIpKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHN0cmVhbS5zbGljZShzdGFydCArIDEsIHRoaXMuX2N1cnJlbnQgLSAxKTtcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbC5yZXBsYWNlKFwiXFxcXCdcIiwgXCInXCIpO1xuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVOdW1iZXI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHZhciBtYXhMZW5ndGggPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpc051bShzdHJlYW1bdGhpcy5fY3VycmVudF0pICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUludChzdHJlYW0uc2xpY2Uoc3RhcnQsIHRoaXMuX2N1cnJlbnQpKTtcbiAgICAgICAgICByZXR1cm4ge3R5cGU6IFRPS19OVU1CRVIsIHZhbHVlOiB2YWx1ZSwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgIH0sXG5cbiAgICAgIF9jb25zdW1lTEJyYWNrZXQ6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfRklMVEVSLCB2YWx1ZTogXCJbP1wiLCBzdGFydDogc3RhcnR9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIl1cIikge1xuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0ZMQVRURU4sIHZhbHVlOiBcIltdXCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTEJSQUNLRVQsIHZhbHVlOiBcIltcIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZU9wZXJhdG9yOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgIHZhciBzdGFydGluZ0NoYXIgPSBzdHJlYW1bc3RhcnRdO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICBpZiAoc3RhcnRpbmdDaGFyID09PSBcIiFcIikge1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIj1cIikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTkUsIHZhbHVlOiBcIiE9XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTk9ULCB2YWx1ZTogXCIhXCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI8XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0xURSwgdmFsdWU6IFwiPD1cIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0xULCB2YWx1ZTogXCI8XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0dURSwgdmFsdWU6IFwiPj1cIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0dULCB2YWx1ZTogXCI+XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0VRLCB2YWx1ZTogXCI9PVwiLCBzdGFydDogc3RhcnR9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVMaXRlcmFsOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICB2YXIgbGl0ZXJhbDtcbiAgICAgICAgICB3aGlsZShzdHJlYW1bdGhpcy5fY3VycmVudF0gIT09IFwiYFwiICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gWW91IGNhbiBlc2NhcGUgYSBsaXRlcmFsIGNoYXIgb3IgeW91IGNhbiBlc2NhcGUgdGhlIGVzY2FwZS5cbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW2N1cnJlbnRdID09PSBcIlxcXFxcIiAmJiAoc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJcXFxcXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJgXCIpKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsaXRlcmFsU3RyaW5nID0gdHJpbUxlZnQoc3RyZWFtLnNsaWNlKHN0YXJ0LCB0aGlzLl9jdXJyZW50KSk7XG4gICAgICAgICAgbGl0ZXJhbFN0cmluZyA9IGxpdGVyYWxTdHJpbmcucmVwbGFjZShcIlxcXFxgXCIsIFwiYFwiKTtcbiAgICAgICAgICBpZiAodGhpcy5fbG9va3NMaWtlSlNPTihsaXRlcmFsU3RyaW5nKSkge1xuICAgICAgICAgICAgICBsaXRlcmFsID0gSlNPTi5wYXJzZShsaXRlcmFsU3RyaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBUcnkgdG8gSlNPTiBwYXJzZSBpdCBhcyBcIjxsaXRlcmFsPlwiXG4gICAgICAgICAgICAgIGxpdGVyYWwgPSBKU09OLnBhcnNlKFwiXFxcIlwiICsgbGl0ZXJhbFN0cmluZyArIFwiXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gKzEgZ2V0cyB1cyB0byB0aGUgZW5kaW5nIFwiYFwiLCArMSB0byBtb3ZlIG9uIHRvIHRoZSBuZXh0IGNoYXIuXG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHJldHVybiBsaXRlcmFsO1xuICAgICAgfSxcblxuICAgICAgX2xvb2tzTGlrZUpTT046IGZ1bmN0aW9uKGxpdGVyYWxTdHJpbmcpIHtcbiAgICAgICAgICB2YXIgc3RhcnRpbmdDaGFycyA9IFwiW3tcXFwiXCI7XG4gICAgICAgICAgdmFyIGpzb25MaXRlcmFscyA9IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcIm51bGxcIl07XG4gICAgICAgICAgdmFyIG51bWJlckxvb2tpbmcgPSBcIi0wMTIzNDU2Nzg5XCI7XG5cbiAgICAgICAgICBpZiAobGl0ZXJhbFN0cmluZyA9PT0gXCJcIikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydGluZ0NoYXJzLmluZGV4T2YobGl0ZXJhbFN0cmluZ1swXSkgPj0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGpzb25MaXRlcmFscy5pbmRleE9mKGxpdGVyYWxTdHJpbmcpID49IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChudW1iZXJMb29raW5nLmluZGV4T2YobGl0ZXJhbFN0cmluZ1swXSkgPj0gMCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShsaXRlcmFsU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfTtcblxuICAgICAgdmFyIGJpbmRpbmdQb3dlciA9IHt9O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19FT0ZdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfVU5RVU9URURJREVOVElGSUVSXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1FVT1RFRElERU5USUZJRVJdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUkJSQUNLRVRdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUlBBUkVOXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0NPTU1BXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1JCUkFDRV0gPSAwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19OVU1CRVJdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfQ1VSUkVOVF0gPSAwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19FWFBSRUZdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUElQRV0gPSAxO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19PUl0gPSAyO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19BTkRdID0gMztcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfRVFdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfR1RdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfTFRdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfR1RFXSA9IDU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xURV0gPSA1O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19ORV0gPSA1O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19GTEFUVEVOXSA9IDk7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1NUQVJdID0gMjA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0ZJTFRFUl0gPSAyMTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfRE9UXSA9IDQwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19OT1RdID0gNDU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xCUkFDRV0gPSA1MDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfTEJSQUNLRVRdID0gNTU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xQQVJFTl0gPSA2MDtcblxuICBmdW5jdGlvbiBQYXJzZXIoKSB7XG4gIH1cblxuICBQYXJzZXIucHJvdG90eXBlID0ge1xuICAgICAgcGFyc2U6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLl9sb2FkVG9rZW5zKGV4cHJlc3Npb24pO1xuICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgIHZhciBhc3QgPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX0VPRikge1xuICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgdG9rZW4gdHlwZTogXCIgKyB0LnR5cGUgKyBcIiwgdmFsdWU6IFwiICsgdC52YWx1ZSk7XG4gICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIlBhcnNlckVycm9yXCI7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfSxcblxuICAgICAgX2xvYWRUb2tlbnM6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIoKTtcbiAgICAgICAgICB2YXIgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoZXhwcmVzc2lvbik7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19FT0YsIHZhbHVlOiBcIlwiLCBzdGFydDogZXhwcmVzc2lvbi5sZW5ndGh9KTtcbiAgICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgIH0sXG5cbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKHJicCkge1xuICAgICAgICAgIHZhciBsZWZ0VG9rZW4gPSB0aGlzLl9sb29rYWhlYWRUb2tlbigwKTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLm51ZChsZWZ0VG9rZW4pO1xuICAgICAgICAgIHZhciBjdXJyZW50VG9rZW4gPSB0aGlzLl9sb29rYWhlYWQoMCk7XG4gICAgICAgICAgd2hpbGUgKHJicCA8IGJpbmRpbmdQb3dlcltjdXJyZW50VG9rZW5dKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgbGVmdCA9IHRoaXMubGVkKGN1cnJlbnRUb2tlbiwgbGVmdCk7XG4gICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICB9LFxuXG4gICAgICBfbG9va2FoZWFkOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pbmRleCArIG51bWJlcl0udHlwZTtcbiAgICAgIH0sXG5cbiAgICAgIF9sb29rYWhlYWRUb2tlbjogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaW5kZXggKyBudW1iZXJdO1xuICAgICAgfSxcblxuICAgICAgX2FkdmFuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgIH0sXG5cbiAgICAgIG51ZDogZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgdmFyIGxlZnQ7XG4gICAgICAgIHZhciByaWdodDtcbiAgICAgICAgdmFyIGV4cHJlc3Npb247XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgIGNhc2UgVE9LX0xJVEVSQUw6XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiTGl0ZXJhbFwiLCB2YWx1ZTogdG9rZW4udmFsdWV9O1xuICAgICAgICAgIGNhc2UgVE9LX1VOUVVPVEVESURFTlRJRklFUjpcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJGaWVsZFwiLCBuYW1lOiB0b2tlbi52YWx1ZX07XG4gICAgICAgICAgY2FzZSBUT0tfUVVPVEVESURFTlRJRklFUjpcbiAgICAgICAgICAgIHZhciBub2RlID0ge3R5cGU6IFwiRmllbGRcIiwgbmFtZTogdG9rZW4udmFsdWV9O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0xQQVJFTikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1b3RlZCBpZGVudGlmaWVyIG5vdCBhbGxvd2VkIGZvciBmdW5jdGlvbiBuYW1lcy5cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBUT0tfTk9UOlxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLk5vdCk7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiTm90RXhwcmVzc2lvblwiLCBjaGlsZHJlbjogW3JpZ2h0XX07XG4gICAgICAgICAgY2FzZSBUT0tfU1RBUjpcbiAgICAgICAgICAgIGxlZnQgPSB7dHlwZTogXCJJZGVudGl0eVwifTtcbiAgICAgICAgICAgIHJpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19SQlJBQ0tFVCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpbiBhIG11bHRpc2VsZWN0LFxuICAgICAgICAgICAgICAgIC8vIFthLCBiLCAqXVxuICAgICAgICAgICAgICAgIHJpZ2h0ID0ge3R5cGU6IFwiSWRlbnRpdHlcIn07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJWYWx1ZVByb2plY3Rpb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0ZJTFRFUjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZCh0b2tlbi50eXBlLCB7dHlwZTogXCJJZGVudGl0eVwifSk7XG4gICAgICAgICAgY2FzZSBUT0tfTEJSQUNFOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlTXVsdGlzZWxlY3RIYXNoKCk7XG4gICAgICAgICAgY2FzZSBUT0tfRkxBVFRFTjpcbiAgICAgICAgICAgIGxlZnQgPSB7dHlwZTogVE9LX0ZMQVRURU4sIGNoaWxkcmVuOiBbe3R5cGU6IFwiSWRlbnRpdHlcIn1dfTtcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5GbGF0dGVuKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJQcm9qZWN0aW9uXCIsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgICAgICBjYXNlIFRPS19MQlJBQ0tFVDpcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19OVU1CRVIgfHwgdGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ09MT04pIHtcbiAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMuX3BhcnNlSW5kZXhFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3RJZlNsaWNlKHt0eXBlOiBcIklkZW50aXR5XCJ9LCByaWdodCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX1NUQVIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9va2FoZWFkKDEpID09PSBUT0tfUkJSQUNLRVQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiUHJvamVjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFt7dHlwZTogXCJJZGVudGl0eVwifSwgcmlnaHRdfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlTXVsdGlzZWxlY3RMaXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFRPS19DVVJSRU5UOlxuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfQ1VSUkVOVH07XG4gICAgICAgICAgY2FzZSBUT0tfRVhQUkVGOlxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvbihiaW5kaW5nUG93ZXIuRXhwcmVmKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJFeHByZXNzaW9uUmVmZXJlbmNlXCIsIGNoaWxkcmVuOiBbZXhwcmVzc2lvbl19O1xuICAgICAgICAgIGNhc2UgVE9LX0xQQVJFTjpcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fbG9va2FoZWFkKDApICE9PSBUT0tfUlBBUkVOKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DVVJSRU5UKSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHt0eXBlOiBUT0tfQ1VSUkVOVH07XG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JQQVJFTik7XG4gICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5fZXJyb3JUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGxlZDogZnVuY3Rpb24odG9rZW5OYW1lLCBsZWZ0KSB7XG4gICAgICAgIHZhciByaWdodDtcbiAgICAgICAgc3dpdGNoKHRva2VuTmFtZSkge1xuICAgICAgICAgIGNhc2UgVE9LX0RPVDpcbiAgICAgICAgICAgIHZhciByYnAgPSBiaW5kaW5nUG93ZXIuRG90O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX1NUQVIpIHtcbiAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMuX3BhcnNlRG90UkhTKHJicCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlN1YmV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGluZyBhIHByb2plY3Rpb24uXG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKHJicCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlZhbHVlUHJvamVjdGlvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0XX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFRPS19QSVBFOlxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLlBpcGUpO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfUElQRSwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX09SOlxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLk9yKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJPckV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0FORDpcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKGJpbmRpbmdQb3dlci5BbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIkFuZEV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0xQQVJFTjpcbiAgICAgICAgICAgIHZhciBuYW1lID0gbGVmdC5uYW1lO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uLCBub2RlO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX1JQQVJFTikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ1VSUkVOVCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB7dHlwZTogVE9LX0NVUlJFTlR9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT01NQSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19DT01NQSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JQQVJFTik7XG4gICAgICAgICAgICBub2RlID0ge3R5cGU6IFwiRnVuY3Rpb25cIiwgbmFtZTogbmFtZSwgY2hpbGRyZW46IGFyZ3N9O1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgY2FzZSBUT0tfRklMVEVSOlxuICAgICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0tFVCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfRkxBVFRFTikge1xuICAgICAgICAgICAgICByaWdodCA9IHt0eXBlOiBcIklkZW50aXR5XCJ9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLkZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiRmlsdGVyUHJvamVjdGlvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0LCBjb25kaXRpb25dfTtcbiAgICAgICAgICBjYXNlIFRPS19GTEFUVEVOOlxuICAgICAgICAgICAgdmFyIGxlZnROb2RlID0ge3R5cGU6IFRPS19GTEFUVEVOLCBjaGlsZHJlbjogW2xlZnRdfTtcbiAgICAgICAgICAgIHZhciByaWdodE5vZGUgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLkZsYXR0ZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlByb2plY3Rpb25cIiwgY2hpbGRyZW46IFtsZWZ0Tm9kZSwgcmlnaHROb2RlXX07XG4gICAgICAgICAgY2FzZSBUT0tfRVE6XG4gICAgICAgICAgY2FzZSBUT0tfTkU6XG4gICAgICAgICAgY2FzZSBUT0tfR1Q6XG4gICAgICAgICAgY2FzZSBUT0tfR1RFOlxuICAgICAgICAgIGNhc2UgVE9LX0xUOlxuICAgICAgICAgIGNhc2UgVE9LX0xURTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZUNvbXBhcmF0b3IobGVmdCwgdG9rZW5OYW1lKTtcbiAgICAgICAgICBjYXNlIFRPS19MQlJBQ0tFVDpcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRPS19OVU1CRVIgfHwgdG9rZW4udHlwZSA9PT0gVE9LX0NPTE9OKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZUluZGV4RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0SWZTbGljZShsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19TVEFSKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfUkJSQUNLRVQpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiUHJvamVjdGlvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0XX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5fZXJyb3JUb2tlbih0aGlzLl9sb29rYWhlYWRUb2tlbigwKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9tYXRjaDogZnVuY3Rpb24odG9rZW5UeXBlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gdG9rZW5UeXBlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIiArIHRva2VuVHlwZSArIFwiLCBnb3Q6IFwiICsgdC50eXBlKTtcbiAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiUGFyc2VyRXJyb3JcIjtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2Vycm9yVG9rZW46IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiSW52YWxpZCB0b2tlbiAoXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi50eXBlICsgXCIpOiBcXFwiXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSArIFwiXFxcIlwiKTtcbiAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJFcnJvclwiO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSxcblxuXG4gICAgICBfcGFyc2VJbmRleEV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT0xPTiB8fCB0aGlzLl9sb29rYWhlYWQoMSkgPT09IFRPS19DT0xPTikge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VTbGljZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiSW5kZXhcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9sb29rYWhlYWRUb2tlbigwKS52YWx1ZX07XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JCUkFDS0VUKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX3Byb2plY3RJZlNsaWNlOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICAgIHZhciBpbmRleEV4cHIgPSB7dHlwZTogXCJJbmRleEV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGlmIChyaWdodC50eXBlID09PSBcIlNsaWNlXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUHJvamVjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtpbmRleEV4cHIsIHRoaXMuX3BhcnNlUHJvamVjdGlvblJIUyhiaW5kaW5nUG93ZXIuU3RhcildXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluZGV4RXhwcjtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfcGFyc2VTbGljZUV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIFtzdGFydDplbmQ6c3RlcF0gd2hlcmUgZWFjaCBwYXJ0IGlzIG9wdGlvbmFsLCBhcyB3ZWxsIGFzIHRoZSBsYXN0XG4gICAgICAgICAgLy8gY29sb24uXG4gICAgICAgICAgdmFyIHBhcnRzID0gW251bGwsIG51bGwsIG51bGxdO1xuICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgdmFyIGN1cnJlbnRUb2tlbiA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICB3aGlsZSAoY3VycmVudFRva2VuICE9PSBUT0tfUkJSQUNLRVQgJiYgaW5kZXggPCAzKSB7XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50VG9rZW4gPT09IFRPS19DT0xPTikge1xuICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VG9rZW4gPT09IFRPS19OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnRzW2luZGV4XSA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLl9sb29rYWhlYWQoMCk7XG4gICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJTeW50YXggZXJyb3IsIHVuZXhwZWN0ZWQgdG9rZW46IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnZhbHVlICsgXCIoXCIgKyB0LnR5cGUgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJlcnJvclwiO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gdGhpcy5fbG9va2FoZWFkKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfUkJSQUNLRVQpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiU2xpY2VcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IHBhcnRzXG4gICAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIF9wYXJzZUNvbXBhcmF0b3I6IGZ1bmN0aW9uKGxlZnQsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKGJpbmRpbmdQb3dlcltjb21wYXJhdG9yXSk7XG4gICAgICAgIHJldHVybiB7dHlwZTogXCJDb21wYXJhdG9yXCIsIG5hbWU6IGNvbXBhcmF0b3IsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgIH0sXG5cbiAgICAgIF9wYXJzZURvdFJIUzogZnVuY3Rpb24ocmJwKSB7XG4gICAgICAgICAgdmFyIGxvb2thaGVhZCA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICB2YXIgZXhwclRva2VucyA9IFtUT0tfVU5RVU9URURJREVOVElGSUVSLCBUT0tfUVVPVEVESURFTlRJRklFUiwgVE9LX1NUQVJdO1xuICAgICAgICAgIGlmIChleHByVG9rZW5zLmluZGV4T2YobG9va2FoZWFkKSA+PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24ocmJwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxvb2thaGVhZCA9PT0gVE9LX0xCUkFDS0VUKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19MQlJBQ0tFVCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZU11bHRpc2VsZWN0TGlzdCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobG9va2FoZWFkID09PSBUT0tfTEJSQUNFKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19MQlJBQ0UpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VNdWx0aXNlbGVjdEhhc2goKTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfcGFyc2VQcm9qZWN0aW9uUkhTOiBmdW5jdGlvbihyYnApIHtcbiAgICAgICAgICB2YXIgcmlnaHQ7XG4gICAgICAgICAgaWYgKGJpbmRpbmdQb3dlclt0aGlzLl9sb29rYWhlYWQoMCldIDwgMTApIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB7dHlwZTogXCJJZGVudGl0eVwifTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0xCUkFDS0VUKSB7XG4gICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKHJicCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19GSUxURVIpIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24ocmJwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0RPVCkge1xuICAgICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfRE9UKTtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZURvdFJIUyhyYnApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5fbG9va2FoZWFkVG9rZW4oMCk7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlN5dGFueCBlcnJvciwgdW5leHBlY3RlZCB0b2tlbjogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC52YWx1ZSArIFwiKFwiICsgdC50eXBlICsgXCIpXCIpO1xuICAgICAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJFcnJvclwiO1xuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgICAgfSxcblxuICAgICAgX3BhcnNlTXVsdGlzZWxlY3RMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5fbG9va2FoZWFkKDApICE9PSBUT0tfUkJSQUNLRVQpIHtcbiAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT01NQSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX0NPTU1BKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19SQlJBQ0tFVCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFJicmFja2V0XCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0tFVCk7XG4gICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIk11bHRpU2VsZWN0TGlzdFwiLCBjaGlsZHJlbjogZXhwcmVzc2lvbnN9O1xuICAgICAgfSxcblxuICAgICAgX3BhcnNlTXVsdGlzZWxlY3RIYXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhaXJzID0gW107XG4gICAgICAgIHZhciBpZGVudGlmaWVyVHlwZXMgPSBbVE9LX1VOUVVPVEVESURFTlRJRklFUiwgVE9LX1FVT1RFRElERU5USUZJRVJdO1xuICAgICAgICB2YXIga2V5VG9rZW4sIGtleU5hbWUsIHZhbHVlLCBub2RlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAga2V5VG9rZW4gPSB0aGlzLl9sb29rYWhlYWRUb2tlbigwKTtcbiAgICAgICAgICBpZiAoaWRlbnRpZmllclR5cGVzLmluZGV4T2Yoa2V5VG9rZW4udHlwZSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RpbmcgYW4gaWRlbnRpZmllciB0b2tlbiwgZ290OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5VG9rZW4udHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleU5hbWUgPSBrZXlUb2tlbi52YWx1ZTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX0NPTE9OKTtcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICBub2RlID0ge3R5cGU6IFwiS2V5VmFsdWVQYWlyXCIsIG5hbWU6IGtleU5hbWUsIHZhbHVlOiB2YWx1ZX07XG4gICAgICAgICAgcGFpcnMucHVzaChub2RlKTtcbiAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ09NTUEpIHtcbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19DT01NQSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19SQlJBQ0UpIHtcbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7dHlwZTogXCJNdWx0aVNlbGVjdEhhc2hcIiwgY2hpbGRyZW46IHBhaXJzfTtcbiAgICAgIH1cbiAgfTtcblxuXG4gIGZ1bmN0aW9uIFRyZWVJbnRlcnByZXRlcihydW50aW1lKSB7XG4gICAgdGhpcy5ydW50aW1lID0gcnVudGltZTtcbiAgfVxuXG4gIFRyZWVJbnRlcnByZXRlci5wcm90b3R5cGUgPSB7XG4gICAgICBzZWFyY2g6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXQobm9kZSwgdmFsdWUpO1xuICAgICAgfSxcblxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIG1hdGNoZWQsIGN1cnJlbnQsIHJlc3VsdCwgZmlyc3QsIHNlY29uZCwgZmllbGQsIGxlZnQsIHJpZ2h0LCBjb2xsZWN0ZWQsIGk7XG4gICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJGaWVsZFwiOlxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIGZpZWxkID0gdmFsdWVbbm9kZS5uYW1lXTtcbiAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTdWJleHByZXNzaW9uXCI6XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlIFwiSW5kZXhFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICAgIGxlZnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMV0sIGxlZnQpO1xuICAgICAgICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICAgICAgICBjYXNlIFwiSW5kZXhcIjpcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IG5vZGUudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHZhbHVlLmxlbmd0aCArIGluZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgY2FzZSBcIlNsaWNlXCI6XG4gICAgICAgICAgICAgIGlmICghaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgc2xpY2VQYXJhbXMgPSBub2RlLmNoaWxkcmVuLnNsaWNlKDApO1xuICAgICAgICAgICAgICB2YXIgY29tcHV0ZWQgPSB0aGlzLmNvbXB1dGVTbGljZVBhcmFtcyh2YWx1ZS5sZW5ndGgsIHNsaWNlUGFyYW1zKTtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY29tcHV0ZWRbMF07XG4gICAgICAgICAgICAgIHZhciBzdG9wID0gY29tcHV0ZWRbMV07XG4gICAgICAgICAgICAgIHZhciBzdGVwID0gY29tcHV0ZWRbMl07XG4gICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RvcDsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPiBzdG9wOyBpICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGNhc2UgXCJQcm9qZWN0aW9uXCI6XG4gICAgICAgICAgICAgIC8vIEV2YWx1YXRlIGxlZnQgY2hpbGQuXG4gICAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmICghaXNBcnJheShiYXNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmFzZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMV0sIGJhc2VbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcbiAgICAgICAgICAgIGNhc2UgXCJWYWx1ZVByb2plY3Rpb25cIjpcbiAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgbGVmdCBjaGlsZC5cbiAgICAgICAgICAgICAgYmFzZSA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29sbGVjdGVkID0gW107XG4gICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBvYmpWYWx1ZXMoYmFzZSk7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcbiAgICAgICAgICAgIGNhc2UgXCJGaWx0ZXJQcm9qZWN0aW9uXCI6XG4gICAgICAgICAgICAgIGJhc2UgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gW107XG4gICAgICAgICAgICAgIHZhciBmaW5hbFJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJhc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzJdLCBiYXNlW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmFsc2UobWF0Y2hlZCkpIHtcbiAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnB1c2goYmFzZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmlsdGVyZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCBmaWx0ZXJlZFtqXSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmluYWxSZXN1bHRzO1xuICAgICAgICAgICAgY2FzZSBcIkNvbXBhcmF0b3JcIjpcbiAgICAgICAgICAgICAgZmlyc3QgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgc2Vjb25kID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHN3aXRjaChub2RlLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19FUTpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHN0cmljdERlZXBFcXVhbChmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVE9LX05FOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gIXN0cmljdERlZXBFcXVhbChmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVE9LX0dUOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3QgPiBzZWNvbmQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19HVEU6XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBmaXJzdCA+PSBzZWNvbmQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19MVDpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpcnN0IDwgc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUT0tfTFRFOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3QgPD0gc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29tcGFyYXRvcjogXCIgKyBub2RlLm5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlIFRPS19GTEFUVEVOOlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBtZXJnZWQgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9yaWdpbmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG9yaWdpbmFsW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICBtZXJnZWQucHVzaC5hcHBseShtZXJnZWQsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgICAgIGNhc2UgXCJJZGVudGl0eVwiOlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlTZWxlY3RMaXN0XCI6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29sbGVjdGVkLnB1c2godGhpcy52aXNpdChub2RlLmNoaWxkcmVuW2ldLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlTZWxlY3RIYXNoXCI6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IHt9O1xuICAgICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNvbGxlY3RlZFtjaGlsZC5uYW1lXSA9IHRoaXMudmlzaXQoY2hpbGQudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xuICAgICAgICAgICAgY2FzZSBcIk9yRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmIChpc0ZhbHNlKG1hdGNoZWQpKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgICAgICAgICBjYXNlIFwiQW5kRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBmaXJzdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgIGlmIChpc0ZhbHNlKGZpcnN0KSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwiTm90RXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBmaXJzdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICByZXR1cm4gaXNGYWxzZShmaXJzdCk7XG4gICAgICAgICAgICBjYXNlIFwiTGl0ZXJhbFwiOlxuICAgICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgVE9LX1BJUEU6XG4gICAgICAgICAgICAgIGxlZnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblsxXSwgbGVmdCk7XG4gICAgICAgICAgICBjYXNlIFRPS19DVVJSRU5UOlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwiRnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgdmFyIHJlc29sdmVkQXJncyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcmdzLnB1c2godGhpcy52aXNpdChub2RlLmNoaWxkcmVuW2ldLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bnRpbWUuY2FsbEZ1bmN0aW9uKG5vZGUubmFtZSwgcmVzb2x2ZWRBcmdzKTtcbiAgICAgICAgICAgIGNhc2UgXCJFeHByZXNzaW9uUmVmZXJlbmNlXCI6XG4gICAgICAgICAgICAgIHZhciByZWZOb2RlID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgLy8gVGFnIHRoZSBub2RlIHdpdGggYSBzcGVjaWZpYyBhdHRyaWJ1dGUgc28gdGhlIHR5cGVcbiAgICAgICAgICAgICAgLy8gY2hlY2tlciB2ZXJpZnkgdGhlIHR5cGUuXG4gICAgICAgICAgICAgIHJlZk5vZGUuam1lc3BhdGhUeXBlID0gVE9LX0VYUFJFRjtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlZk5vZGU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIgKyBub2RlLnR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGNvbXB1dGVTbGljZVBhcmFtczogZnVuY3Rpb24oYXJyYXlMZW5ndGgsIHNsaWNlUGFyYW1zKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHNsaWNlUGFyYW1zWzBdO1xuICAgICAgICB2YXIgc3RvcCA9IHNsaWNlUGFyYW1zWzFdO1xuICAgICAgICB2YXIgc3RlcCA9IHNsaWNlUGFyYW1zWzJdO1xuICAgICAgICB2YXIgY29tcHV0ZWQgPSBbbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgICAgIGlmIChzdGVwID09PSBudWxsKSB7XG4gICAgICAgICAgc3RlcCA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkludmFsaWQgc2xpY2UsIHN0ZXAgY2Fubm90IGJlIDBcIik7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IFwiUnVudGltZUVycm9yXCI7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ZXBWYWx1ZU5lZ2F0aXZlID0gc3RlcCA8IDAgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydCA9IHN0ZXBWYWx1ZU5lZ2F0aXZlID8gYXJyYXlMZW5ndGggLSAxIDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5jYXBTbGljZVJhbmdlKGFycmF5TGVuZ3RoLCBzdGFydCwgc3RlcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RvcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RvcCA9IHN0ZXBWYWx1ZU5lZ2F0aXZlID8gLTEgOiBhcnJheUxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3AgPSB0aGlzLmNhcFNsaWNlUmFuZ2UoYXJyYXlMZW5ndGgsIHN0b3AsIHN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVkWzBdID0gc3RhcnQ7XG4gICAgICAgIGNvbXB1dGVkWzFdID0gc3RvcDtcbiAgICAgICAgY29tcHV0ZWRbMl0gPSBzdGVwO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgICB9LFxuXG4gICAgICBjYXBTbGljZVJhbmdlOiBmdW5jdGlvbihhcnJheUxlbmd0aCwgYWN0dWFsVmFsdWUsIHN0ZXApIHtcbiAgICAgICAgICBpZiAoYWN0dWFsVmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgIGFjdHVhbFZhbHVlICs9IGFycmF5TGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoYWN0dWFsVmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBhY3R1YWxWYWx1ZSA9IHN0ZXAgPCAwID8gLTEgOiAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhY3R1YWxWYWx1ZSA+PSBhcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICBhY3R1YWxWYWx1ZSA9IHN0ZXAgPCAwID8gYXJyYXlMZW5ndGggLSAxIDogYXJyYXlMZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhY3R1YWxWYWx1ZTtcbiAgICAgIH1cblxuICB9O1xuXG4gIGZ1bmN0aW9uIFJ1bnRpbWUoaW50ZXJwcmV0ZXIpIHtcbiAgICB0aGlzLl9pbnRlcnByZXRlciA9IGludGVycHJldGVyO1xuICAgIHRoaXMuZnVuY3Rpb25UYWJsZSA9IHtcbiAgICAgICAgLy8gbmFtZTogW2Z1bmN0aW9uLCA8c2lnbmF0dXJlPl1cbiAgICAgICAgLy8gVGhlIDxzaWduYXR1cmU+IGNhbiBiZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgIGFyZ3M6IFtbdHlwZTEsIHR5cGUyXSwgW3R5cGUxLCB0eXBlMl1dLFxuICAgICAgICAvLyAgIHZhcmlhZGljOiB0cnVlfGZhbHNlXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRWFjaCBhcmcgaW4gdGhlIGFyZyBsaXN0IGlzIGEgbGlzdCBvZiB2YWxpZCB0eXBlc1xuICAgICAgICAvLyAoaWYgdGhlIGZ1bmN0aW9uIGlzIG92ZXJsb2FkZWQgYW5kIHN1cHBvcnRzIG11bHRpcGxlXG4gICAgICAgIC8vIHR5cGVzLiAgSWYgdGhlIHR5cGUgaXMgXCJhbnlcIiB0aGVuIG5vIHR5cGUgY2hlY2tpbmdcbiAgICAgICAgLy8gb2NjdXJzIG9uIHRoZSBhcmd1bWVudC4gIFZhcmlhZGljIGlzIG9wdGlvbmFsXG4gICAgICAgIC8vIGFuZCBpZiBub3QgcHJvdmlkZWQgaXMgYXNzdW1lZCB0byBiZSBmYWxzZS5cbiAgICAgICAgYWJzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uQWJzLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBhdmc6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25BdmcsIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZX05VTUJFUl19XX0sXG4gICAgICAgIGNlaWw6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25DZWlsLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBjb250YWluczoge1xuICAgICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uQ29udGFpbnMsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkcsIFRZUEVfQVJSQVldfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlczogW1RZUEVfQU5ZXX1dfSxcbiAgICAgICAgXCJlbmRzX3dpdGhcIjoge1xuICAgICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uRW5kc1dpdGgsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkddfSwge3R5cGVzOiBbVFlQRV9TVFJJTkddfV19LFxuICAgICAgICBmbG9vcjoge19mdW5jOiB0aGlzLl9mdW5jdGlvbkZsb29yLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbkxlbmd0aCxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX1NUUklORywgVFlQRV9BUlJBWSwgVFlQRV9PQkpFQ1RdfV19LFxuICAgICAgICBtYXA6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1hcCxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0VYUFJFRl19LCB7dHlwZXM6IFtUWVBFX0FSUkFZXX1dfSxcbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NYXgsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BUlJBWV9OVU1CRVIsIFRZUEVfQVJSQVlfU1RSSU5HXX1dfSxcbiAgICAgICAgXCJtZXJnZVwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NZXJnZSxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX09CSkVDVF0sIHZhcmlhZGljOiB0cnVlfV1cbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXhfYnlcIjoge1xuICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1heEJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIHN1bToge19mdW5jOiB0aGlzLl9mdW5jdGlvblN1bSwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQVJSQVlfTlVNQkVSXX1dfSxcbiAgICAgICAgXCJzdGFydHNfd2l0aFwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25TdGFydHNXaXRoLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfU1RSSU5HXX0sIHt0eXBlczogW1RZUEVfU1RSSU5HXX1dfSxcbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NaW4sXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BUlJBWV9OVU1CRVIsIFRZUEVfQVJSQVlfU1RSSU5HXX1dfSxcbiAgICAgICAgXCJtaW5fYnlcIjoge1xuICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1pbkJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25UeXBlLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BTlldfV19LFxuICAgICAgICBrZXlzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uS2V5cywgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfT0JKRUNUXX1dfSxcbiAgICAgICAgdmFsdWVzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uVmFsdWVzLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9PQkpFQ1RdfV19LFxuICAgICAgICBzb3J0OiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uU29ydCwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQVJSQVlfU1RSSU5HLCBUWVBFX0FSUkFZX05VTUJFUl19XX0sXG4gICAgICAgIFwic29ydF9ieVwiOiB7XG4gICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uU29ydEJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIGpvaW46IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbkpvaW4sXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbXG4gICAgICAgICAgICAgICAge3R5cGVzOiBbVFlQRV9TVFJJTkddfSxcbiAgICAgICAgICAgICAgICB7dHlwZXM6IFtUWVBFX0FSUkFZX1NUUklOR119XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHJldmVyc2U6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvblJldmVyc2UsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkcsIFRZUEVfQVJSQVldfV19LFxuICAgICAgICBcInRvX2FycmF5XCI6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25Ub0FycmF5LCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BTlldfV19LFxuICAgICAgICBcInRvX3N0cmluZ1wiOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uVG9TdHJpbmcsIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FOWV19XX0sXG4gICAgICAgIFwidG9fbnVtYmVyXCI6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25Ub051bWJlciwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQU5ZXX1dfSxcbiAgICAgICAgXCJub3RfbnVsbFwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25Ob3ROdWxsLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQU5ZXSwgdmFyaWFkaWM6IHRydWV9XVxuICAgICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIFJ1bnRpbWUucHJvdG90eXBlID0ge1xuICAgIGNhbGxGdW5jdGlvbjogZnVuY3Rpb24obmFtZSwgcmVzb2x2ZWRBcmdzKSB7XG4gICAgICB2YXIgZnVuY3Rpb25FbnRyeSA9IHRoaXMuZnVuY3Rpb25UYWJsZVtuYW1lXTtcbiAgICAgIGlmIChmdW5jdGlvbkVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGZ1bmN0aW9uOiBcIiArIG5hbWUgKyBcIigpXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdmFsaWRhdGVBcmdzKG5hbWUsIHJlc29sdmVkQXJncywgZnVuY3Rpb25FbnRyeS5fc2lnbmF0dXJlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbkVudHJ5Ll9mdW5jLmNhbGwodGhpcywgcmVzb2x2ZWRBcmdzKTtcbiAgICB9LFxuXG4gICAgX3ZhbGlkYXRlQXJnczogZnVuY3Rpb24obmFtZSwgYXJncywgc2lnbmF0dXJlKSB7XG4gICAgICAgIC8vIFZhbGlkYXRpbmcgdGhlIGFyZ3MgcmVxdWlyZXMgdmFsaWRhdGluZ1xuICAgICAgICAvLyB0aGUgY29ycmVjdCBhcml0eSBhbmQgdGhlIGNvcnJlY3QgdHlwZSBvZiBlYWNoIGFyZy5cbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgYXJndW1lbnQgaXMgZGVjbGFyZWQgYXMgdmFyaWFkaWMsIHRoZW4gd2UgbmVlZFxuICAgICAgICAvLyBhIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3MgdG8gYmUgcmVxdWlyZWQuICBPdGhlcndpc2UgaXQgaGFzIHRvXG4gICAgICAgIC8vIGJlIGFuIGV4YWN0IGFtb3VudC5cbiAgICAgICAgdmFyIHBsdXJhbGl6ZWQ7XG4gICAgICAgIGlmIChzaWduYXR1cmVbc2lnbmF0dXJlLmxlbmd0aCAtIDFdLnZhcmlhZGljKSB7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBzaWduYXR1cmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGx1cmFsaXplZCA9IHNpZ25hdHVyZS5sZW5ndGggPT09IDEgPyBcIiBhcmd1bWVudFwiIDogXCIgYXJndW1lbnRzXCI7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnRFcnJvcjogXCIgKyBuYW1lICsgXCIoKSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGFrZXMgYXQgbGVhc3RcIiArIHNpZ25hdHVyZS5sZW5ndGggKyBwbHVyYWxpemVkICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIFwiICsgYXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoICE9PSBzaWduYXR1cmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBwbHVyYWxpemVkID0gc2lnbmF0dXJlLmxlbmd0aCA9PT0gMSA/IFwiIGFyZ3VtZW50XCIgOiBcIiBhcmd1bWVudHNcIjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50RXJyb3I6IFwiICsgbmFtZSArIFwiKCkgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGFrZXMgXCIgKyBzaWduYXR1cmUubGVuZ3RoICsgcGx1cmFsaXplZCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIFwiICsgYXJncy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50U3BlYztcbiAgICAgICAgdmFyIGFjdHVhbFR5cGU7XG4gICAgICAgIHZhciB0eXBlTWF0Y2hlZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWduYXR1cmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHR5cGVNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjdXJyZW50U3BlYyA9IHNpZ25hdHVyZVtpXS50eXBlcztcbiAgICAgICAgICAgIGFjdHVhbFR5cGUgPSB0aGlzLl9nZXRUeXBlTmFtZShhcmdzW2ldKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3VycmVudFNwZWMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHlwZU1hdGNoZXMoYWN0dWFsVHlwZSwgY3VycmVudFNwZWNbal0sIGFyZ3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0eXBlTWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGVFcnJvcjogXCIgKyBuYW1lICsgXCIoKSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgYXJndW1lbnQgXCIgKyAoaSArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgdG8gYmUgdHlwZSBcIiArIGN1cnJlbnRTcGVjICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIHR5cGUgXCIgKyBhY3R1YWxUeXBlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3R5cGVNYXRjaGVzOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBhcmdWYWx1ZSkge1xuICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQU5ZKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQVJSQVlfU1RSSU5HIHx8XG4gICAgICAgICAgICBleHBlY3RlZCA9PT0gVFlQRV9BUlJBWV9OVU1CRVIgfHxcbiAgICAgICAgICAgIGV4cGVjdGVkID09PSBUWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICAvLyBUaGUgZXhwZWN0ZWQgdHlwZSBjYW4gZWl0aGVyIGp1c3QgYmUgYXJyYXksXG4gICAgICAgICAgICAvLyBvciBpdCBjYW4gcmVxdWlyZSBhIHNwZWNpZmljIHN1YnR5cGUgKGFycmF5IG9mIG51bWJlcnMpLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBzaW1wbGVzdCBjYXNlIGlzIGlmIFwiYXJyYXlcIiB3aXRoIG5vIHN1YnR5cGUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgaWYgKGV4cGVjdGVkID09PSBUWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdHVhbCA9PT0gVFlQRV9BUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWN0dWFsID09PSBUWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gY2hlY2sgc3VidHlwZXMuXG4gICAgICAgICAgICAgICAgLy8gSSB0aGluayB0aGlzIGhhcyBwb3RlbnRpYWwgdG8gYmUgaW1wcm92ZWQuXG4gICAgICAgICAgICAgICAgdmFyIHN1YnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkID09PSBUWVBFX0FSUkFZX05VTUJFUikge1xuICAgICAgICAgICAgICAgICAgc3VidHlwZSA9IFRZUEVfTlVNQkVSO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQVJSQVlfU1RSSU5HKSB7XG4gICAgICAgICAgICAgICAgICBzdWJ0eXBlID0gVFlQRV9TVFJJTkc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90eXBlTWF0Y2hlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXRUeXBlTmFtZShhcmdWYWx1ZVtpXSksIHN1YnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdWYWx1ZVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhY3R1YWwgPT09IGV4cGVjdGVkO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfZ2V0VHlwZU5hbWU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSB7XG4gICAgICAgICAgICBjYXNlIFwiW29iamVjdCBTdHJpbmddXCI6XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFX1NUUklORztcbiAgICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IE51bWJlcl1cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfTlVNQkVSO1xuICAgICAgICAgICAgY2FzZSBcIltvYmplY3QgQXJyYXldXCI6XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFX0FSUkFZO1xuICAgICAgICAgICAgY2FzZSBcIltvYmplY3QgQm9vbGVhbl1cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfQk9PTEVBTjtcbiAgICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IE51bGxdXCI6XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFX05VTEw7XG4gICAgICAgICAgICBjYXNlIFwiW29iamVjdCBPYmplY3RdXCI6XG4gICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gZXhwcmVmLiAgSWYgaXQgaGFzLCBpdCdzIGJlZW5cbiAgICAgICAgICAgICAgLy8gdGFnZ2VkIHdpdGggYSBqbWVzcGF0aFR5cGUgYXR0ciBvZiAnRXhwcmVmJztcbiAgICAgICAgICAgICAgaWYgKG9iai5qbWVzcGF0aFR5cGUgPT09IFRPS19FWFBSRUYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVFlQRV9FWFBSRUY7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfT0JKRUNUO1xuICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uU3RhcnRzV2l0aDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlZEFyZ3NbMF0ubGFzdEluZGV4T2YocmVzb2x2ZWRBcmdzWzFdKSA9PT0gMDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uRW5kc1dpdGg6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgc2VhcmNoU3RyID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICB2YXIgc3VmZml4ID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgICByZXR1cm4gc2VhcmNoU3RyLmluZGV4T2Yoc3VmZml4LCBzZWFyY2hTdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgIT09IC0xO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25SZXZlcnNlOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICAgICAgaWYgKHR5cGVOYW1lID09PSBUWVBFX1NUUklORykge1xuICAgICAgICAgIHZhciBvcmlnaW5hbFN0ciA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICB2YXIgcmV2ZXJzZWRTdHIgPSBcIlwiO1xuICAgICAgICAgIGZvciAodmFyIGkgPSBvcmlnaW5hbFN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICByZXZlcnNlZFN0ciArPSBvcmlnaW5hbFN0cltpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldmVyc2VkU3RyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXZlcnNlZEFycmF5ID0gcmVzb2x2ZWRBcmdzWzBdLnNsaWNlKDApO1xuICAgICAgICAgIHJldmVyc2VkQXJyYXkucmV2ZXJzZSgpO1xuICAgICAgICAgIHJldHVybiByZXZlcnNlZEFycmF5O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbkFiczogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uQ2VpbDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uQXZnOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIHZhciBpbnB1dEFycmF5ID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBpbnB1dEFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW0gLyBpbnB1dEFycmF5Lmxlbmd0aDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uQ29udGFpbnM6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdLmluZGV4T2YocmVzb2x2ZWRBcmdzWzFdKSA+PSAwO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25GbG9vcjogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHJlc29sdmVkQXJnc1swXSk7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbkxlbmd0aDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgaWYgKCFpc09iamVjdChyZXNvbHZlZEFyZ3NbMF0pKSB7XG4gICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdLmxlbmd0aDtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgLy8gQXMgZmFyIGFzIEkgY2FuIHRlbGwsIHRoZXJlJ3Mgbm8gd2F5IHRvIGdldCB0aGUgbGVuZ3RoXG4gICAgICAgICAvLyBvZiBhbiBvYmplY3Qgd2l0aG91dCBPKG4pIGl0ZXJhdGlvbiB0aHJvdWdoIHRoZSBvYmplY3QuXG4gICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzb2x2ZWRBcmdzWzBdKS5sZW5ndGg7XG4gICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25NYXA6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIG1hcHBlZCA9IFtdO1xuICAgICAgdmFyIGludGVycHJldGVyID0gdGhpcy5faW50ZXJwcmV0ZXI7XG4gICAgICB2YXIgZXhwcmVmTm9kZSA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgIHZhciBlbGVtZW50cyA9IHJlc29sdmVkQXJnc1sxXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtYXBwZWQucHVzaChpbnRlcnByZXRlci52aXNpdChleHByZWZOb2RlLCBlbGVtZW50c1tpXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uTWVyZ2U6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIG1lcmdlZCA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvbHZlZEFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSByZXNvbHZlZEFyZ3NbaV07XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjdXJyZW50KSB7XG4gICAgICAgICAgbWVyZ2VkW2tleV0gPSBjdXJyZW50W2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1heDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICBpZiAocmVzb2x2ZWRBcmdzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdWzBdKTtcbiAgICAgICAgaWYgKHR5cGVOYW1lID09PSBUWVBFX05VTUJFUikge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCByZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICB2YXIgbWF4RWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKG1heEVsZW1lbnQubG9jYWxlQ29tcGFyZShlbGVtZW50c1tpXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBtYXhFbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1heEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1pbjogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICBpZiAocmVzb2x2ZWRBcmdzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdWzBdKTtcbiAgICAgICAgaWYgKHR5cGVOYW1lID09PSBUWVBFX05VTUJFUikge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCByZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICB2YXIgbWluRWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzW2ldLmxvY2FsZUNvbXBhcmUobWluRWxlbWVudCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBtaW5FbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1pbkVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25TdW06IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICB2YXIgbGlzdFRvU3VtID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0VG9TdW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtICs9IGxpc3RUb1N1bVtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdW07XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblR5cGU6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2dldFR5cGVOYW1lKHJlc29sdmVkQXJnc1swXSkpIHtcbiAgICAgICAgICBjYXNlIFRZUEVfTlVNQkVSOlxuICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICAgICAgY2FzZSBUWVBFX1NUUklORzpcbiAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICAgIGNhc2UgVFlQRV9BUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgICAgICAgY2FzZSBUWVBFX09CSkVDVDpcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiO1xuICAgICAgICAgIGNhc2UgVFlQRV9CT09MRUFOOlxuICAgICAgICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuICAgICAgICAgIGNhc2UgVFlQRV9FWFBSRUY6XG4gICAgICAgICAgICByZXR1cm4gXCJleHByZWZcIjtcbiAgICAgICAgICBjYXNlIFRZUEVfTlVMTDpcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25LZXlzOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc29sdmVkQXJnc1swXSk7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblZhbHVlczogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHZhciBvYmogPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKG9ialtrZXlzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uSm9pbjogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHZhciBqb2luQ2hhciA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgdmFyIGxpc3RKb2luID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgICByZXR1cm4gbGlzdEpvaW4uam9pbihqb2luQ2hhcik7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblRvQXJyYXk6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICBpZiAodGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdKSA9PT0gVFlQRV9BUlJBWSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbcmVzb2x2ZWRBcmdzWzBdXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25Ub1N0cmluZzogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLl9nZXRUeXBlTmFtZShyZXNvbHZlZEFyZ3NbMF0pID09PSBUWVBFX1NUUklORykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblRvTnVtYmVyOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICAgICAgdmFyIGNvbnZlcnRlZFZhbHVlO1xuICAgICAgICBpZiAodHlwZU5hbWUgPT09IFRZUEVfTlVNQkVSKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSBUWVBFX1NUUklORykge1xuICAgICAgICAgICAgY29udmVydGVkVmFsdWUgPSArcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICAgICAgaWYgKCFpc05hTihjb252ZXJ0ZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk5vdE51bGw6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc29sdmVkQXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dldFR5cGVOYW1lKHJlc29sdmVkQXJnc1tpXSkgIT09IFRZUEVfTlVMTCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZEFyZ3NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblNvcnQ6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgc29ydGVkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF0uc2xpY2UoMCk7XG4gICAgICAgIHNvcnRlZEFycmF5LnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIHNvcnRlZEFycmF5O1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25Tb3J0Qnk6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgc29ydGVkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF0uc2xpY2UoMCk7XG4gICAgICAgIGlmIChzb3J0ZWRBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWRBcnJheTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJwcmV0ZXIgPSB0aGlzLl9pbnRlcnByZXRlcjtcbiAgICAgICAgdmFyIGV4cHJlZk5vZGUgPSByZXNvbHZlZEFyZ3NbMV07XG4gICAgICAgIHZhciByZXF1aXJlZFR5cGUgPSB0aGlzLl9nZXRUeXBlTmFtZShcbiAgICAgICAgICAgIGludGVycHJldGVyLnZpc2l0KGV4cHJlZk5vZGUsIHNvcnRlZEFycmF5WzBdKSk7XG4gICAgICAgIGlmIChbVFlQRV9OVU1CRVIsIFRZUEVfU1RSSU5HXS5pbmRleE9mKHJlcXVpcmVkVHlwZSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlRXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAvLyBJbiBvcmRlciB0byBnZXQgYSBzdGFibGUgc29ydCBvdXQgb2YgYW4gdW5zdGFibGVcbiAgICAgICAgLy8gc29ydCBhbGdvcml0aG0sIHdlIGRlY29yYXRlL3NvcnQvdW5kZWNvcmF0ZSAoRFNVKVxuICAgICAgICAvLyBieSBjcmVhdGluZyBhIG5ldyBsaXN0IG9mIFtpbmRleCwgZWxlbWVudF0gcGFpcnMuXG4gICAgICAgIC8vIEluIHRoZSBjbXAgZnVuY3Rpb24sIGlmIHRoZSBldmFsdWF0ZWQgZWxlbWVudHMgYXJlXG4gICAgICAgIC8vIGVxdWFsLCB0aGVuIHRoZSBpbmRleCB3aWxsIGJlIHVzZWQgYXMgdGhlIHRpZWJyZWFrZXIuXG4gICAgICAgIC8vIEFmdGVyIHRoZSBkZWNvcmF0ZWQgbGlzdCBoYXMgYmVlbiBzb3J0ZWQsIGl0IHdpbGwgYmVcbiAgICAgICAgLy8gdW5kZWNvcmF0ZWQgdG8gZXh0cmFjdCB0aGUgb3JpZ2luYWwgZWxlbWVudHMuXG4gICAgICAgIHZhciBkZWNvcmF0ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRlY29yYXRlZC5wdXNoKFtpLCBzb3J0ZWRBcnJheVtpXV0pO1xuICAgICAgICB9XG4gICAgICAgIGRlY29yYXRlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICB2YXIgZXhwckEgPSBpbnRlcnByZXRlci52aXNpdChleHByZWZOb2RlLCBhWzFdKTtcbiAgICAgICAgICB2YXIgZXhwckIgPSBpbnRlcnByZXRlci52aXNpdChleHByZWZOb2RlLCBiWzFdKTtcbiAgICAgICAgICBpZiAodGhhdC5fZ2V0VHlwZU5hbWUoZXhwckEpICE9PSByZXF1aXJlZFR5cGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUeXBlRXJyb3I6IGV4cGVjdGVkIFwiICsgcmVxdWlyZWRUeXBlICsgXCIsIHJlY2VpdmVkIFwiICtcbiAgICAgICAgICAgICAgICAgIHRoYXQuX2dldFR5cGVOYW1lKGV4cHJBKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGF0Ll9nZXRUeXBlTmFtZShleHByQikgIT09IHJlcXVpcmVkVHlwZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlR5cGVFcnJvcjogZXhwZWN0ZWQgXCIgKyByZXF1aXJlZFR5cGUgKyBcIiwgcmVjZWl2ZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgdGhhdC5fZ2V0VHlwZU5hbWUoZXhwckIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4cHJBID4gZXhwckIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXhwckEgPCBleHByQikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGV5J3JlIGVxdWFsIGNvbXBhcmUgdGhlIGl0ZW1zIGJ5IHRoZWlyXG4gICAgICAgICAgICAvLyBvcmRlciB0byBtYWludGFpbiByZWxhdGl2ZSBvcmRlciBvZiBlcXVhbCBrZXlzXG4gICAgICAgICAgICAvLyAoaS5lLiB0byBnZXQgYSBzdGFibGUgc29ydCkuXG4gICAgICAgICAgICByZXR1cm4gYVswXSAtIGJbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVW5kZWNvcmF0ZTogZXh0cmFjdCBvdXQgdGhlIG9yaWdpbmFsIGxpc3QgZWxlbWVudHMuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGVjb3JhdGVkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc29ydGVkQXJyYXlbal0gPSBkZWNvcmF0ZWRbal1bMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvcnRlZEFycmF5O1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25NYXhCeTogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICB2YXIgZXhwcmVmTm9kZSA9IHJlc29sdmVkQXJnc1sxXTtcbiAgICAgIHZhciByZXNvbHZlZEFycmF5ID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgdmFyIGtleUZ1bmN0aW9uID0gdGhpcy5jcmVhdGVLZXlGdW5jdGlvbihleHByZWZOb2RlLCBbVFlQRV9OVU1CRVIsIFRZUEVfU1RSSU5HXSk7XG4gICAgICB2YXIgbWF4TnVtYmVyID0gLUluZmluaXR5O1xuICAgICAgdmFyIG1heFJlY29yZDtcbiAgICAgIHZhciBjdXJyZW50O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvbHZlZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnQgPSBrZXlGdW5jdGlvbihyZXNvbHZlZEFycmF5W2ldKTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPiBtYXhOdW1iZXIpIHtcbiAgICAgICAgICBtYXhOdW1iZXIgPSBjdXJyZW50O1xuICAgICAgICAgIG1heFJlY29yZCA9IHJlc29sdmVkQXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXhSZWNvcmQ7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1pbkJ5OiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgIHZhciBleHByZWZOb2RlID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgdmFyIHJlc29sdmVkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICB2YXIga2V5RnVuY3Rpb24gPSB0aGlzLmNyZWF0ZUtleUZ1bmN0aW9uKGV4cHJlZk5vZGUsIFtUWVBFX05VTUJFUiwgVFlQRV9TVFJJTkddKTtcbiAgICAgIHZhciBtaW5OdW1iZXIgPSBJbmZpbml0eTtcbiAgICAgIHZhciBtaW5SZWNvcmQ7XG4gICAgICB2YXIgY3VycmVudDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzb2x2ZWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50ID0ga2V5RnVuY3Rpb24ocmVzb2x2ZWRBcnJheVtpXSk7XG4gICAgICAgIGlmIChjdXJyZW50IDwgbWluTnVtYmVyKSB7XG4gICAgICAgICAgbWluTnVtYmVyID0gY3VycmVudDtcbiAgICAgICAgICBtaW5SZWNvcmQgPSByZXNvbHZlZEFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWluUmVjb3JkO1xuICAgIH0sXG5cbiAgICBjcmVhdGVLZXlGdW5jdGlvbjogZnVuY3Rpb24oZXhwcmVmTm9kZSwgYWxsb3dlZFR5cGVzKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgaW50ZXJwcmV0ZXIgPSB0aGlzLl9pbnRlcnByZXRlcjtcbiAgICAgIHZhciBrZXlGdW5jID0gZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IGludGVycHJldGVyLnZpc2l0KGV4cHJlZk5vZGUsIHgpO1xuICAgICAgICBpZiAoYWxsb3dlZFR5cGVzLmluZGV4T2YodGhhdC5fZ2V0VHlwZU5hbWUoY3VycmVudCkpIDwgMCkge1xuICAgICAgICAgIHZhciBtc2cgPSBcIlR5cGVFcnJvcjogZXhwZWN0ZWQgb25lIG9mIFwiICsgYWxsb3dlZFR5cGVzICtcbiAgICAgICAgICAgICAgICAgICAgXCIsIHJlY2VpdmVkIFwiICsgdGhhdC5fZ2V0VHlwZU5hbWUoY3VycmVudCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGtleUZ1bmM7XG4gICAgfVxuXG4gIH07XG5cbiAgZnVuY3Rpb24gY29tcGlsZShzdHJlYW0pIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcigpO1xuICAgIHZhciBhc3QgPSBwYXJzZXIucGFyc2Uoc3RyZWFtKTtcbiAgICByZXR1cm4gYXN0O1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5pemUoc3RyZWFtKSB7XG4gICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIoKTtcbiAgICAgIHJldHVybiBsZXhlci50b2tlbml6ZShzdHJlYW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VhcmNoKGRhdGEsIGV4cHJlc3Npb24pIHtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKCk7XG4gICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGltcHJvdmVkLiAgQm90aCB0aGUgaW50ZXJwcmV0ZXIgYW5kIHJ1bnRpbWUgZGVwZW5kIG9uXG4gICAgICAvLyBlYWNoIG90aGVyLiAgVGhlIHJ1bnRpbWUgbmVlZHMgdGhlIGludGVycHJldGVyIHRvIHN1cHBvcnQgZXhwcmVmcy5cbiAgICAgIC8vIFRoZXJlJ3MgbGlrZWx5IGEgY2xlYW4gd2F5IHRvIGF2b2lkIHRoZSBjeWNsaWMgZGVwZW5kZW5jeS5cbiAgICAgIHZhciBydW50aW1lID0gbmV3IFJ1bnRpbWUoKTtcbiAgICAgIHZhciBpbnRlcnByZXRlciA9IG5ldyBUcmVlSW50ZXJwcmV0ZXIocnVudGltZSk7XG4gICAgICBydW50aW1lLl9pbnRlcnByZXRlciA9IGludGVycHJldGVyO1xuICAgICAgdmFyIG5vZGUgPSBwYXJzZXIucGFyc2UoZXhwcmVzc2lvbik7XG4gICAgICByZXR1cm4gaW50ZXJwcmV0ZXIuc2VhcmNoKG5vZGUsIGRhdGEpO1xuICB9XG5cbiAgZXhwb3J0cy50b2tlbml6ZSA9IHRva2VuaXplO1xuICBleHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuICBleHBvcnRzLnNlYXJjaCA9IHNlYXJjaDtcbiAgZXhwb3J0cy5zdHJpY3REZWVwRXF1YWwgPSBzdHJpY3REZWVwRXF1YWw7XG59KSh0eXBlb2YgZXhwb3J0cyA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMuam1lc3BhdGggPSB7fSA6IGV4cG9ydHMpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG9ialtrXS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiBpc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIWlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnkgY29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgdGhlIHBhcnQgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhcyBub24gQVNDSUkgY2hhcmFjdGVycy4gSS5lLiBpdCBkb3NlbnQgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBpbiBBU0NJSS5cbiAgICAgIHZhciBkb21haW5BcnJheSA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBuZXdPdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9tYWluQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHMgPSBkb21haW5BcnJheVtpXTtcbiAgICAgICAgbmV3T3V0LnB1c2gocy5tYXRjaCgvW15BLVphLXowLTlfLV0vKSA/XG4gICAgICAgICAgICAneG4tLScgKyBwdW55Y29kZS5lbmNvZGUocykgOiBzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBuZXdPdXQuam9pbignLicpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAoaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKGlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICByZXN1bHRba10gPSB0aGlzW2tdO1xuICB9LCB0aGlzKTtcblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIE9iamVjdC5rZXlzKHJlbGF0aXZlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChrICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICB9KTtcblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfSk7XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCFpc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8XG4gICAgICBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiAgYXJnID09IG51bGw7XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCJ2YXIgdjEgPSByZXF1aXJlKCcuL3YxJyk7XG52YXIgdjQgPSByZXF1aXJlKCcuL3Y0Jyk7XG5cbnZhciB1dWlkID0gdjQ7XG51dWlkLnYxID0gdjE7XG51dWlkLnY0ID0gdjQ7XG5cbm1vZHVsZS5leHBvcnRzID0gdXVpZDtcbiIsIi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4O1xuICAvLyBqb2luIHVzZWQgdG8gZml4IG1lbW9yeSBpc3N1ZSBjYXVzZWQgYnkgY29uY2F0ZW5hdGlvbjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzE3NSNjNFxuICByZXR1cm4gKFtidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dXSkuam9pbignJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXNUb1V1aWQ7XG4iLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgSW4gdGhlXG4vLyBicm93c2VyIHRoaXMgaXMgYSBsaXR0bGUgY29tcGxpY2F0ZWQgZHVlIHRvIHVua25vd24gcXVhbGl0eSBvZiBNYXRoLnJhbmRvbSgpXG4vLyBhbmQgaW5jb25zaXN0ZW50IHN1cHBvcnQgZm9yIHRoZSBgY3J5cHRvYCBBUEkuICBXZSBkbyB0aGUgYmVzdCB3ZSBjYW4gdmlhXG4vLyBmZWF0dXJlLWRldGVjdGlvblxuXG4vLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG9cbi8vIGltcGxlbWVudGF0aW9uLiBBbHNvLCBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gb24gSUUxMS5cbnZhciBnZXRSYW5kb21WYWx1ZXMgPSAodHlwZW9mKGNyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mKG1zQ3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKSk7XG5cbmlmIChnZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0byBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIHZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG4gICAgcmV0dXJuIHJuZHM4O1xuICB9O1xufSBlbHNlIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgcm5kcyA9IG5ldyBBcnJheSgxNik7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXRoUk5HKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBybmRzO1xuICB9O1xufVxuIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG52YXIgX25vZGVJZDtcbnZhciBfY2xvY2tzZXE7XG5cbi8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxudmFyIF9sYXN0TVNlY3MgPSAwO1xudmFyIF9sYXN0TlNlY3MgPSAwO1xuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgdmFyIGIgPSBidWYgfHwgW107XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7XG5cbiAgLy8gbm9kZSBhbmQgY2xvY2tzZXEgbmVlZCB0byBiZSBpbml0aWFsaXplZCB0byByYW5kb20gdmFsdWVzIGlmIHRoZXkncmUgbm90XG4gIC8vIHNwZWNpZmllZC4gIFdlIGRvIHRoaXMgbGF6aWx5IHRvIG1pbmltaXplIGlzc3VlcyByZWxhdGVkIHRvIGluc3VmZmljaWVudFxuICAvLyBzeXN0ZW0gZW50cm9weS4gIFNlZSAjMTg5XG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIHZhciBzZWVkQnl0ZXMgPSBybmcoKTtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbiAgICAgIG5vZGUgPSBfbm9kZUlkID0gW1xuICAgICAgICBzZWVkQnl0ZXNbMF0gfCAweDAxLFxuICAgICAgICBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XVxuICAgICAgXTtcbiAgICB9XG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9XG5cbiAgLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gIHZhciBkdCA9IChtc2VjcyAtIF9sYXN0TVNlY3MpICsgKG5zZWNzIC0gX2xhc3ROU2VjcykvMTAwMDA7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9XG5cbiAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfVxuXG4gIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gIC8vIGB0aW1lX2xvd2BcbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAvLyBgdGltZV9taWRgXG4gIHZhciB0bWggPSAobXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwKSAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAvLyBgbm9kZWBcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmID8gYnVmIDogYnl0ZXNUb1V1aWQoYik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjE7XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IGJ5dGVzVG9VdWlkKHJuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHY0O1xuIiwiaW1wb3J0ICogYXMgQVdTIGZyb20gJ2F3cy1zZGsvZ2xvYmFsJztcbmltcG9ydCB7IERlYnVnTGV2ZWxFbnVtLCBsb2cgfSBmcm9tICcuLy4uL3V0aWxzL2NvbnNvbGVfd3JhcHBlcic7XG5sb2coJ2NvZ25pdG8gbG9hZGVkLicsIERlYnVnTGV2ZWxFbnVtLkJBU0lDKTtcbmV4cG9ydCBjbGFzcyBDcmVkZW50aWFsc1Byb3ZpZGVyIHtcbiAgICBwdWJsaWMgc3RhdGljIGlwSUQgPSAndXMtZWFzdC0yOjk0Zjc2M2VjLTM4NjQtNGU4OS04MTBkLTZkMmJhNzAxNzJiYSc7XG4gICAgcHVibGljIHN0YXRpYyByZWdpb24gPSAndXMtZWFzdC0yJztcblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0KFxuICAgICAgICBpZGVudGl0eVBvb2xJZCA9IENyZWRlbnRpYWxzUHJvdmlkZXIuaXBJRCxcbiAgICAgICAgcmVnaW9uID0gQ3JlZGVudGlhbHNQcm92aWRlci5yZWdpb25cbiAgICApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDcmVkZW50aWFsc1Byb3ZpZGVyKGlkZW50aXR5UG9vbElkLCByZWdpb24pO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlZHM6IEFXUy5Db2duaXRvSWRlbnRpdHlDcmVkZW50aWFscztcblxuICAgIGNvbnN0cnVjdG9yKGlkZW50aXR5UG9vbElkOiBzdHJpbmcsIHByaXZhdGUgcmVnaW9uOiBzdHJpbmcpIHtcbiAgICAgICAgQVdTLmNvbmZpZy5yZWdpb24gPSByZWdpb247XG4gICAgICAgIHRoaXMuY3JlZHMgPSBuZXcgQVdTLkNvZ25pdG9JZGVudGl0eUNyZWRlbnRpYWxzKHtcbiAgICAgICAgICAgIElkZW50aXR5UG9vbElkOiBpZGVudGl0eVBvb2xJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3JlZHMuZ2V0KChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICA/IGxvZyhlcnJvci5tZXNzYWdlLCBEZWJ1Z0xldmVsRW51bS5ERVRBSUxFRClcbiAgICAgICAgICAgICAgICA6IGxvZygnTm8gZXJyb3Igd2FzIHJlcG9ydGVkLicsIERlYnVnTGV2ZWxFbnVtLkRFVEFJTEVEKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSB0aGlzLmNyZWRzO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgY3JlZGVudGlhbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWRzO1xuICAgIH1cbn1cbiIsImltcG9ydCBTMyBmcm9tICdhd3Mtc2RrL2NsaWVudHMvczMnO1xuaW1wb3J0IHsgRGVidWdMZXZlbEVudW0sIGVycm9yLCBsb2cgfSBmcm9tICcuLi91dGlscy9jb25zb2xlX3dyYXBwZXInO1xuaW1wb3J0IHsgQ3JlZGVudGlhbHNQcm92aWRlciB9IGZyb20gJy4vY29nbml0byc7XG5pbXBvcnQgeyBTM0NsaWVudCB9IGZyb20gJy4vczMnO1xubG9nKCdtdHVyayBsb2FkZWQuJywgRGVidWdMZXZlbEVudW0uQkFTSUMpO1xuZXhwb3J0IGNsYXNzIE10dXJrQ2xpZW50IHtcbiAgICBwdWJsaWMgc3RhdGljIGluaXQoYnVja2V0TmFtZTogc3RyaW5nLCBrZXlQcmVmaXg6IHN0cmluZykge1xuICAgICAgICBNdHVya0NsaWVudC5zMyA9IFMzQ2xpZW50LmdldChidWNrZXROYW1lLCBrZXlQcmVmaXgpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHdpbmRvdywge1xuICAgICAgICAgICAgczM6IE10dXJrQ2xpZW50LnMzLFxuICAgICAgICAgICAgY29nOiBNdHVya0NsaWVudC5jb2duaXRvLFxuICAgICAgICAgICAgc3ViOiBNdHVya0NsaWVudC5zdWJtaXQsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgc3VibWl0KG5hbWU6IHN0cmluZywgZGF0YTogYW55KSB7XG4gICAgICAgIHJldHVybiBlcnJvcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHJEYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdHJEYXRhKTtcbiAgICAgICAgICAgIGxldCByZXQgPSBhd2FpdCBNdHVya0NsaWVudC5zMy51cGxvYWQobmFtZSwgc3RyRGF0YSk7XG4gICAgICAgICAgICByZXQgPSByZXQgYXMgUzMuUHV0T2JqZWN0T3V0cHV0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGtleUdlbihoaXRJRDogc3RyaW5nLCBhc3NpZ25tZW50SUQ6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gYCR7aGl0SUR9XyR7YXNzaWdubWVudElEfV9sb2cuanNvbmA7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyB1cGRhdGVDb2duaXRvKGNwOiBDcmVkZW50aWFsc1Byb3ZpZGVyKSB7XG4gICAgICAgIE10dXJrQ2xpZW50LmNvZ25pdG8gPSBjcDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHVwZGF0ZVMzKHMzOiBTM0NsaWVudCkge1xuICAgICAgICBNdHVya0NsaWVudC5zMyA9IHMzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IENoYW5nZSB0aGVzZSBiYWNrIHRvIHByaXZhdGUgYWZ0ZXIgZGVidWdnaW5nLlxuICAgIHB1YmxpYyBzdGF0aWMgY29nbml0byA9IENyZWRlbnRpYWxzUHJvdmlkZXIuZ2V0KCk7XG4gICAgcHVibGljIHN0YXRpYyBzMzogUzNDbGllbnQ7XG59XG4iLCJpbXBvcnQgUzMgZnJvbSAnYXdzLXNkay9jbGllbnRzL3MzJztcbmltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrL2dsb2JhbCc7XG5pbXBvcnQgeyBEZWJ1Z0xldmVsRW51bSwgbG9nIH0gZnJvbSAnLi4vdXRpbHMvY29uc29sZV93cmFwcGVyJztcbmxvZygnczMgbG9hZGVkLicsIERlYnVnTGV2ZWxFbnVtLkJBU0lDKTtcbmV4cG9ydCBjbGFzcyBTM0NsaWVudCB7XG4gICAgcHVibGljIHN0YXRpYyBidWNrZXROYW1lID0gJyc7XG4gICAgcHVibGljIHN0YXRpYyBhcGlWZXJzaW9uID0gJzIwMDYtMDMtMDEnO1xuICAgIHB1YmxpYyBzdGF0aWMga2V5UHJlZml4ID0gJyc7XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldChidWNrZXQ6IHN0cmluZyA9IFMzQ2xpZW50LmJ1Y2tldE5hbWUsIGtleVByZWZpeDogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUzNDbGllbnQoYnVja2V0LCBrZXlQcmVmaXgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgczM6IFMzO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBidWNrZXROYW1lOiBzdHJpbmcsIHByaXZhdGUga2V5UHJlZml4OiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zMyA9IG5ldyBTMyh7XG4gICAgICAgICAgICBhcGlWZXJzaW9uOiBTM0NsaWVudC5hcGlWZXJzaW9uLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGJ1Y2tldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0TmFtZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBsb2FkKFxuICAgICAgICBuYW1lOiBzdHJpbmcsXG4gICAgICAgIGRhdGE6IGFueVxuICAgICk6IFByb21pc2U8QVdTLkFXU0Vycm9yIHwgUzMuUHV0T2JqZWN0T3V0cHV0PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnMzLnB1dE9iamVjdChcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIEtleTogdGhpcy5rZXlQcmVmaXggKyAnLycgKyBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBCb2R5OiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBCdWNrZXQ6IHRoaXMuYnVja2V0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKGVycjogQVdTLkFXU0Vycm9yLCBzdWNjZXNzOiBTMy5QdXRPYmplY3RPdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgVHJhY2tlckV2ZW50IH0gZnJvbSAnLi9ldmVudCc7XG5jb25zb2xlLmxvZygnZGF0YSBsb2FkZWQuJyk7XG5leHBvcnQgaW50ZXJmYWNlIE10dXJrVVJMRGF0YSB7XG4gICAgcmF3OiBzdHJpbmc7XG4gICAgYXNzaWdubWVudElEOiBzdHJpbmcgfCBudWxsO1xuICAgIGhpdElEOiBzdHJpbmcgfCBudWxsO1xuICAgIHdvcmtlcklEOiBzdHJpbmcgfCBudWxsO1xuICAgIHN1Ym1pdFRvOiBzdHJpbmcgfCBudWxsO1xufVxuXG5jb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNwbGl0KCc/JylbMV0pO1xuXG5leHBvcnQgY29uc3QgdXJsRGF0YTogTXR1cmtVUkxEYXRhID0ge1xuICAgIHJhdzogdXJsUGFyYW1zLnRvU3RyaW5nKCksXG4gICAgYXNzaWdubWVudElEOiB1cmxQYXJhbXMuZ2V0KCdhc3NpZ25tZW50SWQnKSxcbiAgICBoaXRJRDogdXJsUGFyYW1zLmdldCgnaGl0SWQnKSxcbiAgICB3b3JrZXJJRDogdXJsUGFyYW1zLmdldCgnd29ya2VySWQnKSxcbiAgICBzdWJtaXRUbzogdXJsUGFyYW1zLmdldCgndHVya1N1Ym1pdFRvJyksXG59O1xuXG5leHBvcnQgY2xhc3MgRGF0YSB7XG4gICAgcHVibGljIGxvZ3M6IHsgW2V2ZW50VHlwZTogc3RyaW5nXTogVHJhY2tlckV2ZW50W10gfSA9IHt9O1xuICAgIHB1YmxpYyBkYXRhOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge307XG4gICAgcHVibGljIGVycm9yczogYW55W10gPSBbXTtcbiAgICBwdWJsaWMgdXJsRGF0YTogTXR1cmtVUkxEYXRhO1xuXG4gICAgY29uc3RydWN0b3IocmF3TXR1cmtVUkxEYXRhOiBNdHVya1VSTERhdGEpIHtcbiAgICAgICAgdGhpcy51cmxEYXRhID0gcmF3TXR1cmtVUkxEYXRhO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRhdGEgPSBuZXcgRGF0YSh1cmxEYXRhKTtcblxuT2JqZWN0LmFzc2lnbih3aW5kb3csIHsgZGF0YSB9KTtcbiIsImltcG9ydCB7IERlYnVnTGV2ZWxFbnVtLCBsb2cgfSBmcm9tIFwiLi4vdXRpbHMvY29uc29sZV93cmFwcGVyXCI7XG5pbXBvcnQgeyBub3cgfSBmcm9tIFwiLi4vdXRpbHMvZnVuY3NcIjtcbmxvZyhcImV2ZW50IGxvYWRlZC5cIiwgRGVidWdMZXZlbEVudW0uQkFTSUMpO1xuZXhwb3J0IGNvbnN0IGVudW0gQWN0aW9uRW51bSB7XG4gIENMSUNLID0gXCJjbGlja1wiLFxuICBCVVRUT04gPSBcImJ1dHRvblwiLFxuICBTQ1JPTEwgPSBcInNjcm9sbFwiLFxuICBISVNUT1JZID0gXCJoaXN0b3J5XCIsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhY2tlckV2ZW50IHtcbiAgYWN0aW9uOiBzdHJpbmc7XG4gIHRpbWU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdFRvVHJhY2tlckV2ZW50KG9iajogYW55LCBhY3Rpb246IHN0cmluZykge1xuICBvYmouYWN0aW9uID0gYWN0aW9uO1xuICBvYmoudGltZSA9IG5vdygpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUcmFja2VyRXZlbnQob2JqOiBhbnkpOiBvYmogaXMgVHJhY2tlckV2ZW50IHtcbiAgcmV0dXJuIG9iai5hY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBvYmoudGltZSAhPT0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgY2xhc3MgQmFzZVRyYWNrZXJFdmVudDxUPiBpbXBsZW1lbnRzIFRyYWNrZXJFdmVudCB7XG4gIHB1YmxpYyBjdXN0RXY6IEN1c3RvbUV2ZW50O1xuICBwdWJsaWMgYWN0aW9uOiBzdHJpbmc7XG4gIHB1YmxpYyB0aW1lOiBudW1iZXI7XG4gIGNvbnN0cnVjdG9yKGFjdGlvbjogc3RyaW5nLCBldmVudEluaXREaWN0PzogQ3VzdG9tRXZlbnRJbml0PFQ+IHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5jdXN0RXYgPSBuZXcgQ3VzdG9tRXZlbnQoYWN0aW9uLCBldmVudEluaXREaWN0KTtcbiAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcbiAgICB0aGlzLnRpbWUgPSBub3coKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgZGV0YWlsKCkge1xuICAgIHJldHVybiB0aGlzLmN1c3RFdi5kZXRhaWw7XG4gIH1cbn1cblxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtYXgtY2xhc3Nlcy1wZXItZmlsZVxuZXhwb3J0IGNsYXNzIENsaWNrRXZlbnQgZXh0ZW5kcyBCYXNlVHJhY2tlckV2ZW50PHtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIGlkOiBzdHJpbmc7XG59PiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHg6IG51bWJlcixcbiAgICB5OiBudW1iZXIsXG4gICAgaWQ6IHN0cmluZyxcbiAgICBldmVudEluaXREaWN0PzpcbiAgICAgIHwgQ3VzdG9tRXZlbnRJbml0PHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IGlkOiBzdHJpbmcgfT5cbiAgICAgIHwgdW5kZWZpbmVkXG4gICkge1xuICAgIHN1cGVyKEFjdGlvbkVudW0uQ0xJQ0ssIGV2ZW50SW5pdERpY3QpO1xuICAgIHRoaXMuZGV0YWlsLnggPSB4O1xuICAgIHRoaXMuZGV0YWlsLnkgPSB5O1xuICAgIHRoaXMuZGV0YWlsLmlkID0gaWQ7XG4gIH1cbn1cblxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtYXgtY2xhc3Nlcy1wZXItZmlsZVxuZXhwb3J0IGNsYXNzIEJ1dHRvbkV2ZW50IGV4dGVuZHMgQmFzZVRyYWNrZXJFdmVudDx7IGtleTogc3RyaW5nOyBpZDogc3RyaW5nIH0+IHtcbiAgY29uc3RydWN0b3IoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgaWQ6IHN0cmluZyxcbiAgICBldmVudEluaXREaWN0PzogQ3VzdG9tRXZlbnRJbml0PHsga2V5OiBzdHJpbmc7IGlkOiBzdHJpbmcgfT4gfCB1bmRlZmluZWRcbiAgKSB7XG4gICAgc3VwZXIoQWN0aW9uRW51bS5DTElDSywgZXZlbnRJbml0RGljdCk7XG4gICAgdGhpcy5kZXRhaWwua2V5ID0ga2V5O1xuICAgIHRoaXMuZGV0YWlsLmlkID0gaWQ7XG4gIH1cbn1cblxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtYXgtY2xhc3Nlcy1wZXItZmlsZVxuZXhwb3J0IGNsYXNzIEhpc3RvcnlFdmVudCBleHRlbmRzIEJhc2VUcmFja2VyRXZlbnQ8e1xuICB1cmw6IHN0cmluZztcbiAgZXh0cmE/OiBhbnk7XG59PiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGV4dHJhPzogYW55LFxuICAgIGV2ZW50SW5pdERpY3Q/OiBDdXN0b21FdmVudEluaXQ8eyB1cmw6IHN0cmluZyB9PiB8IHVuZGVmaW5lZFxuICApIHtcbiAgICBzdXBlcihBY3Rpb25FbnVtLkhJU1RPUlksIGV2ZW50SW5pdERpY3QpO1xuICAgIHRoaXMuZGV0YWlsLnVybCA9IHVybDtcbiAgICB0aGlzLmRldGFpbC5leHRyYSA9IGV4dHJhO1xuICB9XG59XG4iLCJpbXBvcnQgeyBEZWJ1Z0xldmVsRW51bSwgbG9nIH0gZnJvbSBcIi4uL3V0aWxzL2NvbnNvbGVfd3JhcHBlclwiO1xuaW1wb3J0IHsgaXNUcmFja2VyRXZlbnQsIFRyYWNrZXJFdmVudCB9IGZyb20gXCIuL2V2ZW50XCI7XG5sb2coXCJyZWNlaXZlciBsb2FkZWQuXCIsIERlYnVnTGV2ZWxFbnVtLkJBU0lDKTtcbmV4cG9ydCBjbGFzcyBFdmVudFJlY2VpdmVyIHtcbiAgcHJpdmF0ZSBtYXAgPSBuZXcgTWFwPHN0cmluZywgKGV2ZW50OiBUcmFja2VyRXZlbnQpID0+IHZvaWQ+KCk7XG4gIHByaXZhdGUgZW1pdHRlciA9IG5ldyBFdmVudFRhcmdldCgpO1xuXG4gIHB1YmxpYyByZWdpc3RlcihldmVudFR5cGU6IHN0cmluZywgY2FsbGJhY2s/OiAoZXZlbnQ6IFRyYWNrZXJFdmVudCkgPT4gdm9pZCkge1xuICAgIHRoaXMuZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgY29uc3QgdHJhY2tFdiA9ICgoZXZlbnQgYXMgdW5rbm93bikgYXMgQ3VzdG9tRXZlbnQpXG4gICAgICAgIC5kZXRhaWwgYXMgVHJhY2tlckV2ZW50O1xuICAgICAgaWYgKGlzVHJhY2tlckV2ZW50KHRyYWNrRXYpICYmIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKHRyYWNrRXYpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy5tYXAuc2V0KGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkb0V2ZW50KGV2ZW50OiBUcmFja2VyRXZlbnQpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMubWFwLmdldChcIlwiICsgZXZlbnQuYWN0aW9uKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IFJvdXRlciB9IGZyb20gXCIuLi9yb3V0ZXIvcm91dGVyXCI7XG5pbXBvcnQgeyBEZWJ1Z0xldmVsRW51bSwgbG9nIH0gZnJvbSBcIi4uL3V0aWxzL2NvbnNvbGVfd3JhcHBlclwiO1xuaW1wb3J0IHsgSGlzdG9yeSB9IGZyb20gXCIuLy4uL3JvdXRlci9oaXN0b3J5XCI7XG5pbXBvcnQgeyBEIH0gZnJvbSBcIi4vZG9jdW1lbnRcIjtcbmltcG9ydCB7IEVsZW1lbnRzIH0gZnJvbSBcIi4vZWxlbWVudHNcIjtcbmxvZyhcImJhbm5lciBsb2FkZWQuXCIsIERlYnVnTGV2ZWxFbnVtLkJBU0lDKTtcbmV4cG9ydCBjbGFzcyBUb3BCYW5uZXIge1xuICBwdWJsaWMgc3RhdGljIHNob3coKSB7XG4gICAgVG9wQmFubmVyLnNob3dpbmcgPSB0cnVlO1xuICAgIEQuZGlzcGxheShFbGVtZW50cy5kZFVwLCB0cnVlKTtcbiAgICBELmRpc3BsYXkoRWxlbWVudHMuZGREb3duLCBmYWxzZSk7XG4gICAgRC5kaXNwbGF5KEVsZW1lbnRzLmRkQ29udGVudCwgdHJ1ZSk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGhpZGUoKSB7XG4gICAgVG9wQmFubmVyLnNob3dpbmcgPSBmYWxzZTtcbiAgICBELmRpc3BsYXkoRWxlbWVudHMuZGREb3duLCB0cnVlKTtcbiAgICBELmRpc3BsYXkoRWxlbWVudHMuZGRVcCwgZmFsc2UpO1xuICAgIEQuZGlzcGxheShFbGVtZW50cy5kZENvbnRlbnQsIGZhbHNlKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZG9EaXNwbGF5Q2hhbmdlKCkge1xuICAgIFRvcEJhbm5lci5zaG93aW5nID8gVG9wQmFubmVyLmhpZGUoKSA6IFRvcEJhbm5lci5zaG93KCk7XG4gIH1cbiAgcHVibGljIHN0YXRpYyBzZXR1cCgpIHtcbiAgICBELmFkZEV2ZW50TGlzdGVuZXIoRWxlbWVudHMuZGRBcnJvdywgXCJjbGlja1wiLCBUb3BCYW5uZXIuZG9EaXNwbGF5Q2hhbmdlKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIHNob3dpbmcgPSB0cnVlO1xufVxuXG5ELmFkZEV2ZW50TGlzdGVuZXIoXCJtdHVyay10b3AtYmFubmVyLWJhY2tcIiwgXCJjbGlja1wiLCAoZSkgPT4ge1xuICBpZiAoSGlzdG9yeS5jYW5CYWNrd2FyZCgpKSB7XG4gICAgUm91dGVyLmxvYWRXaXRoUGF0aFByZWZpeChIaXN0b3J5LmJhY2t3YXJkKCkpO1xuICB9IGVsc2Uge1xuICAgIGFsZXJ0KFwiVGhlcmUgaXMgbm8gcGFnZSBoaXN0b3J5IHRvIGdvIGJhY2sgZm9yIGF0IHRoaXMgdGltZSFcIik7XG4gIH1cbn0pO1xuIiwiaW1wb3J0IHsgRGVidWdMZXZlbEVudW0sIGVycm9yLCBsb2cgfSBmcm9tIFwiLi8uLi91dGlscy9jb25zb2xlX3dyYXBwZXJcIjtcbmxvZyhcImRvY3VtZW50IGxvYWRlZC5cIiwgRGVidWdMZXZlbEVudW0uQkFTSUMpO1xuZXhwb3J0IGNsYXNzIEQge1xuICBwdWJsaWMgc3RhdGljIGRvYzogRG9jdW1lbnQgPSBkb2N1bWVudDtcblxuICBwdWJsaWMgc3RhdGljIGVsZW0oZWxlbTogRWxlbWVudCB8IHN0cmluZyk6IEVsZW1lbnQge1xuICAgIGlmICh0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIEQuaWQoZWxlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGVtIGFzIEVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBkaXNwbGF5KGVsZW06IEVsZW1lbnQgfCBzdHJpbmcsIHNob3c6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBlbGVtID0gRC5lbGVtKGVsZW0pO1xuICAgIGlmIChzaG93KSB7XG4gICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoXCJub25lXCIpO1xuICAgICAgZWxlbS5jbGFzc0xpc3QuYWRkKFwiZGlzcGxheVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKFwiZGlzcGxheVwiKTtcbiAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZChcIm5vbmVcIik7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpZChpZDogc3RyaW5nKTogSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBELmRvYy5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgaWYgKGVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRWxlbWVudCB3YXMgbm90IGZvdW5kLCBpZDogPCR7aWR9Pi5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICB9XG4gIHB1YmxpYyBzdGF0aWMgY2xheihjbGF6OiBzdHJpbmcpOiBIVE1MQ29sbGVjdGlvbk9mPEVsZW1lbnQ+IHtcbiAgICByZXR1cm4gRC5kb2MuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGF6KTtcbiAgfVxuICBwdWJsaWMgc3RhdGljIHRhZyh0YWc6IHN0cmluZyk6IEhUTUxDb2xsZWN0aW9uT2Y8RWxlbWVudD4ge1xuICAgIHJldHVybiBELmRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcpO1xuICB9XG4gIHB1YmxpYyBzdGF0aWMgaW1hZ2UoaWQ6IHN0cmluZywgdXJsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBlcnJvcigoKSA9PiBELmlkKGlkKS5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgdXJsKSk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGFkZEV2ZW50TGlzdGVuZXIoXG4gICAgZWxlbTogRWxlbWVudCB8IHN0cmluZyxcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgbGlzdGVuZXI6IChlOiBFdmVudCkgPT4gYW55XG4gICkge1xuICAgIGVsZW0gPSB0aGlzLmVsZW0oZWxlbSk7XG4gICAgY29uc3Qgd3JhcHBlckZ1bmMgPSAoZTogRXZlbnQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyKGUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIChlbGVtIGFzIEVsZW1lbnQpLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgd3JhcHBlckZ1bmMpO1xuICAgIHJldHVybiB3cmFwcGVyRnVuYztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZWFjaChlbGVtOiBFbGVtZW50IHwgc3RyaW5nLCBhcHBseTogKG5vZGU6IEVsZW1lbnQpID0+IGFueSkge1xuICAgIGVsZW0gPSB0aGlzLmVsZW0oZWxlbSk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBlbGVtLmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFwcGx5KGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGVhY2hSZWN1cihcbiAgICBlbGVtOiBFbGVtZW50IHwgc3RyaW5nLFxuICAgIGFwcGx5OiAobm9kZTogRWxlbWVudCkgPT4gYW55XG4gICkge1xuICAgIGVsZW0gPSB0aGlzLmVsZW0oZWxlbSk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBlbGVtLmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBhcHBseShjaGlsZCk7XG4gICAgICBELmVhY2hSZWN1cihjaGlsZCwgYXBwbHkpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlPEsgZXh0ZW5kcyBrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXA+KFxuICAgIHRhZ05hbWU6IEssXG4gICAgb3B0aW9ucz86IEVsZW1lbnRDcmVhdGlvbk9wdGlvbnNcbiAgKTogSFRNTEVsZW1lbnRUYWdOYW1lTWFwW0tdIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBvcHRpb25zKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGVidWdMZXZlbEVudW0sIGxvZyB9IGZyb20gJy4uL3V0aWxzL2NvbnNvbGVfd3JhcHBlcic7XG5pbXBvcnQgeyBEIH0gZnJvbSAnLi9kb2N1bWVudCc7XG5sb2coJ2VsZW1lbnQgbG9hZGVkLicsIERlYnVnTGV2ZWxFbnVtLkJBU0lDKTtcbi8qKlxuICogVGhlc2UgYXJlIGVsZW1lbnRzIHRoYXQgYXJlIGluIGV2ZXJ5IHNpbmdsZSBwcm9qZWN0LiBFdmVuIGlmIHRoZXkgYXJlIG5vdCB1c2VkIHRoZXkgc2hvdWxkXG4gKiBiZSBwbGFjZSBpbiB0aGUgcHJvamVjdCBhbmQgZGlzcGxheSBzaG91bGQgYmUgc2V0IHRvIG5vbmUuIFRoaXMgc2ltcGxpZmllcyBjb25maWd1cmF0aW9uXG4gKiBhbmQgc29tZSBjb21tb24gZnVuY3Rpb25zIGFuZCBhbGxvd3MgbGVzcyBudWxsIGNoZWNrcyB0byBiZSBwZXJmb3JtZWQgb3ZlcmFsbC4gSWYgdGhlXG4gKiBlbGVtZW50IGRvZXMgbm90IGV4aXN0IGF0IHJ1biB0aW1lIGFuIGVtcHR5IGRpdiB3aXRoIHRoYXQgaWQgaXMgY3JlYXRlZCBhbmQgaXRzIGRpc3BsYXlcbiAqIGlzIHNldCB0byBub25lIHRoZW4gYXBwZW5kZWQgdG8gdGhlIGJvZHkuXG4gKi9cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBnZXQgYW4gZWxlbWVudCwgaWYgdW5zdWNjZXNzZnVsLCBjcmVhdGVzIGRpdiB3aXRoIGlkIGFuZCBhcHBlbmRzIHRvIGJvZHkuXG4gKlxuICogQHBhcmFtIGlkIC0gdGhlIGlkIG9mIHRoZSBlbGVtZW50IHRvIHJldHJpZXZlLlxuICovXG5mdW5jdGlvbiBtYWtlRWxlbUlmTm90RXhpc3QoaWQ6IHN0cmluZyk6IEhUTUxFbGVtZW50IHtcbiAgICBsZXQgZWxlbTtcbiAgICB0cnkge1xuICAgICAgICBlbGVtID0gRC5pZChpZCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVsZW0gPSBELmNyZWF0ZSgnZGl2Jyk7XG4gICAgICAgIGVsZW0uaWQgPSBpZDtcbiAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChlbGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW07XG59XG5cbi8qKlxuICogQ29tbW9ubHkgYWNjZXNzZWQgZWxlbWVudHMsIGFsbG93cyBmb3IgY2xlYXJlciBkb20gbWFuaXAgb24gdGhlc2UgZWxlbWVudHMuXG4gKi9cbmV4cG9ydCBjb25zdCBFbGVtZW50cyA9IHtcbiAgICBkb2N1bWVudDogRC5kb2MuZG9jdW1lbnRFbGVtZW50LFxuICAgIHdyYXBwZXI6IG1ha2VFbGVtSWZOb3RFeGlzdCgnd3JhcHBlcicpLFxuICAgIGh0bWxMb2M6IG1ha2VFbGVtSWZOb3RFeGlzdCgnaHRtbC1sb2MnKSxcbiAgICBpbm5lckJvZHk6IG1ha2VFbGVtSWZOb3RFeGlzdCgnaW5uZXItYm9keScpLFxuICAgIGRkRG93bjogbWFrZUVsZW1JZk5vdEV4aXN0KCdtdHVyay10b3AtYmFubmVyLWRyb3AtZG93bi1idXR0b24nKSxcbiAgICBkZFVwOiBtYWtlRWxlbUlmTm90RXhpc3QoJ210dXJrLXRvcC1iYW5uZXItY29sbGFwc2UtYnV0dG9uJyksXG4gICAgZGRDb250ZW50OiBtYWtlRWxlbUlmTm90RXhpc3QoJ210dXJrLXRvcC1iYW5uZXItZHJvcC1kb3duLWNvbnRlbnQnKSxcbiAgICBiYWNrQnV0dG9uOiBtYWtlRWxlbUlmTm90RXhpc3QoJ210dXJrLXRvcC1iYW5uZXItYmFjaycpLFxuICAgIGRkQXJyb3c6IG1ha2VFbGVtSWZOb3RFeGlzdCgnbXR1cmstdG9wLWJhbm5lci1hcnJvdycpLFxuICAgIG10VG9wQmFubmVyVGV4dDogbWFrZUVsZW1JZk5vdEV4aXN0KCdtdHVyay10b3AtYmFubmVyLXRleHQnKSxcbiAgICBtdFNjZW5hcmlvQ29udGV4dDogbWFrZUVsZW1JZk5vdEV4aXN0KCdzY2VuYXJpb19jb250ZXh0JyksXG4gICAgbXRTY2VuYXJpb1F1ZXN0aW9uOiBtYWtlRWxlbUlmTm90RXhpc3QoJ3NjZW5hcmlvX3F1ZXN0aW9uJyksXG4gICAgbG9nRmlsZUlucHV0OiBtYWtlRWxlbUlmTm90RXhpc3QoXG4gICAgICAgICdtdHVyay10b3AtYmFubmVyLWRyb3AtZG93bi1jb250ZW50LWxvZy1maWxlLWlucHV0J1xuICAgICksXG4gICAgc3VibWl0Rm9ybTogbWFrZUVsZW1JZk5vdEV4aXN0KCdtdHVyay1zdWJtaXQtZm9ybScpLFxuICAgIG1vZGFsOiBtYWtlRWxlbUlmTm90RXhpc3QoJ21vZGFsJyksXG59O1xuIiwiaW1wb3J0IHsgRGVidWdMZXZlbEVudW0sIGxvZyB9IGZyb20gJy4uL3V0aWxzL2NvbnNvbGVfd3JhcHBlcic7XG5pbXBvcnQgeyBFbGVtZW50cyB9IGZyb20gJy4vLi4vZG9tL2VsZW1lbnRzJztcbmxvZygnaHRtbCBsb2MgbG9hZGVkLicsIERlYnVnTGV2ZWxFbnVtLkJBU0lDKTtcbmV4cG9ydCBlbnVtIEFwcEVudW0ge1xuICAgIElORk9STUFUSU9OX0ZPUkFHSU5HID0gJ2luZm9ybWF0aW9uLWZvcmFnaW5nJyxcbiAgICBDT0dOSVRJVkVfTE9BRCA9ICdjb2duaXRpdmUtbG9hZCcsXG4gICAgR0VOREVSX01BRyA9ICdnZW5kZXItbWFnJyxcbiAgICBFUlJPUiA9ICdlcnJvcicsXG59XG5cbmV4cG9ydCBlbnVtIE1vZGVFbnVtIHtcbiAgICBSRUFMID0gJ3JlYWwnLFxuICAgIFNBTkRCT1ggPSAnc2FuZGJveCcsXG4gICAgVEVTVCA9ICd0ZXN0JyxcbiAgICBFUlJPUiA9ICdlcnJvcicsXG59XG5cbmV4cG9ydCBjbGFzcyBIVE1MTG9jIHtcbiAgICBwdWJsaWMgc3RhdGljIGVsZW0gPSBFbGVtZW50cy5odG1sTG9jO1xuICAgIHB1YmxpYyBzdGF0aWMgYXBwOiBBcHBFbnVtO1xuICAgIHB1YmxpYyBzdGF0aWMgbW9kZTogTW9kZUVudW07XG4gICAgcHVibGljIHN0YXRpYyBzY2VuYXJpbzogc3RyaW5nO1xuXG4gICAgcHVibGljIHN0YXRpYyBzZXR1cCgpIHtcbiAgICAgICAgSFRNTExvYy5hcHAgPSAoSFRNTExvYy5lbGVtLmRhdGFzZXQuYXBwIGFzIEFwcEVudW0pIHx8IEFwcEVudW0uRVJST1I7XG4gICAgICAgIEhUTUxMb2MubW9kZSA9XG4gICAgICAgICAgICAoSFRNTExvYy5lbGVtLmRhdGFzZXQubW9kZSBhcyBNb2RlRW51bSkgfHwgTW9kZUVudW0uRVJST1I7XG4gICAgICAgIEhUTUxMb2Muc2NlbmFyaW8gPSBIVE1MTG9jLmVsZW0uZGF0YXNldC5zY2VuYXJpbyB8fCAnZXJyb3InO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IERlYnVnTGV2ZWxFbnVtLCBsb2cgfSBmcm9tICcuLy4uL3V0aWxzL2NvbnNvbGVfd3JhcHBlcic7XG5pbXBvcnQgeyBEIH0gZnJvbSAnLi9kb2N1bWVudCc7XG5pbXBvcnQgeyBFbGVtZW50cyB9IGZyb20gJy4vZWxlbWVudHMnO1xubG9nKCdtb2RhbCBsb2FkZWQuJywgRGVidWdMZXZlbEVudW0uQkFTSUMpO1xuZXhwb3J0IGNsYXNzIE1vZGFsIHtcbiAgICBwdWJsaWMgc3RhdGljIGVsZW0gPSBFbGVtZW50cy5tb2RhbDtcblxuICAgIHB1YmxpYyBzdGF0aWMgZGlzcGxheShzcmM6IHN0cmluZykge1xuICAgICAgICBNb2RhbC5lbGVtLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICdzdHlsZScsXG4gICAgICAgICAgICBgbGVmdDogJHtNYXRoLnJvdW5kKHdpbmRvdy5wYWdlWE9mZnNldCl9cHg7IHRvcDogJHtNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgIHdpbmRvdy5wYWdlWU9mZnNldFxuICAgICAgICAgICAgKX1weDtgXG4gICAgICAgICk7XG4gICAgICAgIE1vZGFsLmVsZW0uY2xhc3NMaXN0LnJlcGxhY2UoJ2hpZGUtbW9kYWwnLCAnc2hvdy1tb2RhbCcpO1xuICAgICAgICBELmVhY2goTW9kYWwuZWxlbSwgKG5vZGUpID0+IHtcbiAgICAgICAgICAgIChub2RlIGFzIEhUTUxJRnJhbWVFbGVtZW50KS5zcmMgPSBzcmM7XG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ25vc2Nyb2xsJyk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBoaWRlKCkge1xuICAgICAgICBNb2RhbC5lbGVtLmNsYXNzTGlzdC5yZXBsYWNlKCdzaG93LW1vZGFsJywgJ2hpZGUtbW9kYWwnKTtcbiAgICAgICAgRC5lYWNoKE1vZGFsLmVsZW0sIChub2RlKSA9PiB7XG4gICAgICAgICAgICAobm9kZSBhcyBIVE1MSUZyYW1lRWxlbWVudCkuc3JjID0gJyc7XG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ25vc2Nyb2xsJyk7XG4gICAgfVxufVxuXG5ELmFkZEV2ZW50TGlzdGVuZXIoTW9kYWwuZWxlbSwgJ2NsaWNrJywgKGUpID0+IHtcbiAgICBNb2RhbC5oaWRlKCk7XG59KTtcbkQuZWFjaChNb2RhbC5lbGVtLCAobm9kZSkgPT4ge1xuICAgIEQuYWRkRXZlbnRMaXN0ZW5lcihub2RlLCAnY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG59KTtcbiIsImltcG9ydCB7IERlYnVnTGV2ZWxFbnVtLCBlcnJvciwgbG9nIH0gZnJvbSBcIi4uL3V0aWxzL2NvbnNvbGVfd3JhcHBlclwiO1xuaW1wb3J0IHsgbm9vcCwgbm93IH0gZnJvbSBcIi4vLi4vdXRpbHMvZnVuY3NcIjtcbmxvZyhcInNjcm9sbCBsb2FkZWQuXCIsIERlYnVnTGV2ZWxFbnVtLkJBU0lDKTtcbi8qKlxuICogTGluZWFyIGltcGxlbWVudGF0aW9uIG9mIHNjcm9sbGluZy5cbiAqIEZvbGxvd3MgdGhlIHNpbmdsZXRvbiBwYXR0ZXJuLCBjYWxsIGRvIHRvIHN0YXJ0IGEgc2Nyb2xsIG9wZXJhdGlvbi5cbiAqXG4gKiBJZiBhIHNjcm9sbCBpcyBjYWxsZWQgd2hlbiBhbm90aGVyIHNjcm9sbCBoYXMgYWxyZWFkeSBiZWd1biBhblxuICogZXJyb3Igd2lsbCBiZSB0aHJvd24sIGJ1dCB0aGUgZmlyc3Qgc2Nyb2xsIHdpbGwgY29udGludWUgdW50aWwgY29tcGxldGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFNjcm9sbCB7XG4gIHB1YmxpYyBzdGF0aWMgU1RFUF9JTl9NUyA9IDE3O1xuXG4gIHB1YmxpYyBzdGF0aWMgY2FsbGJhY2soXG4gICAgZW5kUG9zOiBudW1iZXIsXG4gICAgZHVyYXRpb246IG51bWJlciA9IDIwMCxcbiAgICBjb21wbGV0ZTogKC4uLmFyZ3M6IGFueSkgPT4gYW55ID0gbm9vcFxuICApOiB2b2lkIHtcbiAgICBpZiAoU2Nyb2xsLnJ1bm5pbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtYWtlIG11bHRpcGxlIGNhbGxzIHRvIHNjcm9sbCBhdCB0aGUgc2FtZSB0aW1lLlwiKTtcbiAgICB9XG4gICAgU2Nyb2xsLnJ1bm5pbmcgPSB0cnVlO1xuICAgIGNvbnN0IG9sZENvbXBsZXRlID0gY29tcGxldGU7XG4gICAgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICBTY3JvbGwucnVubmluZyA9IGZhbHNlO1xuICAgICAgZXJyb3Iob2xkQ29tcGxldGUpO1xuICAgIH07XG4gICAgdGhpcy5pbnN0YW5jZS51cGRhdGUoZW5kUG9zLCBkdXJhdGlvbiwgY29tcGxldGUpLmF0dGVtcHRTY3JvbGwoKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgcHJvbWlzZShlbmRQb3M6IG51bWJlciwgZHVyYXRpb246IG51bWJlciA9IDIwMCkge1xuICAgIGlmIChTY3JvbGwucnVubmluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1ha2UgbXVsdGlwbGUgY2FsbHMgdG8gc2Nyb2xsIGF0IHRoZSBzYW1lIHRpbWUuXCIpO1xuICAgIH1cbiAgICBTY3JvbGwucnVubmluZyA9IHRydWU7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlOiAoKSA9PiB2b2lkLCByZWplY3Q6IChhcmcwOiBhbnkpID0+IHZvaWQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJ1blJlc29sdmVyID0gKCkgPT4ge1xuICAgICAgICAgIFNjcm9sbC5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluc3RhbmNlLnVwZGF0ZShlbmRQb3MsIGR1cmF0aW9uLCBydW5SZXNvbHZlcikuYXR0ZW1wdFNjcm9sbCgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIFNjcm9sbC5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgcnVubmluZyA9IGZhbHNlO1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZSA9IG5ldyBTY3JvbGwoMCwgMCwgbm9vcCk7XG4gIHByaXZhdGUgY29tcGxldGU6ICguLi5hcmdzOiBhbnkpID0+IGFueTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZW5kUG9zOiBudW1iZXIsXG4gICAgcHJpdmF0ZSBkdXJhdGlvbjogbnVtYmVyLFxuICAgIGNvbXBsZXRlOiAoLi4uYXJnczogYW55KSA9PiBhbnlcbiAgKSB7XG4gICAgdGhpcy5jb21wbGV0ZSA9ICguLi5hcmdzOiBhbnkpID0+IHtcbiAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwic2Nyb2xsXCIpKTtcbiAgICAgIGNvbXBsZXRlKGFyZ3MpO1xuICAgIH07XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGdldCBpc1J1bm5pbmcoKSB7XG4gICAgcmV0dXJuIFNjcm9sbC5ydW5uaW5nO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGUoXG4gICAgZW5kUG9zOiBudW1iZXIsXG4gICAgZHVyYXRpb246IG51bWJlcixcbiAgICBjb21wbGV0ZTogKC4uLmFyZ3M6IGFueSkgPT4gYW55XG4gICk6IFNjcm9sbCB7XG4gICAgdGhpcy5lbmRQb3MgPSBlbmRQb3M7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuY29tcGxldGUgPSBjb21wbGV0ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHByaXZhdGUgY2FsY1Njcm9sbEFtb3VudCgpIHtcbiAgICBjb25zdCBjdXJUaW1lID0gbm93KCk7XG4gICAgY29uc3Qgc3RlcHMgPSBNYXRoLm1heCgxLCAodGhpcy5kdXJhdGlvbiAtIGN1clRpbWUpIC8gU2Nyb2xsLlNURVBfSU5fTVMpO1xuICAgIGNvbnN0IGN1clBvcyA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKCh0aGlzLmVuZFBvcyAtIGN1clBvcykgLyBzdGVwcyk7XG4gIH1cblxuICBwcml2YXRlIHNjcm9sbCgpIHtcbiAgICB3aW5kb3cuc2Nyb2xsKDAsIHRoaXMuY2FsY1Njcm9sbEFtb3VudCgpKTtcbiAgICBpZiAod2luZG93LnBhZ2VZT2Zmc2V0ID09PSB0aGlzLmVuZFBvcykge1xuICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5zY3JvbGwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXR0ZW1wdFNjcm9sbCgpIHtcbiAgICBpZiAoXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIiBpbiB3aW5kb3cgPT09IGZhbHNlKSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsKDAsIHRoaXMuZW5kUG9zKTtcbiAgICB9XG4gICAgdGhpcy5zY3JvbGwoKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3V0aWxzL2Z1bmNzJztcbmltcG9ydCB7IE10dXJrQ2xpZW50IH0gZnJvbSAnLi8uLi9hd3MvbXR1cmsnO1xuaW1wb3J0IHsgZGF0YSB9IGZyb20gJy4vLi4vZGF0YS1sb2cvZGF0YSc7XG5pbXBvcnQgeyBEZWJ1Z0xldmVsRW51bSwgbG9nIH0gZnJvbSAnLi8uLi91dGlscy9jb25zb2xlX3dyYXBwZXInO1xuaW1wb3J0IHsgRCB9IGZyb20gJy4vZG9jdW1lbnQnO1xuaW1wb3J0IHsgRWxlbWVudHMgfSBmcm9tICcuL2VsZW1lbnRzJztcbmxvZygnc3VibWl0IGZvcm0gbG9hZGVkLicsIERlYnVnTGV2ZWxFbnVtLkJBU0lDKTtcbmV4cG9ydCBpbnRlcmZhY2UgQWxsb3dTdWJtaXNzaW9uIHtcbiAgICBhbGxvdygpOiBzdHJpbmcgfCBudWxsO1xuICAgIHByZVN1Ym1pdCguLi5hcmdzOiBhbnkpOiBhbnk7XG59XG5cbmNvbnN0IEFsbG93U3VibWlzc2lvbkRlZmF1bHQ6IEFsbG93U3VibWlzc2lvbiA9IHtcbiAgICBhbGxvdzogKCkgPT4gbnVsbCxcbiAgICBwcmVTdWJtaXQ6IG5vb3AsXG59O1xuXG5leHBvcnQgY2xhc3MgU3VibWl0Rm9ybSB7XG4gICAgcHVibGljIHN0YXRpYyBlbGVtID0gRWxlbWVudHMuc3VibWl0Rm9ybSBhcyBIVE1MRm9ybUVsZW1lbnQ7XG4gICAgcHVibGljIHN0YXRpYyBhbGxvd1N1Ym1pdERlZmF1bHQgPSB7IGFsbG93OiAoKSA9PiB0cnVlLCBwcmVTdWJtaXQ6IG5vb3AgfTtcblxuICAgIHB1YmxpYyBzdGF0aWMgc2V0dXAoXG4gICAgICAgIGFsbG93U3VibWlzc2lvbjogQWxsb3dTdWJtaXNzaW9uID0gQWxsb3dTdWJtaXNzaW9uRGVmYXVsdFxuICAgICkge1xuICAgICAgICBpZiAoZGF0YS51cmxEYXRhLmFzc2lnbm1lbnRJRCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgKEQuaWQoJ2Fzc2lnbm1lbnQtaWQnKSBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZSA9XG4gICAgICAgICAgICAgICAgZGF0YS51cmxEYXRhLmFzc2lnbm1lbnRJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS51cmxEYXRhLmhpdElEICE9PSBudWxsKSB7XG4gICAgICAgICAgICAoRC5pZCgnaGl0LWlkJykgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPSBkYXRhLnVybERhdGEuaGl0SUQ7XG4gICAgICAgIH1cbiAgICAgICAgU3VibWl0Rm9ybS5zdWJtaXRGdW5jID0gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY29uc3QgYWxsb3dlZCA9IGFsbG93U3VibWlzc2lvbi5hbGxvdygpO1xuICAgICAgICAgICAgaWYgKGFsbG93ZWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhbGxvd1N1Ym1pc3Npb24ucHJlU3VibWl0KCk7XG4gICAgICAgICAgICAgICAgbGV0IGhpdElEID0gZGF0YS51cmxEYXRhLmhpdElEO1xuICAgICAgICAgICAgICAgIGlmIChoaXRJRCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBoaXRJRCA9ICdoaXRpZCcgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYXNzaWdubW5ldElEID0gZGF0YS51cmxEYXRhLmFzc2lnbm1lbnRJRDtcbiAgICAgICAgICAgICAgICBpZiAoYXNzaWdubW5ldElEID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbm1uZXRJRCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAnYXNzaWdubW5ldGlkJyArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMDAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IE10dXJrQ2xpZW50LnN1Ym1pdChcbiAgICAgICAgICAgICAgICAgICAgTXR1cmtDbGllbnQua2V5R2VuKGhpdElELCBhc3NpZ25tbmV0SUQpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnaGVsbG8nKTtcbiAgICAgICAgICAgICAgICBTdWJtaXRGb3JtLmVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAgICAgJ3N1Ym1pdCcsXG4gICAgICAgICAgICAgICAgICAgIFN1Ym1pdEZvcm0uc3VibWl0RnVuY1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgU3VibWl0Rm9ybS5lbGVtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbGVydChhbGxvd2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgU3VibWl0Rm9ybS5lbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIFN1Ym1pdEZvcm0uc3VibWl0RnVuYyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgc3VibWl0RnVuYzogKGV2ZW50OiBFdmVudCkgPT4gYW55O1xufVxuIiwiaW1wb3J0IHsgVG9wQmFubmVyIH0gZnJvbSBcIi4vYmFubmVyXCI7XG5pbXBvcnQgeyBIVE1MTG9jIH0gZnJvbSBcIi4vaHRtbF9sb2NcIjtcblxuZXhwb3J0IGNsYXNzIFRyYWNrZXJFbGVtZW50cyB7XG4gIHB1YmxpYyBzdGF0aWMgc2V0dXBUcmFja2VyRWxlbWVudHMoKSB7XG4gICAgLy8gc2V0dXAgZG9tIGVsZW1lbnRzXG4gICAgVG9wQmFubmVyLnNldHVwKCk7XG4gICAgSFRNTExvYy5zZXR1cCgpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBUcmFja2VyIH0gZnJvbSAnLi8uLi90cmFja2VyL3RyYWNrZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvcnlFbnRyeSB7XG4gICAgaGFzUHJldlVSTDogYm9vbGVhbjtcbiAgICBwcmV2RW50cnk/OiBIaXN0b3J5RW50cnk7XG4gICAgY3VyclVSTDogc3RyaW5nO1xuICAgIGV4dHJhPzogYW55O1xuICAgIG5leHRFbnRyaWVzOiBIaXN0b3J5RW50cnlbXTtcbn1cblxuZnVuY3Rpb24gbmV3SGlzdG9yeUVudHJ5KFxuICAgIGN1cnJVUkw6IHN0cmluZyxcbiAgICBoYXNQcmV2VVJMOiBib29sZWFuLFxuICAgIHByZXZFbnRyeT86IEhpc3RvcnlFbnRyeSxcbiAgICBleHRyYT86IGFueVxuKTogSGlzdG9yeUVudHJ5IHtcbiAgICBUcmFja2VyLmdldEV2ZW50RGlzcGF0Y2hGdW5jKCdoaXN0b3J5JykoeyB1cmw6IGN1cnJVUkwsIGV4dHJhIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGN1cnJVUkwsXG4gICAgICAgIGhhc1ByZXZVUkwsXG4gICAgICAgIHByZXZFbnRyeSxcbiAgICAgICAgZXh0cmEsXG4gICAgICAgIG5leHRFbnRyaWVzOiBbXSxcbiAgICB9O1xufVxuXG5leHBvcnQgY2xhc3MgSGlzdG9yeSB7XG4gICAgcHVibGljIHN0YXRpYyBmb3J3YXJkKHVybDogc3RyaW5nLCBleHRyYT86IGFueSk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGhpc3RFbnQgPSBuZXdIaXN0b3J5RW50cnkodXJsLCB0cnVlLCBIaXN0b3J5LmN1cnJoaXN0b3J5LCBleHRyYSk7XG4gICAgICAgIEhpc3RvcnkuY3Vycmhpc3RvcnkubmV4dEVudHJpZXMucHVzaChoaXN0RW50KTtcbiAgICAgICAgSGlzdG9yeS5jdXJyaGlzdG9yeSA9IGhpc3RFbnQ7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBjYW5CYWNrd2FyZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIEhpc3RvcnkuY3Vycmhpc3RvcnkuaGFzUHJldlVSTCAmJlxuICAgICAgICAgICAgIUhpc3RvcnkuY3Vycmhpc3RvcnkucHJldkVudHJ5Py5leHRyYT8ud3JhcHBlclxuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgYmFja3dhcmQoKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKCFIaXN0b3J5LmNhbkJhY2t3YXJkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGdvIGJhY2sgYW55IGZ1cnRoZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coSGlzdG9yeS5jdXJyaGlzdG9yeS5wcmV2RW50cnkpO1xuICAgICAgICBjb25zdCBwcmV2RW50cnkgPSBIaXN0b3J5LmN1cnJoaXN0b3J5LnByZXZFbnRyeSBhcyBIaXN0b3J5RW50cnk7XG4gICAgICAgIGNvbnN0IG5leHRVUkwgPSBwcmV2RW50cnkuY3VyclVSTDtcbiAgICAgICAgY29uc3QgaGlzdEVudCA9IG5ld0hpc3RvcnlFbnRyeShcbiAgICAgICAgICAgIG5leHRVUkwsXG4gICAgICAgICAgICBwcmV2RW50cnkuaGFzUHJldlVSTCxcbiAgICAgICAgICAgIHByZXZFbnRyeS5wcmV2RW50cnksXG4gICAgICAgICAgICB7IGJhY2s6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgICBIaXN0b3J5LmN1cnJoaXN0b3J5ID0gaGlzdEVudDtcbiAgICAgICAgcmV0dXJuIG5leHRVUkw7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBzZXR1cCh1cmw6IHN0cmluZywgZXh0cmE/OiBhbnkpIHtcbiAgICAgICAgSGlzdG9yeS5maXJzdEhpc3RvcnkgPSBuZXdIaXN0b3J5RW50cnkodXJsLCBmYWxzZSwgdW5kZWZpbmVkLCBleHRyYSk7XG4gICAgICAgIEhpc3RvcnkuY3Vycmhpc3RvcnkgPSBIaXN0b3J5LmZpcnN0SGlzdG9yeTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBmaXJzdEhpc3Rvcnk6IEhpc3RvcnlFbnRyeTtcbiAgICBwcml2YXRlIHN0YXRpYyBjdXJyaGlzdG9yeTogSGlzdG9yeUVudHJ5O1xufVxuIiwiaW1wb3J0IHsgRCB9IGZyb20gJy4uL2RvbS9kb2N1bWVudCc7XG5pbXBvcnQgeyBFbGVtZW50cyB9IGZyb20gJy4uL2RvbS9lbGVtZW50cyc7XG5pbXBvcnQgeyBNb2RhbCB9IGZyb20gJy4uL2RvbS9tb2RhbCc7XG5pbXBvcnQgeyBEZWJ1Z0xldmVsRW51bSwgZXJyb3IsIGxvZyB9IGZyb20gJy4uL3V0aWxzL2NvbnNvbGVfd3JhcHBlcic7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vdXRpbHMvZnVuY3MnO1xuaW1wb3J0IHsgSFRNTExvYWRlciB9IGZyb20gJy4uL3V0aWxzL2h0bWxfbG9hZGVyJztcbmltcG9ydCB7IEhpc3RvcnkgfSBmcm9tICcuL2hpc3RvcnknO1xubG9nKCdyb3V0ZXIgbG9hZGVkLicsIERlYnVnTGV2ZWxFbnVtLkJBU0lDKTtcbmV4cG9ydCBjb25zdCBlbnVtIFJvdXRlck1vZGUge1xuICAgIE9GRixcbiAgICBPTixcbiAgICBTVEFOREFSRF9BTExPV0FOQ0VTLFxufVxuXG4vLyBUT0RPOiBOZWVkIHRvIGltcHJvdmUgdGhpcyB0byB0YWtlIGluIGEgZnVuY3Rpb24gZm9yIHRoZSBhbGxvd2FuY2Ugb3IgcmVkdWNlIGFic3RyYWN0bmVzcyBvdmVyYWxsLlxuXG5leHBvcnQgY29uc3QgZW51bSBSb3V0ZXJNb2R1bGUge1xuICAgIEEgPSAnQScsXG4gICAgSU1HID0gJ0lNRycsXG4gICAgRk9STSA9ICdGT1JNJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJDb25maWcge1xuICAgIG1vZHVsZTogUm91dGVyTW9kdWxlO1xuICAgIG1vZGU6IFJvdXRlck1vZGU7XG59XG5cbmludGVyZmFjZSBGdWxsUm91dGVyQ29uZmlnIGV4dGVuZHMgUm91dGVyQ29uZmlnIHtcbiAgICBzZXR1cChjb25maWc6IEZ1bGxSb3V0ZXJDb25maWcsIGVsZW06IEVsZW1lbnQpOiBhbnk7XG59XG5cbmZ1bmN0aW9uIHRlc3RPbihlbGVtOiBFbGVtZW50LCBjb25maWc6IFJvdXRlckNvbmZpZykge1xuICAgIHJldHVybiAoXG4gICAgICAgIGVsZW0udGFnTmFtZSA9PT0gY29uZmlnLm1vZHVsZSAmJlxuICAgICAgICAoY29uZmlnLm1vZGUgPT09IFJvdXRlck1vZGUuT04gfHxcbiAgICAgICAgICAgIGNvbmZpZy5tb2RlID09PSBSb3V0ZXJNb2RlLlNUQU5EQVJEX0FMTE9XQU5DRVMpXG4gICAgKTtcbn1cbmZ1bmN0aW9uIHRlc3RBbGxvd2FuY2UoY29uZmlnOiBSb3V0ZXJDb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnLm1vZGUgPT09IFJvdXRlck1vZGUuU1RBTkRBUkRfQUxMT1dBTkNFUztcbn1cblxuZXhwb3J0IGNsYXNzIFJvdXRlciB7XG4gICAgcHVibGljIHN0YXRpYyBIQVNIX1RBR1MgPSBuZXcgUmVnRXhwKCcjJyk7XG4gICAgcHVibGljIHN0YXRpYyBFTVBUWSA9IG5ldyBSZWdFeHAoJ14kJyk7XG4gICAgcHVibGljIHN0YXRpYyBBVF9TWU1CT0wgPSBuZXcgUmVnRXhwKCdAJyk7XG5cbiAgICBwdWJsaWMgc3RhdGljIEhBU0hfVEFHX1JFU1BPTkRFUiA9IG5vb3A7XG4gICAgcHVibGljIHN0YXRpYyBFTVBUWV9SRVNQT05ERVIgPSAoZXZlbnQ6IEV2ZW50KSA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHB1YmxpYyBzdGF0aWMgQVRfU1lNQk9MX1JFU1BPTkRFUiA9IChldmVudDogRXZlbnQpID0+XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBwdWJsaWMgc3RhdGljIHBhdGhQcmVmaXggPSAnJztcblxuICAgIHB1YmxpYyBzdGF0aWMgY29uZmlndXJlKGNvbmZpZ3M6IFJvdXRlckNvbmZpZ1tdLCBwYXRoUHJlZml4OiBzdHJpbmcpIHtcbiAgICAgICAgY29uZmlncy5mb3JFYWNoKChjb25maWcpID0+IHtcbiAgICAgICAgICAgIFJvdXRlci5jb25maWdzLnNldChjb25maWcubW9kdWxlLCBSb3V0ZXIudXBncmFkZUNvbmZpZyhjb25maWcpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFJvdXRlci5wYXRoUHJlZml4ID0gcGF0aFByZWZpeDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHNldHVwKGVsZW06IEVsZW1lbnQgfCBzdHJpbmcpIHtcbiAgICAgICAgRC5lYWNoUmVjdXIoZWxlbSwgKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29uZmlnIG9mIFJvdXRlci5jb25maWdzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RPbihub2RlLCBjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zZXR1cChjb25maWcsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBTVEFOREFSRF9MSU5LX0xJU1RFTkVSKGU6IE1vdXNlRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKCgpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxBbmNob3JFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgdXJsID0gdGFyZ2V0LmhyZWY7XG4gICAgICAgICAgICBIaXN0b3J5LmZvcndhcmQoUm91dGVyLmdldFBhdGhOYW1lKHVybCkpO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gSFRNTExvYWRlci5sb2FkVVJMKHVybCwgRWxlbWVudHMuaHRtbExvYyk7XG4gICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ25ld1BhZ2VMb2FkJykpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBPTl9DT01QTEVURV9TTEwocG9zdDogKGU6IE1vdXNlRXZlbnQpID0+IGFueSkge1xuICAgICAgICByZXR1cm4gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGVycm9yKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBSb3V0ZXIuU1RBTkRBUkRfTElOS19MSVNURU5FUihlKTtcbiAgICAgICAgICAgICAgICBwb3N0KGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBJTUFHRV9MSU5LX0xJU1RFTkVSKGU6IE1vdXNlRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFRPRE86IExvYWQgbW9kYWwgb3IgbG9hZCBub3RoaW5nIGF0IGFsbCwgZml4IHRoaXNcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxJbWFnZUVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSB0YXJnZXQuc3JjO1xuICAgICAgICAgICAgSGlzdG9yeS5mb3J3YXJkKFJvdXRlci5nZXRQYXRoTmFtZSh1cmwpKTtcbiAgICAgICAgICAgIHJldHVybiBIVE1MTG9hZGVyLmxvYWRVUkwodXJsLCBFbGVtZW50cy5odG1sTG9jKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBGT1JNX09GRl9MSVNURU5FUihlOiBFdmVudCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnQWxsIGZvcm1zIGV4Y2VwdCBmb3IgdGhlIG9uZSBpbiB0aGUgdG9wIGhlYWRlciBhcmUgaW5hY3RpdmUuJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZGVmYXVsdEFsbG93YW5jZXNPbigpIHtcbiAgICAgICAgUm91dGVyLnJlZ2lzdGVyQWxsb3dhbmNlKFxuICAgICAgICAgICAgeyByZWdleDogUm91dGVyLkVNUFRZLCBmdW5jOiBSb3V0ZXIuRU1QVFlfUkVTUE9OREVSIH0sXG4gICAgICAgICAgICB7IHJlZ2V4OiBSb3V0ZXIuSEFTSF9UQUdTLCBmdW5jOiBSb3V0ZXIuSEFTSF9UQUdfUkVTUE9OREVSIH0sXG4gICAgICAgICAgICB7IHJlZ2V4OiBSb3V0ZXIuQVRfU1lNQk9MLCBmdW5jOiBSb3V0ZXIuQVRfU1lNQk9MX1JFU1BPTkRFUiB9XG4gICAgICAgICk7XG4gICAgfVxuICAgIHB1YmxpYyBzdGF0aWMgZGVmYXVsdEFsbG93YW5jZXNPZmYoKSB7XG4gICAgICAgIFJvdXRlci51bnJlZ2lzdGVyQWxsb3dhbmNlKFxuICAgICAgICAgICAgUm91dGVyLkVNUFRZLFxuICAgICAgICAgICAgUm91dGVyLkhBU0hfVEFHUyxcbiAgICAgICAgICAgIFJvdXRlci5BVF9TWU1CT0xcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcHVibGljIHN0YXRpYyByZWdpc3RlckFsbG93YW5jZShcbiAgICAgICAgLi4ucmVnZXhzOiBBcnJheTx7IHJlZ2V4OiBSZWdFeHA7IGZ1bmM6IChldmVudDogRXZlbnQpID0+IGFueSB9PlxuICAgICkge1xuICAgICAgICByZWdleHMuZm9yRWFjaCgocmVnZXgpID0+XG4gICAgICAgICAgICBSb3V0ZXIubGlua0FsbG93YW5jZXMuc2V0KHJlZ2V4LnJlZ2V4LCByZWdleC5mdW5jKVxuICAgICAgICApO1xuICAgIH1cbiAgICBwdWJsaWMgc3RhdGljIHVucmVnaXN0ZXJBbGxvd2FuY2UoLi4ucmVnZXhzOiBSZWdFeHBbXSkge1xuICAgICAgICByZWdleHMuZm9yRWFjaCgocmVnZXgpID0+IFJvdXRlci5saW5rQWxsb3dhbmNlcy5kZWxldGUocmVnZXgpKTtcbiAgICB9XG4gICAgcHVibGljIHN0YXRpYyBjbGVhckFsbG93YW5jZXMoKSB7XG4gICAgICAgIFJvdXRlci5saW5rQWxsb3dhbmNlcy5jbGVhcigpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZCh1cmw6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBIaXN0b3J5LmZvcndhcmQoUm91dGVyLmdldFBhdGhOYW1lKHVybCkpO1xuICAgICAgICBjb25zdCByZXQgPSBhd2FpdCBIVE1MTG9hZGVyLmxvYWRVUkwodXJsLCBFbGVtZW50cy5odG1sTG9jKTtcbiAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCduZXdQYWdlTG9hZCcpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvYWRXaXRoUGF0aFByZWZpeChwYWdlOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgcmV0ID0gSFRNTExvYWRlci5sb2FkVVJMKFxuICAgICAgICAgICAgUm91dGVyLnBhdGhQcmVmaXggKyBwYWdlLFxuICAgICAgICAgICAgRWxlbWVudHMuaHRtbExvY1xuICAgICAgICApO1xuICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ25ld1BhZ2VMb2FkJykpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIFNldHVwRnVuY3Rpb25zID0ge1xuICAgICAgICBBOiAoY29uZmlnOiBGdWxsUm91dGVyQ29uZmlnLCBlbGVtOiBFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhTm9kZSA9IGVsZW0gYXMgSFRNTEFuY2hvckVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAodGVzdEFsbG93YW5jZShjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhc3Nlc1JlZ2V4VGVzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgaHJlZiA9IGFOb2RlLmhyZWY7XG4gICAgICAgICAgICAgICAgUm91dGVyLmxpbmtBbGxvd2FuY2VzLmZvckVhY2goKGZ1bmMsIHJlZ2V4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QgPSByZWdleC50ZXN0KGhyZWYpO1xuICAgICAgICAgICAgICAgICAgICBwYXNzZXNSZWdleFRlc3QgPSBwYXNzZXNSZWdleFRlc3QgJiYgIXRlc3Q7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBELmFkZEV2ZW50TGlzdGVuZXIoZWxlbSwgJ2NsaWNrJywgZnVuYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocGFzc2VzUmVnZXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChocmVmLnN1YnN0cihocmVmLmxlbmd0aCAtIDMpID09PSAncGRmJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgRC5hZGRFdmVudExpc3RlbmVyKGVsZW0sICdjbGljaycsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1vZGFsLmRpc3BsYXkoaHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEQuYWRkRXZlbnRMaXN0ZW5lcihlbGVtLCAnY2xpY2snLCAoZSkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuU1RBTkRBUkRfTElOS19MSVNURU5FUihlIGFzIE1vdXNlRXZlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBELmFkZEV2ZW50TGlzdGVuZXIoZWxlbSwgJ2NsaWNrJywgKGUpID0+XG4gICAgICAgICAgICAgICAgICAgIFJvdXRlci5TVEFOREFSRF9MSU5LX0xJU1RFTkVSKGUgYXMgTW91c2VFdmVudClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBJTUc6IChjb25maWc6IEZ1bGxSb3V0ZXJDb25maWcsIGVsZW06IEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGltZ05vZGUgPSBlbGVtIGFzIEhUTUxJbWFnZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAodGVzdEFsbG93YW5jZShjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhc3Nlc1JlZ2V4VGVzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgUm91dGVyLmxpbmtBbGxvd2FuY2VzLmZvckVhY2goKGZ1bmMsIHJlZ2V4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QgPSAhcmVnZXgudGVzdChpbWdOb2RlLnNyYyk7XG4gICAgICAgICAgICAgICAgICAgIHBhc3Nlc1JlZ2V4VGVzdCA9IHBhc3Nlc1JlZ2V4VGVzdCAmJiB0ZXN0O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgRC5hZGRFdmVudExpc3RlbmVyKGVsZW0sICdjbGljaycsIGZ1bmMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhc3Nlc1JlZ2V4VGVzdCkge1xuICAgICAgICAgICAgICAgICAgICBELmFkZEV2ZW50TGlzdGVuZXIoZWxlbSwgJ2NsaWNrJywgKGUpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuU1RBTkRBUkRfTElOS19MSVNURU5FUihlIGFzIE1vdXNlRXZlbnQpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBELmFkZEV2ZW50TGlzdGVuZXIoZWxlbSwgJ2NsaWNrJywgKGUpID0+XG4gICAgICAgICAgICAgICAgICAgIFJvdXRlci5TVEFOREFSRF9MSU5LX0xJU1RFTkVSKGUgYXMgTW91c2VFdmVudClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBGT1JNOiAoY29uZmlnOiBGdWxsUm91dGVyQ29uZmlnLCBlbGVtOiBFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmb3JtTm9kZSA9IGVsZW0gYXMgSFRNTEZvcm1FbGVtZW50O1xuICAgICAgICAgICAgaWYgKHRlc3RBbGxvd2FuY2UoY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXNzZXNSZWdleFRlc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIFJvdXRlci5saW5rQWxsb3dhbmNlcy5mb3JFYWNoKChmdW5jLCByZWdleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ID0gIXJlZ2V4LnRlc3QoZm9ybU5vZGUuc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgcGFzc2VzUmVnZXhUZXN0ID0gcGFzc2VzUmVnZXhUZXN0ICYmIHRlc3Q7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBELmFkZEV2ZW50TGlzdGVuZXIoZWxlbSwgJ2NsaWNrJywgZnVuYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocGFzc2VzUmVnZXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIEQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3VibWl0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvdXRlci5GT1JNX09GRl9MSVNURU5FUlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgRC5hZGRFdmVudExpc3RlbmVyKGVsZW0sICdzdWJtaXQnLCBSb3V0ZXIuRk9STV9PRkZfTElTVEVORVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjb25maWdzID0gbmV3IE1hcDxSb3V0ZXJNb2R1bGUsIEZ1bGxSb3V0ZXJDb25maWc+KCk7XG5cbiAgICBwcml2YXRlIHN0YXRpYyBsaW5rQWxsb3dhbmNlczogTWFwPFJlZ0V4cCwgKGV2ZW50OiBFdmVudCkgPT4gYW55PiA9IG5ldyBNYXA8XG4gICAgICAgIFJlZ0V4cCxcbiAgICAgICAgKGV2ZW50OiBFdmVudCkgPT4gYW55XG4gICAgPigpO1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcGF0aFJlZ2V4ID0gL1xcLyhbXFx3XSsuaHRtbCkvO1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgdXBncmFkZUNvbmZpZyhjb25maWc6IFJvdXRlckNvbmZpZyk6IEZ1bGxSb3V0ZXJDb25maWcge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9kdWxlOiBjb25maWcubW9kdWxlLFxuICAgICAgICAgICAgbW9kZTogY29uZmlnLm1vZGUsXG4gICAgICAgICAgICBzZXR1cDogUm91dGVyLlNldHVwRnVuY3Rpb25zW2NvbmZpZy5tb2R1bGVdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRQYXRoTmFtZSh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHJldCA9IFJvdXRlci5wYXRoUmVnZXguZXhlYyh1cmwpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSBudWxsID8gdXJsIDogcmV0Lmxlbmd0aCA+IDEgPyByZXRbMV0gOiB1cmw7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaXNUcmFja2VyRXZlbnQsIG9iamVjdFRvVHJhY2tlckV2ZW50IH0gZnJvbSAnLi4vZGF0YS1sb2cvZXZlbnQnO1xuaW1wb3J0IHsgRXZlbnRSZWNlaXZlciB9IGZyb20gJy4uL2RhdGEtbG9nL3JlY2VpdmVyJztcbmltcG9ydCB7IEVsZW1lbnRzIH0gZnJvbSAnLi4vZG9tL2VsZW1lbnRzJztcbmltcG9ydCB7IFRyYWNrZXJFbGVtZW50cyB9IGZyb20gJy4uL2RvbS90cmFja2VyX2VsZW1zJztcbmltcG9ydCB7IERlYnVnTGV2ZWxFbnVtLCBsb2csIHNldERlYnVnTGV2ZWwgfSBmcm9tICcuLi91dGlscy9jb25zb2xlX3dyYXBwZXInO1xuaW1wb3J0IHsgU2NlbmFyaW8gfSBmcm9tICcuLi91dGlscy9zY2VuYXJpb3MnO1xuaW1wb3J0IHsgTXR1cmtDbGllbnQgfSBmcm9tICcuLy4uL2F3cy9tdHVyayc7XG5pbXBvcnQgeyBkYXRhIH0gZnJvbSAnLi8uLi9kYXRhLWxvZy9kYXRhJztcbmltcG9ydCB7IEFsbG93U3VibWlzc2lvbiwgU3VibWl0Rm9ybSB9IGZyb20gJy4vLi4vZG9tL3N1Ym1pdF9mb3JtJztcblxubG9nKCd0cmFja2VyIGxvYWRlZC4nLCBEZWJ1Z0xldmVsRW51bS5CQVNJQyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhY2tlckNvbmZpZ3VyYXRpb24ge1xuICAgIGFsbG93U3VibWlzc2lvbjogQWxsb3dTdWJtaXNzaW9uO1xuICAgIGRlYnVnTGV2ZWw6IERlYnVnTGV2ZWxFbnVtO1xuICAgIGJ1Y2tldE5hbWU6IHN0cmluZztcbiAgICBrZXlQcmVmaXg6IHN0cmluZztcbiAgICBzZXR1cCgpOiB2b2lkO1xufVxuXG5leHBvcnQgY2xhc3MgVHJhY2tlciB7XG4gICAgcHVibGljIHN0YXRpYyBsYXN0UG9zID0geyB4OiAwLCB5OiAwLCB0aW1lOiAwIH07XG5cbiAgICBwdWJsaWMgc3RhdGljIGxvYWRTY2VuYXJpbyhzY2VuOiBTY2VuYXJpbykge1xuICAgICAgICBsZXQgc3ViID0gc2Nlbi5zY2VuYXJpbztcbiAgICAgICAgaWYgKHN1Yi5sZW5ndGggPiA1MCkge1xuICAgICAgICAgICAgc3ViID0gc3ViLnN1YnN0cmluZygwLCA1MCk7XG4gICAgICAgICAgICBjb25zdCBpbmRzID0gW1xuICAgICAgICAgICAgICAgIHN1Yi5sYXN0SW5kZXhPZignICcpLFxuICAgICAgICAgICAgICAgIHN1Yi5sYXN0SW5kZXhPZignLicpLFxuICAgICAgICAgICAgICAgIHN1Yi5sYXN0SW5kZXhPZignLCcpLFxuICAgICAgICAgICAgICAgIHN1Yi5sYXN0SW5kZXhPZignPycpLFxuICAgICAgICAgICAgICAgIHN1Yi5sYXN0SW5kZXhPZignIScpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IGluZCA9IE1hdGgubWF4KC4uLmluZHMpO1xuICAgICAgICAgICAgc3ViID0gc3ViLnN1YnN0cmluZygwLCBpbmQpICsgJy4uLic7XG4gICAgICAgIH1cblxuICAgICAgICBFbGVtZW50cy5tdFRvcEJhbm5lclRleHQuaW5uZXJUZXh0ID0gc3ViO1xuICAgICAgICBFbGVtZW50cy5tdFNjZW5hcmlvQ29udGV4dC5pbm5lclRleHQgPSBzY2VuLnNjZW5hcmlvO1xuICAgICAgICBFbGVtZW50cy5tdFNjZW5hcmlvUXVlc3Rpb24uaW5uZXJUZXh0ID0gc2Nlbi5xdWVzdGlvbjtcbiAgICAgICAgRWxlbWVudHMuaHRtbExvYy5kYXRhc2V0LnRhc2sgPSBzY2VuLnRhZztcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHN0YXJ0KGNvbmZpZzogVHJhY2tlckNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgc2V0RGVidWdMZXZlbChjb25maWcuZGVidWdMZXZlbCk7XG4gICAgICAgIC8vIGNvbmZpZ3VyZSB0cmFja2VyIHNwZWNpZmljIGVsZW1lbnRzXG4gICAgICAgIFRyYWNrZXJFbGVtZW50cy5zZXR1cFRyYWNrZXJFbGVtZW50cygpO1xuICAgICAgICBTdWJtaXRGb3JtLnNldHVwKGNvbmZpZy5hbGxvd1N1Ym1pc3Npb24pO1xuICAgICAgICBNdHVya0NsaWVudC5pbml0KGNvbmZpZy5idWNrZXROYW1lLCBjb25maWcua2V5UHJlZml4KTtcbiAgICAgICAgZGF0YS5kYXRhLnRhc2sgPSBFbGVtZW50cy5odG1sTG9jLmRhdGFzZXQudGFzaztcbiAgICAgICAgY29uZmlnLnNldHVwKCk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyByZWdpc3RlckV2ZW50KGV2ZW50VHlwZTogc3RyaW5nKSB7XG4gICAgICAgIGRhdGEubG9nc1tldmVudFR5cGVdID0gW107XG4gICAgICAgIHRoaXMucmVjZWl2ZXIucmVnaXN0ZXIoZXZlbnRUeXBlLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGRhdGEubG9nc1tldmVudFR5cGVdLnB1c2goZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXZlbnREaXNwYXRjaEZ1bmMoZXZlbnRUeXBlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldEV2ZW50RGlzcGF0Y2hGdW5jKGV2ZW50VHlwZTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAoZXZEYXRhOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZEYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmICghaXNUcmFja2VyRXZlbnQoZXZEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RUb1RyYWNrZXJFdmVudChldkRhdGEsIGV2ZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVjZWl2ZXIuZG9FdmVudChldkRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgYXR0YWNoRGF0YShrZXk6IHN0cmluZywgYXR0cmlidXRlOiBhbnkpIHtcbiAgICAgICAgZGF0YS5kYXRhW2tleV0gPSBhdHRyaWJ1dGU7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBjb21wdXRlQXR0cmlidXRlKG5hbWU6IHN0cmluZywgY29tcHV0ZTogKHZhbDogYW55KSA9PiBhbnkpIHtcbiAgICAgICAgZGF0YS5kYXRhW25hbWVdID0gY29tcHV0ZShkYXRhLmRhdGFbbmFtZV0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHJlY2VpdmVyID0gbmV3IEV2ZW50UmVjZWl2ZXIoKTtcbn1cbiIsImltcG9ydCB7IGRhdGEgfSBmcm9tIFwiLi8uLi9kYXRhLWxvZy9kYXRhXCI7XG5sb2coXCJjb25zb2xlIHdyYXBwZXIgbG9hZGVkLlwiLCBEZWJ1Z0xldmVsRW51bS5CQVNJQyk7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXJyb3I8VD4oXG4gIGZ1bmM6ICguLi5hcmdzOiBhbnkpID0+IFRcbik6IFByb21pc2U8VCB8IHVuZGVmaW5lZD4ge1xuICByZXR1cm4gZXJyb3JITyhmdW5jKSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JITzxUPihcbiAgZnVuYzogKC4uLmFyZ3M6IGFueSkgPT4gVFxuKTogKC4uLmFyZ3M6IGFueSkgPT4gUHJvbWlzZTxUIHwgdW5kZWZpbmVkPiB7XG4gIHJldHVybiBhc3luYyAoLi4uYXJnczogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jKGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkYXRhLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gRGVidWdMZXZlbEVudW0ge1xuICBOT05FID0gMSxcbiAgQkFTSUMgPSAyLFxuICBERVRBSUxFRCA9IDMsXG59XG5cbmxldCBkZWJ1Z0xldmVsOiBEZWJ1Z0xldmVsRW51bSA9IERlYnVnTGV2ZWxFbnVtLkJBU0lDO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0RGVidWdMZXZlbChsZXZlbDogRGVidWdMZXZlbEVudW0pIHtcbiAgZGVidWdMZXZlbCA9IGxldmVsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nKG1lc3NhZ2U6IHN0cmluZywgaW1wb3J0YW5jZTogRGVidWdMZXZlbEVudW0pIHtcbiAgaWYgKGRlYnVnTGV2ZWwgPj0gaW1wb3J0YW5jZSkge1xuICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBEZWJ1Z0xldmVsRW51bSwgbG9nIH0gZnJvbSBcIi4vY29uc29sZV93cmFwcGVyXCI7XG5sb2coXCJmdW5jcyBsb2FkZWQuXCIsIERlYnVnTGV2ZWxFbnVtLkJBU0lDKTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tZW1wdHlcbmV4cG9ydCBmdW5jdGlvbiBub29wKCkge31cbmV4cG9ydCBmdW5jdGlvbiBub3coKTogbnVtYmVyIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufVxuIiwiaW1wb3J0IHsgRCB9IGZyb20gJy4uL2RvbS9kb2N1bWVudCc7XG5pbXBvcnQgeyBEZWJ1Z0xldmVsRW51bSwgbG9nIH0gZnJvbSAnLi9jb25zb2xlX3dyYXBwZXInO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4vZnVuY3MnO1xubG9nKCdodG1sIGxvYWRlciBsb2FkZWQuJywgRGVidWdMZXZlbEVudW0uQkFTSUMpO1xuZXhwb3J0IGludGVyZmFjZSBDYWNoZSB7XG4gICAgW25hbWU6IHN0cmluZ106IEVsZW1lbnQ7XG59XG5leHBvcnQgY2xhc3MgSFRNTExvYWRlciB7XG4gICAgcHVibGljIHN0YXRpYyBDQUNIRTogQ2FjaGUgPSB7fTtcblxuICAgIHB1YmxpYyBzdGF0aWMgZmluaXNoKCkge1xuICAgICAgICBIVE1MTG9hZGVyLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgSFRNTExvYWRlci5mbGF0dGVuVFNMb2FkVGFncygpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgaXNGaW5pc2hlZCgpIHtcbiAgICAgICAgcmV0dXJuIEhUTUxMb2FkZXIuZmluaXNoZWQ7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBjYWNoZUhUTUwobmFtZTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKEhUTUxMb2FkZXIuZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnQ2Fubm90IGNhY2hlIG5ldyBIVE1MIGVudGl0aWVzIGFmdGVyIHRoZSBhcHBsaWNhdGlvbiBoYXMgYmVlbiBzdGFydGVkLidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHNsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHMtbG9hZCcpO1xuICAgICAgICB0c2wuZGF0YXNldC5uYW1lID0gbmFtZTtcbiAgICAgICAgdHNsLmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuQ0FDSEVbbmFtZV0gPSB0c2w7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyByZWdpc3RlclBvc3RMb2FkRnVuYyhmdW5jOiAoKSA9PiBhbnkpIHtcbiAgICAgICAgbG9nKCdyZWdzaXRlciBwb3N0IGxvYWQgZnVuY3Rpb24nLCBEZWJ1Z0xldmVsRW51bS5ERVRBSUxFRCk7XG4gICAgICAgIEhUTUxMb2FkZXIucG9zdExvYWRGdW5jID0gZnVuYztcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGxvYWQoaHRtbDogc3RyaW5nLCBlbGVtOiBFbGVtZW50IHwgc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxib29sZWFuPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxvZygnYmVnaW4gbG9hZCcsIERlYnVnTGV2ZWxFbnVtLkRFVEFJTEVEKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gRC5lbGVtKGVsZW0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJhZyA9IHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChodG1sKTtcbiAgICAgICAgICAgICAgICBIVE1MTG9hZGVyLnJlbW92ZVRhZ3NGcm9tRG9jdW1lbnRGcmFnbWVudChmcmFnLCAnc2NyaXB0Jyk7XG4gICAgICAgICAgICAgICAgSFRNTExvYWRlci5sb2FkQWxsQ2FjaGVkRWxlbWVudHMoZnJhZyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFwcGVuZENoaWxkKGZyYWcpO1xuICAgICAgICAgICAgICAgIGxvZygnZW5kIGxvYWQnLCBEZWJ1Z0xldmVsRW51bS5ERVRBSUxFRCk7XG4gICAgICAgICAgICAgICAgSFRNTExvYWRlci5wb3N0TG9hZEZ1bmMoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZFVSTCh1cmw6IHN0cmluZywgZWxlbTogRWxlbWVudCB8IHN0cmluZykge1xuICAgICAgICByZXR1cm4gSFRNTExvYWRlci5sb2FkKGF3YWl0IEhUTUxMb2FkZXIuZ2V0SFRNTCh1cmwpLCBlbGVtKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldEhUTUwodXJsOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxvZygnYmVnaW4gcmVxdWVzdCcsIERlYnVnTGV2ZWxFbnVtLkRFVEFJTEVEKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Quc2VuZChudWxsKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKCdyZXNvbHZlIHJlcXVlc3QnLCBEZWJ1Z0xldmVsRW51bS5ERVRBSUxFRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZmluaXNoZWQgPSBmYWxzZTtcblxuICAgIHByaXZhdGUgc3RhdGljIHBvc3RMb2FkRnVuYzogKCkgPT4gYW55ID0gbm9vcDtcblxuICAgIHByaXZhdGUgc3RhdGljIHJlbW92ZVRhZ3NGcm9tRG9jdW1lbnRGcmFnbWVudChcbiAgICAgICAgZnJhZzogRG9jdW1lbnRGcmFnbWVudCxcbiAgICAgICAgdGFnTmFtZTogc3RyaW5nXG4gICAgKSB7XG4gICAgICAgIGZyYWcucXVlcnlTZWxlY3RvckFsbCh0YWdOYW1lKS5mb3JFYWNoKCh0YWcpID0+IGZyYWcucmVtb3ZlQ2hpbGQodGFnKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZmxhdHRlblRTTG9hZFRhZ3MoKSB7XG4gICAgICAgIGxvZygnRmxhdHRlbmluZycsIERlYnVnTGV2ZWxFbnVtLkRFVEFJTEVEKTtcbiAgICAgICAgY29uc3QgcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgICBPYmplY3Qua2V5cyhIVE1MTG9hZGVyLkNBQ0hFKS5mb3JFYWNoKFxuICAgICAgICAgICAgKG5hbWUpID0+XG4gICAgICAgICAgICAgICAgKEhUTUxMb2FkZXIuQ0FDSEVbbmFtZV0gPSBIVE1MTG9hZGVyLmZsYXR0ZW5UU0xvYWRUYWcoXG4gICAgICAgICAgICAgICAgICAgIEhUTUxMb2FkZXIuZ2V0Q2FjaGVkQ29udGVudChuYW1lKSBhcyBFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBzLFxuICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgKSBhcyBFbGVtZW50KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIG11bHRpcGxlVGFicyhuOiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICBsZXQgcmV0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICByZXQgKz0gJ1xcdCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBmbGF0dGVuVFNMb2FkVGFnKFxuICAgICAgICBlbGVtOiBFbGVtZW50LFxuICAgICAgICBmbGF0dGVuZWQ6IFNldDxzdHJpbmc+LFxuICAgICAgICBjb3VudDogbnVtYmVyXG4gICAgKTogRWxlbWVudCB8IG51bGwge1xuICAgICAgICBjb25zdCB0YWJzID0gSFRNTExvYWRlci5tdWx0aXBsZVRhYnMoY291bnQpO1xuICAgICAgICBpZiAoY291bnQgPiAxMDApIHtcbiAgICAgICAgICAgIGFsZXJ0KCdDaGVjayB0aGUgY29uc29sZSwgYW4gZXJyb3IgaGFzIG9jY3VycmVkLicpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdJdCBzZWVtcyBsaWtlIHlvdSBtaWdodCBoYXZlIGluZmluaXRlbHkgcmVjdXJzaXZlbHkgbmVzdGVkIHRhZ3MuJyArXG4gICAgICAgICAgICAgICAgICAgICdcXG5IZXJlIGFyZSBhbGwgb2YgdGhlIHRhZ3MgdGhhdCBoYXZlIGJlZW4gZmxhdHRlbmVkIHNvIGZhcjogJyArXG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5lZCArXG4gICAgICAgICAgICAgICAgICAgICdcXG5IZXJlIGlzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQ6ICcgK1xuICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1uYW1lJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IGVsZW0uZ2V0QXR0cmlidXRlKCdkYXRhLW5hbWUnKTtcbiAgICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBIVE1MTG9hZGVyLmdldENhY2hlZENvbnRlbnQobmFtZSk7XG4gICAgICAgIGlmIChjb250ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhdHRlbmVkLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQnKS5mb3JFYWNoKChlKSA9PiBlLnJlbW92ZSgpKTtcbiAgICAgICAgY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCd0cy1sb2FkJykuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBIVE1MTG9hZGVyLmZsYXR0ZW5UU0xvYWRUYWcoZSwgZmxhdHRlbmVkLCBjb3VudCArIDEpO1xuICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZS5yZXBsYWNlV2l0aChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmbGF0dGVuZWQuYWRkKG5hbWUpO1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRDYWNoZWRDb250ZW50KFxuICAgICAgICBuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkXG4gICAgKTogRWxlbWVudCB8IG51bGwge1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkIHx8IG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBIVE1MTG9hZGVyLkNBQ0hFW25hbWVdO1xuICAgICAgICBpZiAoY29udGVudCA9PT0gdW5kZWZpbmVkIHx8IGNvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZW50LmNsb25lTm9kZSh0cnVlKSBhcyBFbGVtZW50O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGxvYWRBbGxDYWNoZWRFbGVtZW50cyhmcmFnOiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgIGZyYWcucXVlcnlTZWxlY3RvckFsbCgndHMtbG9hZCcpLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBlbGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1uYW1lJyk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gSFRNTExvYWRlci5nZXRDYWNoZWRDb250ZW50KG5hbWUpO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVsZW0ucmVwbGFjZVdpdGgoY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEVsZW1lbnRzIH0gZnJvbSBcIi4uL2RvbS9lbGVtZW50c1wiO1xuaW1wb3J0IHsgRCB9IGZyb20gXCIuLy4uL2RvbS9kb2N1bWVudFwiO1xuaW1wb3J0IHsgRGVidWdMZXZlbEVudW0sIGxvZyB9IGZyb20gXCIuL2NvbnNvbGVfd3JhcHBlclwiO1xubG9nKFwiaWQgZ2VuZXJhdG9yIGxvYWRlZFwiLCBEZWJ1Z0xldmVsRW51bS5CQVNJQyk7XG5leHBvcnQgY2xhc3MgSURHZW5lcmF0b3Ige1xuICBwdWJsaWMgc3RhdGljIHJlc2V0KCkge1xuICAgIElER2VuZXJhdG9yLmlkQ291bnQgPSAwO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXQgbmV4dCgpIHtcbiAgICBJREdlbmVyYXRvci5pZENvdW50ICs9IDE7XG4gICAgcmV0dXJuIElER2VuZXJhdG9yLnByZWZpeCArIElER2VuZXJhdG9yLmlkQ291bnQ7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGFwcGx5SUQoZWxlbTogRWxlbWVudCkge1xuICAgIGVsZW0uaWQgPSBlbGVtLmlkID8gZWxlbS5pZCA6IElER2VuZXJhdG9yLm5leHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgYWRkcyBpZHMgdG8gYWxsIGVsZW1lbnRzIHRoYXQgYXJlIGJlbG93IHRoZSBnaXZlblxuICAgKiBlbGVtZW50IGluIHRoZSBoZWlyYXJjaHkuXG4gICAqXG4gICAqIEBwYXJhbSBlbGVtIC0gdGhlIGVsZW1lbnQgdG8gc3RhcnQgYXBwbHlpbmcgaWRzIHRvIGl0cyBjaGlsZHJlbi5cbiAgICogICAgICAgICAgICAgICAgICBXaWxsIG5vdCBhcHBseSBhbiBpZCB0byB0aGlzIGVsZW1lbnQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFwcGx5UmVjdXIoZWxlbTogRWxlbWVudCB8IHN0cmluZykge1xuICAgIEQuZWFjaFJlY3VyKGVsZW0sIHRoaXMuYXBwbHlJRCk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoZXMgaWRzIHRvIGFsbCBodG1sIGVsZW1lbnRzIGluIHRoZSB0YXJnZXQgbG9jYXRpb24gaW4gdGhlIERPTSB0aGF0IGRvIG5vdCBoYXZlIGlkcy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXR0YWNoSWRzVG9BbGxFbGVtZW50cygpIHtcbiAgICBJREdlbmVyYXRvci5hcHBseVJlY3VyKEVsZW1lbnRzLmh0bWxMb2MpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgaWRDb3VudCA9IDA7XG4gIHByaXZhdGUgc3RhdGljIHByZWZpeCA9IFwiYXV0b19nZW5faWRfdW5xX1wiO1xufVxuIiwiaW1wb3J0IHsgRGVidWdMZXZlbEVudW0sIGxvZyB9IGZyb20gXCIuL2NvbnNvbGVfd3JhcHBlclwiO1xuXG5sb2coXCJyZWFkeSBsb2FkZWRcIiwgRGVidWdMZXZlbEVudW0uQkFTSUMpO1xuXG5sZXQgcmVhZHkgPSBmYWxzZTtcblxubGV0IHJlc29sdmVGdW5jOiAodmFsOiBib29sZWFuKSA9PiBhbnk7XG5sZXQgcmVqZWN0RnVuYztcbmNvbnN0IHJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlOiAodmFsOiBib29sZWFuKSA9PiBhbnksIHJlamVjdCkgPT4ge1xuICByZXNvbHZlRnVuYyA9IHJlc29sdmU7XG4gIHJlamVjdEZ1bmMgPSByZWplY3Q7XG59KTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xuICBsb2coXCJkb2N1bWVudCBpcyByZWFkeVwiLCBEZWJ1Z0xldmVsRW51bS5ERVRBSUxFRCk7XG4gIHJlYWR5ID0gdHJ1ZTtcbiAgcmVzb2x2ZUZ1bmModHJ1ZSk7XG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVhZHkoKSB7XG4gIHJldHVybiByZWFkeTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3YWl0VW50aWxSZWFkeSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgcmV0dXJuIHJlYWR5ID8gUHJvbWlzZS5yZXNvbHZlKHRydWUpIDogcmVhZHlQcm9taXNlO1xufVxuIiwiaW1wb3J0IHsgRCB9IGZyb20gXCIuLy4uL2NvcmUvZG9tL2RvY3VtZW50XCI7XG5cbmV4cG9ydCBjbGFzcyBBY2NvcmRpb24ge1xuICBwdWJsaWMgc3RhdGljIHNldHVwQWxsKCkge1xuICAgIEFjY29yZGlvbi5kaXNjYXJkQWxsKCk7XG4gICAgY29uc3QgYWNjb3JkaW9ucyA9IEQuY2xheihcImFjY29yZGlvblwiKTtcbiAgICBmb3IgKGxldCBhY2NJbmRleCA9IDA7IGFjY0luZGV4IDwgYWNjb3JkaW9ucy5sZW5ndGg7ICsrYWNjSW5kZXgpIHtcbiAgICAgIGNvbnN0IGVsZW0gPSBhY2NvcmRpb25zLml0ZW0oYWNjSW5kZXgpO1xuICAgICAgaWYgKGVsZW0gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIEFjY29yZGlvbi5hY2NvcmRpb25zLnB1c2gobmV3IEFjY29yZGlvbihlbGVtKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBkaXNjYXJkQWxsKCkge1xuICAgIEFjY29yZGlvbi5hY2NvcmRpb25zID0gW107XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBhY2NvcmRpb25zOiBBY2NvcmRpb25bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgb3V0ZXI6IEVsZW1lbnQpIHtcbiAgICBELmFkZEV2ZW50TGlzdGVuZXIob3V0ZXIsIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgLyogVG9nZ2xlIGJldHdlZW4gYWRkaW5nIGFuZCByZW1vdmluZyB0aGUgXCJhY3RpdmVcIiBjbGFzcyxcbiAgICAgICAgICAgICAgICB0byBoaWdobGlnaHQgdGhlIGJ1dHRvbiB0aGF0IGNvbnRyb2xzIHRoZSBwYW5lbCAqL1xuICAgICAgdGhpcy5vdXRlci5jbGFzc0xpc3QudG9nZ2xlKFwiYWN0aXZlXCIpO1xuXG4gICAgICAvKiBUb2dnbGUgYmV0d2VlbiBoaWRpbmcgYW5kIHNob3dpbmcgdGhlIGFjdGl2ZSBwYW5lbCAqL1xuICAgICAgY29uc3QgcGFuZWwgPSB0aGlzLm91dGVyLm5leHRFbGVtZW50U2libGluZyBhcyBIVE1MRWxlbWVudDtcbiAgICAgIGlmIChwYW5lbC5zdHlsZS5kaXNwbGF5ID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgcGFuZWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFuZWwuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGRvU29tZXRoaW5nKCkge1xuICBjb25zb2xlLmxvZyhcIlB1dCBzb21lIGNvZGUgaW4gaGVyZSFcIik7XG59XG4iLCJpbXBvcnQgeyBIVE1MTG9hZGVyIH0gZnJvbSAnLi4vY29yZS91dGlscy9odG1sX2xvYWRlcic7XG5pbXBvcnQgeyBBY2NvcmRpb24gfSBmcm9tICcuL2FjY29yZGlvbic7XG5pbXBvcnQgeyBkb1NvbWV0aGluZyB9IGZyb20gJy4vZG8tc29tZXRoaW5nJztcbmltcG9ydCB7IEhUTUxDb250ZW50LCBpdGVtc1RvQ2FjaGUgfSBmcm9tICcuL2h0bWwtaW1wb3J0cyc7XG5pbXBvcnQgeyBTbGlkZXNob3cgfSBmcm9tICcuL3NsaWRlc2hvdyc7XG5cbi8vIFB1dCBhbGwgZnVuY3Rpb24gY2FsbHMgdGhhdCBuZWVkIHRvIGJlIG1hZGUgb24gZXZlcnkgcGFnZSBsb2FkIGluc2lkZSB0aGUgc2V0dXBBbGwgZnVuY3Rpb24gYm9keS5cbmV4cG9ydCBmdW5jdGlvbiBQdXRTdHVkZW50UGFnZUxvYWRPcGVyYXRpb25zSW5zaWRlVGhpc1N0dWRlbnRCb2R5KCkge1xuICAgIC8vIFRPRE86IFB1dCBhbGwgb3BlcmF0aW9ucyB0aGF0IHlvdSB3YW50IHRvIGhhcHBlbiBvbiBldmVyIHBhZ2UgbG9hZCBpbiB0aGlzIGZ1bmN0aW9uLlxuICAgIC8vIEZvciBleGFtcGxlIHlvdSBjb3VsZCB3cml0ZTogU3RpY2t5LnNldHVwKClcbiAgICBkb1NvbWV0aGluZygpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0dXBBbGwoKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHI6IGFueSkgPT4gc2V0VGltZW91dChyLCAxMDApKTtcbiAgICBjb25zb2xlLmxvZygncmVsb2FkaW5nJyk7XG4gICAgU2xpZGVzaG93LnNldHVwQWxsKCk7XG4gICAgQWNjb3JkaW9uLnNldHVwQWxsKCk7XG4gICAgUHV0U3R1ZGVudFBhZ2VMb2FkT3BlcmF0aW9uc0luc2lkZVRoaXNTdHVkZW50Qm9keSgpO1xuICAgIGNvbnNvbGUubG9nKCdyZWxvYWRlZCcpO1xufVxuXG5pdGVtc1RvQ2FjaGUuZm9yRWFjaCgoaXRlbTogSFRNTENvbnRlbnQpID0+IHtcbiAgICBIVE1MTG9hZGVyLmNhY2hlSFRNTChpdGVtLm5hbWUsIGl0ZW0uY29udGVudCk7XG59KTtcbih3aW5kb3cgYXMgYW55KS5IVE1MTG9hZGVyID0gSFRNTExvYWRlcjtcblxuY29uc29sZS5sb2coJ2R5bmFtaWMtZG9tIGxvYWRlZCcpO1xuLy8gRG8gbm90IHRvdWNoIHRoaXMgbGluZSwgbmVlZGVkIHRvIHJlaW5pdGlhbGl6ZSBjb2RlIGluIHRoZSBkeW5hbWljLWRvbS50cyBzZXR1cEFsbCBmdW5jdGlvblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ25ld1BhZ2VMb2FkJywgKCkgPT4gc2V0dXBBbGwoKSk7XG4iLCJkZWNsYXJlIGZ1bmN0aW9uIHJlcXVpcmUoaWQ6IHN0cmluZyk6IHN0cmluZztcblxuLy8gVGhpcyBkZWZpbmVzIHRoZSBkYXRhIHRoYXQgbmVlZHMgdG8gYmUgcGFzc2VkIHRvIHRoZSBIVE1MTG9hZGVyIHRvIGNhY2hlIHlvdXIgaHRtbCBjb250ZW50LlxuZXhwb3J0IGludGVyZmFjZSBIVE1MQ29udGVudCB7XG4gICAgbmFtZTogc3RyaW5nOyAvLyBUaGUgbmFtZSB0aGF0IHlvdSB3aWxsIHVzZSB0byByZWZlcmVuY2UgdGhlIGNvbnRlbnQgaW4geW91ciBodG1sIHBhZ2VzLlxuICAgIGNvbnRlbnQ6IHN0cmluZzsgLy8gVGhlIGFjdHVhbCBodG1sIHN0cmluZyB0aGF0IHdpbGwgYmUgcHVsbGVkIGZyb20gdGhlIHNvdXJjZSBmaWxlIHRoYXQgeW91IHNwZWNpZnkuXG59XG5cbi8vIEFuIEhUTUxDb250ZW50IG9iamVjdCBzaG91bGQgbG9vayBsaWtlIHRoZSBmb2xsb3dpbmc6XG4vLyB7XG4vLyAgICAgbmFtZTogJ2Zvb3RlcicsXG4vLyAgICAgY29udGVudDogcmVxdWlyZSgnLi9odG1sL2Zvb3Rlci5odG1sJyksXG4vLyB9XG5cbi8vIFRoZW4geW91IGNhbiByZWZlcmVuY2UgdGhhdCBjb250ZW50IGluIHlvdXIgaHRtbCB1c2luZyB0aGUgZm9sbG93aW5nIHRhZyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIG5hbWUgYXR0cmlidXRlLlxuLy8gPHRzLWxvYWQgZGF0YS1uYW1lPVwiaGVhZGVyXCI+PC90cy1sb2FkPlxuXG4vLyBZb3UgY2FuIHNwZWNpZnkgYXMgbWFueSBhcyB5b3Ugd2FudCBpbnNpZGUgb2YgdGhlIGFycmF5IGFuZCB0aGV5IHdpbGwgYWxsIGJlIGJ1bmRsZWQgdXAgd2l0aCB5b3VyIHdlYnNpdGUuXG4vLyBNYWtlIHN1cmUgdG8gbWFrZSBhIGNvcnJlc3BvbmRpbmcgaHRtbCBmaWxlIGluIHRoZSBodG1sIGZpbGUgZm9sZGVyIGZvciBlYWNoIGVsZW1lbnQgeW91IHNwZWNpZnkuXG5cbmV4cG9ydCBjb25zdCBpdGVtc1RvQ2FjaGUgPSBbXG4gICAgLy8gRmVlbCBmcmVlIHRvIGNoYW5nZSB0aGUgY29udGVudCBpbnNpZGUgYW55IG9mIHRoZSBodG1sIGZpbGVzIGluIHRoZSBodG1sIGZpbGUgZm9sZGVyIHRvIHN1aXQgeW91ciBuZWVkcy5cbiAgICB7XG4gICAgICAgIG5hbWU6ICdoZWFkZXInLFxuICAgICAgICBjb250ZW50OiByZXF1aXJlKCcuL2h0bWwvaGVhZGVyLmh0bWwnKSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2Zvb3RlcicsXG4gICAgICAgIGNvbnRlbnQ6IHJlcXVpcmUoJy4vaHRtbC9mb290ZXIuaHRtbCcpLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnbmVzdGVkJyxcbiAgICAgICAgY29udGVudDogcmVxdWlyZSgnLi9odG1sL25lc3RlZC5odG1sJyksXG4gICAgfSxcbiAgICAvLyBQdXQgbW9yZSBpdGVtcyBpbiB0aGUgYXJyYXkgYmVsb3cgaGVyZS5cbl07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGZvb3RlciBpZD1cXFwiY29sb3Bob25cXFwiIGNsYXNzPVxcXCJmb290ZXJcXFwiIHJvbGU9XFxcImNvbnRlbnRpbmZvXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZvb3Rlci13aWRnZXRzXFxcIj5cXG4gICAgICA8YXNpZGUgY2xhc3M9XFxcIndpZGdldCBzaXRlLWNvbnRhY3RcXFwiPlxcbiAgICAgICAgPGgyIGNsYXNzPVxcXCJmb290ZXItd2lkZ2V0LXRpdGxlXFxcIj5OdXJzZXJ5IFNjaG9vbDwvaDI+XFxuICAgICAgICA8cD42OTI2IEZvcmVzdCBQYXJrIFBhcmt3YXk8L3A+XFxuICAgICAgICA8cD5TdC4gTG91aXMsIE1PIDYzMTMwPC9wPlxcbiAgICAgICAgPHAgY2xhc3M9XFxcInBob25lXFxcIj4zMTQtOTM1LTY2ODkgPHNwYW4+fDwvc3Bhbj4gRmF4OiAzMTQtOTM1LTcyNDk8L3A+XFxuICAgICAgICA8cD5cXG4gICAgICAgICAgPGEgaHJlZj1cXFwiZmlsZXMvbWFpbHRvOm51cnNlcnlAd3VzdGwuZWR1XFxcIj5udXJzZXJ5QHd1c3RsLmVkdTwvYT5cXG4gICAgICAgIDwvcD5cXG4gICAgICA8L2FzaWRlPlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIndpZGdldC13cmFwcGVyXFxcIj5cXG4gICAgICAgIDxhc2lkZSBpZD1cXFwidGV4dC00XFxcIiBjbGFzcz1cXFwid2lkZ2V0IHdpZGdldF90ZXh0IHdpZGdldC1jb3VudC0yXFxcIj5cXG4gICAgICAgICAgPGgyIGNsYXNzPVxcXCJmb290ZXItd2lkZ2V0LXRpdGxlXFxcIj5Ib3VycyBvZiBPcGVyYXRpb248L2gyPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0ZXh0d2lkZ2V0XFxcIj5cXG4gICAgICAgICAgICA8cD5cXG4gICAgICAgICAgICAgIENsYXNzZXMgbWVldCBNb24uIHRocm91Z2ggRnJpLjxiciAvPlxcbiAgICAgICAgICAgICAgTW9ybmluZzogOS0xMTo0NSBhLm0uPGJyIC8+XFxuICAgICAgICAgICAgICBBZnRlcm5vb246IDEyOjMwLTM6MTUgcC5tLjxiciAvPlxcbiAgICAgICAgICAgICAgRnVsbCBkYXk6IDkgYS5tLi0zOjE1IHAubS5cXG4gICAgICAgICAgICA8L3A+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9hc2lkZT5cXG4gICAgICAgIDxhc2lkZSBpZD1cXFwidGV4dC0zXFxcIiBjbGFzcz1cXFwid2lkZ2V0IHdpZGdldF90ZXh0IHdpZGdldC1jb3VudC0yXFxcIj5cXG4gICAgICAgICAgPGgyIGNsYXNzPVxcXCJmb290ZXItd2lkZ2V0LXRpdGxlXFxcIj5BcHBseSBmb3IgdGhlIE51cnNlcnkgU2Nob29sPC9oMj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwidGV4dHdpZGdldFxcXCI+XFxuICAgICAgICAgICAgPHA+XFxuICAgICAgICAgICAgICBFeHBlcmllbmNlIHRoZSBpbm5vdmF0aXZlIGFwcHJvYWNoIGFuZCBkeW5hbWljIHRlYWNoaW5nXFxuICAgICAgICAgICAgICBlbnZpcm9ubWVudCBvZiB0aGUgV2FzaGluZ3RvbiBVbml2ZXJzaXR5IE51cnNlcnkgU2Nob29sLlxcbiAgICAgICAgICAgIDwvcD5cXG4gICAgICAgICAgICA8YSBocmVmPVxcXCJmaWxlcy9hcHBseS5odG1sXFxcIj5SZWdpc3RlciBOb3c8L2E+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9hc2lkZT5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNpdGUtaW5mb1xcXCI+XFxuICAgICAgPHAgY2xhc3M9XFxcImZvb3Rlci1jb3B5cmlnaHRcXFwiPsKpMjAxOSBXYXNoaW5ndG9uIFVuaXZlcnNpdHkgaW4gU3QuIExvdWlzPC9wPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZm9vdGVyPlwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgaWQ9XFxcInd1c3RsLWJyYW5kaW5nXFxcIj5cXG4gIDxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMzIxXFxcIiBoZWlnaHQ9XFxcIjI4XFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIxIDI4XFxcIiBjbGFzcz1cXFwid2FzaHUtbG9nb1xcXCJcXG4gICAgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ0aXRsZVxcXCI+XFxuICAgIDx0aXRsZSBpZD1cXFwidGl0bGVcXFwiPldhc2hpbmd0b24gVW5pdmVyc2l0eSBpbiBTdC4gTG91aXM8L3RpdGxlPlxcbiAgICA8cGF0aCBmaWxsPVxcXCIjRkZGXFxcIlxcbiAgICAgIGQ9XFxcIk0xMC40NiAxLjc2Yy0uMDkgMC00LjQxLjA0LTEwLjQ2LTEuMjFWMThjMCAuMjcuMDEuNDcuMDEuNDd2LjAyYy4wNC44MS4yOCAxLjQ1Ljc3IDIgLjMyLjM0Ljc2LjcgMS4zOCAxLjA1LjE3LjEuMzUuMTguNTUuMjguMTUuMDcuMzEuMTQuNDcuMi4xNC4wNi41NS4yNC42OS4yOWw2LjU5IDIuNSA2LjU5LTIuNWMuMTUtLjA1LjU2LS4yNC42OS0uMjkuMTYtLjA3LjMyLS4xNC40Ny0uMi4xOS0uMS4zOC0uMTguNTUtLjI4LjYyLS4zNSAxLjA2LS43IDEuMzgtMS4wNS40OC0uNTUuNzMtMS4xOS43Ny0ydi0uMDJzMC0uMTkuMDEtLjQ3Vi41NUMxNC44NiAxLjggMTAuNTUgMS43NiAxMC40NiAxLjc2elxcXCI+XFxuICAgIDwvcGF0aD5cXG4gICAgPHBhdGggZmlsbD1cXFwiIzAwNzM2MFxcXCJcXG4gICAgICBkPVxcXCJNMTAuNDYgMi44Yy0uMDkgMC00LjAzLjA0LTkuNTYtMS4xdjE1Ljk1YzAgLjI1LjAxLjQzLjAxLjQ0di4wMmMuMDQuNzQuMjUgMS4zMy43IDEuODMuMjkuMzEuNy42NCAxLjI2Ljk1LjE1LjA5LjMyLjE3LjUuMjYuMTQuMDcuMjguMTMuNDQuMTkuMTIuMDUuNS4yMi42My4yN2w2LjAzIDIuMjkgNi4wMy0yLjI5Yy4xMy0uMDUuNTEtLjIyLjYzLS4yNy4xNS0uMDYuMy0uMTMuNDQtLjE5LjE4LS4wOS4zNS0uMTcuNS0uMjYuNTYtLjMxLjk3LS42NCAxLjI2LS45NS40NC0uNS42Ni0xLjA5LjctMS44M3YtLjAyczAtLjE4LjAxLS40NFYxLjdjLTUuNTUgMS4xNC05LjUgMS4xLTkuNTggMS4xelxcXCI+XFxuICAgIDwvcGF0aD5cXG4gICAgPHBhdGggZmlsbD1cXFwiI0UxQzRBQ1xcXCJcXG4gICAgICBkPVxcXCJNMTAuNDYgMy43NWMtLjA4IDAtMy42OC4wNC04Ljc0LTEuMDJ2NC4wOGM1LjA1IDEuMDUgOC42NyAxLjAyIDguNzQgMS4wMnMzLjY4LjA0IDguNzQtMS4wMlYyLjczYy01LjA2IDEuMDUtOC42NiAxLjAyLTguNzQgMS4wMnpcXFwiPlxcbiAgICA8L3BhdGg+XFxuICAgIDxwYXRoIGZpbGw9XFxcIiNBNTE0MTdcXFwiXFxuICAgICAgZD1cXFwiTTEwLjQ2IDcuODNjLS4wOCAwLTMuNjguMDQtOC43NC0xLjAydjkuMDVjNS4wNSAxLjA1IDguNjcgMS4wMiA4Ljc0IDEuMDJzMy42OC4wNCA4Ljc0LTEuMDJWNi44MmMtNS4wNiAxLjA0LTguNjYgMS4wMS04Ljc0IDEuMDF6XFxcIj5cXG4gICAgPC9wYXRoPlxcbiAgICA8cGF0aCBmaWxsPVxcXCIjRTFDNEFDXFxcIlxcbiAgICAgIGQ9XFxcIk0xLjcyIDE3LjcyYy4wMy42OS4yMyAxLjIzLjY0IDEuNjguMjYuMjguNjQuNTggMS4xNS44Ny4xNS4wOC4yOS4xNS40Ni4yMy4xMy4wNi4yNi4xMi40LjE3LjExLjA1LjQ2LjIuNTguMjRMMTAuNDYgMjNsNS41MS0yLjA5Yy4xMi0uMDQuNDYtLjIuNTgtLjI0LjE0LS4wNi4yNy0uMTIuNC0uMTcuMTYtLjA4LjMyLS4xNS40Ni0uMjMuNTEtLjI5Ljg4LS41OCAxLjE1LS44Ny40MS0uNDYuNi0xIC42NC0xLjY4di0uMDJzMC0uMTYuMDEtLjR2LTEuNDRjLTUuMDUgMS4wNS04LjY3IDEuMDItOC43NCAxLjAycy0zLjY4LjA0LTguNzQtMS4wMnYxLjQ1Yy0uMDIuMjUtLjAxLjQxLS4wMS40MXpcXFwiPlxcbiAgICA8L3BhdGg+XFxuICAgIDxwYXRoIGZpbGw9XFxcIiMwMDczNjBcXFwiXFxuICAgICAgZD1cXFwiTTQuOCAzLjY5bC40MSAxLjIzIDEuMjkuMDEtMS4wNC43Ny4zOSAxLjI0LTEuMDUtLjc2LTEuMDUuNzYuMzktMS4yNC0xLjA0LS43NyAxLjI5LS4wMS40MS0xLjIzem0xMS4zMSAwbC40MiAxLjIzIDEuMjkuMDEtMS4wNC43Ny4zOSAxLjI0LTEuMDYtLjc2LTEuMDUuNzYuMzktMS4yNC0xLjA0LS43NyAxLjI5LS4wMS40MS0xLjIzem0tNS42NS40OGwuNDIgMS4yMyAxLjI5LjAxLTEuMDQuNzcuMzkgMS4yNC0xLjA2LS43Ni0xLjA2Ljc1LjM5LTEuMjQtMS4wNC0uNzcgMS4zLS4wMS40MS0xLjIyek0xMC40NiAxNy4yMWwtLjQ2LjQ1djEuMjJsLjIzLjY1djEuMDloLjQ1di0xLjA5bC4yMy0uNjV2LTEuMjJsLS40NS0uNDV6bS4yMiA0LjQxdi0uNjVoLS40NXYuNjVsLS4yMy40Mi40Ni41Ni40Ni0uNTYtLjI0LS40MnptLjMzLS42NXYuNWwuMjkuMzEuNTEtLjQxdi0uNDFoLS44em0uNTQtMi4wNGwtLjU0LjZ2MS4wOWguNDR2LS42NWwuNDMtLjQ2LjU1LjM2LjM1LS4zNnYtLjU4aC0xLjIzem0tMS42NCAyLjA0di41bC0uMjkuMzEtLjUyLS40MXYtLjQxaC44MXptLS41NS0yLjA0bC41NC42djEuMDloLS40M3YtLjY1bC0uNDMtLjQ2LS41NS4zNi0uMzUtLjM2di0uNThoMS4yMnpcXFwiPlxcbiAgICA8L3BhdGg+XFxuICAgIDxwYXRoIGZpbGw9XFxcIiNFMUM0QUNcXFwiXFxuICAgICAgZD1cXFwiTTE0LjYyIDkuMjd2NS4xOWgtMy40OWwtLjI1LjIxLS40My4zNy0uNDMtLjM3LS4yNS0uMjFINi4yOVY5LjI3bC0uNzQuNTR2NS4zOGg0LjEybC4zNy4zMS40My4zOC40My0uMzguMzctLjMxaDQuMTJWOS44MWwtLjc3LS41NHpcXFwiPlxcbiAgICA8L3BhdGg+XFxuICAgIDxwYXRoIGZpbGw9XFxcIiNFMUM0QUNcXFwiXFxuICAgICAgZD1cXFwiTTExLjAyIDguODNsLS4xNC4xMS0uNDMuMzgtLjQzLS4zOC0uMTItLjExSDcuMDN2NC44OWgyLjg4bC4yLjE3LjM1LjMxLjM2LS4zMS4xOS0uMTdoMi44OFY4LjgzaC0yLjg3ek0xNi4xMSAxMC4zNXYzLjMxYy45NS0uMTQgMS45OC0uMzEgMy4wOC0uNTRWOS44MWE1MC41IDUwLjUgMCAwIDEtMy4wOC41NHptLTExLjMxIDBjLS45NS0uMTQtMS45OC0uMzEtMy4wOC0uNTR2My4zMWMxLjEuMjMgMi4xNC40MSAzLjA4LjU0di0zLjMxelxcXCI+XFxuICAgIDwvcGF0aD5cXG4gICAgPHBhdGggZmlsbD1cXFwiIzAwNzM2MFxcXCJcXG4gICAgICBkPVxcXCJNMTYuMTEgMTYuNzZsLS4zMS4zMnYuODZsLjE1LjQ2di43N2guMzF2LS43N2wuMTYtLjQ2di0uODZsLS4zMS0uMzJ6bS4xNiAzLjA5di0uNDVoLS4zMXYuNDZsLS4xNS4zLjMxLjQuMzItLjQtLjE3LS4zMXptLjIzLS40NXYuMzVsLjIuMjIuMzYtLjI4di0uMjloLS41NnptLjM4LTEuNDNsLS4zOC40M3YuNzdoLjMxdi0uNDZsLjMtLjMzLjM4LjI1LjI0LS4yNXYtLjQxaC0uODV6bS0xLjE0IDEuNDN2LjM1bC0uMjEuMjItLjM1LS4yOHYtLjI5aC41NnptLS4zOS0xLjQzbC4zOS40M3YuNzdoLS4zMXYtLjQ2bC0uMy0uMzMtLjM5LjI1LS4yNC0uMjV2LS40MWguODV6TTQuOCAxNi43NmwtLjMyLjMydi44NmwuMTYuNDZ2Ljc3aC4zMXYtLjc3bC4xNS0uNDZ2LS44NmwtLjMtLjMyem0uMTYgMy4wOXYtLjQ1aC0uMzF2LjQ2bC0uMTYuMy4zMi40LjMxLS40LS4xNi0uMzF6bS4yMi0uNDV2LjM1bC4yMS4yMi4zNS0uMjh2LS4yOWgtLjU2em0uMzktMS40M2wtLjM5LjQzdi43N2guMzF2LS40NmwuMy0uMzMuMzkuMjUuMjQtLjI1di0uNDFoLS44NXpNNC40MiAxOS40di4zNWwtLjIuMjItLjM2LS4yOHYtLjI5aC41NnptLS4zOC0xLjQzbC4zOC40M3YuNzdoLS4zMXYtLjQ2bC0uMy0uMzMtLjM4LjI1LS4yNC0uMjV2LS40MWguODV6XFxcIj5cXG4gICAgPC9wYXRoPlxcbiAgICA8ZyBmaWxsPVxcXCIjRkZGXFxcIiBjbGFzcz1cXFwid2FzaHUtbG9nby10ZXh0XFxcIj5cXG4gICAgICA8cGF0aFxcbiAgICAgICAgZD1cXFwiTTIzMi40NyA4LjE2Yy4zMyAwIDEuMDctMS4yIDEuMDctMS41NyAwLS4zNi0uNzQtMS42LTEuMDctMS42LS4zIDAtMS4wNyAxLjI2LTEuMDcgMS42cy43NiAxLjU3IDEuMDcgMS41N3ptMTMuODIgMTIuMDN2LTUuMDhjMC0yLjM0LS43Ni01Ljc2LTQuMjItNS43Ni0yLjUxIDAtMy44MSAyLjM4LTMuNzYgMi4wMVY5LjU5YzAtLjMxLS4xNS0uNDktLjMxLS40OS0uNiAwLTEuMDQgMS4wMS0zLjA2IDEuNjItLjEzLjAzLS41LjA0LS41MS4yNyAwIC42NSAyLjAzLS44NCAxLjk5IDEuNjh2Ny42NGMwIDEuNDMtLjcgMS41NS0xLjIxIDEuNjgtLjAzIDAtLjA2LS4wMS0uMSAwLS41Mi0uMDMtMS42My0uMjMtMS42My0xLjM1VjkuNTljMC0uMzEtLjE1LS40OS0uMzEtLjQ5LS42IDAtLjk4IDEuMDgtMi42MyAxLjY0LS4xMy4wMy0uMzcuMDYtLjM3LjI0IDAgLjY1IDEuNDktLjYxIDEuNDIgMS42OXY3LjI3Yy4wNiAxLjg2LS45NiAyLjA0LTEuNTIgMi4wNC0uODQtLjAxLS42My4xLS42My4zNi4wMy4zMS41My4zMyAxLjM3LjM0LjI5IDAgMS0uMTEgMS44Mi0uMTEgMS4wNyAwIDEuODcuMTIgMi40MS4xMi4zMSAwIDEuMTUtLjEzIDIuNTMtLjEzIDEuNSAwIDIuMDIuMTMgMi40Ni4xMy4zOSAwIC44My0uMTcuNTctLjQ0LS40Mi0uNDEtMi4yOC4wNi0yLjI4LTIuMDZWMTMuMWMtLjAzLS40OS44OC0yLjQgMy4wNi0yLjQgMi4xIDAgMy4wMyAyLjMxIDMuMDMgMy44NXY1Ljc2Yy0uMDMgMi4yNy0uOCAxLjU1LTEuMTEgMi0uMTcuMjUuMTMuMzcuNDYuMzdzLjg4LS4xMyAxLjg3LS4xM2MxLjI3IDAgMS44Mi4xMiAyLjE2LjEyLjI2IDAgLjczLS4yLjQ1LS40NC0uNjgtLjUtMS45Ny4zLTEuOTUtMi4wNHpNNDguOTEgMi40Yy4zNy0uMDUuNTUtLjE5LjU1LS4xOSAwLS4yNC0uMDUtLjMtLjM5LS4zLS42NSAwLTEuMDUuMTEtMS42OS4xMS0uNzEgMC0xLjI1LS4wOC0xLjg1LS4wOC0uMzQgMC0uMzEuMTEtLjMxLjMgMCAuMjEuNjUuMDggMS4wMi44OS4yMS40NC4xMyAxLjM2LS4wOCAxLjlsLTUuMDEgMTMuNzQtMi4xNC02LjEtLjgzLTIuMjNzLS4xMy4wNi40Ni0xLjc5bDEuMTctMy41MmMuNTctMS43MyAxLjE0LTIuNjQgMS44OC0yLjY1LjkyLS4wMi45Mi0uNTcuMjEtLjU3cy0xLjEzLjA2LTEuNzUuMDZjLS42NSAwLS45OS0uMDYtMS42OS0uMDYtLjI2IDAtLjU1LjA4LS41Mi4zLjAzLjIxLjQyLjE0LjcxLjMuNDcuMjQuNzggMS4yNS40NSAyLjNsLTEuMzggNC40Mi0xLjU4LTQuMTNjLS4zMS0uNzgtLjczLTIuNTIuMDMtMi42Ny43My0uMTUuNjMtLjUyLjE4LS41Mi0uODYgMC0xLjMyLjExLTIuMTUuMTEtLjkxIDAtMS41OS0uMTEtMi40NS0uMTEtLjE4IDAtLjUyLjAzLS40Mi4zOC4wNS4yMS40OS4xNC43Ni4zIDEuMDUuNjggMS4yNSAxLjU1IDEuNjIgMi41MmwyLjMgNi40OGMuNDIgMS4xNi40NS43NC4xMSAxLjczbC0yIDUuNS00Ljk1LTE0LjExYy0uMzktMS4wNi0uNi0xLjc5LjI2LTIuMi4zNy0uMTkuNDctLjIyLjUyLS4zLjA1LS4wNy4xLS4zMi0uNDUtLjMtLjg5LjAzLTEuNDMuMTEtMi4zMi4xMS0uOTQgMC0xLjU5LS4xMS0yLjQ1LS4xMS0uMjkgMC0uMzQuMTQtLjM0LjM1IDAgLjMzLjcxLjExIDEuMzEuODEuMzQuMzguOTkgMS42NiAxLjE0IDIuMTJMMzIuOCAyMi4zYy4xMS4yNS4xNC43Ni40OC43Ni4yNyAwIC4zMy0uNTcuNDItLjc5bDMuMTMtOC41OSAzLjA1IDguMTZjLjEzLjMzLjMxIDEuMjIuNjMgMS4yMi4yNiAwIC4zNi0uNDMuNDktLjgzbDUuOS0xNi44N2MuNS0xLjM2IDEuMDctMi43OSAyLjAxLTIuOTZ6bTY1LjQ2IDYuNzFjLTMuMjYgMC01Ljc3IDMuMjgtNS43NyA3LjEzIDAgMS45Ni41MiAzLjUxIDEuNDIgNC42My0uMzEuMjEtLjkyLjctMi4xNS43LTEuMDcgMC0xLjY4LS42NC0xLjc0LTJWMTEuMmwzLjM4LS4wMWMuMjIgMCAuNjUtMS40NC42Ny0xLjUyLjA0LS4xOC4xLS4zMy4xMi0uNDYuMDQtLjI4LS4xNy0uMy0uMzctLjAxLS4xNS4xNS0uMzIuNTUtLjk5LjU1aC0yLjgxYzAtMi40MS4wMy0zLjUxLS4zNS0zLjUxLS4zNiAwLS4zLjEtLjYzIDEuMTctLjQ0IDEuNDQtMS43OSAyLjIzLTIuNjMgMi42OC0uMzguMDktLjgxLjEyLTEuMjkuMDEtLjc0LS4xNi0xLjYtMS4wNi0zLjgzLTEuMDYtMi4zOCAwLTQuNDYgMS45NS00LjQ2IDQuNTUgMCAxLjQuNjIgMi43NiAxLjcxIDMuNDgtLjIuMTItMS41MyAxLjI0LTEuMzcgMi41NiAwIDAtLjAzIDEuMzcgMS4wNSAxLjgyLS4zMy4xNC0uNjcuMzYtLjk2LjYzLS43LS4yNi0xLjcyLS4wNi0xLjcyLTEuOTFWMTUuMWMwLTIuMzQtLjc2LTUuNzYtNC4yMi01Ljc2LTIuNTEgMC0zLjgxIDIuMzgtMy43NiAyLjAxVjkuNTljMC0uMzEtLjE1LS40OS0uMzEtLjQ5LS42IDAtLjczLjk5LTIuOTEgMS41NS0uMTMuMDMtLjQzLjEtLjQ0LjM0IDAgLjY1IDEuNzUtLjcxIDEuNzYgMS42OHY3LjY0YzAgMS42NS0xLjMxIDEuNjUtMS41NCAxLjY3LS4xIDAtLjE5IDAtLjMxLjAxLS41NS0uMDUtMS41MS0uMy0xLjUxLTEuMzRWOS41OWMwLS4zMS0uMTUtLjQ5LS4zMS0uNDktLjYgMC0uOTggMS4wOC0yLjYzIDEuNjQtLjEzLjAzLS4zNy4wNi0uMzcuMjQgMCAuNjUgMS40OS0uNjEgMS40MiAxLjY5djcuMjdjLjA2IDEuNzgtLjg2IDIuMDEtMS40MyAyLjAzLS42OS0uMDktMS4yMi0uMzctMS4yMi0xLjQxdi01LjE0YzAtMi42NS0xLjAxLTYuMDctNC4zMy02LjA3LTEuNDcgMC0yLjc1LjgxLTMuNzMgMS45MlYyLjQxYzAtLjMxLS4xNS0uNDgtLjMxLS40OS0uNC0uMDMtMS4wNyAxLjE5LTIuOTYgMS42My0uMTMuMDMtLjYyLjA3LS42Mi4yNSAwIC42NSAxLjk3LS4zMSAxLjk5IDEuNjlWMjAuNmMwIDEuNTEtMS4zIDEuMzEtMS41MyAxLjc5LS4wNC4yMS4wOC4zMS4yNi4zMS40MiAwIDEuNTUtLjEyIDIuMzUtLjEyczIuMS4xMiAyLjY0LjEyYy4zMSAwIC40NC0uMDYuNDQtLjQ0LS4yNy0uNTItMi4yOC4yOC0yLjI4LTIuMzd2LTYuNWMwLTEuNTcgMS44Ny0yLjc4IDMuMDMtMi43OC45MSAwIDMuMTQuNzEgMy4xNCA0LjUzdjUuNjRjMCAxLjExLTEuMTggMS4yMy0xLjI3IDEuNTcgMCAuMjQuMTUuMzQuNDIuMzQuMjggMCAxLjExLS4xMiAyLjEyLS4xMi41NiAwIDEuMDcuMDMgMS41LjA2LjIzLjA1LjU3LjA1Ljk5LjA1LjI4IDAgMS0uMTEgMS44Mi0uMTFzMS40OC4wNyAxLjk5LjExYy4xLjAxLjIuMDEuMy4wMS4wNCAwIC4wOC4wMS4xMi4wMWguMDFjLjMyLjAxLjYxIDAgLjc0IDAgLjMxIDAgLjgzLS4xMyAyLjItLjEzIDEuNSAwIDIuMDIuMTMgMi40Ni4xMy4zOSAwIC44My0uMTcuNTctLjQ0LS40Mi0uNDEtMi4yOC4wNi0yLjI4LTIuMDZ2LTcuMDljLS4wMy0uNDkuODgtMi40IDMuMDYtMi40IDIuMSAwIDMuMDMgMi4zMSAzLjAzIDMuODV2NS43NmMwIDItLjggMS41NS0xLjExIDItLjE3LjI1LjEzLjM3LjQ2LjM3cy44OC0uMTMgMS44Ny0uMTNjLjkzIDAgMS41My4wNyAxLjkxLjEtLjI5LjQyLS40OC45LS41MSAxLjQtLjE0IDIuNTEgMi45MyAzLjQxIDUuNTEgMy4zNyA1LjEyLS4wNyA2LjU3LTMuNjIgNS41MS01LjUxLTEuMDktMS45NS0zLjQ0LTEuODctNS42OC0xLjg2LTQuMi4wMi0zLjQxLTIuNTktMS42OS0yLjQ5LjQuMDIuMi4xNCAxLjU3LjE0IDIuNDMgMCA0Ljc2LTEuNjYgNC43LTQuMzgtLjAxLS4yMy4wNS0xLjAzLS41My0yLjE0IDEuMTQuMDEuNjkgMCAyLjQxIDBsLS4wMSA3LjYzYzAgMy40NSAxLjY0IDQuMDMgMi44NyA0LjAzIDEuNzQgMCAzLjAxLTEuMTUgMy4yNC0xLjY4IDEuMDMgMS4xIDIuNDYgMS42OCA0LjEyIDEuNjggMy4xOSAwIDUuNi0yLjkzIDUuNi02Ljc4IDAtNS44LTMuNjUtNi45Ni01LjYxLTYuOTZ6TTk1LjYyIDIxLjcyYy4yMS0uMDEuMjcuMDggMi42NC4xNyAyLjQ1LjA2IDMuMzMuNzcgMy40OSAxLjQuMjYgMS4xMi0uNTMgMy41Mi00LjA1IDMuMjktMi4yMi0uMTUtMi44Ny0xLjItMy4wMy0xLjQ0LS44NC0xLjE2LS4xNi0zLjM1Ljk1LTMuNDJ6bTIuMDEtNC41N2MtMi4wOCAwLTIuNzgtMi0yLjc4LTMuOTEgMC0xLjk2LjU5LTMuNTggMi42Ny0zLjU4IDIuMTEgMCAyLjk1IDIuMTYgMi45NSA0LjA3LjAxIDEuOTMtLjg3IDMuNDItMi44NCAzLjQyem0xNi45OSA0LjgxYy0zLjAzIDAtNC4yMi0zLjc2LTQuMjItNi44MiAwLTIuNjUgMS4wNC01LjEgMy41Ny01LjEgMy4wOCAwIDQuMTkgMy4yOSA0LjE5IDYuNTEuMDEgMy44Ny0xLjM2IDUuNDEtMy41NCA1LjQxelxcXCI+XFxuICAgICAgPC9wYXRoPlxcbiAgICAgIDxwYXRoXFxuICAgICAgICBkPVxcXCJNMTMxLjExIDIwLjE5di01LjA4YzAtMi4zNC0uNzYtNS43Ni00LjIyLTUuNzYtMi41MSAwLTMuODEgMi4zOC0zLjc2IDIuMDFWOS41OWMwLS4zMS0uMTUtLjQ5LS4zMS0uNDktLjYgMC0xLjA0IDEuMDEtMy4wNyAxLjYyLS4xMy4wMy0uNS4wNC0uNTEuMjcgMCAuNjUgMi4wMy0uODQgMiAxLjY4djcuNjRjMCAyLTEuMzUgMS41Mi0xLjY2IDIuMDQtLjE1LjI3LjI1LjMzLjU5LjMzLjMxIDAgLjgzLS4xMyAyLjItLjEzIDEuNSAwIDIuMDIuMTMgMi40Ni4xMy4zOSAwIC44My0uMTcuNTctLjQ0LS40Mi0uNDEtMi4yOC4wNi0yLjI4LTIuMDZ2LTcuMDljLS4wMy0uNDkuODgtMi40IDMuMDYtMi40IDIuMSAwIDMuMDMgMi4zMSAzLjAzIDMuODV2NS43NmMtLjAzIDIuMjctLjggMS41NS0xLjExIDItLjE3LjI1LjEzLjM3LjQ2LjM3cy44OC0uMTMgMS44Ny0uMTNjMS4yNyAwIDEuODIuMTIgMi4xNi4xMi4yNiAwIC43My0uMi40NC0uNDQtLjY1LS40OS0xLjk0LjMxLTEuOTItMi4wM3pNNzcuNDEgOC4xNmMuMzMgMCAxLjA3LTEuMiAxLjA3LTEuNTcgMC0uMzYtLjc0LTEuNi0xLjA3LTEuNi0uMyAwLTEuMDcgMS4yNi0xLjA3IDEuNi4wMi4zNS43NyAxLjU3IDEuMDcgMS41N3ptLTE3LjMgNi45NmMtLjUxLS4yNC0xLjI3LS42OC0xLjY1LS44OC0xLjYzLS44OS0yLjI3LTEuNDctMi4zMS0yLjMtLjA4LTEuNDQgMS4xNS0yLjE5IDIuMjEtMi4wOCAyLjU0LS4wNCAyLjg4IDIuOCAzLjE0IDIuOC4zOSAwIC4yOC0uMzcuMjgtMS4yMSAwLS4yMS4wMy0xLjI3LS4xMy0xLjUyLS4zMS0uNDYtMi4xLS43NC0yLjU1LS43NC0uMTEgMC0uNTItLjAxLS42LS4wMi0uMTMgMC0uMjguMDItLjI4LjAyLTEuODEtLjAzLTMuNSAxLjExLTMuNDUgMy41My4wNSAyLjIxIDIuNjQgMy40NyA0LjA0IDQuMyAxLjA0LjU5IDIuMjYgMS4xNSAyLjI0IDIuNTctLjAyIDEuNjEtMS4yNyAyLjY4LTIuNjEgMi42LTMuMTUtLjA1LTIuNzItNC0zLjI4LTQtLjM5IDAtLjMxIDEtLjMxIDEuNTIgMCAuNTEtLjAxLjk4LS4wMSAxLjM4LS4wNy4zNi0uMi43LS41NC43Mi0xLjI0LjA4LS45NC0xLjktLjk0LTIuOTV2LTYuNDNjLS4wNi0xLjk3LTEuNTQtMy4yNS0zLjgtMy4yNS0zLjA5IDAtNS4zMSAzLjgxLTQuMjUgNSAuMjUuMjggMS4yNi0uOCAxLjMyLS44NnMuMDgtLjEzLjA4LS4xM2MtLjAxLTEuMy45Ny0yLjk1IDIuMzctMy4wOSAxLjYtLjE1IDIuNCAxLjA0IDIuNCAyLjY1djIuMDljLTYuMDYgMS4yMS02LjkzIDMuMjItNi45MyA0Ljg3IDAgMi4yMSAxLjU1IDMuMiAzLjIzIDMuMiAxLjQ1IDAgMi44OC0uNjkgMy45Ni0xLjguMzQgMS4wMyAxLjAxIDEuNjUgMi4wMiAxLjYyLjM1LS4wMS40MS4wOSAxLjQ2LS4zNy4zNy0uMS4zNS0uMDkuNzctLjAxLjU2LjE5IDEuMzIuNTcgMi42Ni41NyAyLjAzLjAzIDMuODUtMS44NSAzLjg1LTQuMTcgMC0xLjUtLjQzLTIuNDEtMi4zOS0zLjYzem0tOC40MyA0LjMyYzAgMS42NS0xLjY4IDIuNTItMi42IDIuNTItMS4zOCAwLTIuMzMtLjg5LTIuMzMtMi42NiAwLTIuNzMgMy4yOC0zLjIzIDQuOTQtMy42Ny0uMDEtLjAxLS4wMSAzLjgxLS4wMSAzLjgxem0yMTkuOTkuMTljLS4zMSAwLTEuMDcgMS4yOS0xLjA3IDEuNjMgMCAuMzQuNzcgMS42IDEuMDcgMS42LjMzIDAgMS4wNy0xLjIzIDEuMDctMS42cy0uNzMtMS42My0xLjA3LTEuNjN6bTMzLjcxIDEuMTJWOS45MmMwLS42MS0uMzQtLjc3LS40NC0uNzctLjM5IDAtLjYxLjEtLjg4LjE2LS4yNy4xLS41OC4yMy0xLjI5LjIzLS4xMyAwLS43OS0uMTItLjc2LjI1LjA0LjM3IDEuNTcuMTUgMS41OCAxLjIzdjcuODNjLS4xMiAxLjM3LTEuMjcgMi44OC0yLjY2IDIuODgtLjMyIDAtMi4zOS0uMjItMi4zNy0zLjY1VjkuOTJjMC0uNjEtLjM0LS43Ny0uNDQtLjc3LS4zOSAwLS42MS4xLS44OC4xNi0uMjcuMS0uNjEuMjItMS4zMi4xOS0uMzgtLjAyLS43OS0uMDctLjczLjI5LjA2LjMyIDEuNTkgMCAxLjU5IDEuMjN2Ny41MWMwIDIuNzQgMS42MSA0LjMyIDMuNTYgNC4zMiAxLjMgMCAyLjQ5LS4yOCAzLjI0LTEuOGguMDV2MS4zMmMwIC4xMy4wMy40OC4yMi40OC4zNyAwIC41Ni0uMy44My0uNC4yOS0uMDcuMzctLjMzIDEuMjgtLjQyLjM5LS4wNC44Mi0uMjQuODItLjUtLjExLS41My0xLjQuMDYtMS40LS43OHpNMjkwLjA5IDkuMTFjLTMuMjYgMC01Ljc3IDMuMjgtNS43NyA3LjEzIDAgMS43My40MiAzLjE1IDEuMTMgNC4yMy0uNzkuNTctMi4yMyAxLjEtNC45NiAxLjEtMi4xMyAwLTEuOTMtLjc0LTEuOTMtMi41NVY0LjU3YzAtMi42NiAxLjk5LTEuODkgMi4wMy0yLjM3LjAzLS4zNC0uMjgtLjI2LS42MS0uMjYtLjM4IDAtMS4wNy4xNS0yLjUyLjE1LTEuMjUgMC0yLjM0LS4xMi0yLjg4LS4xMi0uMzMgMC0uNjMuMS0uNTIuMzUuMjUuNTcgMi4xNC4wNSAyLjE0IDEuNjV2MTUuMWMwIDEuNDQuMjEgMi4zNi0uNDUgMi43My0uODEuNDktMS43Ni41MS0xLjY4LjgzLjA1LjE5LjQ1LjIuNjguMiAxLjAyIDAgMi40Mi0uMTMgMy40NC0uMTUgMS45NC0uMDYgMy44Ni4xMyA1Ljc5LjEzIDEuMTIgMCAxLjQtLjIyIDIuMjItMS4zMy4wMS0uMDIuMDItLjAzLjA0LS4wNSAxLjAxLjk0IDIuMzQgMS40NCAzLjg3IDEuNDQgMy4xOSAwIDUuNi0yLjkzIDUuNi02Ljc4LjAxLTUuODItMy42NS02Ljk4LTUuNjItNi45OHptLjI2IDEyLjg1Yy0zLjAzIDAtNC4yMi0zLjc2LTQuMjItNi44MiAwLTIuNjUgMS4wNC01LjEgMy41Ny01LjEgMy4wOCAwIDQuMTkgMy4yOSA0LjE5IDYuNTEuMDEgMy44Ny0xLjM2IDUuNDEtMy41NCA1LjQxem0tMzIuMDMtMTAuNDljLS43NS0uMzctMS44NS0xLjA0LTIuMzktMS4zNi0yLjM3LTEuMzctMy4zLTIuMjYtMy4zNy0zLjUyLS4xMi0yLjIxIDIuMDQtMy41MiAzLjU4LTMuMzUgMS45NiAwIDMuNTcgMS4xOSA0LjI0IDMuNzMuMDcuMjcuMzEuODkuNTYuODkuMjIgMCAuMjYtLjIuMjQtLjQ1bC0uMzMtNC4wMmMtLjAyLS4zMy0uMTQtLjQyLS4yNy0uNDItLjIyIDAtLjM2LjMzLS41Ni4zMy0uMzEgMC0xLjEtMS4xMS0zLjgtMS4wOS0uMTgtLjAxLS40My4wMi0uNDMuMDItMi42My0uMDUtNS4xIDEuNy01LjAyIDUuNC4wNyAzLjM3IDMuODUgNS4zIDUuODkgNi41OSAxLjUxLjkgMy4wOSAyLjM0IDMuMDQgMy45NS0uMDggMi40Ny0xLjYzIDQuMDgtMy41OCAzLjk0LTQuNTktLjA4LTMuOTYtNi4xMy00Ljc4LTYuMTMtLjU2IDAtLjQ1IDEuNTItLjQ2IDIuMzIgMCAxLjkyLS4wOCAzLjQ5LjE0IDMuNzcuMDcuMDkuMjkuMDUuNzQuMDUuOSAwIDIgMS4wNSA0LjY1IDEuMDUgMi45NS4wNSA1LjM4LTIuNjkgNS4zOC02LjI1LS4wMS0yLjE5LS42Mi0zLjU4LTMuNDctNS40NXptNTEuNjktMy4zMWMuMzMgMCAxLjA3LTEuMiAxLjA3LTEuNTcgMC0uMzYtLjc0LTEuNi0xLjA3LTEuNi0uMyAwLTEuMDcgMS4yNi0xLjA3IDEuNnMuNzYgMS41NyAxLjA3IDEuNTd6TTMxMi42NCAyMmMtLjUyLS4wMy0xLjYzLS4yMy0xLjYzLTEuMzVWOS41OWMwLS4zMS0uMTUtLjQ5LS4zMS0uNDktLjYgMC0uOTggMS4wOC0yLjYzIDEuNjQtLjEzLjAzLS4zNy4wNi0uMzcuMjQgMCAuNjUgMS40OS0uNjEgMS40MiAxLjY5djcuMjdjLjA2IDEuODYtLjk2IDIuMDQtMS41MiAyLjA0LS44NC0uMDEtLjYzLjEtLjYzLjM2LjAzLjMxLjUzLjMzIDEuMzcuMzQuMjggMCAxLS4xMSAxLjgyLS4xMSAxLjA3IDAgMS44Ny4xMiAyLjQxLjEyLjMzIDAgLjc2LS44LjA3LS42OXptNS45OC02Ljg4Yy0uNTEtLjI0LTEuMjctLjY4LTEuNjUtLjg4LTEuNjMtLjg5LTIuMjctMS40Ny0yLjMxLTIuMy0uMDgtMS40NCAxLjE1LTIuMTkgMi4yMS0yLjA4IDIuNTQtLjA1IDIuODggMi44IDMuMTQgMi44LjM5IDAgLjI4LS4zNy4yOC0xLjIxIDAtLjIxLjAzLTEuMjctLjEzLTEuNTItLjMxLS40Ni0yLjExLS43NC0yLjU1LS43NC0uMTEgMC0uNTItLjAxLS42LS4wMS0uMTMgMC0uMjguMDEtLjI4LjAxLTEuODEtLjAzLTMuNSAxLjExLTMuNDQgMy41My4wNSAyLjIxIDIuNjQgMy40NiA0LjA0IDQuMyAxLjA0LjU5IDIuMjYgMS4xNSAyLjI0IDIuNTctLjAyIDEuNjEtMS4yNyAyLjY4LTIuNjEgMi42LTMuMTUtLjA1LTIuNzItNC0zLjI4LTQtLjM5IDAtLjMxIDEtLjMxIDEuNTItLjAxIDEuMjUtLjA2IDIuMjguMSAyLjQ2LjA1LjA2LjIuMDMuNS4wMy42MiAwIDEuMzguNjkgMy4xOS42OSAyLjAzLjAzIDMuODUtMS44NSAzLjg1LTQuMTctLjAxLTEuNDgtLjQzLTIuMzktMi4zOS0zLjZ6bS00OC43MyA1LjY2Yy0uMjYuMTMtLjg1Ljc3LTIuMjguNzctMS4wNyAwLTEuNjgtLjY0LTEuNzQtMnYtOC44MmwzLjM4LS4wMWMuMjIgMCAuNjUtMS40NC42Ny0xLjUyLjA0LS4xOC4xLS4zMy4xMi0uNDYuMDQtLjI4LS4xNy0uMy0uMzctLjAxLS4xNS4xNS0uMzIuNTUtLjk5LjU1aC0yLjgxYzAtMi40MS4wMy0zLjA0LS4zNS0zLjA0LS4zNiAwLS4zLjEtLjYzIDEuMTctLjU0IDEuNzktMi41MiAyLjU4LTMuMTUgMi45Ny0uMTUuMDgtLjE1LjExLS4xNS4xOS0uMDEuMjMuNzUuMTQgMi4zMS4xN2wtLjAxIDguMDdjMCAzLjQ1IDEuNjQgNC4wMyAyLjg3IDQuMDMgMS44NyAwIDMuMjEtMS4zNCAzLjI4LTEuOC4wMy0uMjUgMC0uMjgtLjE1LS4yNnptLTgxLjMyLTEuMDljLS41NyAwLTEuNDIgMS42Mi0zLjY2IDEuNjItMS41OCAwLTQuMTctMS41My00LjE3LTYuNjZoNi45Yy42IDAgLjg4LjAzLjg4LS41MiAwLTEuMjUtMS40LTQuOTUtNC41OS00Ljk1LTMuMjQgMC01LjA4IDMuMzMtNS4wOCA3LjMxIDAgMi4wNSAxLjM1IDYuMzggNS4yNCA2LjM4IDIuMzMgMCA0LjU5LTIuMjQgNC41OS0yLjk1LS4wMS0uMTEtLjAxLS4yMy0uMTEtLjIzem0tNS4wOC05LjgxYzEuNDIgMCAyLjg4IDEuNTYgMi44OCAzLjMgMCAuNDYtLjE1LjYyLS41Mi42MmgtNS4xMWMwLTEuNzEgMS4xMy0zLjkyIDIuNzUtMy45MnptLTMxLjctNy4zM2MuMS0uMTYtLjI1LS4yNC0uMzctLjI0LS40MiAwLTEuMzcuMTEtMS44LjExLS44OSAwLTEuNjQtLjA5LTIuNTMtLjA5LS4wNyAwLS40Ni4wNS0uNDYuMTgtLjAxLjYzIDIuMTMtLjExIDIuMTMgMi42djEwLjU3YzAgMy4xMy0uOTkgNi40MS01LjI5IDYuNDEtMy4wOSAwLTQuNzYtMS45NC00Ljc2LTYuMTdWNC40MWMwLTEuOTEgMS40OS0xLjQ5IDEuNTItMS45Mi4wMy0uNDEtMS4zMy0uMTYtMS40My0uMTYtLjcxIDAtMS4yMS4wOC0xLjk1LjA4LS42MiAwLTEuMzctLjEtMS45Ny0uMS0uMTIgMC0uNTMtLjAyLS42MS4xNS0uMjMuNTYgMS45MS4yNiAxLjkxIDEuODN2MTAuOTJjMCA0LjA4IDEuMTQgOC4wOCA3LjE3IDcuOTcgNy4xNC0uMTIgNy4wMS02LjU0IDcuMDEtNy44M1Y1LjEyYy4wMS0yLjQzIDEuMi0yLjIgMS40My0yLjU3em0yOC4xOSA3LjI0Yy4xNy0uMi4yMi0uNTMtLjU3LS40Ni0uNDUgMC0uNzcuMDgtMS4yMi4wOC0uNTcgMC0uNjgtLjAyLTEuMjItLjA0LS42OC0uMDItLjg2LjA1LS44Mi4yNS4xMi42IDEuNTUuMDEgMS4zNiAxLjgtLjE2IDEuNS0uNjUgMi43OS0xLjE0IDQuMDdsLTEuNzMgNC42Mi0yLjU0LTcuN2MtLjMxLS45Ni0uNDUtMS40Ny0uNDUtMS41NyAwLS45NiAxLjE2LS43NSAxLjQyLTEuMTQuMTYtLjI2LS4xNy0uNC0uNTQtLjQtLjMxIDAtLjY3LjExLTEuNjMuMTMtLjc5LjAyLTEuMzYuMDItMS43LS4wNS0uODktLjE2LS44Mi4zMy0uNTEuNDhzLjQ2LjAxLjkxIDEuMzZsMy45MSAxMS4wNmMuMDguMjIuMTguNzcuNTIuNzcuMzkgMCAuMzktLjM5Ljg4LTEuNjkgMCAwIDMuNzUtMTAuNDggNC0xMC44Ni41MS0uNzQuODktLjUgMS4wNy0uNzF6bTE0LjQ3LS41Yy0xLjA3IDAtMS44IDEuMjgtMi4zMyAyLjE2aC0uMDVWOS41M2MwLS4zLS4xNS0uNDgtLjMtLjQ4LS40MSAwLS43Mi44MS0yLjg3IDEuMzMtLjEzLjAzLS40OC4xLS40OC4yOCAwIC42NCAxLjgyLS4xOSAxLjgyIDEuOTN2OC4wN2MwIDEuMjUtMS4yOSAxLjEyLTEuMjkgMS43NyAwIC4xOC4wOC4yNy4yOC4yNy4xNyAwIC42My0uMTIgMi4zMi0uMTIgMS40MSAwIDIuMDIuMTIgMi4zNy4xMi4yOCAwIC40MS0uMDYuNDEtLjM0IDAtLjk4LTIuMjUuNDgtMi4yNS0yLjM0di02Ljg4YzAtLjQuNi0xLjggMS42NC0xLjguOTEgMCAxLjAyLjcgMS41LjcuMyAwIC45MS0uOTEuOTEtMS4zOC0uMDEtLjU4LTEuMTYtMS4zNy0xLjY4LTEuMzd6bTMyLjU1LjFjLS4yNyAwLS45Ni4wNC0xLjU5LjA0LS43NiAwLTEuMTMtLjA5LTEuNDUtLjA5LS40OCAwLS45NiAwLS44Ny4zMi4xLjM2IDEuNzMuMjMgMS43MyAyLjAxIDAgLjIzIDAgLjUyLS4zMyAxLjcxbC0yLjA4IDYuNjMtMi45LTguMTVzLS4xNC0uMjYtLjE0LS43OWMwLTEuMzIgMS41NC0xLjE3IDEuNi0xLjQxLjA1LS4xOS0uMjEtLjQtLjYyLS40aC0zLjYzYy0uMDIgMC0uMDMuMDEtLjA1LjAxaC0yLjgxYzAtMi40MS4wMy0zLjA0LS4zNS0zLjA0LS4zNiAwLS4zLjEtLjYzIDEuMTctLjU0IDEuNzktMi41MiAyLjU4LTMuMTUgMi45Ny0uMTUuMDgtLjE1LjExLS4xNS4xOS0uMDEuMjIuNzYuMTQgMi4zMS4xN2wtLjAxIDguMDdjMCAzLjQ1IDEuNjQgNC4wMyAyLjg3IDQuMDMgMS44NyAwIDMuMjEtMS4zMyAzLjI4LTEuOCAwLS4yNy0uMDQtLjI5LS4xOC0uMjctLjI2LjEzLS44NS43Ny0yLjI4Ljc3LTEuMDcgMC0xLjY4LS42NC0xLjc0LTJWMTAuN3MyLjUtLjAxIDMuMjEtLjAxYy4wNC4wNi4wOC4xMy4xLjE5bDIuOTkgOC40NWMuMjQuNjkuMzkuOTIuNjggMi4xNC4xOS43OS4xMiAxLjUxLjEyIDEuNTEtLjI5IDEuMjctMS4wNyAxLjk5LTIuMjYgNC4zNC0uMTIuMjIgMS43MS0uMDIgMS44MS0uMDUuMTUtLjA1LjEzLS4wOS4zMS0uNDJsMS4zMi0zLjkzIDMuNjktMTEuMzRjLjU0LTEuOTggMS4zOS0xLjYyIDEuNTMtMS44OS4xMi0uMTMgMC0uMy0uMzMtLjN6XFxcIj5cXG4gICAgICA8L3BhdGg+XFxuICAgICAgPHBhdGhcXG4gICAgICAgIGQ9XFxcIk0yMjIuMjIgMjIuNzZsLS4wNy4xOVYyM2wuMDctLjI0em0tMTQuNzQtMTQuNmMuMzMgMCAxLjA3LTEuMiAxLjA3LTEuNTcgMC0uMzYtLjc0LTEuNi0xLjA3LTEuNi0uMyAwLTEuMDcgMS4yNi0xLjA3IDEuNnMuNzYgMS41NyAxLjA3IDEuNTd6TTIxMC4xMSAyMmMtLjUyLS4wMy0xLjYzLS4yMy0xLjYzLTEuMzVWOS41OWMwLS4zMS0uMTUtLjQ5LS4zMS0uNDktLjYgMC0uOTggMS4wOC0yLjYzIDEuNjQtLjEzLjAzLS4zNy4wNi0uMzcuMjQgMCAuNjUgMS40OS0uNjEgMS40MiAxLjY5djcuMjdjLjA2IDEuODYtLjk2IDIuMDQtMS41MiAyLjA0LS44NC0uMDEtLjYzLjEtLjYzLjM2LjAzLjMxLjUzLjMzIDEuMzcuMzQuMjggMCAxLS4xMSAxLjgyLS4xMSAxLjA3IDAgMS44Ny4xMiAyLjQxLjEyLjMzIDAgLjc2LS44LjA3LS42OXpNMTY2LjUyIDguMTZjLjMzIDAgMS4wNy0xLjIgMS4wNy0xLjU3IDAtLjM2LS43NC0xLjYtMS4wNy0xLjYtLjMgMC0xLjA3IDEuMjYtMS4wNyAxLjZzLjc3IDEuNTcgMS4wNyAxLjU3ek0xNjkuMTcgMjJjLS41Mi0uMDMtMS42My0uMjMtMS42My0xLjM1VjkuNTljMC0uMzEtLjE1LS40OS0uMzEtLjQ5LS42IDAtLjk4IDEuMDgtMi42MyAxLjY0LS4xMy4wMy0uMzcuMDYtLjM3LjI0IDAgLjY1IDEuNDktLjYxIDEuNDIgMS42OXY3LjI3Yy4wNiAxLjg2LS45NiAyLjA0LTEuNTIgMi4wNGgtLjE3Yy0uNTQtLjEtMS4wNi0uMzItMS4wNS0xLjc5di01LjA4YzAtMi4zNC0uNzYtNS43Ni00LjIyLTUuNzYtMi41MSAwLTMuODEgMi4zOC0zLjc2IDIuMDFWOS41OWMwLS4zMS0uMTUtLjQ5LS4zMS0uNDktLjYgMC0xLjA0IDEuMDEtMy4wNyAxLjYyLS4xMy4wMy0uNS4wNC0uNTEuMjcgMCAuNjUgMi4wMy0uODQgMiAxLjY4djcuNjRjMCAyLTEuMzUgMS41Mi0xLjY2IDIuMDQtLjE1LjI3LjI1LjMzLjU5LjMzLjMxIDAgLjgzLS4xMyAyLjItLjEzIDEuNSAwIDIuMDIuMTMgMi40Ni4xMy4zOSAwIC44My0uMTcuNTctLjQ0LS40Mi0uNDEtMi4yOC4wNi0yLjI4LTIuMDZ2LTcuMDljLS4wMy0uNDkuODgtMi40IDMuMDYtMi40IDIuMSAwIDMuMDMgMi4zMSAzLjAzIDMuODV2NS43NmMtLjAzIDIuMjctLjggMS41NS0xLjExIDItLjE3LjI1LjEzLjM3LjQ2LjM3cy44OC0uMTMgMS44Ny0uMTNjMS4yNyAwIDEuODIuMTIgMi4xNi4xMi4wNCAwIC4wOS0uMDEuMTMtLjAxLjExIDAgLjIxLjAxLjM0LjAxLjI4IDAgMS0uMTEgMS44Mi0uMTEgMS4wNyAwIDEuODcuMTIgMi40MS4xMi4zNC4wMi43NS0uNzguMDgtLjY3em0zMi43Mi02Ljg5Yy0uNTEtLjI0LTEuMjctLjY4LTEuNjUtLjg4LTEuNjMtLjg5LTIuMjctMS40Ny0yLjMxLTIuMy0uMDgtMS40NCAxLjE1LTIuMTkgMi4yMS0yLjA4IDIuNTQtLjA1IDIuODggMi44IDMuMTQgMi44LjM5IDAgLjI4LS4zNy4yOC0xLjIxIDAtLjIxLjAzLTEuMjctLjEzLTEuNTItLjMxLS40Ni0yLjEtLjc0LTIuNTUtLjc0LS4xMSAwLS41Mi0uMDEtLjYtLjAyLS4xMyAwLS4yOC4wMi0uMjguMDItMS44MS0uMDMtMy41IDEuMTEtMy40NSAzLjUzLjA1IDIuMjEgMi42NCAzLjQ2IDQuMDQgNC4zIDEuMDQuNTkgMi4yNiAxLjE1IDIuMjQgMi41Ny0uMDIgMS42Mi0xLjI3IDIuNjgtMi42MSAyLjYtMy4xNS0uMDUtMi43Mi00LTMuMjgtNC0uMzkgMC0uMzEgMS0uMzEgMS41MiAwIDEuMjUtLjA2IDIuMjguMSAyLjQ2LjA1LjA2LjIuMDMuNS4wMy42MiAwIDEuMzguNjkgMy4xOS42OSAyLjAzLjAzIDMuODUtMS44NSAzLjg1LTQuMTcgMC0xLjQ3LS40Mi0yLjM4LTIuMzgtMy42elxcXCI+XFxuICAgICAgPC9wYXRoPlxcbiAgICA8L2c+XFxuICA8L3N2Zz5cXG48L2Rpdj5cXG48aGVhZGVyIHJvbGU9XFxcImJhbm5lclxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcbiAgICA8YSBjbGFzcz1cXFwic2l0ZS10aXRsZVxcXCIgaHJlZj1cXFwiZmlsZXMvaW5kZXguaHRtbFxcXCI+TnVyc2VyeSBTY2hvb2w8L2E+XFxuICA8L2Rpdj5cXG4gIDxkaXYgaWQ9XFxcIm1haW4tbWVudS1jb250YWluZXJcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhclxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkcm9wZG93blxcXCI+XFxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImRyb3BidG5cXFwiPlxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJhYm91dFxcXCIgaHJlZj1cXFwiZmlsZXMvYWJvdXQuaHRtbFxcXCI+QWJvdXRcXG4gICAgICAgICAgICA8L2E+XFxuICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkcm9wZG93bi1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICA8YSBpZD1cXFwidHVpdGlvblxcXCIgaHJlZj1cXFwiZmlsZXMvdHVpdGlvbi5odG1sXFxcIj5UdWl0aW9uPC9hPlxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJzdGFmZlxcXCIgaHJlZj1cXFwiZmlsZXMvc3RhZmYuaHRtbFxcXCI+U3RhZmY8L2E+XFxuICAgICAgICAgICAgPGEgaWQ9XFxcInBhcmVudC1oYW5kYm9va1xcXCIgaHJlZj1cXFwiZmlsZXMvcGFyZW50X2hhbmRib29rLmh0bWxcXFwiPlBhcmVudCBIYW5kYm9vazwvYT5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImRyb3Bkb3duXFxcIj5cXG4gICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiZHJvcGJ0blxcXCI+XFxuICAgICAgICAgICAgPGEgaWQ9XFxcImNsYXNzcm9vbXNcXFwiIGhyZWY9XFxcImZpbGVzL2NsYXNzcm9vbXMuaHRtbFxcXCI+Q2xhc3Nyb29tc1xcbiAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRyb3Bkb3duLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJjdXJyaWN1bHVtLW92ZXJ2aWV3XFxcIiBocmVmPVxcXCJmaWxlcy9jdXJyaWN1bHVtX292ZXJ2aWV3Lmh0bWxcXFwiPkN1cnJpY3VsdW0gT3ZlcnZpZXc8L2E+XFxuICAgICAgICAgICAgPGEgaWQ9XFxcInRlZGR5LWJlYXJzXFxcIiBocmVmPVxcXCJmaWxlcy90ZWRkeV9iZWFycy5odG1sXFxcIj5UZWRkeSBCZWFyczwvYT5cXG4gICAgICAgICAgICA8YSBpZD1cXFwicGFuZGEtYmVhcnNcXFwiIGhyZWY9XFxcImZpbGVzL3BhbmRhX2JlYXJzLmh0bWxcXFwiPlBhbmRhIEJlYXJzPC9hPlxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJiZWFyLWN1YnNcXFwiIGhyZWY9XFxcImZpbGVzL2JlYXJfY3Vicy5odG1sXFxcIj5CZWFyIEN1YnM8L2E+XFxuICAgICAgICAgICAgPGEgaWQ9XFxcImJpZy1iZWFyc1xcXCIgaHJlZj1cXFwiZmlsZXMvYmlnX2JlYXJzLmh0bWxcXFwiPkJpZyBCZWFyczwvYT5cXG4gICAgICAgICAgICA8YSBpZD1cXFwic3VuLWJlYXJzXFxcIiBocmVmPVxcXCJmaWxlcy9zdW5fYmVhcnMuaHRtbFxcXCI+U3VuIEJlYXJzPC9hPlxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJiZWFyLXRyYWNrc1xcXCIgaHJlZj1cXFwiZmlsZXMvYmVhcl90cmFja3MuaHRtbFxcXCI+QmVhciBUcmFja3M8L2E+XFxuICAgICAgICAgICAgPGEgaWQ9XFxcImVucmljaG1lbnQtcHJvZ3JhbVxcXCIgaHJlZj1cXFwiZmlsZXMvZW5yaWNobWVudF9wcm9ncmFtcy5odG1sXFxcIj5FbnJpY2htZW50IFByb2dyYW08L2E+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8YSBpZD1cXFwiY2FsZW5kYXJcXFwiIGhyZWY9XFxcImZpbGVzL2NhbGVuZGFyLmh0bWxcXFwiPkNhbGVuZGFyPC9hPlxcbiAgICAgICAgPGEgaWQ9XFxcInN1bW1lci1jYW1wXFxcIiBocmVmPVxcXCJmaWxlcy9zdW1tZXJfY2FtcC5odG1sXFxcIj5TdW1tZXIgQ2FtcDwvYT5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImRyb3Bkb3duXFxcIj5cXG4gICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiZHJvcGJ0blxcXCI+XFxuICAgICAgICAgICAgPGEgaWQ9XFxcImdldC1pbnZvbHZlZFxcXCIgaHJlZj1cXFwiZmlsZXMvZ2V0X2ludm9sdmVkLmh0bWxcXFwiPkdldCBJbnZvbHZlZDwvYT5cXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRyb3Bkb3duLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJudXJzZXJ5LXNjaG9vbC1tZXJjaGFuZGlzZVxcXCIgaHJlZj1cXFwiZmlsZXMvbnVyc2VyeV9zY2hvb2xfbWVyY2hhbmRpc2UuaHRtbFxcXCI+TnVyc2VyeSBTY2hvb2xcXG4gICAgICAgICAgICAgIE1lcmNoYW5kaXNlPC9hPlxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJwYXJlbnQtYXNzb2NpYXRpb25cXFwiIGhyZWY9XFxcImZpbGVzL3BhcmVudF9hc3NvY2lhdGlvbi5odG1sXFxcIj5QYXJlbnQgQXNzb2NpYXRpb248L2E+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8YSBpZD1cXFwiYXBwbHlcXFwiIGhyZWY9XFxcImZpbGVzL2FwcGx5Lmh0bWxcXFwiPkFwcGx5PC9hPlxcbiAgICAgICAgPGEgaWQ9XFxcImZvcm1zXFxcIiBocmVmPVxcXCJmaWxlcy9mb3Jtcy5odG1sXFxcIj5Gb3JtczwvYT5cXG5cXG4gICAgICAgIDxhIGlkPVxcXCJwYXJlbnQtcmVzb3VyY2VzXFxcIiBocmVmPVxcXCJmaWxlcy9wYXJlbnRfcmVzb3VyY2VzLmh0bWxcXFwiPlBhcmVudCBSZXNvdXJjZXM8L2E+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9oZWFkZXI+XCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHRzLWxvYWQgZGF0YS1uYW1lPVxcXCJmb290ZXJcXFwiPjwvdHMtbG9hZD5cIjtcbiIsImltcG9ydCB7IEQgfSBmcm9tIFwiLi8uLi9jb3JlL2RvbS9kb2N1bWVudFwiO1xuXG5leHBvcnQgY2xhc3MgU2xpZGVzaG93IHtcbiAgcHVibGljIHN0YXRpYyBzZXR1cEFsbCgpIHtcbiAgICBTbGlkZXNob3cuZGlzY2FyZEFsbCgpO1xuICAgIGNvbnN0IHNsaWRlc2hvd3MgPSBELmNsYXooXCJzbGlkZXNob3dcIik7XG4gICAgZm9yIChsZXQgc3NJbmRleCA9IDA7IHNzSW5kZXggPCBzbGlkZXNob3dzLmxlbmd0aDsgKytzc0luZGV4KSB7XG4gICAgICBjb25zdCBlbGVtID0gc2xpZGVzaG93cy5pdGVtKHNzSW5kZXgpO1xuICAgICAgaWYgKGVsZW0gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIFNsaWRlc2hvdy5zbGlkZXNob3dzLnB1c2gobmV3IFNsaWRlc2hvdyhlbGVtKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBkaXNjYXJkQWxsKCkge1xuICAgIFNsaWRlc2hvdy5zbGlkZXNob3dzID0gW107XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBzbGlkZXNob3dzOiBTbGlkZXNob3dbXSA9IFtdO1xuXG4gIHByaXZhdGUgc2xpZGVJbmRleCA9IDA7XG4gIHByaXZhdGUgc2xpZGVDb3VudCA9IDA7XG4gIHByaXZhdGUgc2xpZGVzOiBFbGVtZW50W10gPSBbXTtcbiAgcHJpdmF0ZSBkb3RzOiBFbGVtZW50W10gPSBbXTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG91dGVyOiBFbGVtZW50KSB7XG4gICAgRC5lYWNoUmVjdXIodGhpcy5vdXRlciwgKGVsZW0pID0+IHtcbiAgICAgIGNvbnN0IGNMaXN0ID0gZWxlbS5jbGFzc0xpc3Q7XG4gICAgICBpZiAoY0xpc3QuY29udGFpbnMoXCJwcmV2LXNsaWRlc2hvdy1idXR0b25cIikpIHtcbiAgICAgICAgRC5hZGRFdmVudExpc3RlbmVyKGVsZW0sIFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5taW51c1NsaWRlKDEpKTtcbiAgICAgIH0gZWxzZSBpZiAoY0xpc3QuY29udGFpbnMoXCJuZXh0LXNsaWRlc2hvdy1idXR0b25cIikpIHtcbiAgICAgICAgRC5hZGRFdmVudExpc3RlbmVyKGVsZW0sIFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5wbHVzU2xpZGUoMSkpO1xuICAgICAgfSBlbHNlIGlmIChjTGlzdC5jb250YWlucyhcInNsaWRlc2hvdy1lbnRyeVwiKSkge1xuICAgICAgICB0aGlzLnNsaWRlcy5wdXNoKGVsZW0pO1xuICAgICAgfSBlbHNlIGlmIChjTGlzdC5jb250YWlucyhcInNsaWRlc2hvdy1kb3RcIikpIHtcbiAgICAgICAgdGhpcy5kb3RzLnB1c2goZWxlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRvdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIEQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmRvdHNbaV0sIFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5zaG93U2xpZGUoaSkpO1xuICAgIH1cbiAgICB0aGlzLnNsaWRlQ291bnQgPSB0aGlzLnNsaWRlcy5sZW5ndGg7XG4gICAgdGhpcy5zaG93U2xpZGUodGhpcy5zbGlkZUluZGV4KTtcbiAgfVxuXG4gIHB1YmxpYyBwbHVzU2xpZGUobjogbnVtYmVyKSB7XG4gICAgdGhpcy5zaG93U2xpZGUoKHRoaXMuc2xpZGVJbmRleCArPSBuKSk7XG4gIH1cbiAgcHVibGljIG1pbnVzU2xpZGUobjogbnVtYmVyKSB7XG4gICAgdGhpcy5zaG93U2xpZGUoKHRoaXMuc2xpZGVJbmRleCAtPSBuKSk7XG4gIH1cbiAgcHVibGljIHNob3dTbGlkZShpbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5zbGlkZUluZGV4ID0gaW5kZXggJSB0aGlzLnNsaWRlQ291bnQ7XG4gICAgdGhpcy5zbGlkZUluZGV4ID0gTWF0aC5tYXgodGhpcy5zbGlkZUluZGV4LCAtMSAqIHRoaXMuc2xpZGVJbmRleCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNsaWRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgKHRoaXMuc2xpZGVzW2ldIGFzIEhUTUxFbGVtZW50KS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmRvdHNbaV0uY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICB9XG4gICAgKHRoaXMuc2xpZGVzW3RoaXMuc2xpZGVJbmRleF0gYXMgSFRNTEVsZW1lbnQpLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgdGhpcy5kb3RzW3RoaXMuc2xpZGVJbmRleF0uY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgZGF0YSB9IGZyb20gJy4vLi4vY29yZS9kYXRhLWxvZy9kYXRhJztcbmltcG9ydCB7IEFjdGlvbkVudW0gfSBmcm9tICcuLy4uL2NvcmUvZGF0YS1sb2cvZXZlbnQnO1xuaW1wb3J0IHsgRCB9IGZyb20gJy4vLi4vY29yZS9kb20vZG9jdW1lbnQnO1xuaW1wb3J0IHsgRWxlbWVudHMgfSBmcm9tICcuLy4uL2NvcmUvZG9tL2VsZW1lbnRzJztcbmltcG9ydCB7IFNjcm9sbCB9IGZyb20gJy4vLi4vY29yZS9kb20vc2Nyb2xsJztcbmltcG9ydCB7IEhpc3RvcnkgfSBmcm9tICcuLy4uL2NvcmUvcm91dGVyL2hpc3RvcnknO1xuaW1wb3J0IHsgUm91dGVyLCBSb3V0ZXJNb2RlLCBSb3V0ZXJNb2R1bGUgfSBmcm9tICcuLy4uL2NvcmUvcm91dGVyL3JvdXRlcic7XG5pbXBvcnQgeyBUcmFja2VyIH0gZnJvbSAnLi8uLi9jb3JlL3RyYWNrZXIvdHJhY2tlcic7XG5pbXBvcnQgeyBEZWJ1Z0xldmVsRW51bSB9IGZyb20gJy4vLi4vY29yZS91dGlscy9jb25zb2xlX3dyYXBwZXInO1xuaW1wb3J0IHsgSFRNTExvYWRlciB9IGZyb20gJy4vLi4vY29yZS91dGlscy9odG1sX2xvYWRlcic7XG5pbXBvcnQgeyBJREdlbmVyYXRvciB9IGZyb20gJy4vLi4vY29yZS91dGlscy9pZF9nZW5lcmF0b3InO1xuaW1wb3J0IHsgd2FpdFVudGlsUmVhZHkgfSBmcm9tICcuLy4uL2NvcmUvdXRpbHMvcmVhZHknO1xuaW1wb3J0IHsgc2NlbmFyaW9zIH0gZnJvbSAnLi8uLi9jb3JlL3V0aWxzL3NjZW5hcmlvcyc7XG5cbmNvbnN0IHNldHVwID0gYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHdhaXRVbnRpbFJlYWR5KCk7XG4gICAgLy8gY29uc3Qgc2NlbmFyaW9UYWcgPSB3aW5kb3cubG9jYXRpb24uaGFzaC5zcGxpdCgnPycpWzBdLnJlcGxhY2UoJyMnLCAnJyk7XG4gICAgLy8gY29uc3Qgc2NlbmFyaW8gPSBzY2VuYXJpb3MuZmluZCgoc2NlbikgPT4gc2Nlbi50YWcgPT09IHNjZW5hcmlvVGFnKTtcbiAgICAvLyBpZiAoc2NlbmFyaW8gPT09IG51bGwgfHwgc2NlbmFyaW8gPT09IHVuZGVmaW5lZCkge1xuICAgIC8vICAgICBhbGVydCgnVGhpcyBISVQgaXMgYnJva2VuIGFuZCBjYW5ub3QgYmUgY29tcGxldGVkIGF0IHRoaXMgdGltZS4nKTtcbiAgICAvLyAgICAgcmV0dXJuO1xuICAgIC8vIH1cbiAgICAvLyBUcmFja2VyLmxvYWRTY2VuYXJpbyhzY2VuYXJpbyk7XG4gICAgVHJhY2tlci5zdGFydCh7XG4gICAgICAgIGtleVByZWZpeDogJ2luZm9ybWF0aW9uLWZvcmFnaW5nJyxcbiAgICAgICAgYnVja2V0TmFtZTogJ2NzZS0yNTYtbG9nJyxcbiAgICAgICAgYWxsb3dTdWJtaXNzaW9uOiB7XG4gICAgICAgICAgICBhbGxvdygpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0QXJlYSA9IEQuaWQoJ3RleHQtYXJlYScpIGFzIEhUTUxUZXh0QXJlYUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRleHRBcmVhLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRBcmVhLnZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdZb3UgbXVzdCBmaWxsIG91dCB0aGUgdGV4dCBib3ggdG8gdHVybiB0aGlzIEhJVCBpbi4nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnVGhlcmUgd2FzIGFuIGVycm9yIGZpbGwgb3V0IHRoZSBmb3JtIGFuZCB0cnkgYWdhaW4uJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlU3VibWl0KCkge1xuICAgICAgICAgICAgICAgIGRhdGEuZGF0YS5yZXNwb25zZSA9IChELmlkKFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1hcmVhJ1xuICAgICAgICAgICAgICAgICkgYXMgSFRNTFRleHRBcmVhRWxlbWVudCkudmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcblxuICAgICAgICBkZWJ1Z0xldmVsOiBEZWJ1Z0xldmVsRW51bS5OT05FLFxuXG4gICAgICAgIGFzeW5jIHNldHVwKCkge1xuICAgICAgICAgICAgLy8gY29uZmlndXJlIHJvdXRlclxuICAgICAgICAgICAgUm91dGVyLmRlZmF1bHRBbGxvd2FuY2VzT24oKTtcbiAgICAgICAgICAgIFJvdXRlci5jb25maWd1cmUoXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBSb3V0ZXJNb2RlLlNUQU5EQVJEX0FMTE9XQU5DRVMsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IFJvdXRlck1vZHVsZS5BLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7IG1vZGU6IFJvdXRlck1vZGUuT0ZGLCBtb2R1bGU6IFJvdXRlck1vZHVsZS5GT1JNIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IFJvdXRlck1vZGUuU1RBTkRBUkRfQUxMT1dBTkNFUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZTogUm91dGVyTW9kdWxlLklNRyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICcvZmlsZXMvJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIEhpc3Rvcnkuc2V0dXAod2luZG93LmxvY2F0aW9uLmhyZWYsIHsgd3JhcHBlcjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIC8vIGNvbmZpZ3VyZSBodG1sIGxvYWRlciBwb3N0IG9wZXJhdGlvblxuICAgICAgICAgICAgSFRNTExvYWRlci5maW5pc2goKTtcbiAgICAgICAgICAgIEhUTUxMb2FkZXIucmVnaXN0ZXJQb3N0TG9hZEZ1bmMoKCkgPT4ge1xuICAgICAgICAgICAgICAgIElER2VuZXJhdG9yLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgSURHZW5lcmF0b3IuYXR0YWNoSWRzVG9BbGxFbGVtZW50cygpO1xuICAgICAgICAgICAgICAgIFJvdXRlci5zZXR1cChFbGVtZW50cy5odG1sTG9jKTtcbiAgICAgICAgICAgICAgICBTY3JvbGwucHJvbWlzZSgwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gY29uZmlndXJlIGxpc3RlbmVycyBvbiBodG1sIGxvY1xuICAgICAgICAgICAgRC5hZGRFdmVudExpc3RlbmVyKEVsZW1lbnRzLmh0bWxMb2MsIEFjdGlvbkVudW0uQ0xJQ0ssIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXYgPSBlIGFzIE1vdXNlRXZlbnQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBldi5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICB5OiBldi5jbGllbnRZLFxuICAgICAgICAgICAgICAgICAgICBpZDogKGV2LnRhcmdldCBhcyBIVE1MRWxlbWVudCkuaWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBUcmFja2VyLmdldEV2ZW50RGlzcGF0Y2hGdW5jKEFjdGlvbkVudW0uQ0xJQ0spKG9iaik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEQuYWRkRXZlbnRMaXN0ZW5lcihFbGVtZW50cy5kb2N1bWVudCwgJ2tleXByZXNzJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBldiA9IGUgYXMgS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogZXYua2V5LFxuICAgICAgICAgICAgICAgICAgICBpZDogKGV2LnNyY0VsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLmlkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgVHJhY2tlci5nZXRFdmVudERpc3BhdGNoRnVuYyhBY3Rpb25FbnVtLkJVVFRPTikob2JqKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gU1BFQ0lBTCBDQVNFOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgZG9lcyBub3QgYmVoYXZlIHRoZSBzYW1lIHdheSBhcyBkb2N1bWVudCBzbyB0aGUgYmVsb3cgZnVuY3Rpb24gbXVzdCBiZWhhdmUgZGlmZmVyZW50bHkgdGhhbiB0aGUgbGlzdGVuZXJzIGFib3ZlLlxuICAgICAgICAgICAgY29uc3Qgc0VsZW0gPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IGFzIEVsZW1lbnQ7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGR4ID0gc0VsZW0uc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICBjb25zdCBkeSA9IHNFbGVtLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICBjb25zdCBkdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoVHJhY2tlci5sYXN0UG9zLnggLSBkeCkgPiAxMCB8fFxuICAgICAgICAgICAgICAgICAgICAoTWF0aC5hYnMoVHJhY2tlci5sYXN0UG9zLnkgLSBkeSkgPiAxMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZHRpbWUgLSBUcmFja2VyLmxhc3RQb3MudGltZSA+IDEwMClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgVHJhY2tlci5sYXN0UG9zLnggPSBkeDtcbiAgICAgICAgICAgICAgICAgICAgVHJhY2tlci5sYXN0UG9zLnkgPSBkeTtcbiAgICAgICAgICAgICAgICAgICAgVHJhY2tlci5sYXN0UG9zLnRpbWUgPSBkdGltZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqID0geyB4OiBkeCwgeTogZHkgfTtcbiAgICAgICAgICAgICAgICAgICAgVHJhY2tlci5nZXRFdmVudERpc3BhdGNoRnVuYyhBY3Rpb25FbnVtLlNDUk9MTCkob2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGNvbmZpZ3VyZSB0cmFja2VkIGV2ZW50c1xuICAgICAgICAgICAgVHJhY2tlci5yZWdpc3RlckV2ZW50KEFjdGlvbkVudW0uSElTVE9SWSk7XG4gICAgICAgICAgICBUcmFja2VyLnJlZ2lzdGVyRXZlbnQoQWN0aW9uRW51bS5CVVRUT04pO1xuICAgICAgICAgICAgVHJhY2tlci5yZWdpc3RlckV2ZW50KEFjdGlvbkVudW0uQ0xJQ0spO1xuICAgICAgICAgICAgVHJhY2tlci5yZWdpc3RlckV2ZW50KEFjdGlvbkVudW0uU0NST0xMKTtcbiAgICAgICAgICAgIC8vIGxvYWQgZmlyc3QgcGFnZVxuICAgICAgICAgICAgYXdhaXQgUm91dGVyLmxvYWQoJy9maWxlcy9pbmRleC5odG1sJyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59O1xuXG5zZXR1cCgpO1xuIl19
